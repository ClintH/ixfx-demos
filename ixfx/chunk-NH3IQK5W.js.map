{"version":3,"sources":["../src/data/index.ts","../src/data/Normalise.ts","../src/data/FrequencyMutable.ts","../src/data/MovingAverage.ts","../src/data/IntervalTracker.ts","../src/data/chains/index.ts","../src/Iterable.ts","../src/data/chains/Util.ts","../src/data/chains/Links.ts","../src/data/chains/Dom.ts","../src/data/graphs/index.ts","../src/data/graphs/UndirectedGraph.ts","../src/data/Correlate.ts","../src/data/Pool.ts"],"sourcesContent":["\n\n/**\n * Normalise module\n * * {@link array}: Normalises the contents of an array of known values.\n * * {@link stream}: Normalises a stream of unknown values.\n */\nexport * as Normalise from './Normalise.js';\n\nexport * from './FrequencyMutable.js';\nexport * from './MovingAverage.js';\nexport * from './NumberTracker.js';\nexport * from './IntervalTracker.js';\nexport * from './PointTracker.js';\nexport * from './TrackedValue.js';\nexport * from './TrackerBase.js';\nexport * from './PrimitiveTracker.js';\n\nexport * from './Clamp.js';\nexport * from './Scale.js';\nexport * from './Flip.js';\n\nexport * as Reactive from './Reactive.js';\nexport * as Chains from './chains/index.js';\nexport * as Graphs from './graphs/index.js'\nexport * from './TrackUnique.js';\nexport * from './Table.js';\n\n/**\n * Work with bipolar values (-1...1)\n * \n * Import:\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Overview:\n * * {@link immutable}: Immutable wrapper around a value\n * * {@link clamp}: Clamp on -1..1 scale\n * * {@link scale}: Scale a value to -1..1\n * * {@link toScalar}: Convert -1..1 to 0..1\n * * {@link fromScalar}: Convert from 0..1 to -1..1\n * * {@link towardZero}: Nudge a bipolar value towards zero\n */\nexport * as Bipolar from './Bipolar.js';\nexport * from './Interpolate.js';\nexport * from './Wrap.js';\nexport * as Correlate from './Correlate.js';\nexport * as Pool from './Pool.js';\nexport * from './Types.js';\nexport const piPi = Math.PI * 2;\n","import { minMaxAvg } from '../collections/arrays/NumericArrays.js';\nimport { clamp } from './Clamp.js';\nimport { scale } from './Scale.js';\nimport { throwNumberTest } from '../Guards.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passingin `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * Note that if a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  //eslint-disable-next-line functional/no-let\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  throwNumberTest(minDefault);\n  throwNumberTest(maxDefault);\n\n  return (v: number): number => {\n    throwNumberTest(v);\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (\n  values: readonly number[],\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new Error(`values param should be an array`);\n  }\n  const mma = minMaxAvg(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","/// âœ” Unit tested!\n\nimport { type ToString } from '../Util.js';\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as KeyValueUtil from '../KeyValue.js';\nimport { KeyValues } from '../index.js';\n\nexport type FrequencyEventMap = {\n  readonly change: { context: any };\n};\n\nexport class FrequencyMutable<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString?: ToString<V> | undefined) {\n    super();\n    this.#store = new Map();\n\n    if (keyString === undefined) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        return typeof a === `string` ? a : JSON.stringify(a);\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, { context: this });\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): Array<[ key: string, count: number ]> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    //eslint-disable-next-line functional/no-let\n    let t = ``;\n    for (const [ key, count ] of this.#store.entries()) {\n      t += `${ key }: ${ count }, `;\n    }\n    if (t.endsWith(`, `)) return t.slice(0, Math.max(0, t.length - 2));\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    //eslint-disable-next-line functional/no-let\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.minMaxAvg();\n    return freq / mma.total;\n  }\n\n  /**\n   * @returns Copy of entries as an array\n   */\n  entries(): Array<KeyValueUtil.KeyValue> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   *\n   * @returns Returns `{min,max,avg,total}`\n   */\n  minMaxAvg() {\n    return KeyValues.minMaxAvg(this.entries());\n  }\n\n  /**\n   *\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: KeyValues.SortSyles = `value`\n  ): ReadonlyArray<KeyValues.KeyValue> {\n    const s = KeyValueUtil.getSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   *\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  add(...values: Array<V>) {\n    if (values === undefined) throw new Error(`value parameter is undefined`);\n\n    const keys = values.map(v => this.#keyString(v));\n\n    //const key = this.#keyString(value);\n    for (const key of keys) {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    }\n    this.fireEvent(`change`, { context: this });\n  }\n}\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link frequencyMutable}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = frequencyMutable();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = frequencyMutable();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequencyMutable( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @template V Type of items\n */\nexport const frequencyMutable = <V>(keyString?: ToString<V> | undefined) =>\n  new FrequencyMutable<V>(keyString);\n","import { averageWeighted } from '../collections/arrays/AverageWeighted.js';\nimport { average } from '../collections/arrays/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { throwNumberTest } from '../Guards.js';\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * `add()` adds a new value and returns the calculated average.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma.add(50);  // 50\n * ma.add(100); // 75\n * ma.add(75);  // 75\n * ma.add(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * Use `clear()` to reset the moving average, or `compute()` to get the current value without adding.\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns {@link MovingAverage}\n */\nexport const movingAverageLight = (scaling = 3): MovingAverage => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  //eslint-disable-next-line functional/no-let\n  let average = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n\n  //eslint-disable-next-line functional/no-let\n  let disposed = false;\n  const ma: MovingAverage = {\n    dispose() {\n      disposed = true;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    add(v: number) {\n      if (disposed) throw new Error(`MovingAverage disposed, cannot add`);\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n      return average;\n    },\n    clear() {\n      if (disposed) throw new Error(`MovingAverage disposed, cannot clear`);\n      average = 0;\n      count = 0;\n    },\n    compute() {\n      return average;\n    },\n  };\n  return ma;\n};\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * @param updateRateMs\n * @param value\n * @param scaling\n * @returns\n */\nexport const movingAverageTimed = (\n  updateRateMs = 200,\n  value = 0,\n  scaling = 3\n): MovingAverage => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n  const mal = movingAverageLight(scaling);\n\n  //eslint-disable-next-line functional/no-let\n  let timer = 0;\n\n  const reschedule = () => {\n    if (timer !== 0) clearTimeout(timer);\n    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n    // @ts-ignore\n    timer = setTimeout(decay, updateRateMs) as number;\n  };\n\n  const decay = () => {\n    mal.add(value);\n    if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n  };\n\n  const ma: MovingAverage = {\n    add(v: number) {\n      reschedule();\n      return mal.add(v);\n    },\n\n    dispose() {\n      mal.dispose();\n    },\n    clear: function (): void {\n      mal.clear();\n    },\n    compute: function (): number {\n      return mal.compute();\n    },\n    isDisposed: false,\n  };\n\n  return ma;\n};\n\n/**\n * Creates a moving average for a set number of `samples`.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n * `add` adds a number and returns the computed average. Call `compute` to\n * get the average without adding a new value.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma.add(10); // 10\n * ma.add(5);  // 7.5\n * ```\n *\n * `clear` clears the average.\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, Easings.gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): MovingAverage => {\n  //eslint-disable-next-line functional/no-let\n  let disposed = false;\n\n  //eslint-disable-next-line functional/no-let\n  let q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  const clear = () => {\n    q = new QueueMutable<number>({\n      capacity: samples,\n      discardPolicy: `older`,\n    });\n  };\n\n  const compute = () => {\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  };\n\n  const add = (v: number) => {\n    q.enqueue(v);\n    return compute();\n  };\n\n  const dispose = () => {\n    disposed = true;\n  };\n\n  return { add, compute, clear, dispose, isDisposed: disposed };\n};\n\n/**\n * Moving average.\n * Create via {@link movingAverage} or {@link movingAverageLight}.\n */\nexport type MovingAverage = {\n  /**\n   * Clear data\n   */\n  clear(): void;\n  /**\n   * Returns current average\n   */\n  compute(): number;\n  /**\n   * Adds a value, returning new average\n   * @param v Value to add\n   */\n  add(v: number): number;\n\n  dispose(): void;\n  get isDisposed(): boolean;\n};\n\nconst PiPi = Math.PI * 2;\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin \n * @param speedCoefficient \n * @param cutoffDefault \n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { NumberTracker } from './NumberTracker.js';\nimport { type TrackedValueOpts as TrackOpts } from './TrackedValue.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n *\n * @export\n * @class IntervalTracker\n * @extends {ValueTracker}\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(performance.now() - this.lastMark);\n    }\n    this.lastMark = performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { intervalTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const t = intervalTracker();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = intervalTracker({ resetAfterSamples: 100} );\n * ```\n * @param opts Options for tracker\n * @returns New interval tracker\n */\nexport const intervalTracker = (opts?: TrackOpts) => new IntervalTracker(opts);\n","/* eslint-disable @typescript-eslint/require-await */\n/* eslint-disable unicorn/prefer-ternary */\nimport { Async } from \"../../Generators.js\";\nimport { delay, Elapsed } from \"../../flow/index.js\";\nimport { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\n\nimport { Queues } from \"../../collections/index.js\";\n\nimport { resolveToAsyncGen, resolveToGen } from \"./Util.js\";\nimport type { Link, GenFactoryNoInput, LazyChain, GenOrData, LinksWithSource, Gen, Links, TickOptions, DelayOptions } from \"./Types.js\";\nimport * as L from './Links.js';\nexport * as Dom from './Dom.js';\nexport * as Links from './Links.js';\n\nfunction isNoInput<Out>(c: Link<any, any>): c is GenFactoryNoInput<Out> {\n  if (`_allowNoInput` in c) return true;\n  return false;\n}\n\nexport function lazy<In, Out>(): LazyChain<In, Out> {\n  const chained: Array<Link<any, any>> = [];\n  let dataToUse: GenOrData<In> | undefined;\n\n  const asGenerator = <V>(data?: GenOrData<In>) => {\n    if (data === undefined) data = dataToUse;\n    let d = resolveToAsyncGen(data);\n    for (const c of chained) {\n      if (d === undefined) {\n        if (isNoInput<In>(c)) {\n          d = c();\n        } else {\n          throw new Error(`Function '${ getLinkName(c) }' requires input. Provide it to the function, or call 'input' earlier.`)\n        }\n      } else {\n        d = c(d);\n      }\n    }\n    return d as AsyncGenerator<V>\n  }\n\n  const w = {\n    asGenerator,\n    transform: (transformer: (v: any) => any) => {\n      chained.push(L.transform(transformer));\n      return w;\n    },\n    flatten: (flattener: (values: Array<any>) => any) => {\n      chained.push(L.flatten(flattener));\n      return w;\n    },\n    drop: (predicate: (v: In) => boolean) => {\n      chained.push(L.drop(predicate));\n      return w;\n    },\n    delay: (options: DelayOptions) => {\n      chained.push(L.delay(options));\n      return w;\n    },\n    duration: (elapsed: Interval) => {\n      chained.push(L.duration(elapsed));\n      return w;\n    },\n    debounce: (rate: Interval) => {\n      chained.push(L.debounce(rate));\n      return w;\n    },\n    fromFunction: (callback: () => any) => {\n      chained.push(fromFunction(callback));\n      return w;\n    },\n    take: (limit: number) => {\n      chained.push(L.take(limit));\n      return w;\n    },\n    chunk: (size: number, returnRemainders = true) => {\n      chained.push(L.chunk(size, returnRemainders))\n      return w;\n    },\n    filter: (predicate: (input: any) => boolean) => {\n      chained.push(L.filter(v => predicate(v)));\n      return w;\n    },\n    min: (): LazyChain<any, number> => {\n      chained.push(L.min());\n      return w as unknown as LazyChain<any, number>;\n    },\n    max: (): LazyChain<any, number> => {\n      chained.push(L.max());\n      return w as unknown as LazyChain<any, number>;\n    },\n    average: (): LazyChain<any, number> => {\n      chained.push(L.average());\n      return w as unknown as LazyChain<any, number>;\n    },\n    total: (): LazyChain<any, number> => {\n      chained.push(L.total());\n      return w as unknown as LazyChain<any, number>;\n    },\n    tally: (): LazyChain<any, number> => {\n      chained.push(L.tally());\n      return w as unknown as LazyChain<any, number>;\n    },\n    input(data: GenOrData<In>) {\n      dataToUse = data;\n      return w\n    },\n    asAsync(data?: GenOrData<In>) {\n      let d = data ?? dataToUse;\n      for (const c of chained) {\n        if (d === undefined && isNoInput<In>(c)) {\n          d = c();\n        } else if (d === undefined) {\n          throw new Error(`Function '${ getLinkName(c) }' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n        } else {\n          d = c(d);\n        }\n      }\n      return w;\n    },\n    asArray: async (data?: GenOrData<In>): Promise<Array<Out>> => {\n      const g = asGenerator<Out>(data);\n      return await Async.toArray<Out>(g);\n    },\n    firstOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      const v = await g.next();\n      return v.value as Out;\n    },\n    lastOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      let lastValue: Out | undefined;\n      for await (const v of g) {\n        lastValue = v as Out;\n      }\n      return lastValue;\n    },\n  }\n  return w as unknown as LazyChain<In, Out>;\n}\n\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever. \n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n * \n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options \n * @returns \n */\nexport function tick(options: TickOptions): GenFactoryNoInput<number> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const asClockTime = options.asClockTime ?? false;\n  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n  let looped = 0;\n  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n\n  async function* ts(): AsyncGenerator<number> {\n    const elapsed = Elapsed.since();\n    while (looped < loops && elapsed() < durationTime) {\n      yield asClockTime ? Date.now() : elapsed();\n\n      // Adjust sleep period so timing errors don't accumulate\n      const expectedTimeDiff = (looped * intervalMs) - elapsed();\n      await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n      looped++;\n    }\n  }\n  ts._name = `timestamp`;\n  return ts;\n}\n\n/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n * \n * ```js\n * const callback = () => Math.random();\n * \n * const f = Chains.fromFunction(callback);\n * f(); // New random number\n * ```\n * \n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.fromFunction(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback \n * @returns \n */\nexport function fromFunction<Out>(callback: () => Promise<Out> | Out): GenFactoryNoInput<Out> {\n  async function* fromFunction(): AsyncGenerator<Out> {\n    while (true) {\n      const v = await callback();\n      if (v === undefined) break;\n      yield v;\n    }\n  }\n  fromFunction._name = `fromFunction`;\n  return fromFunction;\n}\n\nconst oncePromise = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};\n\nexport function fromEvent<Out>(target: EventTarget, name: string) {\n  async function* fromEvent(): AsyncGenerator<Out> {\n    while (true) {\n      yield await oncePromise(target, name) as Out;\n    }\n  }\n  fromEvent._name = `fromEvent`;\n  return fromEvent;\n}\n\n/**\n * Treats the chain/generator as a promise\n * \n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n * \n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap \n * @returns \n */\nexport function asPromise<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>) {\n  let lastValue: V | undefined;\n\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  async function asPromise(): Promise<V | undefined> {\n    const v = await outputType.next();\n    if (v.done) return;\n    lastValue = v.value;\n    return lastValue;\n  }\n  return asPromise;\n}\n\n\n\n/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n * \n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n * \n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n * \n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns \n */\nexport function asValue<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>, initialValue?: V) {\n  let lastValue: V | undefined = initialValue;\n  let awaiting = false;\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  function asValue(): V | undefined {\n    if (!awaiting) {\n      awaiting = true;\n      outputType.next().then(v => {\n        lastValue = v.value;\n        awaiting = false;\n      }).catch(error => {\n        awaiting = false;\n        throw error;\n      });\n    }\n    return lastValue;\n  }\n  return asValue;\n}\n\n/**\n * Calls `callback` whenever the chain/generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap \n * @param callback \n */\nexport async function asCallback<V>(valueToWrap: GenOrData<V> | GenFactoryNoInput<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\n\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n * @param valueToWrap \n * @returns \n */\nexport async function asArray<Out>(valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>): Promise<Array<Out>> {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  return Async.toArray(outputType);\n}\n\n/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n * \n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap \n * @param array \n */\nexport async function addToArray<Out>(array: Array<Out>, valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    array.push(value);\n  }\n}\n\n/**\n * Input a single value to the chain, return a single result\n * @param f \n * @param input \n * @returns \n */\nexport async function single<In, Out>(f: Link<In, Out>, input: In): Promise<Out | undefined> {\n  const iterator = await f([ input ]).next();\n  return iterator.value as Out | undefined;\n}\n\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n * \n * Alternatively:\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link synchronise} which releases a set of results when all inputs have emitted a value\n * @param sources \n */\nexport async function* mergeFlat<Out>(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Out> {\n  const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n  const buffer = Queues.mutable<Out>();\n  let completed = 0;\n\n  const schedule = async (source: AsyncGenerator<any> | undefined) => {\n    if (source === undefined) {\n      completed++;\n      return;\n    }\n\n    const x = await source.next();\n    if (x.done) {\n      completed++;\n    } else {\n      buffer.enqueue(x.value as Out);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(() => schedule(source), 1);\n    }\n  }\n\n  for (const source of sourcesInput) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(() => schedule(source), 1);\n  }\n\n  const loopSpeed = 10;\n  let loopFactor = 1;\n  while (completed < sourcesInput.length) {\n    const d = buffer.dequeue();\n    if (d === undefined) {\n      // Grow loop factor up to 10\n      loopFactor = Math.min(loopFactor + 1, 10);\n    } else {\n      yield d;\n      // Reset loop factor\n      loopFactor = 1;\n    }\n    await sleep(loopSpeed * loopFactor);\n  }\n}\n\n/**\n * Generate values for each source, returning results as an array.  \n * If a source finishes before another, null will be used at its position in the results.\n * Use {@link synchronise} instead to only release results when all sources have yielded a value.\n * \n * Finishes when all generators finish.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link synchronise} only return results when all sourcse have yielded a value\n * @param sources \n */\nexport async function* mergeAsArray(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingProduced = true;\n  while (somethingProduced) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingProduced = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (!v.done) {\n        data[ index ] = v.value;\n        somethingProduced = true;\n      }\n    }\n    if (somethingProduced) {\n      // Send data\n      yield data;\n      data = [];\n    }\n  }\n}\n\n/**\n * Synchronise several sources, releasing a set of results when every\n * source has produced something. Finishes as soon as _any_ source finishes.\n * \n * ie. the rate of emitting data is determined by the slowest source.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * @param sources \n */\nexport async function* synchronise(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingStopped = false;\n  while (!somethingStopped) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingStopped = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (v.done) {\n        somethingStopped = true;\n        break;\n      } else {\n        data[ index ] = v.value;\n      }\n    }\n\n    if (somethingStopped) break;\n    yield data;\n    data = [];\n  }\n}\n\nconst getLinkName = (c: Link<any, any>): string => {\n  if (`_name` in c) {\n    return c._name as string;\n  } else {\n    return c.name;\n  }\n}\n\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param functions \n * @returns \n */\nexport async function* runN<In, Out>(...functions: LinksWithSource<In, Out>): AsyncGenerator<Out> {\n  let input: Gen<In> | undefined;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v as Out;\n  }\n}\n\nexport function run<T1>(gen: GenOrData<T1> | GenFactoryNoInput<T1>): AsyncGenerator<T1>;\nexport function run<T1, T2>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>): AsyncGenerator<T2>;\nexport function run<T1, T2, T3>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>): AsyncGenerator<T3>;\nexport function run<T1, T2, T3, T4>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>): AsyncGenerator<T4>;\nexport function run<T1, T2, T3, T4, T5>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>): AsyncGenerator<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>): AsyncGenerator<T6>;\nexport function run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>, l5: Link<T6, T7>): AsyncGenerator<T7>;\n\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param gen \n * @param l0 \n * @param l1 \n * @param l2 \n * @param l3 \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0?: Link<T1, T2>, l1?: Link<T2, T3>, l2?: Link<T3, T4>, l3?: Link<T4, T5>, l4?: Link<T5, T6>, l5?: Link<T6, T7>): AsyncGenerator<T1> {\n  let input: Gen<any> | undefined;\n  // eslint-disable-next-line prefer-rest-params\n  const functions = arguments;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v;\n  }\n}\n\n\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\n// export function prepare<In, Out>(...functions: Links<In, Out>) {\n//   const r = (source: GenOrData<In> | GenFactoryNoInput<Out>) => {\n//     return run(source, ...functions);\n//   }\n//   return r;\n// }\n","type WithEvents = {\n  addEventListener(type: string, callbackfn: any): void;\n  removeEventListener(type: string, callbackfn: any): void;\n}\n\n//export { eachInterval } from './flow/Interval.js';\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> =>\n  Symbol.asyncIterator in new Object(v);\n\nexport const isIterable = (v: any): v is Iterable<any> =>\n  Symbol.iterator in new Object(v);\n\nexport const eventsToIterable = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(error),\n      };\n    },\n  };\n  return r;\n};\n","import { Async } from \"../../Generators.js\";\nimport type { GenOrData, GenFactoryNoInput, Gen } from \"./Types.js\";\nimport { isAsyncIterable } from \"../../Iterable.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\n/**\n * Wrap the primitive value as generator\n * @param value \n */\nfunction* primitiveToGenerator(value: number | boolean | string) {\n  yield value;\n}\n\n/**\n * Wrap the primitive value as an async generator\n * @param value \n */\nasync function* primitiveToAsyncGenerator(value: number | boolean | string) {\n  yield value;\n  await sleep(1);\n}\n\n/**\n * Resolve the array, data or function to a Generator\n * @param input \n * @returns \n */\nexport function resolveToGen<V>(input: GenOrData<V> | GenFactoryNoInput<V>): Gen<V> {\n  if (Array.isArray(input)) {\n    const a = input.values();\n    (a as any)._name = `arrayInput`;\n    return a;\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToGenerator(input) as Gen<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  }\n  return input;\n}\n\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input \n * @returns \n */\nexport function resolveToAsyncGen<V>(input: GenOrData<V> | GenFactoryNoInput<V> | undefined): AsyncGenerator<V> | undefined {\n  if (input === undefined) return;\n  if (Array.isArray(input)) {\n    return Async.fromArray(input);\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToAsyncGenerator(input) as AsyncGenerator<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  } else if (isAsyncIterable(input)) {\n    return input;\n  }\n  return Async.fromIterable(input);\n}\n","import { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport type { Link, GenOrData, DelayOptions } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { Elapsed } from \"../../flow/index.js\";\nimport { throwIntegerTest } from \"../../Guards.js\";\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (v: In) => Out): Link<In, Out> {\n  async function* transform(input: GenOrData<In>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield transformer(value);\n    }\n  }\n  transform._name = `transform`;\n  return transform;\n}\n\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit \n * @returns \n */\nexport function take<In>(limit: number): Link<In, In> {\n  async function* take(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let yielded = 0;\n    for await (const value of input) {\n      if (++yielded > limit) break;\n      yield value;\n    }\n  }\n  take._name = `take`;\n  return take;\n}\n\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `flattener` function.\n * \n * ```js\n * // Create a chain that flattens values\n * const flatten = Chains.flatten(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(flatten, [ 1, 2, 3]); // 3\n * ```\n * @param flattener Function to flatten array of values to a single value\n * @returns \n */\nexport function flatten<In, Out>(flattener: (v: Array<In>) => Out): Link<Array<In>, Out> {\n  async function* flatten(input: GenOrData<Array<In>>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield flattener(value);\n    }\n  }\n  flatten._name = `flatten`;\n  return flatten;\n}\n\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed \n * @returns \n */\nexport function duration<In>(elapsed: Interval): Link<In, In> {\n  const durationMs = intervalToMs(elapsed, 0);\n\n  async function* duration(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    const elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() > durationMs) break;\n      yield value;\n    }\n  }\n  duration._name = `duration`;\n  return duration;\n}\n\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options \n * @returns \n */\nexport function delay<In>(options: DelayOptions): Link<In, In> {\n  const before = intervalToMs(options.before, 0);\n  const after = intervalToMs(options.after, 0);\n\n  async function* delay(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (before > 0) {\n        await sleep(before);\n      }\n      yield value;\n      if (after > 0) {\n        await sleep(after);\n      }\n    }\n  }\n  delay._name = `delay`;\n  return delay;\n}\n\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n * \n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.chain(\n *  // Produce values every 10ms for 350ms\n *  Chains.tick({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.debounce(100)\n * );\n * ```\n * @param rate \n * @returns \n */\nexport function debounce<In>(rate: Interval): Link<In, In> {\n  const rateMs = intervalToMs(rate, 0);\n\n  async function* debounce(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() < rateMs) continue;\n      yield value;\n      elapsed = Elapsed.since();\n    }\n  }\n  debounce._name = `debounce`;\n  return debounce;\n}\n\n\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * \n * This is different than {@link total} which adds up numeric values\n * @returns \n */\nexport function tally<In>(): Link<In, number> {\n  async function* tally(input: GenOrData<In>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let count = 0;\n    for await (const _ of input) {\n      yield ++count;\n    }\n  }\n  tally._name = `tally`;\n  return tally;\n}\n\n/**\n * Returns the smallest value from the input.\n * Non-numeric data is filtered out\n * @returns \n */\nexport function min(): Link<number, number> {\n  async function* min(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let min = Number.MAX_SAFE_INTEGER;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n\n      min = Math.min(value, min);\n      yield min;\n    }\n  }\n  min._name = `min`;\n  return min;\n}\n\n/**\n * Returns the largest value from the input\n * Non-numeric data is filtered out\n * @returns \n */\nexport function max(): Link<number, number> {\n  async function* max(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let max = Number.MIN_SAFE_INTEGER;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      max = Math.max(value, max);\n      yield max;\n    }\n  }\n  max._name = `max`;\n  return max;\n}\n\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function average(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    let count = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      count++;\n      total += value;\n      yield total / count;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function total(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      total += value;\n      yield total;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Chunks an input stream into `size` chunks.\n * \n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n * \n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size \n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns \n */\nexport function chunk<In>(size: number, returnRemainders = true): Link<In, Array<In>> {\n  throwIntegerTest(size, `aboveZero`, `size`);\n  async function* chunk(input: GenOrData<In>): AsyncGenerator<Array<In>> {\n    input = resolveToGen(input);\n    let buffer: Array<In> = [];\n    for await (const value of input) {\n      buffer.push(value);\n      if (buffer.length >= size) {\n        yield buffer;\n        buffer = []\n      }\n    }\n    if (returnRemainders && buffer.length > 0) yield buffer;\n  }\n  chunk._name = `chunk`;\n  return chunk;\n}\n\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n * \n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate \n * @returns \n */\nexport function filter<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* filter(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  filter._name = `filter`;\n  return filter;\n}\n\n\n\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n * \n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate \n * @returns \n */\nexport function drop<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* drop(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (!predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  drop._name = `drop`;\n  return drop;\n}\n","//import { query as DomQuery } from \"../../dom/Query.js\";\n\nimport type { GenOrData, Link } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { resolveEl } from \"../../dom/ResolveEl.js\";\n\nexport type QueryOptions = {\n  baseElement: HTMLElement;\n}\n\nexport type CreateOptions<In> = {\n  parentEl: string | HTMLElement\n  key: (value: In) => string\n}\n\n// export type IMapValueBasedMutable<T> = {\n//   set(value: T): void\n//   has(value: T): boolean\n//   delete(value: T): boolean\n//   clear(): void\n// }\n\n// const createMap = <T>(keyFunction?: (value: T) => string): IMapValueBasedMutable<T> => {\n//   if (keyFunction === undefined) {\n//     const map = new Map<T, T>();\n\n//     return {\n//       add(value) {\n//         map.set(value, value);\n//       },\n//       clear() {\n//         map.clear();\n//       },\n//       delete(value) {\n//         return map.delete(value);\n//       },\n//       has(value) {\n//         return map.has(value);\n//       },\n//     }\n//   } else {\n//     const map = new Map<string, T>();\n\n//     return {\n//       add(value) {\n//         map.set(keyFunction(value), value);\n//       },\n//       clear() {\n//         map.clear();\n//       },\n//       delete(value) {\n//         return map.delete(keyFunction(value));\n//       },\n//       has(value) {\n//         return map.has(keyFunction(value));\n//       },\n//     }\n//   }\n// }\n\n\nconst createMap = <T, TValue>(key?: (value: T) => string) => {\n  const keyFunction = key ?? ((value: T) => value);\n\n  const map = new Map<ReturnType<typeof keyFunction>, TValue>();\n  return {\n    has(key: T) {\n      return map.has(keyFunction(key));\n    },\n    get(key: T) {\n      return map.get(keyFunction(key));\n    },\n    set(key: T, value: TValue) {\n      map.set(keyFunction(key), value);\n    }\n  }\n\n}\n\nexport type ElementWithValue<T> = {\n  el: HTMLElement\n  value: T\n}\n\n/**\n * Creates a HTML element per value.\n * \n * \n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n * \n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n */\nexport function perValue<In>(options: Partial<CreateOptions<In>> = {}): Link<In, ElementWithValue<In>> {\n  const map = createMap<In, HTMLElement>(options.key);\n  const parentElementOrQuery = options.parentEl ?? document.body;\n  const parentEl = resolveEl(parentElementOrQuery);\n\n  async function* perValue(input: GenOrData<In>): AsyncGenerator<ElementWithValue<In>> {\n    for await (const value of resolveToGen(input)) {\n      let el = map.get(value);\n      if (!el) {\n        el = document.createElement(`div`);\n        map.set(value, el);\n        parentEl.append(el);\n      }\n      yield { el, value };\n    }\n  }\n  perValue._name = `dom.perValue`;\n  return perValue;\n}\n\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options \n * @returns \n */\nexport function query(options: Partial<QueryOptions> = {}): Link<string, HTMLElement> {\n  const baseElement = options.baseElement ?? document;\n\n  async function* query(input: GenOrData<string>): AsyncGenerator<HTMLElement> {\n    const gen = resolveToGen(input);\n    for await (const value of gen) {\n      for (const element of baseElement.querySelectorAll(value)) {\n        yield element as HTMLElement;\n      }\n    }\n  }\n  query._name = `dom.query`;\n  return query;\n}\n\n","export * as Directed from './DirectedGraph.js';\nexport * as Undirected from './UndirectedGraph.js';","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { Table } from \"../Table.js\"\n\n\nexport type Vertex = Readonly<{\n  id: string\n}>\n\nexport type Edge = Readonly<{\n  a: string,\n  b: string,\n  weight?: number\n}>\n\nexport type Graph = Readonly<{\n  edges: ReadonlyArray<Edge>,\n  vertices: IMapImmutable<string, Vertex>\n}>\n\nexport type ConnectOptions = Readonly<{\n  a: string\n  b: string | Array<string>\n  weight?: number\n}>\n\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id\n  }\n}\n\nexport const updateGraphVertex = (graph: Graph, vertex: Vertex): Graph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\nexport const getOrCreate = (graph: Graph, id: string): Readonly<{ graph: Graph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\nfunction resolveVertex(graph: Graph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\nexport const hasConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): boolean => {\n  const edge = getConnection(graph, a, b);\n  return edge !== undefined;\n}\n\nexport const getConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): Edge | undefined => {\n  const aa = resolveVertex(graph, a);\n  const bb = resolveVertex(graph, b);\n  for (const edge of graph.edges) {\n    if (edge.a == aa.id && edge.b === bb.id) return edge;\n    if (edge.a == bb.id && edge.b === aa.id) return edge;\n  }\n  return;\n}\n\n/**\n * Connect A <-> B\n * @param graph \n * @param a \n * @param b \n * @param weight \n * @returns \n */\nexport function connectTo(graph: Graph, a: string, b: string, weight?: number): { graph: Graph, edge: Edge } {\n  const aResult = getOrCreate(graph, a);\n  graph = aResult.graph;\n  const bResult = getOrCreate(graph, b);\n  graph = bResult.graph;\n\n  let edge = getConnection(graph, a, b);\n  if (edge !== undefined) return { graph, edge };\n  edge = {\n    a,\n    b,\n    weight\n  }\n\n  const graphChanged: Graph = {\n    ...graph,\n    edges: [ ...graph.edges, edge ]\n  }\n  return { graph: graphChanged, edge }\n}\n\nexport function connect(graph: Graph, options: ConnectOptions): Graph {\n  const { a, weight, b } = options;\n  const destinations = Array.isArray(b) ? b : [ b ];\n\n  for (const destination of destinations) {\n    const result = connectTo(graph, a, destination, weight);\n    graph = result.graph;\n  }\n\n  return graph;\n}\n\nexport const graph = (...initialConnections: Array<ConnectOptions>): Graph => {\n  let g: Graph = {\n    vertices: immutableMap(),\n    edges: []\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\nexport function toAdjacencyMatrix(graph: Graph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    table.setRow(i, v.length, false);\n\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      const connected = hasConnection(graph, ii, jj);\n      if (connected) {\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: Graph): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: Graph): Array<string> => {\n  const r: Array<string> = [];\n\n  r.push(`Vertices: ${ [ ...graph.vertices.values() ].map(v => v.id).join(`, `) }`);\n  // eslint-disable-next-line unicorn/no-array-push-push\n  r.push(`Edges:`);\n  for (const edge of graph.edges) {\n    r.push(stringForEdge(edge));\n  }\n  return r;\n}\n\nconst stringForEdge = (edge: Edge) => {\n  const weight = edge.weight ? ` (${ edge.weight })` : ``;\n  return `${ edge.a } <-> ${ edge.b }${ weight }`\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield resolveVertex(graph, edge.b);\n    else if (edge.b === context) yield resolveVertex(graph, edge.a);\n  }\n}\n\nexport function* edgesForVertex(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield edge;\n    else if (edge.b === context) yield edge;\n  }\n}","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn\n * @param lastData\n * @param newData\n * @param opts\n * @returns\n */\n//eslint-disable-next-line functional/immutable-data\nexport const align = <V>(\n  similarityFn: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  opts: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = opts.matchThreshold ?? 0;\n  const debug = opts.debug ?? false;\n  const results = new Map();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map();\n  lastData?.forEach((d, index) => {\n    if (d === undefined) {\n      throw new Error(`'lastData' contains undefined (index: ${index})`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < newData.length; i++) {\n    const newD = newData[i];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${newD.id}`);\n\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: last.id,\n      score: last === null ? -1 : similarityFn(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n    //eslint-disable-next-line functional/immutable-data\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[0];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${top.score} id: ${newD.id}`\n        );\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score})`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    //eslint-disable-next-line functional/immutable-data\n    lastMap.delete(top.id);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn\n * @param opts\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, opts: AlignOpts = {}) => {\n  //eslint-disable-next-line functional/no-let\n  let lastData: readonly DataWithId<V>[] = [];\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, opts);\n    return [...lastData];\n  };\n  return compute;\n};\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as Debug from '../debug/index.js';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type Opts<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string, data: V) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    //const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`, data);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: Array<PoolUser<V>>;\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`, data);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n */\nexport class Pool<V> {\n  private _resources: Array<Resource<V>>;\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet;\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param opts Pool options\n   */\n  constructor(opts: Opts<V> = {}) {\n    this.capacity = opts.capacity ?? -1;\n    this.fullPolicy = opts.fullPolicy ?? `error`;\n    this.capacityPerResource = opts.capacityPerResource ?? 1;\n    this.userExpireAfterMs = opts.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      opts.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = opts.generate;\n    this.freeResource = opts.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, opts.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    //eslint-disable-next-line functional/no-let\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a resource to the pool.\n   * Throws an error if the capacity limit is reached.\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new Error(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    //eslint-disable-next-line functional/no-let\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Array<Resource<V>> = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: Array<string> = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`, user.data);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  private _findUser(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    //eslint-disable-next-line functional/no-let\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a user key.\n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * @param userKey\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this._findUser(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      //console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this._findUser(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param opts\n * @returns\n */\nexport const create = <V>(opts: Opts<V> = {}): Pool<V> => new Pool<V>(opts);\n"],"mappings":"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","names":["min","max","average","smoothingFactor","average","transform","take","flatten","duration","elapsed","delay","debounce","tally","min","max","average","total","chunk","filter","drop","key","perValue","query","average","fromFunction","fromEvent","asPromise","asValue","array","graph","r"]}