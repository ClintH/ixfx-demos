{"version":3,"sources":["../src/collections/Stack.ts","../src/collections/Lists.ts","../src/collections/Set.ts"],"sourcesContent":["// ✔ Unit tested!\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\nexport type StackOpts = {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  readonly overflowPolicy?: OverflowPolicy\r\n}\r\n\r\nconst trimStack = <V>(opts: StackOpts, stack: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = stack.length + toAdd.length;\r\n  const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n\r\n  switch (policy) {\r\n  case OverflowPolicy.DiscardAdditions:\r\n    if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (stack.length === opts.capacity) {\r\n      return stack; // Completely full\r\n    } else {\r\n      // Only add some from the new array\r\n      return [...stack, ...toAdd.slice(0, toAdd.length-toRemove)];\r\n    }\r\n  case OverflowPolicy.DiscardNewer:\r\n    if (toRemove >= stack.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old (from 0)\r\n      if (opts.debug) console.log(` from orig: ${stack.slice(0, toRemove-1)}`);\r\n      return [...stack.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  case OverflowPolicy.DiscardOlder:\r\n    // Oldest item in stack is position 0\r\n    return [...stack, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n// Add to top (last index)\r\nconst push = <V>(opts: StackOpts, stack: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\r\n  //const mutated = [...stack, ...toAdd];\r\n  const potentialLength = stack.length + toAdd.length;\r\n\r\n  const overSize = (opts.capacity && potentialLength > opts.capacity);\r\n  const toReturn  = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];\r\n  return toReturn;\r\n};\r\n\r\n// Remove from top (last index)\r\nconst pop = <V>(opts: StackOpts, stack: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (stack.length === 0) throw new Error(`Stack is empty`);\r\n  return stack.slice(0, stack.length - 1);\r\n};\r\n\r\n/**\r\n * Peek at the top of the stack (end of array)\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {V[]} stack\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: StackOpts, stack: ReadonlyArray<V>): V | undefined => stack[stack.length - 1];\r\n\r\nconst isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => stack.length === 0;\r\n\r\nconst isFull = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return stack.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------\r\n// Immutable\r\n// -------------------------\r\n\r\n/**\r\n * Immutable stack\r\n * `Push` & `pop` both return a new instance, the original is never modified.\r\n * \r\n * Usage:\r\n * ```\r\n * push(item);  // Return a new stack with item(s) added\r\n * pop();       // Return a new stack with top-most item removed (ie. newest)\r\n * .peek;       // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length;     // How many items in stack\r\n * .data;       // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * let sanga = new Stack();\r\n * sanga = sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga = sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * const sangaAlt = sanga.push(`lettuce`, `cheese`); // sanga stays [`bread`, `tomato`], while sangaAlt is [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class Stack\r\n * @template V\r\n */\r\nexport class Stack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): Stack<V> {\r\n    return new Stack<V>(this.opts, push(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  pop(): Stack<V> {\r\n    return new Stack<V>(this.opts, pop(this.opts, this.data));\r\n  }\r\n\r\n  /**\r\n   * Enumerates stack from bottom-to-top\r\n   *\r\n   * @param {(v:V) => void} fn\r\n   * @memberof Stack\r\n   */\r\n  forEach(fn:(v:V) => void): void {\r\n    this.data.forEach(fn);\r\n  }\r\n\r\n  forEachFromTop(fn:(v:V) => void): void {\r\n    [...this.data].reverse().forEach(fn);\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n/**\r\n * Returns an immutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} [opts={}]\r\n * @param {...V[]} startingItems\r\n * @returns {Stack<V>}\r\n */\r\nexport const stack = <V>(opts: StackOpts = {}, ...startingItems: ReadonlyArray<V>): Stack<V> => new Stack({...opts}, [...startingItems]);\r\n\r\n\r\n// -------------------------\r\n// Mutable\r\n// -------------------------\r\n\r\n\r\n/**\r\n * Mutable stack\r\n * \r\n * Usage:\r\n * ```\r\n * push(item); // Add one or more items to the top of the stack\r\n * pop(); // Removes and retiurns the item at the top of the stack (ie the newest thing)\r\n * .peek; // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length; // How many items in stack\r\n * .data; // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const sanga = new MutableStack();\r\n * sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * sanga.push(`lettuce`, `cheese`); // Stack is now [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class MutableStack\r\n * @template V\r\n */\r\nclass MutableStack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = push(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  pop(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    pop(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a mutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {...V[]} startingItems\r\n * @returns\r\n */\r\nexport const stackMutable = <V>(opts: StackOpts, ...startingItems: ReadonlyArray<V>) =>  new MutableStack({...opts}, [...startingItems]);","import {stack, stackMutable,  OverflowPolicy as StackOverflowPolicy} from './Stack.js';\r\nimport {queue, queueMutable, OverflowPolicy as QueueOverflowPolicy} from './Queue.js';\r\nimport {IsEqual, isEqualDefault} from '../util.js';\r\n\r\nexport {stack, stackMutable, StackOverflowPolicy};\r\nexport {queue, queueMutable, QueueOverflowPolicy};\r\n\r\nexport const guardArray = <V>(array:ArrayLike<V>, paramName:string = `?`) => {\r\n  if (array === undefined) throw new Error(`Param '${paramName}' is undefined. Expected array.`);\r\n  if (array === null) throw new Error(`Param '${paramName}' is null. Expected array.`);\r\n  if (!Array.isArray(array)) throw new Error(`Param '${paramName}' not an array as expected`);\r\n};\r\n\r\nexport const randomIndex = <V>(array: ArrayLike<V>): number => Math.floor(Math.random() * array.length);\r\n\r\nexport const randomElement = <V>(array: ArrayLike<V>): V => {\r\n  guardArray(array, `array`);\r\n  return array[Math.floor(Math.random() * array.length)];\r\n};\r\n\r\n/**\r\n * Removes a random item from an array, returning both the item and the new array as a result.\r\n * Does not modify the original array unless `mutate` parameter is true\r\n *\r\n * @template V\r\n * @param {readonly} array Array to pluck item from\r\n * @param {*} V \r\n * @param {*} []\r\n * @return {*}  {({readonly value:V|undefined, readonly array:ReadonlyArray<V> })}\r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const randomPluck = <V>(array:readonly V[], mutate = false):{readonly value:V|undefined, readonly array:Array<V> } => {\r\n  if (array === undefined) throw new Error(`array is undefined`);\r\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\r\n  if (array.length === 0) return {value: undefined, array: []};\r\n  const index = randomIndex(array);\r\n  if (mutate) {\r\n    return {\r\n      value: array[index],\r\n      //eslint-disable-next-line functional/immutable-data\r\n      array: array.splice(index, 1)\r\n    };\r\n  } else {\r\n    // Copy array, remove item from that\r\n    const t = [...array];\r\n    //eslint-disable-next-line functional/immutable-data\r\n    t.splice(index, 1);\r\n    return {\r\n      value: array[index],\r\n      array: t\r\n    };\r\n  }\r\n};\r\n\r\nexport const shuffle = (dataToShuffle:ReadonlyArray<unknown>): ReadonlyArray<unknown> => {\r\n  const array = [...dataToShuffle];\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n};\r\n\r\n/**\r\n * Returns an array with a value omitted.\r\n * Value checking is completed via the provided `comparer` function, or by default checking whether `a === b`.\r\n *\r\n * @template V\r\n * @param {ReadonlyArray<V>} data\r\n * @param {V} value\r\n * @param {IsEqual<V>} [comparer=isEqualDefault]\r\n * @return {*}  {ReadonlyArray<V>}\r\n */\r\nexport const without = <V>(data:ReadonlyArray<V>, value:V, comparer:IsEqual<V> = isEqualDefault):ReadonlyArray<V> => data.filter(v => !comparer(v, value));\r\n\r\n","// ✔ UNIT TESTED\r\n\r\nimport { ToString } from \"../util.js\";\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\n\r\ntype MutableValueSetEventMap<V> = {\r\n  readonly add: {readonly value: V, readonly updated: boolean}\r\n  readonly clear: boolean\r\n  readonly delete: V\r\n}\r\n\r\nexport const addUniqueByHash = <V>(set:ReadonlyMap<string, V>|undefined, hashFunc: ToString<V>, ...values:readonly V[]) => {\r\n  const s = set === undefined ? new Map() : new Map(set);\r\n  values.forEach(v => {\r\n    const vStr = hashFunc(v);\r\n    if (s.has(vStr)) return;\r\n    s.set(vStr, v);\r\n  });\r\n  return s;\r\n};\r\n\r\nexport const mutableStringSet = <V>(keyString: ToString<V> | undefined = undefined) => new MutableStringSetImpl(keyString);\r\n\r\nexport type MutableStringSet<V> = {\r\n  readonly add: (item:V) => void\r\n  readonly has: (item:V) => boolean\r\n}\r\n\r\n/**\r\n * A mutable set that stores unique items by their value, rather\r\n * than object reference.\r\n * \r\n * By default the JSON.stringify() representation is used to compare\r\n * objects. Alternatively, pass a function into the constructor\r\n *\r\n * It also fires `add`, `clear` and `delete` events.\r\n * \r\n * Usage\r\n * ```\r\n * .add(item);    // Add one or more items. Items with same key are overriden.\r\n * .has(item);    // Returns true if item *value* is present\r\n * .clear();      // Remove everything\r\n * .delete(item); // Delete item by value\r\n * .toArray();    // Returns values as an array\r\n * .values();     // Returns an iterator over values\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const people = [\r\n *  {name: `Barry`, city: `London`}\r\n *  {name: `Sally`, city: `Bristol`}\r\n * ];\r\n * const set = mutableValueSet(person => {\r\n *  // Key person objects by name and city (assi)\r\n *  return `${person.name}-${person.city}`\r\n * });\r\n * set.add(...people);\r\n * \r\n * set.has({name:`Barry`, city:`Manchester`})); // False, key is different (Barry-Manchester)\r\n * set.has({name:`Barry`, city:`London`}));     // True, we have Barry-London as a key\r\n * set.has(people[1]);   // True, key of object is found (Sally-Bristol)\r\n * \r\n * set.addEventListener(`add`, newItem => {\r\n *  console.log(`New item added: ${newItem}`);\r\n * });\r\n * ```\r\n * \r\n * @export\r\n * @class MutableValueSet\r\n * @template V\r\n */\r\nclass MutableStringSetImpl<V> extends SimpleEventEmitter<MutableValueSetEventMap<V>> {\r\n  // ✔ UNIT TESTED\r\n  /* eslint-disable functional/prefer-readonly-type */\r\n  store = new Map<string, V>();\r\n  keyString: ToString<V>;\r\n\r\n  constructor(keyString: ToString<V> | undefined = undefined) {\r\n    super();\r\n    \r\n    if (keyString === undefined) {\r\n      keyString = (a) => {\r\n        if (typeof a === `string`) { \r\n          return a;\r\n        } else { \r\n          return JSON.stringify(a);\r\n        }\r\n      };\r\n    }\r\n    this.keyString = keyString;\r\n  }\r\n\r\n  add(...v: ReadonlyArray<V>) {\r\n    v.forEach(i => {\r\n      const isUpdated = this.has(i);\r\n      this.store.set(this.keyString(i), i);\r\n      super.fireEvent(`add`, { value: i, updated: isUpdated});\r\n    });\r\n  }\r\n\r\n  values() {\r\n    return this.store.values();\r\n  }\r\n\r\n  clear() {\r\n    this.store.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  delete(v: V): boolean {\r\n    const isDeleted = this.store.delete(this.keyString(v));\r\n    if (isDeleted) super.fireEvent(`delete`, v);\r\n    return isDeleted;\r\n  }\r\n\r\n  has(v: V): boolean {\r\n    return this.store.has(this.keyString(v));\r\n  }\r\n\r\n  toArray(): V[] {\r\n    return Array.from(this.store.values());\r\n  }\r\n}"],"mappings":"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","names":[]}