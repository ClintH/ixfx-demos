{"version":3,"sources":["../src/rx/index.ts","../src/rx/Util.ts","../src/rx/sources/Function.ts","../src/rx/sources/Iterator.ts","../src/rx/ResolveSource.ts","../src/rx/Cache.ts","../src/rx/InitStream.ts","../src/dom/SetProperty.ts","../src/rx/sinks/Dom.ts","../src/rx/ToReadable.ts","../src/rx/ops/Annotate.ts","../src/rx/ops/Batch.ts","../src/rx/ops/Transform.ts","../src/rx/ops/CloneFromFields.ts","../src/rx/ops/CombineLatestToArray.ts","../src/data/Pathed.ts","../src/data/Util.ts","../src/rx/sources/Object.ts","../src/rx/ops/CombineLatestToObject.ts","../src/rx/ops/ComputeWithPrevious.ts","../src/rx/ops/Debounce.ts","../src/rx/ops/Elapsed.ts","../src/rx/ops/Field.ts","../src/rx/ops/Filter.ts","../src/rx/ops/Interpolate.ts","../src/rx/ops/Math.ts","../src/rx/ops/Pipe.ts","../src/rx/ops/SingleFromArray.ts","../src/rx/ops/Split.ts","../src/rx/ops/Switcher.ts","../src/rx/ops/SyncToArray.ts","../src/rx/ops/SyncToObject.ts","../src/data/Process.ts","../src/rx/ops/Tap.ts","../src/rx/ops/Throttle.ts","../src/rx/ops/TimeoutTrigger.ts","../src/rx/ops/WithValue.ts","../src/rx/Chain.ts","../src/data/graphs/DirectedGraph.ts","../src/data/Table.ts","../src/rx/Graph.ts","../src/rx/Types.ts","../src/rx/ToArray.ts","../src/rx/ToGenerator.ts","../src/data/MapObject.ts","../src/rx/Wrap.ts","../src/rx/Count.ts","../src/rx/Dom.ts","../src/text/Segments.ts","../src/rx/sources/index.ts","../src/rx/sources/Array.ts","../src/rx/sources/ArrayObject.ts","../src/rx/sources/Boolean.ts","../src/rx/sources/Colour.ts","../src/rx/sources/Derived.ts","../src/rx/sources/Event.ts","../src/rx/sources/Dom.ts","../src/rx/sources/FunctionPinged.ts","../src/rx/sources/Number.ts","../src/rx/sources/ObjectProxy.ts","../src/rx/sources/Observable.ts","../src/rx/sources/String.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/unbound-method */\n//#region imports\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet, ReactivePingable } from \"./Types.js\";\nimport type { BatchOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/Types.js\";\nimport type { RankFunction, RankOptions } from \"../data/Types.js\";\nimport type { TimeoutTriggerOptions } from \"./sources/Types.js\";\nimport { type Interval, intervalToMs } from '../flow/IntervalType.js';\nimport { messageHasValue, messageIsDoneSignal, opify } from \"./Util.js\";\nimport { initStream } from \"./InitStream.js\";\nimport { resolveSource } from './ResolveSource.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\n\n//#endregion\n\n//#region exports\nexport * from './Chain.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './Graph.js';\nexport * from './Types.js';\nexport * from './ToArray.js';\nexport * from './ToGenerator.js';\nexport * from './Util.js';\nexport * from './Wrap.js';\nexport * from './ResolveSource.js';\nexport * from './Count.js';\nexport * as Dom from './Dom.js';\nexport * as From from './sources/index.js';\n//#endregion\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    onValue: events.onValue\n  };\n}\n\nexport const Sinks = {\n  setHtmlText: (options: SinkFns.SetHtmlOptions) => {\n    return (source: ReactiveOrSource<string>) => {\n      SinkFns.setHtmlText(source, options);\n    }\n  }\n}\n\nexport const Ops = {\n  /**\n * Annotates values with the result of a function.\n * The input value needs to be an object.\n * \n * For every value `input` emits, run it through `annotator`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param annotator \n * @returns \n */\n  annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => opify(OpFns.annotate, annotator),\n  /**\n   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n   * \n   * ```js\n   * // Emit values from an array\n   * const r1 = Rx.run(\n   *  Rx.From.array([ 1, 2, 3 ]),\n   *  Rx.Ops.annotateWithOp(\n   *    // Add the 'max' operator to emit the largest-seen value\n   *    Rx.Ops.sum()\n   *  )\n   * );\n   * const data = await Rx.toArray(r1);\n   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n   * ```\n   * @param annotatorOp \n   * @returns \n   */\n  annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => opify(OpFns.annotateWithOp, annotatorOp),\n  /**\n   * Takes a stream of values and batches them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  batch: <V>(options: Partial<BatchOptions>): ReactiveOp<V, Array<V>> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.batch(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.debounce(source, options);\n    }\n  },\n  elapsed: <V>(): ReactiveOp<V, number> => opify(OpFns.elapsed),\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options: FieldOptions<TSource, TFieldType>) => {\n    return (source: ReactiveOrSource<TSource>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate \n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @param options \n   * @returns \n   */\n  interpolate: <TIn = number>(options?: Partial<OpFns.OpInterpolateOptions>) => opify<TIn, ReactivePingable<number>>(OpFns.interpolate as any, options),\n  /**\n * Outputs the minimum numerical value of the stream.\n * A value is only emitted when minimum decreases.\n * @returns \n */\n  min: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.min, options),\n  /**\n   * Outputs the maxium numerical value of the stream.\n   * A value is only emitted when maximum increases.\n   * @returns \n   */\n  max: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.max, options),\n  sum: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.sum, options),\n  average: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.average, options),\n  tally: <TIn>(options?: OpFns.TallyOptions) => opify<TIn, Reactive<number>>(OpFns.tally, options),\n  rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => opify<TIn>(OpFns.rank, rank, options),\n\n  pipe: <TInput, TOutput>(...streams: Array<Reactive<any> & ReactiveWritable<any>>) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<Array<V>>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: Array<string>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  tapProcess: <In>(processor: ((value: In) => any)): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapProcess(source, processor);\n    }\n  },\n  tapStream: <In>(divergedStream: ReactiveWritable<In>): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapStream(source, divergedStream);\n    }\n  },\n  tapOps: <In, Out>(...ops: Array<ReactiveOp<In, Out>>) => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapOps(source, ...ops);\n    }\n  },\n\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutTrigger: <V, TTriggerValue>(options: TimeoutTriggerOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutTrigger<V, TTriggerValue>(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out), options: Partial<OpFns.TransformOpts> = {}): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer, options);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n\n\n\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      const value = transform ? transform(message.value) : message.value as TB;\n      b.set(value);\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        b.dispose(`Source closed (${ message.context ?? `` })`);\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      console.warn(`Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}","import { isIterable } from \"../iterables/Iterable.js\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactivePingable, ReactiveWritable, Wrapped } from \"./Types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./sources/Types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport const isPingable = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactivePingable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`ping` in rx) {\n    return true;\n  }\n  return false;\n}\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx \n * @returns \n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx \n * @returns \n */\nexport const isWritable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveWritable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`set` in rx) return true;\n  return false;\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotateElapsed` in v)) return false;\n  return true;\n}\n\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\n\nexport const opify = <TIn, TRxOut = Reactive<TIn>>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => TRxOut, ...args: Array<any>) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    return fn(source, ...args);\n  }\n}\n\n\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./Types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * See also {@link Rx.From.pinged} to trigger a function whenever another Reactive emits a value.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}) {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const interval = intervalToMs(options.interval, 1);\n  const loop = options.interval !== undefined;\n  const predelay = intervalToMs(options.predelay, 1);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  if (options.maximumRepeats && !loop) throw new Error(`'maximumRepeats' has no purpose if 'loop' is not set to true`);\n\n\n\n  // const events = initStream<V>({\n  //   onFirstSubscribe() {\n  //     if (run.runState === `idle`) run.start();\n  //   },\n  //   onNoSubscribers() {\n  //     console.log(`Rx.fromFunction onNoSubscribers. lazy: ${ lazy }`);\n  //     if (lazy === `very`) {\n  //       run.cancel();\n  //     }\n  //   },\n  // })\n\n  const done = (reason: string) => {\n    //console.log(`Rx.fromFunction done ${ reason }`);\n    events.dispose(reason);\n    run.cancel();\n  }\n\n  const run = continuously(async () => {\n    if (predelay) await sleep(predelay);\n\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      events.set(value);\n      sentResults++;\n\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n      }\n    }\n    if (!loop) {\n      done(`fromFunction done`);\n      return false; // Stop loop\n    }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false; // Stop loop\n    }\n\n  }, interval);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      run.start();\n    },\n    onStop() {\n      run.cancel();\n    },\n  });\n\n  if (lazy === `never`) run.start();\n  return events;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { nextWithTimeout } from \"../../iterables/IterableAsync.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { isAsyncIterable } from \"../../iterables/Iterable.js\";\nimport type { Reactive } from \"../Types.js\";\nimport type { GeneratorOptions } from \"./Types.js\";\nimport { StateMachine } from \"../../flow/index.js\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | Array<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.iterator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n    // eslint-disable-next-line unicorn/no-null\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      // @ts-expect-error\n      const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc?.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.From.iterator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isAsyncIterable, isIterable } from \"../iterables/Iterable.js\";\nimport { func } from \"./sources/Function.js\";\nimport { iterator } from \"./sources/Iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./sources/Types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./Types.js\";\nimport { isReactive, isWrapped } from \"./Util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import type { Reactive, ReactiveInitial, ReactiveNonInitial, ReactiveWritable } from \"./Types.js\";\n\nexport type CacheStream<T> = {\n  resetCachedValue: () => void\n  last: () => T | undefined\n}\n\nexport type CacheStreamInitial<T> = CacheStream<T> & {\n  last: () => T\n}\n\n// export function cache<T>(r: ReactiveWritable<T>, initialValue: T): CacheStream & ReactiveWritable<T> & ReactiveInitial<T>;\n// export function cache<T>(r: ReactiveWritable<T>, initialValue?: T | undefined): CacheStream & ReactiveWritable<T> & ReactiveNonInitial<T>;\n\n// export function cache<T>(r: ReactiveWritable<T>, initialValue: T | undefined): CacheStream & ReactiveWritable<T> & ReactiveInitial<T>;\n// export function cache<T>(r: Reactive<T>, initialValue: T | undefined): CacheStream & Reactive<T> & ReactiveInitial<T>;\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue): CacheStreamInitial<TValue> & RT;\n\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue | undefined): CacheStream<TValue> & RT {\n  let lastValue: TValue | undefined = initialValue;\n  r.onValue(value => {\n    lastValue = value;\n  });\n  return {\n    ...r,\n    last() {\n      return lastValue\n    },\n    resetCachedValue() {\n      lastValue = undefined;\n    }\n  }\n}","import { type Dispatch, DispatchList } from \"../flow/DispatchList.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveInitialStream, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./Types.js\";\nimport { messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { cache } from \"./Cache.js\";\n\n\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n * \n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport function initUpstream<In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out> {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  //console.log(`initUpstream${ debugLabel } creating`);\n  const onStart = () => {\n    //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n    if (unsub !== undefined) return;\n    if (options.onStart) options.onStart();\n\n    unsub = source.on(value => {\n      //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          stop();\n          events.signal(value.signal, value.context);\n          if (disposeIfSourceDone) events.dispose(`Upstream source ${ debugLabel } has completed (${ value.context ?? `` })`);\n        } else {\n          //events.through_(value);\n          events.signal(value.signal, value.context);\n        }\n      } else if (messageHasValue(value)) {\n        //lastValue = value.value;\n        onValue(value.value);\n      }\n    });\n  }\n\n  const onStop = () => {\n    //console.log(`Rx.initStream${ debugLabel } stop`);\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  //const initOpts = \n  // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n  //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n  //   initLazyStream<Out>(initOpts);\n  //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart,\n    onStop\n  });\n  return events;\n}\n\n\nexport function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveInitialStream<V> {\n  const r = initLazyStream<V>(options);\n  const c = cache<V, typeof r>(r, options.initialValue);\n  return c;\n}\n\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) {\n        //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n        onStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) {\n        //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n        onStop();\n      }\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n\n/**\n * Initialises a new stream.\n * \n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe ${ debugLabel }`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n      if (onFirstSubscribe) onFirstSubscribe();\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    removeAllSubscribers: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    // through: (pass: Passed<V>) => {\n    //   if (disposed) throw new Error(`Disposed, cannot through`);\n    //   dispatcher?.notify(pass)\n    // },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    onValue: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","import { resolveEls, type QueryOrElements } from \"./ResolveEl.js\";\n\nexport function setText(selectors: QueryOrElements): (value: any) => string;\nexport function setText(selectors: QueryOrElements, value?: any): string;\nexport function setText(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`textContent`, selectors, value)\n};\n\nexport function setHtml(selectors: QueryOrElements): (value: any) => string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`innerHTML`, selectors, value)\n};\n\nexport function setProperty(property: string, selectors: QueryOrElements): (value: any) => string;\nexport function setProperty(property: string, selectors: QueryOrElements, value: any): string;\n\nexport function setProperty(property: string, selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  let elements: Array<HTMLElement> = [];\n  const set = (v: any) => {\n    const typ = typeof v;\n    const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v as string :\n      JSON.stringify(v);\n\n    if (elements.length === 0) {\n      elements = resolveEls(selectors);\n    }\n    for (const element of elements) {\n      (element as any)[ property ] = vv;\n    }\n    return vv;\n  }\n  return value === undefined ? set : set(value);\n};","import { setProperty } from \"../../dom/SetProperty.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\n\nexport type SetHtmlOptionsQuery = {\n  query: string\n}\n\nexport type SetHtmlOptionsElement = {\n  el: HTMLElement\n}\n\nexport type SetHtmlOptions = (SetHtmlOptionsQuery | SetHtmlOptionsElement) & {\n  /**\n   * If _true_ .innerHTML is used\n   * If _false_ (default) .textContent is used\n   */\n  asHtml?: boolean;\n};\n\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource \n * @param optionsOrElementOrQuery \n */\nexport const setHtmlText = (rxOrSource: ReactiveOrSource<any>, optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement) => {\n  let el: HTMLElement | null | undefined;\n  let options: SetHtmlOptions | undefined;\n  if (typeof optionsOrElementOrQuery === `string`) {\n    options = { query: optionsOrElementOrQuery };\n  }\n  if (typeof optionsOrElementOrQuery === `object`) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (`nodeName` in optionsOrElementOrQuery) {\n      options = { el: optionsOrElementOrQuery };\n    } else {\n      options = optionsOrElementOrQuery;\n    }\n  }\n  if (options === undefined) throw new TypeError(`Missing element as second parameter or option`);\n  if (`el` in options) {\n    el = options.el;\n  } else if (`query` in options) {\n    el = document.querySelector<HTMLElement>(options.query);\n  } else {\n    throw new TypeError(`Options does not include 'el' or 'query' fields`);\n  }\n  if (el === null || el === undefined) throw new Error(`Element could not be resolved.`);\n\n  const stream = resolveSource(rxOrSource);\n  const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n  const off = stream.onValue(value => {\n    setter(value)\n  });\n  return off;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveStream } from \"./Types.js\";\n\n/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = <V>(stream: ReactiveStream<V>): Reactive<V> => ({\n  on: stream.on,\n  dispose: stream.dispose,\n  isDisposed: stream.isDisposed,\n  onValue: stream.onValue\n});\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveOp } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n * \n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n * \n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, annotator: (value: In) => TAnnotation, options: Partial<TransformOpts> = {}): Reactive<{ value: In, annotation: TAnnotation }> {\n  const upstream = initUpstream<In, { value: In, annotation: TAnnotation }>(input, {\n    ...options,\n    onValue(value) {\n      const annotation = annotator(value);\n      upstream.set({ value, annotation });\n    },\n  })\n  return toReadable(upstream);\n}\n\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n * \n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns \n */\nexport function annotateWithOp<In, TAnnotation>(input: ReactiveOrSource<In>, annotatorOp: ReactiveOp<In, TAnnotation>): Reactive<{ value: In, annotation: TAnnotation }> {\n\n  const inputStream = resolveSource(input);\n\n  // Create annotations from input\n  const stream = annotatorOp(inputStream);\n\n  const synced = syncToObject({\n    value: inputStream,\n    annotation: stream\n  })\n  return synced as Reactive<{ value: In, annotation: TAnnotation }>;\n}\n\n","import { QueueMutable } from \"../../collections/index.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { BatchOptions } from \"./Types.js\";\n\n/**\n * Queue from `source`, emitting when thresholds are reached. \n * The resulting Reactive produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in batches of 5 items\n * batch(source, { quantity: 5 });\n * // Emit data every second\n * batch(source, { elapsed: 1000 });\n * ```\n * @param batchSource \n * @param options \n * @returns \n */\nexport function batch<V>(batchSource: ReactiveOrSource<V>, options: Partial<BatchOptions> = {}): Reactive<Array<V>> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  //const logic = options.logic ?? `or`;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  //let lastFire = performance.now();\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      if (timer !== undefined && timer.runState === `idle`) {\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(batchSource, upstreamOpts);\n\n  const send = () => {\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    upstream.set(data);\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const traceInput = options.traceInput ?? false;\n  const traceOutput = options.traceOutput ?? false;\n\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      if (traceInput && traceOutput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) } output: ${ JSON.stringify(t) }`);\n      } else if (traceInput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) }`);\n      } else if (traceOutput) {\n        console.log(`Rx.Ops.transform output: ${ JSON.stringify(t) }`);\n      }\n\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n","\nimport { isPlainObjectOrPrimitive } from \"../../util/GuardObject.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source \n * @returns \n */\nexport const cloneFromFields = <In>(source: ReactiveOrSource<In>) => {\n  return transform<In, In>(source, (v): In => {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in v) {\n      const value = (v)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return Object.fromEntries(entries) as In;\n  })\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../Util.js\";\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n * \n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]  \n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): Reactive<RxValueTypes<T>> {\n  const event = initStream<RxValueTypes<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  const sources = reactiveSources.map(source => resolveSource(source));\n  const noop = () => {/** no-op */ };\n  const sourceOff = sources.map(_ => noop);\n  const doneSources = sources.map(_ => false);\n\n  const unsub = () => {\n    for (const v of sourceOff) { v() }\n  }\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    sourceOff[ index ] = v.on(message => {\n      if (messageIsDoneSignal(message)) {\n        doneSources[ index ] = true;\n        sourceOff[ index ]();\n        sourceOff[ index ] = noop;\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is set`);\n          return;\n        }\n        if (!doneSources.includes(false)) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        data[ index ] = message.value;\n        event.set([ ...data ] as RxValueTypes<T>);\n      }\n    });\n  }\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n}\n","import * as TraversableObject from '../collections/tree/TraverseObject.js';\nimport { isPrimitive } from '../IsPrimitive.js';\nimport { isPlainObjectOrPrimitive } from '../util/GuardObject.js';\nimport { isInteger } from '../util/IsInteger.js';\nimport { isEqualContextString, type IsEqualContext } from './Util.js';\nimport { compareKeys } from './Compare.js';\nimport type { Result } from '../util/Results.js';\n\nexport type PathData<V> = {\n  path: string\n  value: V\n}\n\nexport type PathDataChange<V> = PathData<V> & {\n  previous?: V\n  state: `change` | `added` | `removed`\n}\n\nexport type CompareDataOptions<V> = {\n  /**\n   * If _true_, it treats the B value as a partial\n   * version of B. Only the things present in B are compared.\n   * Omissions from B are not treated as removed keys.\n   */\n  asPartial: boolean\n  /**\n   * If _true_ (default), if a value is undefined,\n   * it signals that the key itself is removed.\n   */\n  undefinedValueMeansRemoved: boolean\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n}\n\nconst getEntries = <V extends Record<string, any>>(target: V, deepProbe: boolean) => {\n  if (target === undefined) throw new Error(`Param 'target' is undefined`);\n  if (target === null) throw new Error(`Param 'target' is null`);\n  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${ typeof target })`);\n  if (deepProbe) {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  if (a === undefined) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (b === undefined) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const asPartial = options.asPartial ?? false;\n  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n\n  //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  if (isPrimitive(b)) {\n    yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n\n    const keyOfAInB = key in b;\n    const valueOfKeyInB = b[ key ];\n    //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n\n    if (typeof valueA === `object` && valueA !== null) {\n      if (keyOfAInB) {\n        //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n        if (valueOfKeyInB === undefined) {\n          throw new Error(`Pathed.compareData Value for key ${ key } is undefined`);\n        } else {\n          const sub = [ ...compareData(valueA, valueOfKeyInB, {\n            ...options,\n            pathPrefix: pathPrefix + key + `.`\n          }) ];\n          if (sub.length > 0) {\n            for (const s of sub) yield s;\n            if (includeParents) {\n              yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n            }\n          }\n        }\n      } else {\n        if (asPartial) continue;\n        //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n        yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (keyOfAInB) {\n        // B contains key from A\n        if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n          //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n          yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n        } else {\n          if (!eq(valueA, valueOfKeyInB, subPath)) {\n            //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n          }\n        }\n      } else {\n        // B does not contain key from A\n        if (asPartial) continue; // Ignore\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: Array<PathDataChange<any>>): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: Array<string>, value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): Result<V> => {\n  if (typeof path !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Param string 'path' is empty`);\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (object === null) throw new Error(`Param 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: Array<string>): Result<V> => {\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path has run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n    if (typeof object[ index ] === `undefined`) {\n      return { success: false, error: `Index ${ index } is not present` };\n    }\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return { value: object[ index ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (typeof object === `object` && start in object) {\n    //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return { value: object[ start ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    return { success: false, error: `Path '${ start }' not found` };\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = TraversableObject.depthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    yield { path: sub, value: entries[ 1 ] };\n    yield* getPathsAndDataImpl(entries[ 1 ], sub, maxDepth - 1);\n  }\n}","//import { stringify } from 'json5';\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<any> = (a: any, b: any, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { DispatchList } from \"../../flow/DispatchList.js\";\nimport * as Pathed from \"../../data/Pathed.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ObjectFieldHandler, ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\nimport type { ObjectOptions } from \"./Types.js\";\nimport { isEqualContextString } from \"../../data/Util.js\";\nimport { throwResult } from \"../../util/Results.js\";\nimport { wildcard } from \"../../Text.js\";\n\n//type ObjectFieldHandler = (value: any, fieldName: string) => void\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.on(value => {\n *  const changed = value.value;\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `on` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * \n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Array<Pathed.PathDataChange<any>>>();\n\n  //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n  const fieldChangeEvents: Array<[ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ]> = [];\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    const diff = [ ...Pathed.compareData(value ?? {} as V, v, { ...options, includeMissingFromA: true }) ];\n    if (diff.length === 0) return;\n    value = v;\n    setEvent.set(v);\n    diffEvent.set(diff);\n  }\n\n  const fireFieldUpdate = (field: string, value: any) => {\n    for (const [ matcher, pattern, list ] of fieldChangeEvents) {\n      if (matcher(field)) {\n        list.notify({ fieldName: field, pattern, value });\n      }\n    }\n    //const l = fieldChangeEvents.get(field.toLowerCase());\n    //if (l === undefined) return;\n    //l.notify(value);\n  }\n\n  const updateCompareOptions: Partial<Pathed.CompareDataOptions<V>> = {\n    asPartial: true,\n    includeParents: true\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (value === undefined) {\n      value = toMerge as V;\n      setEvent.set(value);\n      for (const [ k, v ] of Object.entries(toMerge as V)) {\n        fireFieldUpdate(k, v);\n      }\n      return value;\n    } else {\n      const diff = [ ...Pathed.compareData(value, toMerge, updateCompareOptions) ];\n      //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n      if (diff.length === 0) return value; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      setEvent.set(value);\n      diffEvent.set(diff);\n      //console.log(`diff`, diff);\n      for (const d of diff) {\n        fireFieldUpdate(d.path, d.value);\n      }\n      return value;\n    }\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.fromObject.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Pathed.getField<any>(value, path);\n    throwResult(existing); // Eg if path not found\n\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing.value, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = [ ...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true }) ];\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Pathed.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    setEvent.set(o);\n    diffEvent.set(diff);\n    fireFieldUpdate(path, valueForField);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onValue: setEvent.onValue,\n    onDiff: diffEvent.onValue,\n    onField(fieldPattern: string, handler: (result: ObjectFieldHandler) => void) {\n      const matcher = wildcard(fieldPattern);\n      const listeners = new DispatchList<ObjectFieldHandler>();\n      fieldChangeEvents.push([ matcher, fieldPattern, listeners ]);\n      const id = listeners.add(handler);\n      return () => listeners.remove(id);\n      // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n      // if (listeners === undefined) {\n      //   listeners = new DispatchList();\n      //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n      // }\n      // const id = listeners.add((value) => {\n      //   setTimeout(() => { handler(value, fieldName) }, 1);\n      // });\n      // return () => listeners.remove(id);\n    },\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { Maps } from \"../../collections/index.js\"\nimport { initStream } from \"../InitStream.js\"\nimport { resolveSource } from \"../ResolveSource.js\"\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypeObject, ReactiveInitial, RxValueTypeRx, ReactiveDiff } from \"../Types.js\"\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../Util.js\"\nimport { object } from \"../sources/Object.js\"\n\nexport type CombineLatestToObject<T extends Record<string, ReactiveOrSource<any>>> = {\n  hasSource: (field: string) => boolean,\n  replaceSource: (field: Extract<keyof T, string>, source: ReactiveOrSource<any>) => void\n  /**\n   * Reactive sources being combined\n   */\n  sources: RxValueTypeRx<T>\n  /**\n   * Updates writable sources with values.\n   * @param data \n   * @returns Keys and values set to writable source(s)\n   */\n  setWith: (data: Partial<RxValueTypeObject<T>>) => Partial<RxValueTypeObject<T>>\n} & ReactiveDiff<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>>;\n\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n * \n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n * \n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): CombineLatestToObject<T> {// { sources: RxValueTypeRx<T> } & Reactive<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>> {\n  type State<V> = {\n    source: Reactive<V>\n    done: boolean\n    data: V | undefined\n    off: () => void\n  }\n  const disposeSources = options.disposeSources ?? true;\n  const event = object<RxValueTypeObject<T>>(undefined);\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const emitInitial = options.emitInitial ?? true;\n  let emitInitialDone = false;\n\n  const states = new Map<string, State<any>>();\n  for (const [ key, source ] of Object.entries(reactiveSources)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const initialData = (`last` in source) ? (source as any).last() : undefined;\n    const s: State<any> = {\n      source: resolveSource(source),\n      done: false,\n      data: initialData,\n      off: () => { /** no-op */ }\n    }\n    states.set(key, s);\n  }\n  const sources = Object.fromEntries(Object.entries(states).map(entry => [ entry[ 0 ], entry[ 1 ].source ])) as RxValueTypeRx<T>;\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const someUnfinished = () => Maps.some(states, v => !v.done);\n\n  const unsub = () => {\n    //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n    for (const state of states.values()) state.off();\n  }\n\n  const getData = () => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      const d = state.data;\n      if (d !== undefined) {\n        (r as any)[ key ] = state.data;\n      }\n    }\n    //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n\n    return r as RxValueTypeObject<T>;\n  }\n\n  const trigger = () => {\n    emitInitialDone = true;\n    const d = getData();\n    //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n    event.set(d);\n  }\n\n  const wireUpState = (state: State<any>) => {\n    state.off = state.source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        state.done = true;\n        state.off();\n        state.off = () => {/**no-op */ }\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is behaviour`);\n          return;\n        }\n        if (!someUnfinished()) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        state.data = message.value;\n        trigger();\n      }\n    });\n  }\n\n  for (const state of states.values()) {\n    wireUpState(state);\n  }\n\n  if (!emitInitialDone && emitInitial) {\n    //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n    trigger();\n  }\n  return {\n    ...event,\n    hasSource(field: string) {\n      return states.has(field)\n    },\n    replaceSource(field, source) {\n      const state = states.get(field);\n      if (state === undefined) throw new Error(`Field does not exist: '${ field }'`);\n      state.off();\n      const s = resolveSource(source);\n      state.source = s;\n      wireUpState(state);\n    },\n    setWith(data) {\n      let written = {};\n      for (const [ key, value ] of Object.entries(data)) {\n        const state = states.get(key);\n        if (state !== undefined) {\n          if (isWritable(state.source)) {\n            state.source.set(value);\n            (written as any)[ key ] = value;\n          }\n          state.data = value;\n        }\n      }\n      return written;\n    },\n    sources,\n    last() {\n      return getData()\n    },\n    dispose(reason: string) {\n      unsub();\n      event.dispose(reason);\n      if (disposeSources) {\n        for (const v of states.values()) {\n          v.source.dispose(`Part of disposed mergeToObject`)\n        }\n      }\n    }\n  }\n}","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../Types.js\";\nimport { hasLast } from \"../Util.js\";\n\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input \n * @param fn \n * @returns \n */\nexport function computeWithPrevious<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, current: TIn) => TIn): ReactivePingable<TIn> {\n  let previousValue: TIn | undefined;\n  let target: TIn | undefined;\n  if (hasLast(input)) {\n    target = previousValue = input.last();\n  }\n\n  const trigger = () => {\n    if (previousValue === undefined && target !== undefined) {\n      previousValue = target;\n      upstream.set(previousValue);\n    } else if (previousValue !== undefined && target !== undefined) {\n      const vv = fn(previousValue, target);\n      console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n      previousValue = vv;\n      upstream.set(vv);\n    }\n  }\n\n  const upstream = initUpstream<TIn, TIn>(input, {\n    lazy: \"very\",\n    debugLabel: `computeWithPrevious`,\n    onValue(value) {\n      console.log(`onValue ${ value }`);\n      target = value;\n      trigger();\n    },\n  })\n  if (target) trigger();\n\n  return {\n    ...toReadable(upstream),\n    ping: () => {\n      if (target !== undefined) trigger()\n    }\n  }\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { DebounceOptions } from \"./Types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n\n","import type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input \n * @returns \n */\nexport const elapsed = <In>(input: ReactiveOrSource<In>) => {\n  let last = 0;\n  return transform<In, number>(input, (_ignored) => {\n    const elapsed = last === 0 ? 0 : Date.now() - last;\n    last = Date.now();\n    return elapsed;\n  });\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FieldOptions } from \"./Types.js\";\n\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n * \n * If a source value doesn't have that field, it is skipped.\n *\n * @returns \n */\nexport function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options: Partial<FieldOptions<TIn, TFieldType>> = {}): Reactive<TFieldType> {\n  const fallbackFieldValue = options.fallbackFieldValue;\n  const fallbackObject = options.fallbackObject;\n\n  const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      let v: TFieldType | undefined;\n      // 1. Try to read from value\n      if (fieldName in value) {\n        v = value[ fieldName ] as TFieldType;\n      } else if (fallbackObject && fieldName in fallbackObject) {\n        // 2. Read from fallback object\n        v = fallbackObject[ fieldName ] as TFieldType;\n      }\n      // 3. Use fallback value\n      if (v === undefined) {\n        v = fallbackFieldValue;\n      }\n      if (v !== undefined) {\n        upstream.set(v);\n      }\n    },\n  })\n  return toReadable(upstream);\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FilterPredicate } from \"./Types.js\";\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (!predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ReactiveOrSource, ReactivePingable } from \"../Types.js\";\nimport { interpolate as interpolateFunction } from \"../../data/Interpolate.js\";\nimport { hasLast } from \"../Util.js\";\n\nexport type OpInterpolateOptions = {\n  amount: number\n  /**\n   * Percentage of value that we consider 'done'.\n   * Since interpolation can never converge to target exactly, this allows us to snap to completion.\n   * Default: 0.99, meaning if value gets to within 99%, return the target.\n   */\n  snapAt: number\n}\n\n/**\n * Interpolates to the source value.\n * \n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n * @param input \n * @param options \n * @returns \n */\nexport function interpolate(input: ReactiveOrSource<number>, options: Partial<OpInterpolateOptions> = {}): ReactivePingable<number> {\n  const amount = options.amount ?? 0.1;\n  const snapAt = options.snapAt ?? 0.99;\n\n  const i = interpolateFunction(amount);\n\n  return interpolateToTarget<number>(input, (previous, target) => {\n    const v = i(previous, target);\n    if (v / target >= snapAt) return target;\n    return v;\n  });\n}\n\n\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input \n * @param fn \n * @returns \n */\nexport function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n  let previousValue: TIn | undefined;\n  let target: TIn | undefined;\n  if (hasLast(input)) {\n    target = previousValue = input.last();\n  }\n\n  const ping = () => {\n    if (previousValue === undefined && target !== undefined) {\n      previousValue = target;\n    } else if (previousValue !== undefined && target !== undefined) {\n      previousValue = fn(previousValue, target);\n    }\n    upstream.set(previousValue!);\n  }\n\n  const upstream = initUpstream<TIn, TIn>(input, {\n    lazy: \"very\",\n    debugLabel: `computeWithPrevious`,\n    onValue(value) {\n      target = value;\n      ping();\n    },\n  })\n  if (target) ping();\n\n  return {\n    ...toReadable(upstream),\n    ping: () => {\n      if (target !== undefined) ping()\n    }\n  }\n}","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport * as BasicProcessors from '../../data/BasicProcessors.js';\nimport type { Process } from \"../../data/Process.js\";\nimport type { OpAsAnnotation, OpMathOptions } from \"./Types.js\";\nimport type { RankFunction, RankOptions } from \"../../data/Types.js\";\n\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function max(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, max: number }>;\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, max: number }> {\n  const p = BasicProcessors.max();\n  return process(p, `max`, input, options);\n}\n\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function min(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, min: number }>;\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, min: number }> {\n  const p = BasicProcessors.min();\n  return process(p, `min`, input, options);\n}\n\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function average(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, average: number }>;\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, average: number }> {\n  const p = BasicProcessors.average();\n  return process(p, `average`, input, options);\n}\n\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function sum(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, sum: number }>;\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, sum: number }> {\n  const p = BasicProcessors.sum();\n  return process(p, `sum`, input, options);\n}\n\nexport type TallyOptions = OpMathOptions & {\n  countArrayItems: boolean\n}\n\nexport function tally(input: ReactiveOrSource<any>, options: Partial<TallyOptions>): Reactive<number>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: OpAsAnnotation & Partial<TallyOptions>): Reactive<{ value: TIn, tally: number }>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: Partial<TallyOptions> = {}): Reactive<number> | Reactive<{ value: TIn, tally: number }> {\n  const countArrayItems = options.countArrayItems ?? true;\n  const p = BasicProcessors.tally(countArrayItems);\n  return process(p, `tally`, input, options);\n}\n\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: OpAsAnnotation & Partial<RankOptions & OpMathOptions>): Reactive<{ value: TIn, rank: TIn }>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn> | Reactive<{ value: TIn, rank: TIn }> {\n  const p = BasicProcessors.rank(rank, options);\n  return process(p, `rank`, input, options);\n}\n\nfunction process(processor: Process<any, any>, annotationField: string, input: ReactiveOrSource<any>, options: OpMathOptions = {}) {\n  const annotate = options.annotate;\n  let previous: number | undefined;\n  const skipUndefined = options.skipUndefined ?? true;\n  const skipIdentical = options.skipIdentical ?? true;\n  const upstream = initUpstream<any, any>(input, {\n    ...options,\n    onValue(value) {\n      const x = processor(value);\n      if (x === undefined && skipUndefined) return;\n      if (skipIdentical && x === previous) return;\n      previous = x;\n      if (annotate) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const ret: any = { value };\n        ret[ annotationField ] = x;\n        upstream.set(ret);\n      } else {\n        upstream.set(x);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n//todo testing for annotation and non - annotated\n\n\n// rankArray\n\n// chunk, reduce\n\n// debounce, delay\n\n// duration, take","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { PipeSet, Reactive, Passed } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> => {\n  const event = initStream<TOutput>();\n  const unsubs: Array<() => void> = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (!s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    onValue: event.onValue,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}","import { shuffle } from \"../../data/arrays/Random.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport type { SingleFromArrayOptions } from \"./Types.js\";\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<Array<V>>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: Array<V>) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<Array<V>, V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, ReactiveStream, Reactive } from \"../Types.js\";\nimport type { SplitOptions } from \"./Types.js\";\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource \n * @param options \n * @returns \n */\nexport const split = <T>(rxOrSource: ReactiveOrSource<T>, options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  const outputs: Array<ReactiveStream<T>> = [];\n  const source = resolveSource(rxOrSource);\n  for (let index = 0; index < quantity; index++) {\n    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n  }\n  return outputs;\n}\n\n/**\n * Splits `source` into several duplicated streams. \n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const [a,b,c] = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param rxOrSource \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(rxOrSource: ReactiveOrSource<T>, labels: Array<K>): Record<K, Reactive<T>> => {\n  const source = resolveSource(rxOrSource);\n  const t: Partial<Record<K, Reactive<T>>> = {}\n  for (const label of labels) {\n    t[ label ] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n  }\n  return t as Record<K, Reactive<T>>;\n}","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveStream } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./Types.js\";\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options: Partial<SwitcherOptions> = {}): Record<TLabel, Reactive<TValue>> => {\n  // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n  const match = options.match ?? `first`;\n  const source = resolveSource(reactiveOrSource);\n  let disposed = false;\n  // Setup output streams\n  const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n  for (const label of Object.keys(cases)) {\n    (t as any)[ label ] = initStream<TValue>();\n  }\n\n  const performDispose = () => {\n    if (disposed) return;\n    unsub();\n    disposed = true;\n    for (const stream of Object.values(t)) {\n      (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n    }\n  }\n\n  // Listen to source\n  const unsub = source.on(message => {\n    // Got a value\n    if (messageHasValue(message)) {\n      for (const [ lbl, pred ] of Object.entries(cases)) {\n        if (pred(message.value)) {\n          ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n          if (match === `first`) break;\n        }\n      }\n    } else if (messageIsDoneSignal(message)) {\n      performDispose();\n    }\n  })\n  return t as Record<TLabel, Reactive<TValue>>;\n  // }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsSignal } from \"../Util.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypes<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const maximumWait = intervalToMs(options.maximumWait, 2000);\n\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  type State<V> = {\n    done: boolean,\n    finalData: V | undefined,\n    source: Reactive<V>\n    unsub: () => void\n  }\n\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  //const finalData: Array<RxValueTypes<T> | undefined> = [];\n\n  // Resolve sources\n  //const sources = reactiveSources.map(source => resolveSource(source));\n  //const noop = () => {/*no-op*/ }\n  //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n\n  const states: Array<State<any>> = reactiveSources.map(source => ({\n    finalData: undefined,\n    done: false,\n    source: resolveSource(source),\n    unsub: () => {/**no-op */ }\n  }));\n\n\n  const unsubscribe = () => {\n    for (const s of states) {\n      s.unsub();\n      s.unsub = () => {/**no-op */ }\n    }\n  }\n\n  const isDataSetComplete = () => {\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < data.length; index++) {\n      if (onSourceDone === `allow` && states[ index ].done) continue;\n      if (data[ index ] === undefined) return false;\n    }\n    return true;\n  }\n\n  const hasIncompleteSource = () => states.some(s => !s.done);\n  const resetDataSet = () => {\n    for (let index = 0; index < data.length; index++) {\n      if (finalValue === `last` && states[ index ].done) continue; // Don't overwrite\n      data[ index ] = undefined;\n    }\n  }\n\n  const onWatchdog = () => {\n    done(`Sync timeout exceeded (${ maximumWait.toString() })`);\n  }\n\n  const done = (reason: string) => {\n    if (watchdog) clearTimeout(watchdog);\n    unsubscribe();\n    event.dispose(reason);\n  }\n\n  const init = () => {\n    watchdog = setTimeout(onWatchdog, maximumWait);\n\n    for (const [ index, state ] of states.entries()) {\n      data[ index ] = undefined; // init array positions to be undefined\n\n      state.unsub = state.source.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            state.finalData = data[ index ];\n            state.unsub();\n            state.done = true;\n            state.unsub = () => { /** no-op */ }\n            if (finalValue === `undefined`) data[ index ] = undefined;\n            if (onSourceDone === `break`) {\n              done(`Source '${ index.toString() }' done, and onSourceDone:'break' is set`);\n              return;\n            }\n            if (!hasIncompleteSource()) {\n              done(`All sources done`);\n              return;\n            }\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (isDataSetComplete()) {\n          // All array elements contain values\n          // Emit data and reset\n          event.set([ ...data ] as RxValueTypes<T>);\n          resetDataSet();\n          if (watchdog) clearTimeout(watchdog);\n          watchdog = setTimeout(onWatchdog, maximumWait);\n        }\n      });\n    }\n  }\n\n  const event = initStream<RxValueTypes<T>>({\n    onFirstSubscribe() {\n      unsubscribe();\n      init();\n    },\n    onNoSubscribers() {\n      if (watchdog) clearTimeout(watchdog);\n      unsubscribe();\n\n    },\n  });\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n\n}\n","import { zipKeyValue } from \"../../data/maps/MapFns.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../Types.js\";\nimport { syncToArray } from \"./SyncToArray.js\";\nimport { transform } from \"./Transform.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\nexport function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypeObject<T>> {\n  const keys = Object.keys(reactiveSources)\n  const values = Object.values(reactiveSources);\n\n  const s = syncToArray(values, options);\n  const st = transform(s, (streamValues) => {\n    return zipKeyValue(keys, streamValues);\n  });\n  return st as Reactive<RxValueTypeObject<T>>;\n}","import { toStringDefault } from \"../util/ToString.js\";\nimport { isEqualDefault } from \"../util/IsEqual.js\";\nexport { average, max, min, tally, sum, rank } from './BasicProcessors.js';\n\nexport type Process<TIn, TOut> = (value: TIn) => TOut;\nexport type ProcessFactory<TIn, TOut> = () => Process<TIn, TOut>;\n\nexport type Processors1<T1, T2> = [\n  Process<T1, T2>\n]\n\nexport type Processors2<T1, T2, T3> = [\n  Process<T1, T2>,\n  Process<T2, T3>\n]\n\nexport type Processors3<T1, T2, T3, T4> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>\n]\n\nexport type Processors4<T1, T2, T3, T4, T5> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>\n]\n\nexport type Processors5<T1, T2, T3, T4, T5, T6> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>,\n  Process<T5, T6>\n]\nexport type Processors<T1, T2, T3, T4, T5, T6> = Processors1<T1, T2> | Processors2<T1, T2, T3> | Processors3<T1, T2, T3, T4> | Processors4<T1, T2, T3, T4, T5> | Processors5<T1, T2, T3, T4, T5, T6>;\n\nexport function chain<T1, T2>(...processors: [ Process<T1, T2> ]): (value: T1) => T2;\nexport function chain<T1, T2, T3>(...processors: [ Process<T1, T2>, Process<T2, T3> ]): (value: T1) => T3;\nexport function chain<T1, T2, T3, T4>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4> ]): (value: T1) => T4;\nexport function chain<T1, T2, T3, T4, T5>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5> ]): (value: T1) => T5;\nexport function chain<T1, T2, T3, T4, T5, T6>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5>, Process<T5, T6> ]): (value: T1) => T6;\n\n/**\n * Creates a chain of data processors (up to 5 are supported).\n * The chain is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = chain(\n *  (value:string) => value.tUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A) // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param processors \n * @returns \n */\nexport function chain<T1, T2, T3, T4, T5, T6>(...processors: Processors<T1, T2, T3, T4, T5, T6>): (value: T1) => T2 | T3 | T4 | T5 | T6 {\n  return (value: T1) => {\n    let v = value;\n    for (const p of processors) {\n      try {\n        // @ts-expect-error\n        v = p(v);\n      } catch (err) {\n        if (err instanceof CancelError) {\n          break;\n        } else {\n          throw err;\n        }\n      }\n    }\n    return v as T2 | T3 | T4 | T5 | T6;\n  }\n}\n\n/**\n * If a value is same as the previous value, _undefined_ is emitted instead.\n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenLastToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  if (eq === undefined) eq = isEqualDefault;\n  let lastValue: TIn | undefined;\n  return (value: TIn) => {\n    if (value !== lastValue) {\n      lastValue = value;\n      return value;\n    }\n    return undefined;\n  }\n}\n\n/**\n * If a value is same as any previously-seen value, _undefined_ is emitted instead.\n * It stores all previous values and compares against them for each new value. \n * This would likely be not very efficient compared to {@link seenToUndefinedByKey} which uses a one-time computed\n * key and efficient storage of only the keys (using a Set).\n *  \n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  let seen: TIn[] = [];\n  if (eq === undefined) eq = isEqualDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    for (const s of seen) {\n      if (eq(s, value)) return;\n    }\n    seen.push(value);\n    return value;\n  }\n}\n\n/**\n * If a value is the same as any previously-seen value, _undefined_ is emitted instead.\n * This version uses a function to create a string key of the object, by default JSON.stringify.\n * Thus we don't need to store all previously seen objects, just their keys.\n * \n * Alternatively, if a key function doesn't make sense for the value, use\n * {@link seenToUndefined}, which stores the values (less efficient).\n * \n * @param toString \n * @returns \n */\nexport function seenToUndefinedByKey<TIn>(toString?: (value: TIn) => string): Process<TIn, TIn | undefined> {\n  let seen = new Set<string>();\n  if (toString === undefined) toString = toStringDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    const key = toString(value);\n    if (seen.has(key)) return;\n    seen.add(key);\n    return value;\n  }\n}\n/**\n * Calls a function if the input value is not undefined.\n * Return value from function is passed to next function in chain.\n * \n * ```js\n * const chain = Process.chain(\n *  Process.max(),\n *  Process.seenLastToUndefined(),\n *  Process.ifNotUndefined(v => {\n *    console.log(`v:`, v);\n *  })\n * );\n * chain(100); // Prints 'v:100'\n * chain(90);  // Nothing happens max value has not changed\n * chain(110); // Prints 'v:110'\n * @param fn \n * @returns \n */\nexport function ifNotUndefined<TIn, TOut>(fn: (value: Exclude<TIn, undefined>) => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return value;\n    const v = fn(value as Exclude<TIn, undefined>);\n    return v;\n  }\n}\n\nexport class CancelError extends Error {\n  constructor(message: any) {\n    super(message);\n    this.name = `CancelError`;\n  }\n}\n\n/**\n * Cancels the remaining chain operations if _undefined_ is an input.\n * See also {@link ifUndefined} or {@link ifNotUndefined}.\n * \n * ```js\n * const c3 = Process.chain(\n *  Basic.max(),\n *  Process.seenLastToUndefined(),\n *  Process.cancelIfUndefined(),\n *  (v => {\n *   console.log(v);\n *  })\n * );\n * c3(100); // Prints '100'\n * c3(90);  // Doesn't print anything since max does not change\n * c3(110); // Prints '110'\n * ```\n * @returns \n */\nexport function cancelIfUndefined<TIn>() {\n  return (value: TIn | undefined) => {\n    if (value === undefined) throw new CancelError(`cancel`);\n    return value as TIn;\n  }\n}\n/**\n * Returns the output of `fn` if the input value is _undefined_.\n * See also: {@link ifNotUndefined} and {@link cancelIfUndefined}.\n * @param fn \n * @returns \n */\nexport function ifUndefined<TIn, TOut>(fn: () => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return fn();\n    else return value;\n  }\n}","import * as Process from \"../../data/Process.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveWritable, ReactiveOp } from \"../Types.js\";\n\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns \n */\nexport function tapProcess<In, T2, T3, T4, T5, T6>(input: ReactiveOrSource<In>, ...processors: Process.Processors<In, T2, T3, T4, T5, T6>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  // @ts-expect-error\n  const chain = Process.chain(...processors);\n  inputStream.onValue(value => {\n    chain(value);\n  });\n  return inputStream;\n}\n\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to \n * @returns \n */\nexport function tapStream<In>(input: ReactiveOrSource<In>, diverged: ReactiveWritable<In>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  inputStream.onValue(value => {\n    diverged.set(value);\n  });\n  return inputStream;\n}\n\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns \n */\nexport const tapOps = <TIn, TOut>(input: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>): Reactive<TOut> => {\n  for (const op of ops) {\n    // @ts-expect-error\n    input = op(input);\n  }\n  return input as any as Reactive<TOut>;\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ThrottleOptions } from \"./Types.js\";\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { isTrigger, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutTriggerOptions } from \"../sources/Types.js\";\n\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. For example, this allows you to reset a reactive to some\n * 'zero' state if nothing is going on.\n * \n * If `source` emits faster than the `interval`, it won't get triggered.\n * \n * Default for 'timeout': 1000s.\n * \n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutTrigger(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n * \n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutTrigger(source, { fn: Math.random, interval: 500 });\n * ```\n * \n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source \n * @param options \n */\nexport function timeoutTrigger<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutTriggerOptions<TTriggerValue>): Reactive<TSource | TTriggerValue> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const immediate = options.immediate ?? true;\n  const repeat = options.repeat ?? false;\n  const timeoutMs = intervalToMs(options.interval, 1000);\n  if (!isTrigger(options)) {\n    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n  }\n\n  // Send value from trigger\n  const sendFallback = () => {\n    const [ value, done ] = resolveTriggerValue(options);\n    if (done) {\n      events.dispose(`Trigger completed`);\n    } else {\n      if (events.isDisposed()) return;\n      events.set(value);\n      if (repeat) {\n        timer = setTimeout(sendFallback, timeoutMs);\n      }\n    }\n  }\n\n  const events = initUpstream<TSource, TSource | TTriggerValue>(source, {\n    disposeIfSourceDone: true,\n    // Received a value from upstream source\n    onValue(v) {\n      // Reset timeout\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(sendFallback, timeoutMs);\n      // Emit value\n      events.set(v);\n    },\n    onDispose() {\n      if (timer) clearTimeout(timer);\n    },\n  });\n\n  if (immediate && !timer) {\n    timer = setTimeout(sendFallback, timeoutMs);\n  }\n  return events;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\n\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n * @param input \n * @param options \n * @returns \n */\nexport function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In> {\n  let lastValue: In | undefined = options.initial;\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      upstream.set(value);\n    },\n  })\n\n  const readable = toReadable(upstream);\n  return {\n    ...readable,\n    // @ts-expect-error\n    last() {\n      return lastValue;\n    },\n  }\n}","import { resolveSource } from \"./ResolveSource.js\"\nimport type { Reactive, ReactiveOp, ReactiveOrSource } from \"./Types.js\"\nimport { isWritable } from \"./Util.js\"\n\nexport type OpChain1<T1, T2> = [\n  ReactiveOp<T1, T2>\n]\n\nexport type OpChain2<T1, T2, T3> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>\n]\n\nexport type OpChain3<T1, T2, T3, T4> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>,\n  ReactiveOp<T3, T4>\n]\n\nexport type OpChain4<T1, T2, T3, T4, T5> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>,\n  ReactiveOp<T3, T4>,\n  ReactiveOp<T4, T5>\n]\n\nexport type OpChain5<T1, T2, T3, T4, T5, T6> = [\n  ReactiveOp<T1, T2>,\n  ReactiveOp<T2, T3>,\n  ReactiveOp<T3, T4>,\n  ReactiveOp<T4, T5>,\n  ReactiveOp<T5, T6>\n]\nexport type OpChain<T1, T2, T3, T4, T5, T6> = OpChain1<T1, T2> | OpChain2<T1, T2, T3> | OpChain3<T1, T2, T3, T4> | OpChain4<T1, T2, T3, T4, T5> | OpChain5<T1, T2, T3, T4, T5, T6>;\n\nexport function chainer<T1, T2>(...ops: [ ReactiveOp<T1, T2> ]): (source: ReactiveOrSource<T1>) => Reactive<T2>;\nexport function chainer<T1, T2, T3>(...ops: OpChain2<T1, T2, T3>): (source: ReactiveOrSource<T1>) => Reactive<T3>;\nexport function chainer<T1, T2, T3, T4>(...ops: OpChain3<T1, T2, T3, T4>): (source: ReactiveOrSource<T1>) => Reactive<T4>;\nexport function chainer<T1, T2, T3, T4, T5>(...ops: OpChain4<T1, T2, T3, T4, T5>): (source: ReactiveOrSource<T1>) => Reactive<T5>;\nexport function chainer<T1, T2, T3, T4, T5, T6>(...ops: OpChain5<T1, T2, T3, T4, T5, T6>): (source: ReactiveOrSource<T1>) => Reactive<T6>;\n\n/**\n * Creates a chainer of data ops (up to 5 are supported).\n * The chainer is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = chainer(\n *  (value:string) => value.tUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A) // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param ops \n * @returns \n */\nexport function chainer<T1, T2, T3, T4, T5, T6>(...ops: Array<ReactiveOp<any, any>>): (source: ReactiveOrSource<T1>) => Reactive<T2 | T3 | T4 | T5 | T6> {\n  // return (value: T1) => {\n  //   let v = value;\n  //   for (const op of ops) {\n  //     // @ts-expect-error\n  //     v = p(v);\n  //   }\n  //   return v as T2 | T3 | T4 | T5 | T6;\n  // }\n  return (source: ReactiveOrSource<T1>) => {\n    for (const op of ops) {\n      source = op(source);\n    }\n    return source as Reactive<T2 | T3 | T4 | T5 | T6>;\n  }\n}\n\nexport function run<T1, T2>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2>): Reactive<T2>;\nexport function run<T1, T2, T3>(source: ReactiveOrSource<T1>, ...ops: OpChain2<T1, T2, T3>): Reactive<T3>;\nexport function run<T1, T2, T3, T4>(source: ReactiveOrSource<T1>, ...ops: OpChain3<T1, T2, T3, T4>): Reactive<T4>;\nexport function run<T1, T2, T3, T4, T5>(source: ReactiveOrSource<T1>, ...ops: OpChain4<T1, T2, T3, T4, T5>): Reactive<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T6>;\n\n\n/**\n * Connects `source` to serially-connected set of ops. Values thus\n * flow from `source` to each op in turn.\n * \n * Returned result is the final reactive.\n * \n * @param source \n * @param ops \n * @returns \n */\nexport function run<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2> | OpChain2<T1, T2, T3> | OpChain3<T1, T2, T3, T4> | OpChain4<T1, T2, T3, T4, T5> | OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T2 | T3 | T4 | T5 | T6> {\n  let s = resolveSource(source);\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\nexport function runHead<T1, T2>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2>): Reactive<T2>;\nexport function runHead<T1, T2, T3>(source: ReactiveOrSource<T1>, ...ops: OpChain2<T1, T2, T3>): Reactive<T3>;\nexport function runHead<T1, T2, T3, T4>(source: ReactiveOrSource<T1>, ...ops: OpChain3<T1, T2, T3, T4>): Reactive<T4>;\nexport function runHead<T1, T2, T3, T4, T5>(source: ReactiveOrSource<T1>, ...ops: OpChain4<T1, T2, T3, T4, T5>): Reactive<T5>;\nexport function runHead<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T6>;\n\n\n/**\n * Connects `source` to serially-connected set of ops. Values thus\n * flow from `source` to each op in turn.\n * \n * Returned result is the final reactive.\n * \n * @param source \n * @param ops \n * @returns \n */\nexport function runHead<T1, T2, T3, T4, T5, T6>(source: ReactiveOrSource<T1>, ...ops: OpChain1<T1, T2> | OpChain2<T1, T2, T3> | OpChain3<T1, T2, T3, T4> | OpChain4<T1, T2, T3, T4, T5> | OpChain5<T1, T2, T3, T4, T5, T6>): Reactive<T2 | T3 | T4 | T5 | T6> {\n  let originalSource = resolveSource(source);\n  let s = originalSource;\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  const rr = s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  if (isWritable(originalSource)) {\n    return {\n      ...rr,\n      set(value: T1) {\n        originalSource.set(value);\n      }\n    } as any as Reactive<T2 | T3 | T4 | T5 | T6>\n  } else {\n    return rr;\n  }\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { QueueMutable, StackMutable } from \"../../collections/index.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport * as Sync from \"../../iterables/IterableSync.js\"\nimport { Table } from \"../Table.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. By default unidirectional.\n * Returns a new graph with the connection\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n  }\n\n  if (!bidi) return graph;\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n  }\n  return graph;\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","import * as DiGraph from \"../data/graphs/DirectedGraph.js\";\nimport { initStream } from \"./InitStream.js\";\nimport type { Reactive } from \"./Types.js\";\nimport { isReactive } from \"./Util.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx \n */\nexport function prepare<V extends Record<string, any>>(_rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Rx.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Rx.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: events.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: events.isDisposed,\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: events.onValue\n  }\n  return returnValue;\n}\n\n","import type { Primitive } from '../PrimitiveTypes.js';\nimport type { Interval } from '../flow/IntervalType.js';\nimport * as Immutable from '../data/Pathed.js';\nimport type { BatchOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/Types.js';\nimport type { TimeoutTriggerOptions } from './sources/Types.js';\nimport type { SetHtmlOptions } from './sinks/Dom.js';\nimport type { Processors } from '../data/Process.js';\nimport type { TallyOptions } from './ops/Math.js';\nimport type { ChangeRecord } from '../data/Compare.js';\nimport type { RecursivePartial } from 'src/TsUtil.js';\n\n\nexport type CombineLatestOptions = {\n  /**\n   * If _true_, disposes all the merged sources when the merged reactive closes.\n   * Default: _true_.\n   */\n  disposeSources: boolean\n  /**\n   * How to handle when a source ends.\n   * * 'allow': continue combined stream, last value for done stream will kept\n   * * 'break': stop combined stream\n   * \n   * Default: 'break'\n   */\n  onSourceDone: `allow` | `break`\n  /**\n   * If _true_ (default), emits a value when initialised.\n   */\n  emitInitial: boolean\n}\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: SignalKinds\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: Lazy\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n  debugLabel: string\n  onDispose: (reason: string) => void\n}\n\nexport type UpstreamInitialOptions<In> = UpstreamOptions<In> & {\n  initialValue: In\n}\n\n//export type Processor = <TIn, TOptions>(source: ReactiveOrSource<TIn>) => (options: TOptions) => () => void;\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  enacts: {\n    setHtmlText: (options: SetHtmlOptions) => () => void\n  }\n  source: Reactive<TIn>,\n\n  /**\n   * Annotate values with output from the `annotation` function.\n   * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{ value: TIn, annotation: TAnnotation }>\n  /**\n  * Accumulate a batch of values, emitted as an array\n  * @param options \n  * @returns \n  */\n  batch: (options: Partial<BatchOptions>) => Wrapped<Array<TIn>>\n\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name: string } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  min: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  max: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  average: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  sum: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  tally: (options?: Partial<TallyOptions>) => Wrapped<number>\n\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options?: Partial<SplitOptions>) => Array<Wrapped<TIn>>\n  /**\n * Emits values when this stream and any additional streams produce a value. The resulting stream is\n * thus an array of values, each source at a given index.\n * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n * the slowest stream.\n * @returns \n */\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[ TIn, ...RxValueTypes<T> ]>\n\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: { name?: string } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => Record<K, Wrapped<TIn>>\n  /**\n   * Taps the stream, passing values to one or more 'processor' functions.\n   * This processing essentially happens in parallel, not affecting the main stream.\n   * \n   * ```js\n   * // Stream of pointermove events with {x:0,y:0} as default\n   * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n   * // Wrap it for fluent access\n   * const ptr = Rx.wrap(move)\n   *  .tapProcess(\n   *    // Create a string representation\n   *    v => `${v.x},${v.y}`\n   *    // Set to DOM\n   *    v => {\n   *      document.getElementById(`coords`).innerText = v;\n   *    }\n   *   )\n   *  .onValue(value => {\n   *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n   *    // not affecting stream\n   *  });\n   * ```\n   * @param processors One-five processing functions\n   * @returns \n   */\n  tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>\n  tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>\n  tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => Wrapped<TIn>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  timeoutTrigger: <TTriggerValue>(options: TimeoutTriggerOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn>>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn | undefined>>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  onValue: (callback: (value: TIn) => void) => void\n\n}\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n  lazy: Lazy\n  debugLabel?: string\n  onStart: () => void\n  onStop: () => void\n};\n\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n  initialValue: T\n}\n\nexport type CountOptions = { lazy: Lazy, amount: number, offset: number, interval: Interval, signal: AbortSignal }\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V> | (() => V)\n\nexport type BindUpdateOpts<V> = {\n  initial: (v: V, el: HTMLElement) => void,\n  binds: Record<string, DomBindValueTarget & {\n    transform?: (value: any) => string\n  }>\n}\n\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `onValue` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): Unsubscriber\n  /**\n   * Subscribes to a reactive's values.\n   * Returns a function that unsubscribes.\n   * @param handler\n   */\n  onValue(handler: (value: V) => void): Unsubscriber\n\n  dispose(reason: string): void\n  isDisposed(): boolean\n  set?(value: V): void\n}\n\nexport type ReactivePingable<V> = Reactive<V> & {\n  ping(): void\n}\n\nexport type Unsubscriber = () => void;\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\nexport type ReactiveWritable<V> = Reactive<V> & {\n  set(value: V): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveArray<V> = ReactiveWritable<Array<V>> & {\n  push(value: V): void\n  deleteAt(index: number): void\n  deleteWhere(filter: (value: V) => boolean): number\n  setAt(index: number, value: V): void\n  insertAt(index: number, value: V): void\n  onArray(handler: (changes: Passed<Array<ChangeRecord<number>>>) => void): () => void\n}\nexport type ObjectFieldHandler = { value: any, fieldName: string, pattern: string };\n\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Notifies when the value of `fieldName` is changed.\n   * \n   * Use the returned function to unsubscribe.\n   * @param fieldName \n   * @param handler \n   */\n  onField(fieldName: string, handler: (result: ObjectFieldHandler) => void): () => void\n  /**\n   * Notifies of which field(s) were changed.\n   * If you just care about the whole, changed data use the `value` event.\n   * \n   * Use the returned function to unsubscribe.\n   * @param changes \n   */\n  onDiff(changes: (changes: Array<Immutable.PathDataChange<any>>) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   * @returns Returns new value\n   */\n  update(changedPart: RecursivePartial<V>): V\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n  //through_(message: Passed<V>): void\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  removeAllSubscribers(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\nexport type ReactiveInitialStream<V> = ReactiveStream<V> & ReactiveInitial<V>;\n\nexport type DomBindValueTarget = {\n  /**\n   * If _true_ `innerHTML` is set (a shortcut for elField:`innerHTML`)\n   */\n  htmlContent?: boolean\n  /**\n   * If _true_, 'textContent' is set (a shortcut for elField:'textContext')\n   */\n  textContent?: boolean\n  /**\n   * If set, this DOM element field is set. Eg 'textContent'\n   */\n  elField?: string\n  /**\n   * If set, this DOM attribute is set, Eg 'width'\n   */\n  attribName?: string\n  /**\n   * If set, this CSS variable is set, Eg 'hue' (sets '--hue')\n   */\n  cssVariable?: string\n  /**\n   * If set, this CSS property is set, Eg 'background-color'\n   */\n  cssProperty?: string\n}\n\nexport type ElementBind = {\n  /**\n   * Tag name for this binding.\n   * Overrides `defaultTag`\n   */\n  tagName?: string\n  /**\n   * If _true_, sub-paths are appended to element, rather than `container`\n   */\n  nestChildren?: boolean\n  transform?: (value: any) => string\n}\nexport type ElementsOptions = {\n  container: HTMLElement | string\n  defaultTag: string,\n  binds: Record<string, DomBindValueTarget & ElementBind>\n}\n\nexport type DomBindTargetNode = {\n  query?: string\n  element?: HTMLElement\n}\n\nexport type DomBindTargetNodeResolved = {\n  element: HTMLElement\n}\n\nexport type DomBindUnresolvedSource<TSource, TDestination> = DomBindTargetNode & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\nexport type DomBindResolvedSource<TSource, TDestination> = DomBindTargetNodeResolved & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\n\nexport type DomBindSourceValue<TSource, TDestination> = {\n  twoway?: boolean\n  /**\n   * Field from source value to pluck and use.\n   * This will also be the value passed to the transform\n   */\n  sourceField?: keyof TSource\n  transform?: (input: TSource) => TDestination\n  transformValue?: (input: any) => TDestination\n}\n\nexport type DomBindInputOptions<TSource, TDestination> = DomBindSourceValue<TSource, TDestination> & {\n  transformFromInput: (input: TDestination) => TSource\n}\n\n// export type PipeSet<In, Out> = [\n//   Reactive<In>,\n//   ...Array<Reactive<any> & ReactiveWritable<any>>,\n//   ReactiveWritable<Out> & Reactive<any>\n// ]\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...Array<Reactive<any> & ReactiveWritable<any>>\n]\n\nexport type InitStreamOptions = {\n  /**\n   * Optional label to associate with this stream. Useful for debugging.\n   */\n  debugLabel: string\n  /**\n   * Called when there is a subscriber after there were no subscribers.\n   * Useful for 'startup' types of things that we want to run only when someone is actually listening.\n   * \n   * During the lifeycle of a stream, this could be called multiple times. Eg if all subscribers are removed\n   * next time someone subscribes it will get called again.\n   * @returns \n   */\n  onFirstSubscribe: () => void\n  /**\n   * Called when there are no longer any subscribers. Useful for shutting down\n   * activities now that no-one is listening.\n   * \n   * During the lifecycle of a stream, this could be called multiple times.\n   * @returns\n   */\n  onNoSubscribers: () => void\n  /**\n   * Called whenever the stream disposes. Useful for cleaning up.\n   * @param reason \n   * @returns \n   */\n  onDispose: (reason: string) => void\n}\n\n\nexport type DomCreateOptions = {\n  tagName: string\n  parentEl: string | HTMLElement\n}\n\nexport type PipeDomBinding = {\n  /**\n   * Remove binding and optionally delete element(s) (false by default)\n   */\n  remove(deleteElements: boolean): void\n}\n\n\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n  /**\n   * Initial value\n   */\n  initial: V,\n  /**\n   * Laziness\n   */\n  lazy?: Lazy\n}\n\n\n\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n\n  lazy: Lazy\n}\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...Array<ReactiveOp<any, any>>,\n  ReactiveOp<any, Out>\n]\n\nexport type RxValueTypes<T extends ReadonlyArray<ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V :\n    T[ K ] extends Wrapped<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V :\n    never };\n\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? Reactive<V> :\n    T[ K ] extends Wrapped<infer V> ? Reactive<V> :\n    T[ K ] extends Generator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncGenerator<infer V> ? Reactive<V> :\n    T[ K ] extends IterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncIterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends Array<infer V> ? Reactive<V> :\n    never };\n\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    never };\n\n\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport type { ReactiveOrSource, ToArrayOptions } from \"./Types.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V | undefined>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: Array<V | undefined> = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<Array<V | undefined>>((resolve, reject) => {\n    const done = () => {\n      clearTimeout(maxWait)\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) {\n            //console.log(`Rx.toArray filling at index: ${ index }`);\n            read[ index ] = options.fillValue;\n          }\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as Array<V>;\n\n}","import { resolveSource } from \"./ResolveSource.js\";\nimport type { ReactiveOrSource } from \"./Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n","import type { RemapObjectPropertyType } from \"../TsUtil.js\";\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  // eslint-disable-next-line indent\n  object: TSource,\n  // eslint-disable-next-line indent\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n  // eslint-disable-next-line indent\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n  ]) as Array<MapResult>;\n  // @ts-expect-error\n  return Object.fromEntries(mapped);\n};\n\nexport type MapObjectArgs = {\n  field: string\n  path: string\n  value: any\n  index: number\n}\n\nexport function mapObjectByObject(data: any, mapper: Record<string, (value: any, context: any) => any>) {\n  const entries = Object.entries(data);\n  for (let i = 0; i < entries.length; i++) {\n    const e = entries[ i ];\n    if (e[ 0 ] in mapper) {\n      const m = mapper[ e[ 0 ] ];\n      e[ 1 ] = (typeof m === `object`) ?\n        mapObjectByObject(e[ 1 ], m) :\n        m(e[ 1 ], data);\n    }\n  }\n  return Object.fromEntries(entries);\n}","import * as Ops from \"./ops/index.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { toArray, toArrayOrThrow } from \"./ToArray.js\";\nimport type { ReactiveOrSource, Wrapped, ToArrayOptions, InitStreamOptions, Reactive, RxValueTypes, CombineLatestOptions, ReactiveOp, } from \"./Types.js\";\nimport type { BatchOptions, FieldOptions, FilterPredicate, DebounceOptions, SwitcherOptions, SplitOptions, ThrottleOptions, TransformOpts, SyncOptions, } from './ops/Types.js'\nimport type { TimeoutTriggerOptions } from './sources/Types.js'\nimport { messageHasValue } from \"./Util.js\";\nimport { mapObjectShallow } from '../data/MapObject.js';\nimport * as Enacts from './sinks/index.js';\nimport type { Processors } from \"../data/Process.js\";\n\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n * \n * Example:\n * For every `pointerup` event on the body, batch the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .batch({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    enacts: {\n      setHtmlText: (options) => {\n        return Enacts.setHtmlText(source, options);\n      },\n    },\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation): Wrapped<{ value: TIn, annotation: TAnnotation }> => {\n      const a = Ops.annotate<TIn, TAnnotation>(source, transformer);\n      return wrap(a);\n    },\n    batch: (options: Partial<BatchOptions>): Wrapped<Array<TIn>> => {\n      const w = wrap<Array<TIn>>(Ops.batch(source, options));\n      return w;\n    },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(Ops.debounce<TIn>(source, options));\n    },\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>> = {}) => {\n      // Ops.field requires TIn extends object\n      // Would be good if `wrap` returns different versions depending on TIn, so .field\n      // would not be present at all if we had Reactive<number>, for example\n      // @ts-expect-error\n      const f = Ops.field<TIn, TFieldType>(source, fieldName, options);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(Ops.filter(source, predicate, options));\n    },\n    combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}) => {\n      const srcs = [ source, ...sources ] as any as T;\n      return wrap(Ops.combineLatestToArray(srcs, options));\n    },\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<CombineLatestOptions>) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.combineLatestToObject(o, options));\n    },\n    min: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.min(source, options));\n    },\n    max: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.max(source, options));\n    },\n    average: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.average(source, options));\n    },\n    sum: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.sum(source, options));\n    },\n    tally: (options: Partial<Ops.TallyOptions> = {}) => {\n      return wrap(Ops.tally(source, options));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = Ops.split<TIn>(source, options).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => {\n      const l = Ops.splitLabelled<TIn, keyof TIn>(source, labels);\n      const m = mapObjectShallow<typeof l, Wrapped<TIn>>(l, args => wrap(args.value as Reactive<TIn>)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = Ops.switcher<TIn, TRec, TLabel>(source, cases, options);\n      const m = mapObjectShallow<typeof s, Wrapped<TIn>>(s, args => wrap(args.value as Reactive<TIn>));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(additionalSources: T, options: Partial<SyncOptions> = {}) => {\n      const unwrapped = [ source, ...additionalSources ].map(v => resolveSource(v));\n      const x = Ops.syncToArray(unwrapped, options) as Reactive<[ TIn, ...RxValueTypes<T> ]>;\n      return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n    },\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<SyncOptions> = {}) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.syncToObject(o, options));\n    },\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => {\n      Ops.tapProcess(source, ...processors)\n      return wrap(source);\n    },\n    tapStream: (divergedStream) => {\n      Ops.tapStream(source, divergedStream);\n      return wrap(source);\n    },\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => {\n      Ops.tapOps(source, ...ops);\n      return wrap(source);\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(Ops.throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(Ops.transform(source, transformer, options));\n    },\n    timeoutTrigger: <TTrigger>(options: TimeoutTriggerOptions<TTrigger>) => {\n      return wrap(Ops.timeoutTrigger<TIn, TTrigger>(source, options));\n    },\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    onValue: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    }\n  }\n}\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport { continuously } from \"../flow/Continuously.js\";\nimport type { CountOptions } from \"./Types.js\";\nimport { initLazyStream } from \"./InitStream.js\";\n\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n * \n * ```js\n * const r = Rx.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n * \n * The `limit` is exclusive\n * ```js\n * const r = Rx.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n * \n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n * \n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.count({ start: 10, amount: 2, interval: 500 });\n * ```\n * \n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options \n */\nexport function count(options: Partial<CountOptions> = {}) {\n\n  const lazy = options.lazy ?? `initial`;\n  const interval = intervalToMs(options.interval, 1000);\n  const amount = options.amount ?? 1;\n  const offset = options.offset ?? 0;\n\n  let produced = 0;\n  let value = offset;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n  }\n\n  const timer = continuously(() => {\n    if (options.signal?.aborted) {\n      done(`Aborted (${ options.signal.reason })`);\n      return false;\n    }\n    events.set(value);\n    value += 1;\n    produced++;\n    if (produced >= amount) {\n      done(`Limit reached`);\n      return false;\n    }\n  }, interval);\n\n  const events = initLazyStream<number>({\n    onStart() {\n      timer.start();\n    },\n    onStop() {\n      timer.cancel();\n    },\n    onDispose() {\n      timer.cancel();\n    },\n    lazy\n  });\n  return events;\n}\n","import * as Immutable from \"../data/Pathed.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport * as Rx from \"./index.js\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind } from './Types.js';\nimport { hasLast, messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { getFromKeys } from \"../data/maps/MapFns.js\";\nimport { afterMatch, beforeMatch } from \"../Text.js\";\nimport { stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"../text/Segments.js\";\nimport { QueueMutable } from \"../collections/index.js\";\nimport { object } from \"./sources/Object.js\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as Array<HTMLElement>;\n\n  return object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.\n * Use {@link bindValueRange} when setting numeric values\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\nexport const bindValueText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n}\n\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\nconst setupInput = <TSource, TDestination>(b: PipeDomBinding, input: Rx.Reactive<TDestination>, source: Rx.Reactive<TSource>, twoway: boolean, transformFromInput: (value: TDestination) => TSource) => {\n  input.onValue(value => {\n    const v = transformFromInput(value);\n    if (twoway && Rx.isWritable(source)) {\n      source.set(v);\n    }\n  });\n  const dispose = () => {\n    input.dispose(`bindInput twoway dispose`);\n    b.remove(false);\n  }\n  return { ...b, dispose, input };\n}\n\nconst validateElement = (elOrQuery: string | HTMLInputElement | null, type?: string): HTMLInputElement => {\n  const el = resolveEl(elOrQuery);\n  if (el.nodeName !== `INPUT`) throw new Error(`HTML INPUT element expected. Got: ${ el.nodeName }`);\n  if (type !== undefined && el.type !== type) throw new Error(`HTML INPUT element expected with type 'range'. Got: ${ el.type }`);\n  return el;\n}\n\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<TSource, string> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery Element to update to, or query string such as '#someid'\n * @param source Source of data\n * @param binds Bindings\n */\nexport const bindElement = <TSource, TDestination>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, ...binds: Array<DomBindSourceValue<TSource, TDestination> & Rx.DomBindValueTarget>): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<TSource, TDestination>;\n    return { ...bind, element: el } as DomBindResolvedSource<TSource, TDestination>\n  });\n  return bind<TSource, TDestination>(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <TSource, TDestination>(bind: DomBindSourceValue<TSource, TDestination>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: TSource) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: TSource) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <TSource, TDestination>(source: Rx.Reactive<TSource>, ...bindsUnresolvedElements: Array<Rx.DomBindUnresolvedSource<TSource, TDestination>>): PipeDomBinding => {\n  const binds: Array<DomBindResolvedSource<TSource, TDestination>> = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<TSource, TDestination>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: TSource) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      update(message.value);\n    } else if (messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Array<Immutable.PathDataChange<any>>, el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  //const binds = opts.binds;\n  const update = (value: Array<Immutable.PathDataChange<any>>) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(value => {\n    update(value);\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = getFromKeys(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: Array<Immutable.PathDataChange<any> | Immutable.PathData<any>>) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (!(`previous` in d) || d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = [ ...Immutable.getPathsAndData(d.value, Number.MAX_SAFE_INTEGER, path) ];\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(value => {\n    //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n    changes(value);\n  });\n\n  // Source has an initial value, use that\n  if (hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes([ ...Immutable.getPathsAndData(last as object, 1) ]);\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = Rx.From.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = Rx.From.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n","export * from './Array.js';\nexport * from './ArrayObject.js';\nexport * from './Boolean.js';\nexport * from './Colour.js';\nexport * from './Derived.js';\nexport * from './Dom.js';\nexport * from './Event.js';\nexport * from './Function.js';\nexport * from './FunctionPinged.js';\nexport * from './Iterator.js';\nexport * from './Number.js';\nexport * from './Object.js';\nexport * from './ObjectProxy.js';\nexport * from './Observable.js';\nexport * from './String.js';\nexport * from './Types.js';","\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveFinite, ReactiveInitial } from \"../Types.js\";\nimport type { ArrayOptions } from \"./Types.js\";\n\nexport const of = <V>(source: Array<V> | Iterable<V>, options: Partial<ArrayOptions> = {}) => {\n  if (Array.isArray(source)) {\n    return array(source, options);\n  } else {}\n}\n\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n * \n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n * @param sourceArray \n * @param options \n * @returns \n */\nexport const array = <V>(sourceArray: Array<V>, options: Partial<ArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const whenStopped = options.whenStopped ?? `continue`;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const array = [ ...sourceArray ];\n\n  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${ lazy }'. Use lazy:'very' instead.`);\n\n  const intervalMs = intervalToMs(options.interval, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);\n      c.start();\n    },\n    onStop() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${ whenStopped } index: ${ index }`);\n\n      c.cancel();\n      if (whenStopped === `reset`) index = 0;\n    },\n    // onFirstSubscribe() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n    //   // Start if in lazy mode and not running\n    //   if (lazy !== `never` && c.runState === `idle`) c.start();\n    // },\n    // onNoSubscribers() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n    //   if (lazy === `very`) {\n    //     c.cancel();\n    //     if (whenStopped === `reset`) {\n    //       index = 0;\n    //     }\n    //   }\n    // }\n  });\n\n  const c = continuously(() => {\n    if (signal?.aborted) {\n      s.dispose(`Signalled (${ signal.reason })`);\n      return false; // stop looping\n    }\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      s.dispose(`Source array complete`);\n      return false; // stop loop\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: s.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: s.isDisposed,\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: s.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: s.onValue\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveInitial, ReactiveNonInitial, ReactiveArray, Reactive } from \"../Types.js\";\nimport type { ArrayObjectOptions } from \"./Types.js\";\nimport { compareArrays, type ChangeRecord } from \"../../data/Compare.js\";\nimport { remove as ArraysRemove } from '../../data/arrays/Remove.js';\nimport { insertAt as ArraysInsertAt } from \"../../data/arrays/InsertAt.js\";\n/**\n * Wraps an array object\n * @param initialValue \n * @param options \n * @returns \n */\nexport function arrayObject<V>(initialValue: ReadonlyArray<V> = [], options: Partial<ArrayObjectOptions<V>> = {}): Reactive<ReadonlyArray<V>> & ReactiveArray<V> & (ReactiveInitial<ReadonlyArray<V>> | ReactiveNonInitial<ReadonlyArray<V>>) {\n  const eq = options.eq ?? isEqualValueDefault;\n  const setEvent = initStream<Array<V>>();\n  //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n  const arrayEvent = initStream<Array<ChangeRecord<number>>>();\n  let value: ReadonlyArray<V> = initialValue;\n  let disposed = false;\n\n  const set = (replacement: Array<V> | ReadonlyArray<V>) => {\n    const diff = compareArrays<V>(value as Array<V>, replacement as Array<V>, eq);\n    //console.log(`Rx.fromArray.set diff`, diff);\n    //if (diff.length === 0) return;\n    //diffEvent.set(diff);\n    value = replacement;\n    setEvent.set([ ...replacement ]);\n  }\n\n  const setAt = (index: number, v: V) => {\n    (value as Array<V>)[ index ] = v;\n    setEvent.set([ ...value ]);\n  }\n\n  const push = (v: V) => {\n    value = [ ...value, v ];\n    setEvent.set([ ...value ]);\n    const cr: ChangeRecord<number> = [ `add`, value.length - 1, v ];\n    arrayEvent.set([ cr ]);\n  }\n\n  const deleteAt = (index: number) => {\n    const valueChanged = ArraysRemove(value, index);\n    if (valueChanged.length === value.length) return; // no change\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    //console.log(diff.summary);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  const deleteWhere = (filter: (value: V) => boolean) => {\n    const valueChanged = value.filter(v => !filter(v));\n    const count = value.length - valueChanged.length;\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n    return count;\n  }\n\n  const insertAt = (index: number, v: V) => {\n    const valueChanged = ArraysInsertAt(value, index, v);\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  // const update = (toMerge: Partial<V>) => {\n  //   // eslint-disable-next-line unicorn/prefer-ternary\n  //   if (value === undefined) {\n  //     value = toMerge as V;\n  //   } else {\n  //     const diff = Immutable.compareData(toMerge, value);\n  //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n  //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n  //     if (diff.length === 0) return; // No changes\n  //     value = {\n  //       ...value,\n  //       ...toMerge\n  //     }\n  //     diffEvent.set(diff);\n  //   }\n  //   setEvent.set(value);\n  // }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    //diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  const r = {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    last: () => value,\n    on: setEvent.on,\n    onArray: arrayEvent.on,\n    onValue: setEvent.onValue,\n    setAt,\n    push,\n    deleteAt,\n    deleteWhere,\n    insertAt,\n    /**\n     * Set the whole object\n     */\n    set\n  }\n  return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function boolean(initialValue: boolean): ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport function boolean(): ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\nexport function boolean(initialValue?: boolean): ReactiveWritable<boolean> & (ReactiveNonInitial<boolean> | ReactiveInitial<boolean>) {\n  let value = initialValue;\n  const events = initStream<boolean>();\n\n  const set = (v: boolean) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type Color from \"colorjs.io\";\nimport * as Colour from '../../visual/Colour.js';\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport type ReactiveColour = ReactiveWritable<Color> & {\n  setHsl: (hsl: Colour.Hsl) => void;\n}\n\nexport function colour(initialValue: Color): ReactiveColour & ReactiveInitial<Color>;\nexport function colour(): ReactiveColour & ReactiveNonInitial<Color>;\nexport function colour(initialValue?: Color): ReactiveColour & (ReactiveNonInitial<Color> | ReactiveInitial<Color>) {\n  let value = initialValue;\n  const events = initStream<Color>();\n\n  const set = (v: Color) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set,\n    setHsl: (hsl: Colour.Hsl) => {\n      set(Colour.resolve(hsl))\n    }\n  }\n}\n","import { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { cache } from \"../Cache.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport { type CombineLatestToObject, combineLatestToObject } from \"../ops/CombineLatestToObject.js\";\nimport type { ReactiveNonInitial, ReactiveOrSource, RxValueTypeObject } from \"../Types.js\";\nimport type { DerivedOptions } from \"./Types.js\";\n\nexport function derived<TResult, const T extends Record<string, ReactiveOrSource<any>>>(fn: (combined: RxValueTypeObject<T>) => TResult | undefined, reactiveSources: T, options: Partial<DerivedOptions<TResult, CombineLatestToObject<T>>> = {}): ReactiveNonInitial<TResult> {\n  const ignoreIdentical = options.ignoreIdentical ?? true;\n  const eq = options.eq ?? isEqualValueDefault<TResult>;\n\n  const sources = combineLatestToObject(reactiveSources);\n\n  const handle = (v: RxValueTypeObject<T>) => {\n    const last = output.last();\n    const vv = fn(v);\n    if (vv !== undefined) {\n      if (ignoreIdentical && last !== undefined) {\n        if (eq(vv, last)) return vv;\n      }\n      output.set(vv);\n    }\n\n    return vv;\n  }\n\n  // When the combined stream emits a value, output it\n  const s = initUpstream<RxValueTypeObject<T>, TResult>(sources, {\n    ...options,\n    onValue(v) {\n      handle(v);\n    },\n  });\n  const output = cache(s, fn(sources.last()));\n  return output;\n}\n\n","import type { Passed, Reactive, ReactiveInitial } from \"../Types.js\";\nimport { field } from \"../ops/Field.js\";\nimport { object } from \"./Object.js\";\nimport type { FieldOptions } from \"../ops/Types.js\";\nimport type { EventOptions, EventTriggerOptions } from \"./Types.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { Elapsed } from \"../../flow/index.js\";\n/**\n * Fired when `eventName` fires on `target`. \n * \n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n * \n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId') \n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options: Partial<EventOptions & FieldOptions<any, TFieldValue>> = {}) {\n\n  const initial: Record<string, any> = {};\n  initial[ fieldName ] = initialValue;\n\n  const rxField = field<any, TFieldValue>(\n    event(targetOrQuery, eventName, initial, options),\n    fieldName,\n    options\n  );\n  return rxField;\n}\n\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options: Partial<EventOptions> = {}): ReactiveInitial<TEventArgs> & Reactive<TEventArgs> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const lazy = options.lazy ?? false;\n  if (initialValue === undefined) initialValue = {} as TEventArgs;\n  const rxObject = object<TEventArgs>(initialValue, { deepEntries: true });\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(args as TEventArgs);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<TEventArgs>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    onValue: (handler: (v: TEventArgs) => void) => {\n      if (lazy) add();\n      return rxObject.onValue(handler);\n    }\n  }\n}\n\nexport type TriggerData = {\n  sinceLast: number\n  total: number\n}\n\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of \n * times event has been fired.\n * @param targetOrQuery \n * @param name \n * @param options \n * @returns \n */\nexport function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options: Partial<EventTriggerOptions> = {}): Reactive<TriggerData> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const fireInitial = options.fireInitial ?? false;\n\n  let count = 0;\n  const elapsed = Elapsed.interval();\n\n  const stream = initLazyStream<TriggerData>({\n    lazy: options.lazy ?? `very`,\n    onStart() {\n      target.addEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger add '${ name }'`);\n      }\n      if (fireInitial && count === 0) {\n        if (debugLifecycle || debugFiring) console.log(`Rx.From.eventTrigger: firing initial`);\n        callback();\n      }\n    },\n    onStop() {\n      target.removeEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger remove '${ name }'`);\n      }\n    },\n  });\n\n  const callback = (_args?: any) => {\n    if (debugFiring) console.log(`Rx.From.eventTrigger '${ name }' triggered'`)\n    stream.set({\n      sinceLast: elapsed(),\n      total: ++count\n    });\n  }\n\n  return stream;\n}","import * as Colour from '../../visual/Colour.js';\nimport type { ReactiveInitial, ReactiveWritable, Reactive } from \"../Types.js\";\nimport { eventTrigger } from \"./Event.js\";\nimport type { DomNumberInputValueOptions, DomValueOptions } from \"./Types.js\";\nimport { resolveEl } from '../../dom/ResolveEl.js';\nimport { transform } from '../ops/Transform.js';\nimport { hasLast } from '../Util.js';\n\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n * \n * Options:\n * - relative: if _true_, values are 0..1 (default: false)\n * - inverted: if _true_, values are 1..0 (default: false)\n * \n * If element is missing a 'type' attribute, this will be set to 'range'.\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domNumberInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomNumberInputValueOptions> = {}): ReactiveInitial<number> & ReactiveWritable<number> {\n  const input = domInputValue(targetOrQuery, options);\n  const el = input.el;\n  const relative = options.relative ?? false;\n  const inverted = options.inverted ?? false;\n\n  const rx = transform(input, v => {\n    return Number.parseFloat(v);\n  });\n\n  if (relative) {\n    //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n    el.max = inverted ? \"0\" : \"1\";\n    //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n    el.min = inverted ? \"1\" : \"0\";\n    if (!el.hasAttribute(`step`)) {\n      //el.setAttribute(`step`, \"0.1\");\n      el.step = \"0.1\";\n    }\n  }\n  if (el.getAttribute(`type`) === null) {\n    el.type = `range`;\n  }\n\n  const set = (value: number) => {\n    input.set(value.toString());\n  }\n\n  return {\n    ...rx,\n    last() {\n      return Number.parseFloat(input.last())\n    },\n    set\n  };\n}\n\nexport function domHslInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): ReactiveInitial<Colour.Hsl> & Reactive<Colour.Hsl> & ReactiveWritable<Colour.Hsl> {\n\n  const input = domInputValue(targetOrQuery, {\n    ...options,\n    upstreamFilter(value) {\n      return (typeof value === `object`) ? Colour.toHex(value) : value;\n    },\n  });\n  const rx = transform(input, v => {\n    return Colour.toHsl(v, true);\n  });\n  return {\n    ...rx,\n    last() {\n      return Colour.toHsl(input.last(), true)\n    },\n    set(value) {\n      input.set(Colour.toHex(value));\n    },\n  };\n}\n\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n * \n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): { el: HTMLInputElement } & ReactiveInitial<string> & ReactiveWritable<string> {\n  const target: HTMLInputElement | null = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${ targetOrQuery }'`);\n  if (target === null) throw new Error(`targetOrQuery is null`)\n\n  const el = resolveEl(targetOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const fallbackValue = options.fallbackValue ?? ``;\n  const upstreamSource = options.upstreamSource;\n  let upstreamSourceUnsub = () => {}\n\n  let attribName = options.attributeName;\n  let fieldName = options.fieldName;\n\n  if (fieldName === undefined && attribName === undefined) {\n    attribName = fieldName = `value`;\n  }\n\n  const readValue = () => {\n    let value: string | null | undefined;\n    if (attribName) {\n      value = el.getAttribute(attribName);\n    }\n    if (fieldName) {\n      value = (el as any)[ fieldName ]\n    }\n    if (value === undefined || value === null) value = fallbackValue;\n    //console.log(`domInputValue readValue: ${ value }`);\n    return value;\n  }\n\n  const setValue = (value: string) => {\n    if (attribName) {\n      el.setAttribute(attribName, value);\n    }\n    if (fieldName) {\n      (el as any)[ fieldName ] = value;\n    }\n  }\n\n  const setUpstream = (v: any) => {\n    v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n    setValue(v);\n  }\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n    if (hasLast(upstreamSource)) {\n      setUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(el, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el,\n    last() {\n      return readValue()\n    },\n    set(value) {\n      setValue(value);\n    },\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { Reactive, Unsubscriber } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../Util.js\";\nimport type { PingedFunctionOptions, PingedFunctionFunction } from \"./Types.js\";\n\n\n/**\n * Creates a reactive with `callback` as a value source. This gets called whenever `source` emits a value.\n *\n * @param callback \n * @param source \n * @param options \n * @returns \n */\nexport function pinged<T, TSource>(source: Reactive<TSource>, callback: PingedFunctionFunction<T, TSource>, options: Partial<PingedFunctionOptions> = {}) {\n  const closeOnError = options.closeOnError ?? true;\n  const lazy = options.lazy ?? `initial`;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n\n  let upstreamOff: Unsubscriber | undefined;\n\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, (_) => {\n      done(`Signal received (${ options.signal?.reason })`);\n    })\n  }\n\n  const events = initStream<T>({\n    onFirstSubscribe() {\n      if (lazy !== `never` && upstreamOff === undefined) start();\n    },\n    onNoSubscribers() {\n      // Unsubscribe from source if we're very lazy\n      // Stay subscribed if we're only initially lazy or not lazy at all\n      if (lazy === `very` && upstreamOff !== undefined) {\n        upstreamOff();\n        upstreamOff = undefined;\n      }\n    },\n  })\n\n  const start = () => {\n    upstreamOff = source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Upstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal);\n      } else if (messageHasValue(message)) {\n        void trigger(message.value);\n      }\n    });\n  }\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    if (upstreamOff) upstreamOff();\n  }\n\n  const trigger = async (value: TSource) => {\n    try {\n      const v = await callback(value, internalAbortCallback);\n      events.set(v);\n      // Feedback from callback\n      if (internalAbort.signal.aborted) {\n        done(`callback function aborted (${ internalAbort.signal.reason })`);\n        return false\n      }\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n      }\n    }\n  }\n\n  if (lazy === `never`) start();\n  return events;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function number(initialValue: number): ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}\n","import { object } from \"./Object.js\";\nimport { symbol, type ReactiveDiff, type ReactiveInitial } from \"../Types.js\";\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target`, so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n * \n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * @param target \n * @returns \n */\nexport const objectProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n  const rx = object(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      const isArray = Array.isArray(target);\n      //console.log(`Rx.fromProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (isArray && p === `length`) return true;\n\n      if (typeof p === `string`) {\n        rx.updateField(p, newValue);\n      }\n\n      // If target is array and field looks like an array index...\n      if (isArray && typeof p === `string`) {\n        const pAsNumber = Number.parseInt(p);\n        if (!Number.isNaN(pAsNumber)) {\n          target[ pAsNumber ] = newValue;\n          return true;\n        }\n      }\n      (target as any)[ p ] = newValue;\n      return true;\n    }\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const objectProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = objectProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../Types.js\";\nimport { messageHasValue } from \"../Util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V> {\n  const ow = observableWritable(init);\n  return {\n    dispose: ow.dispose,\n    isDisposed: ow.isDisposed,\n    on: ow.on,\n    onValue: ow.onValue\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V> {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    onValue: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function string(initialValue: string): ReactiveWritable<string> & ReactiveInitial<string>;\nexport function string(): ReactiveWritable<string> & ReactiveNonInitial<string>;\nexport function string(initialValue?: string): ReactiveWritable<string> & (ReactiveNonInitial<string> | ReactiveInitial<string>) {\n  let value = initialValue;\n  const events = initStream<string>();\n\n  const set = (v: string) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}"],"mappings":"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","names":["average","interpolate","max","min","rank","sum","tally","run","iterator","elements","field","event","field","split","object","field","value","event","field","elapsed","elapsed","interpolate","max","min","average","sum","tally","rank","annotate","event","event","chain","elapsed","object","graph","vertices","to","process","resolve","resolve","object","min","max","average","sum","tally","source","elements","bind","field","changes","array","filter","count","insertAt","remove","count","elapsed","target","interpolate","min","max","sum","average","tally","rank","resolve","transform"]}