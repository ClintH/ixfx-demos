{"version":3,"sources":["../src/iterables/sync/Slice.ts","../src/data/arrays/GuardIndex.ts","../src/data/arrays/Filter.ts","../src/numbers/MinMaxAvg.ts"],"sourcesContent":["export function* slice<V>(\n  it: Iterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.iterator ]();\n\n  for (; start > 0; start--, end--) iit.next();\n\n  for (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}","import { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { guardArray } from \"./GuardArray.js\";\n/**\n * Throws if `index` is an invalid array index for `array`, and if\n * `array` itself is not a valid array.\n * @param array\n * @param index\n */\nexport const guardIndex = <V>(\n  array: ArrayLike<V>,\n  index: number,\n  name = `index`\n) => {\n  guardArray(array);\n  throwIntegerTest(index, `positive`, name);\n  if (index > array.length - 1) {\n    throw new Error(\n      `'${ name }' ${ index } beyond array max of ${ array.length - 1 }`\n    );\n  }\n};","import { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { guardArray } from \"./GuardArray.js\";\nimport { guardIndex } from \"./GuardIndex.js\";\n\nexport const withoutUndefined = <V>(data: ReadonlyArray<V> | Array<V>): Array<V> => {\n  return data.filter(v => v !== undefined);\n}\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: ReadonlyArray<V>,\n  filter: (a: V) => boolean\n): [ a: Array<V>, b: Array<V> ] => {\n  const a: Array<V> = [];\n  const b: Array<V> = [];\n  for (const datum of data) {\n    //eslint-disable-next-line functional/immutable-data\n    if (filter(datum)) a.push(datum);\n    //eslint-disable-next-line functional/immutable-data\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween<V>(\n  array: ReadonlyArray<V> | Array<V>,\n  predicate: (\n    value: V,\n    index: number,\n    array: ReadonlyArray<V> | Array<V>\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Generator<V> {\n  guardArray(array);\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n  guardIndex(array, startIndex, `startIndex`);\n  guardIndex(array, endIndex - 1, `endIndex`);\n\n  //const t: Array<V> = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = startIndex; index < endIndex; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    if (predicate(array[ index ], index, array)) yield array[ index ];//t.push(array[ index ]);\n  }\n  //return t;\n};\n\n\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const filtered = Arrays.without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * Arrays.without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * Arrays.without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * Arrays.without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @template V Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  sourceArray: ReadonlyArray<V> | Array<V>,\n  toRemove: V | Array<V>,\n  comparer: IsEqual<V> = isEqualDefault\n): Array<V> => {\n  if (Array.isArray(toRemove)) {\n    const returnArray = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}","import { slice } from '../iterables/sync/Slice.js';\nimport { filterBetween } from '../data/arrays/Filter.js';\nimport type { MinMaxAvgOpts, MinMaxAvgTotal } from './Types.js';\n\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * const v = [10, 2, 4.2, 99];\n * const mma = Arrays.minMaxAvg(v);\n * Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link Numbers.average}, {@link Numbers.max}, {@link Numbers.min} or {@link Numbers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * Arrays.minMaxAvg(count(5,1)); // Averages 1,2,3,4,5\n * ```\n * @param data\n * @param opts Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const minMaxAvg = (\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<number> | Array<number> | Iterable<number>,\n  opts: MinMaxAvgOpts = {}\n): MinMaxAvgTotal => {\n  if (data === undefined) throw new Error(`'data' is undefined`);\n  if (!Array.isArray(data)) {\n    if (`next` in data) {\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      if (opts.startIndex || opts.endIndex) {\n        data = slice(data, opts.startIndex, opts.endIndex);\n      }\n      //eslint-disable-next-line functional/no-let\n      let total = 0;\n      //eslint-disable-next-line functional/no-let\n      let min = Number.MAX_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let max = Number.MIN_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let samples = 0;\n      for (const v of data) {\n        if (typeof v !== `number`) {\n          throw new TypeError(`Generator should yield numbers. Got: ${ typeof v }`);\n        }\n        total += v;\n        samples++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n      }\n      return {\n        avg: total / samples,\n        total,\n        max,\n        min,\n      };\n    } else {\n      throw new Error(`'data' parameter is neither array or iterable`);\n    }\n  }\n\n  if (data.length === 0) {\n    return {\n      total: 0,\n      min: 0,\n      max: 0,\n      avg: 0,\n    };\n  }\n  const startIndex = opts.startIndex ?? 0;\n  const endIndex = opts.endIndex ?? data.length;\n\n  const validNumbers = [ ...filterBetween<number>(\n    data,\n    (d) => typeof d === `number` && !Number.isNaN(d),\n    startIndex,\n    endIndex\n  ) ];\n  const total = validNumbers.reduce((accumulator, v) => accumulator + v, 0);\n  return {\n    total: total,\n    max: Math.max(...validNumbers),\n    min: Math.min(...validNumbers),\n    avg: total / validNumbers.length,\n  };\n};\n"],"mappings":"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","names":["total"]}