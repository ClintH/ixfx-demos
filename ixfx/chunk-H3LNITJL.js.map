{"version":3,"sources":["../src/collections/tree/index.ts","../src/collections/tree/Pathed.ts","../src/collections/tree/TraversableTree.ts"],"sourcesContent":["import { asDynamicTraversable as ObjectToTraversable } from './TraverseObject.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './TreeMutable.js';\nimport type { TraversableTree, TreeNode } from './Types.js';\n\nexport * as Mutable from './TreeMutable.js';\nexport * as Pathed from './Pathed.js'\nexport * as FromObject from './TraverseObject.js';\nexport * as Traverse from './TraversableTree.js';\nexport * from './Compare.js';\nexport type * from './Types.js';\n\nexport const toTraversable = <T>(node: TreeNode<T> | TraversableTree<T> | object) => {\n  if (isTraversable(node)) return node;\n  if (isTreeNode(node)) return TreeNodeToTraversable(node);\n  if (typeof node === `object`) return ObjectToTraversable(node);\n  throw new Error(`Parameter 'node' not convertible`);\n}\n\nexport const isTreeNode = (node: any): node is TreeNode<any> => {\n  if (`parent` in node && `childrenStore` in node && `value` in node) {\n    // eslint-disable-next-line unicorn/no-lonely-if\n    if (Array.isArray(node.childrenStore)) return true;\n  }\n  return false;\n}\n\nexport const isTraversable = (node: any): node is TraversableTree<any> => {\n  return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n}","import * as TreeArrayBacked from \"./TreeMutable.js\";\nimport type { LabelledValue, LabelledNode, TreeNode } from \"./Types.js\";\n/**\n * Options for parsing a path\n */\nexport type PathOpts = Readonly<{\n  /**\n   * Separator for path, eg '.'\n   */\n  separator: string;\n  /**\n   * If two values are stored at same path, what to do? Default: overwrite\n   * * overwrite: last-write wins\n   * * ignore: first-write wins\n   * * allow: allow multiple values\n   */\n  duplicates: `overwrite` | `allow` | `ignore`\n}>;\n\n\n\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n * \n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n * \n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n * \n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n * \n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts \n * @returns \n */\nexport const create = <T>(pathOpts: Partial<PathOpts> = {}) => {\n  let root: TreeNode<LabelledValue<T>> | undefined;\n\n  const add = (value: T, path: string) => {\n    const n = addValueByPath(value, path, root, pathOpts);\n    if (root === undefined) {\n      root = TreeArrayBacked.getRoot(n);\n    }\n  }\n\n  const prettyPrint = () => {\n    if (root === undefined) return `(empty)`;\n    return TreeArrayBacked.toStringDeep(root);\n  }\n\n  const getValue = (path: string): T | undefined => {\n    if (root === undefined) return;\n    return valueByPath(path, root, pathOpts);\n  }\n\n  const remove = (path: string): boolean => {\n    if (root === undefined) return false;\n    return removeByPath(path, root, pathOpts);\n  }\n\n  const hasPath = (path: string): boolean => {\n    if (root === undefined) return false;\n    const c = findChildByPath(path, root, pathOpts);\n    return c !== undefined;\n  }\n\n  const getNode = (path: string): LabelledNode<T> | undefined => {\n    if (root === undefined) return;\n    const c = findChildByPath(path, root, pathOpts);\n    return c;\n  }\n\n  const childrenLength = (path: string): number => {\n    if (root === undefined) return 0;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined) return 0;\n    return c.childrenStore.length;\n  }\n\n  const getValues = (path: string): Array<T> => {\n    if (root === undefined) return [];\n    return valuesByPath(path, root, pathOpts);\n  }\n\n  const clearValues = (path: string): boolean => {\n    if (root === undefined) return false;\n    return clearValuesByPath(path, root, pathOpts);\n  }\n  return { add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues }\n}\n\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n * \n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = <T>(value: T, path: string, node?: LabelledNode<T> | undefined, pathOpts: Partial<PathOpts> = {}): LabelledNode<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n  const split = path.split(separator);\n  let count = 0;\n  for (const p of split) {\n    const lastEntry = count === split.length - 1;\n    //onsole.log(`p: ${ p }`);\n    const found = findChildByLabel(p, node);\n    if (found === undefined) {\n      //onsole.log(`  - not found`);\n      const labelled: LabelledValue<T> = {\n        value: (lastEntry ? value : undefined),\n        label: p\n      };\n      node = TreeArrayBacked.createNode(labelled, node);\n    } else {\n      node = found;\n      if (lastEntry) {\n        switch (duplicatePath) {\n          case `ignore`: {\n            break;\n          }\n          case `allow`: {\n            const existing = getValuesFromNode(node);\n            node.value = {\n              values: [ ...existing, value ],\n              label: p\n            }\n            break;\n          }\n          case `overwrite`: {\n            node.value = {\n              value,\n              label: p\n            }\n            break;\n          }\n        }\n      } else {\n        //onsole.log(`  - found!`, found.value);\n        node = found;\n      }\n    }\n    count++;\n  }\n  if (node === undefined) throw new Error(`Could not create tree`);\n  return node;\n}\n\nexport const removeByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  TreeArrayBacked.remove(c);\n  return true;\n}\n\nexport const clearValuesByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  c.value = {\n    label: c.value?.label ?? ``,\n    value: undefined\n  }\n  return true;\n}\nexport const childrenLengthByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): number => {\n  if (node === undefined) return 0;\n  const c = findChildByPath(path, node, pathOpts);\n  if (c === undefined) return 0;\n  return c.childrenStore.length;\n}\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = <T>(label: string, node: LabelledNode<T> | undefined): LabelledNode<T> | undefined => {\n  if (node === undefined) return undefined;\n  if (label === undefined) throw new Error(`Parameter 'label' cannot be undefined`);\n  if (node.value?.label === label) return node;\n  for (const c of node.childrenStore) {\n    if (c.value?.label === label) return c;\n  }\n}\n\nexport const valueByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): T | undefined => {\n  const values = valuesByPath(path, node, pathOpts);\n  if (values.length === 0) return undefined;\n  if (values.length > 1) throw new Error(`Multiple values at path. Use getValues instead`);\n  return values[ 0 ];\n}\n\nconst getValuesFromNode = <T>(c: LabelledNode<T>): Array<T> => {\n  if (c.value === undefined) return [];\n  if (`values` in c.value) return c.value.values;\n  if (`value` in c.value) {\n    if (c.value.value === undefined) return [];\n    return [ c.value.value ];\n  }\n  return [];\n}\n\nconst findChildByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}) => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      return;\n    }\n  }\n  return c;\n}\n\nexport const valuesByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): Array<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    //onsole.log(`getValue p: ${ p }`);\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n      return [];\n    }\n  }\n  return getValuesFromNode(c);\n}","import { toStringAbbreviate } from \"../../Text.js\";\nimport { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { QueueMutable } from \"../queue/QueueMutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport type { TraversableTree } from \"./Types.js\";\n\nexport const childrenLength = <T>(tree: TraversableTree<T>): number => {\n  return [ ...tree.children() ].length;\n}\n\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = <T>(\n  child: TraversableTree<T>,\n  possibleParent: TraversableTree<T>,\n  eq?: IsEqual<TraversableTree<T>>\n): boolean => {\n  return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyParentValue = <T>(\n  child: TraversableTree<T>,\n  possibleParentValue: T,\n  eq?: IsEqual<T>\n): boolean => {\n  return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findAnyParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq?: IsEqual<TValue>\n): TraversableTree<TValue> | undefined => {\n  return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = <T>(\n  child: TraversableTree<T>,\n  possibleParent: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault<TraversableTree<T>>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = child.getParent();\n  if (p === undefined) return false;\n  if (eq(p, possibleParent)) return true;\n  if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n  return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\n\nexport const hasParentValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault<TValue>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = child.getParent();\n  if (p === undefined) return false;\n  if (eq(p.getValue(), possibleParentValue)) return true;\n  return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\nexport const findParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault<TValue>,\n  maxDepth = 0\n): TraversableTree<TValue> | undefined => {\n  if (maxDepth < 0) return;\n  const p = child.getParent();\n  if (p === undefined) return;\n  if (eq(p.getValue(), possibleParentValue)) return p;\n  return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = <T>(\n  parent: TraversableTree<T>,\n  prospectiveChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n) => {\n\n  if (eq(parent, prospectiveChild)) throw new Error(`Child equals parent`);\n  if (hasAnyChild(parent, prospectiveChild, eq)) {\n    throw new Error(`Circular. Parent already has child`);\n  }\n  if (hasAnyChild(prospectiveChild, parent, eq)) {\n    throw new Error(`Prospective child has parent as child relation`);\n  }\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = <T>(\n  parent: TraversableTree<T>,\n  possibleChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n): boolean => {\n  return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleChildValue: T,\n  eq: IsEqual<T> = isEqualDefault\n): boolean => {\n  return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = <T>(\n  parent: TraversableTree<T>,\n  possibleChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent, possibleChild)) return true;\n  if (eq(parent.getIdentity(), possibleChild.getIdentity())) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c, possibleChild)) return true;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    if (eq(c.getIdentity(), possibleChild.getIdentity())) return true;\n  }\n  return false;\n};\n\nexport const hasChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleValue: T,\n  eq: IsEqual<T> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent.getValue(), possibleValue)) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c.getValue(), possibleValue)) return true;\n  }\n  return false;\n};\n\n/**\n * Iterates over siblings of `node`.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* siblings<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  const p = node.getParent();\n  if (p === undefined) return;\n  for (const s of p.children()) {\n    if (s === node) continue;\n    yield s;\n  }\n}\n\n/**\n * Iterates over parents of `node`, starting with immediate parent\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  let p = node.getParent();\n  while (p !== undefined) {\n    yield p;\n    p = p.getParent();\n  }\n}\n\n\nexport const findAnyChildByValue = <TValue>(parent: TraversableTree<TValue>,\n  possibleValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault\n): TraversableTree<TValue> | undefined => {\n  return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findChildByValue = <TValue>(parent: TraversableTree<TValue>,\n  possibleValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault,\n  maxDepth = 0\n): TraversableTree<TValue> | undefined => {\n\n  if (maxDepth < 0) return;\n  if (eq(parent.getValue(), possibleValue)) return parent;\n\n  for (const d of breadthFirst(parent, maxDepth)) {\n    // This child matches\n    if (eq(d.getValue(), possibleValue)) return d;\n  }\n  return;\n};\n\n/**\n * Iterates over children of `root`, depth-first.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node \n * @returns \n */\nexport function* depthFirst<T extends TraversableTree<any>>(root: T): Generator<T> {\n  if (!root) return;\n  const stack = new StackMutable<T>();\n  let entry: T | undefined = root;\n  while (entry) {\n    const entries = [ ...entry.children() ] as Array<T>;\n    stack.push(...entries);\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n    if (entry) yield entry;\n  }\n}\n\n/**\n * Iterates over the children of `root`, breadth-first\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @param depth How many levels to traverse \n * @returns \n */\nexport function* breadthFirst<T>(root: TraversableTree<T>, depth = Number.MAX_SAFE_INTEGER): IterableIterator<TraversableTree<T>> {\n  if (!root) return;\n  const queue = new QueueMutable<TraversableTree<T>>();\n  let entry: TraversableTree<T> | undefined = root;\n  while (entry) {\n    if (depth < 0) return;\n    for (const c of entry.children()) {\n      yield c;\n      queue.enqueue(c);\n    }\n    entry = queue.dequeue();\n    depth--;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function find<T>(root: TraversableTree<T>, predicate: (node: TraversableTree<T>) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root)) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n  for (const c of iter(root)) {\n    if (predicate(c)) return c;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n * \n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function findByValue<T>(root: TraversableTree<T>, predicate: (nodeValue: T) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root.getValue())) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n\n  for (const c of iter(root)) {\n    if (predicate(c.getValue())) return c;\n  }\n}\n\n/**\n * Search through children in a path-like manner.\n * \n * It finds the first child of `root` that matches `continuePredicate`. \n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n * \n * If it can't find a child, it stops.\n * \n * This is different to 'find' functions, which exhausively search all possible child nodes, regardless of position in tree.\n * \n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n * \n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root \n * @param continuePredicate \n * @param depth \n */\nexport function* followValue<T>(root: TraversableTree<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T> {\n  for (const c of root.children()) {\n    if (continuePredicate(c.getValue(), depth)) {\n      yield c.getValue();\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\nexport function toStringDeep<T>(node: TraversableTree<T>, depth = 0) {\n  if (node === undefined) return `(undefined)`;\n  if (node === null) return `(null)`;\n  const v = node.getValue();\n  let type: string = typeof v;\n  if (Array.isArray(v)) type = `array`;\n  let t = `  `.repeat(depth) + `value: ${ JSON.stringify(v) } (${ type })\\n`;\n  for (const n of node.children()) {\n    t += toStringDeep(n, depth + 1);\n  }\n  return t;\n}\n\nexport function toString(...nodes: Array<TraversableTree<any>>) {\n  let t = ``;\n  for (const node of nodes) {\n    const v = node.getValue();\n    const vString = toStringAbbreviate(v);\n    const children = [ ...node.children() ];\n    const parent = node.getParent();\n    let type: string = typeof v;\n    if (Array.isArray(v)) type = `array`;\n    t += `value: ${ vString } (${ type }) kids: ${ children.length } parented: ${ parent ? `y` : `n` }\\n`;\n  }\n  return t;\n}"],"mappings":"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","names":["remove","childrenLength","toStringDeep","toStringDeep","asDynamicTraversable"]}