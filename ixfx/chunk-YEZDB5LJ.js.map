{"version":3,"sources":["../src/data/Interpolate.ts"],"sourcesContent":["import type { Interval } from '../flow/IntervalType.js';\nimport { wrap } from './Wrap.js';\nimport { progress } from '../flow/Elapsed.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { clamp } from './Clamp.js';\nexport const piPi = Math.PI * 2;\n\nexport type InterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n}\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide](https://clinth.github.io/ixfx-docs/modulation/interpolate/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * Interpolation is often used for animation. In that case, `amount`\n * would start at 0 and you would keep interpolating up to `1`\n * @example\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { percentPingPong } from 'https://unpkg.com/ixfx/dist/modulation.js'\n *\n * // Go back and forth between 0 and 1 by 0.1\n * let pp = percentPingPong(0.1);\n * continuously(() => {\n *  // Get position in ping-pong\n *  const amt = pp.next().value;\n *  // interpolate between Math.PI and Math.PI*2\n *  const v = interpolate(amt, Math.PI, Math.PI*2);\n *  // do something with v...\n * }).start();\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * If two parameters are given, it instead returns a function which interpolates:\n * ```js\n * const i = interpolate(100, 200);\n * i(0.5); // 150\n * \n * // Compared to:\n * interpolate(0.5, 100, 200); // 150\n * ```\n * \n * This is useful if you want to reuse the interpolator with fixed `a` and `b` values.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * To interpolate certain types: {@link Colour.interpolator | Visual.Colour.interpolator }, {@link Points.interpolate | Points.interpolate}.\n * @param amount Interpolation amount, between 0 and 1 inclusive\n * @param a Start (ie when `amt` is 0)\n * @param b End (ie. when `amt` is 1)\n * @returns Interpolated value which will be between `a` and `b`.\n */\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  let opts: Partial<InterpolateOptions> = {};\n\n  const handleAmount = (amount: number) => {\n    if (opts.limits === undefined || opts.limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (opts.limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let amount: number | undefined;\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      opts = pos3 ?? {};\n\n      throwNumberTest(a, ``, `a`);\n      throwNumberTest(b, ``, `b`);\n      return (amount: number) => {\n        let amt = handleAmount(amount);\n        return (1 - amt) * a + amt * b\n      }\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      opts = pos4 ?? {};\n      amount = handleAmount(pos1);\n      throwNumberTest(a, ``, `a`);\n      throwNumberTest(b, ``, `b`);\n      throwNumberTest(amount, ``, `amount`);\n      return (1 - amount) * a + amount * b;\n    } else {\n      throw new Error(`Values for a and b not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    let amount = handleAmount(pos1);\n    opts = pos2 ?? {};\n    throwNumberTest(amount, ``, `amount`);\n\n    return (aValue: number, bValue: number) => {\n      return (1 - amount) * aValue + amount * bValue\n    }\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration\n * @param a \n * @param b \n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1) => {\n  const durationProgression = progress(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b);\n    return value;\n  }\n}\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians\n * @param bRadians\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t));\n};\n\n"],"mappings":";;;;;;;;;;;;;;AAKO,IAAM,OAAO,KAAK,KAAK;AAkEvB,SAAS,YAAY,MAAc,MAA6C,MAA6C,MAAoC;AACtK,MAAI,OAAoC,CAAC;AAEzC,QAAM,eAAe,CAAC,WAAmB;AACvC,QAAI,KAAK,WAAW,UAAa,KAAK,WAAW,SAAS;AACxD,eAAS,MAAM,MAAM;AAAA,IACvB,WAAW,KAAK,WAAW,QAAQ;AACjC,UAAI,SAAS,EAAG,UAAS,SAAS;AAAA,eACzB,SAAS,GAAG;AACnB,iBAAS,IAAK,SAAS;AAAA,MACzB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,SAAS,SAAU,OAAM,IAAI,UAAU,gDAAiD,OAAO,IAAK,EAAE;AACjH,MAAI,OAAO,SAAS,UAAU;AAC5B,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI,SAAS,UAAa,OAAO,SAAS,UAAU;AAElD,UAAI;AACJ,UAAI;AACJ,aAAO,QAAQ,CAAC;AAEhB,sBAAgB,GAAG,IAAI,GAAG;AAC1B,sBAAgB,GAAG,IAAI,GAAG;AAC1B,aAAO,CAACA,YAAmB;AACzB,YAAI,MAAM,aAAaA,OAAM;AAC7B,gBAAQ,IAAI,OAAO,IAAI,MAAM;AAAA,MAC/B;AAAA,IACF,WAAW,OAAO,SAAS,UAAU;AAEnC,UAAI;AACJ,UAAI;AACJ,aAAO,QAAQ,CAAC;AAChB,eAAS,aAAa,IAAI;AAC1B,sBAAgB,GAAG,IAAI,GAAG;AAC1B,sBAAgB,GAAG,IAAI,GAAG;AAC1B,sBAAgB,QAAQ,IAAI,QAAQ;AACpC,cAAQ,IAAI,UAAU,IAAI,SAAS;AAAA,IACrC,OAAO;AACL,YAAM,IAAI,MAAM,gCAAgC;AAAA,IAClD;AAAA,EACF,WAAW,SAAS,UAAa,OAAO,SAAS,UAAU;AAEzD,QAAI,SAAS,aAAa,IAAI;AAC9B,WAAO,QAAQ,CAAC;AAChB,oBAAgB,QAAQ,IAAI,QAAQ;AAEpC,WAAO,CAAC,QAAgB,WAAmB;AACzC,cAAQ,IAAI,UAAU,SAAS,SAAS;AAAA,IAC1C;AAAA,EACF;AACF;AAqCO,IAAM,sBAAsB,CAAC,iBAAyB,IAAI,GAAG,IAAI,GAAG,uBAAuB,MAAM;AACtG,MAAI,SAAS;AACb,SAAO,CAAC,WAAoB,cAAuB;AACjD,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,UAAU,EAAG,QAAO;AACxB,UAAM,QAAQ,YAAY,QAAQ,GAAG,CAAC;AACtC,cAAU;AACV,WAAO;AAAA,EACT;AACF;AA6BO,IAAM,uBAAuB,CAAC,UAAoB,IAAI,GAAG,IAAI,MAAM;AACxE,QAAM,sBAAsB,SAAS,UAAU,EAAE,YAAY,KAAK,CAAC;AACnE,SAAO,CAAC,WAAoB,cAAuB;AACjD,UAAM,SAAS,oBAAoB;AACnC,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,UAAU,EAAG,QAAO;AACxB,UAAM,QAAQ,YAAY,QAAQ,GAAG,CAAC;AACtC,WAAO;AAAA,EACT;AACF;AAcO,IAAM,mBAAmB,CAC9B,QACA,UACA,aACW;AACX,QAAM,IAAI,KAAK,WAAW,UAAU,GAAG,IAAI;AAC3C,SAAO,YAAY,QAAQ,UAAU,YAAY,IAAI,KAAK,KAAK,IAAI,OAAO,EAAE;AAC9E;","names":["amount"]}