{"version":3,"sources":["../src/visual/index.ts","../src/visual/Drawing.ts","../src/visual/Plot2.ts","../src/data/Flip.ts","../src/visual/SceneGraph.ts","../src/visual/ScaleCanvas.ts","../src/visual/Palette.ts","../src/visual/BipolarView.ts","../src/data/Bipolar.ts","../src/visual/PlotOld.ts"],"sourcesContent":["import * as Drawing from './Drawing.js';\nimport * as Svg from './Svg.js';\n//import * as Plot from './Plot.js';\n\nimport * as Plot2 from './Plot2.js';\n\nimport * as Palette from './Palette.js';\nimport * as Colour from './Colour.js';\nimport * as SceneGraph from './SceneGraph.js';\nimport * as Video from './Video.js';\nimport { resolveEl } from '../dom/Util.js';\n\nexport * as ImageDataGrid from './ImageDataGrid.js';\nexport * as BipolarView from './BipolarView.js';\nexport * as Palette from './Palette.js';\nexport * as Drawing from './Drawing.js';\nexport * as Svg from './Svg.js';\n//export * as Plot from './Plot.js';\n\n\nexport * as Plot2 from './Plot2.js';\nexport * as PlotOld from './PlotOld.js';\nexport * as SceneGraph from './SceneGraph.js';\nexport * from './ScaleCanvas.js';\n\n/**\n * Colour interpolation, scale generation and parsing\n *\n * Overview\n * * {@link interpolate}: Blend colours\n * * {@link scale}: Produce colour scale\n * * {@link opacity}: Give a colour opacity\n * * {@link randomHue}: Generate a random hue\n * * {@link goldenAngleColour}: Pick perceptually different shades\n *\n * CSS\n * * {@link getCssVariable}: Parse a CSS-defined colour\n *\n * Conversions: convert from 'blue', 'rgb(255,0,0)',  'hsl(0, 100%, 50%)' etc:\n * * {@link toHex}: to a hex format string\n * * {@link toHsl}: to a `{h, s, l}` object\n * * {@link toRgb}: to a `{r, g, b}` object\n */\nexport * as Colour from './Colour.js';\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n * ```\n */\nexport * as Video from './Video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        SceneGraph,\n        Plot2,\n        Drawing,\n        Svg,\n        Palette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n","import * as Points from '../geometry/point/index.js';\nimport * as Lines from '../geometry/line/index.js';\nimport * as Triangles from '../geometry/triangle/index.js';\nimport { throwArrayTest } from '../Guards.js';\nimport * as Arcs from '../geometry/arc/index.js';\nimport * as Beziers from '../geometry/Bezier.js';\nimport * as Ellipses from '../geometry/Ellipse.js';\nimport * as Colours from '../visual/Colour.js';\nimport { resolveEl } from '../dom/Util.js';\nimport { roundUpToMultiple } from '../Util.js';\nimport type { IStackImmutable } from '../collections/stack/IStackImmutable.js';\nimport { StackImmutable } from '../collections/stack/StackImmutable.js';\nimport type { Point, CirclePositioned, Rect, RectPositioned } from '../geometry/Types.js';\nimport type { Line, Path, Triangle } from '../geometry/Types.js';\nimport { empty as RectsEmpty } from '../geometry/rect/index.js';\nimport { corners as RectsCorners } from '../geometry/rect/index.js';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElCtxOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rect\n) => {\n  // TODO: Is there a way of automagically defining makeHelper to avoid repetition and keep typesafety and JSDoc?\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    paths(pathsToDraw: Array<Path>, opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Line | Array<Line>, opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: RectPositioned | Array<RectPositioned>,\n      opts?: DrawingOpts & { filled?: boolean }\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Array<Point>,\n      opts?: DrawingOpts & { loop?: boolean }\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Array<Point>, opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Point | Array<Point>,\n      opts?: DrawingOpts & {\n        radius: number;\n        outlined?: boolean;\n        filled?: boolean;\n      }\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: CirclePositioned | Array<\n        CirclePositioned>,\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Array<Arcs.ArcPositioned>,\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: Array<string>,\n      opts: DrawingOpts & {\n        anchor: Point;\n        anchorPadding?: number;\n        bounds?: RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: ReadonlyArray<StackOp>\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  //eslint-disable-next-line functional/immutable-data\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | ReadonlyArray<Arcs.ArcPositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param op Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: ReadonlyArray<StackOp>): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    // eslint-disable-next-line functional/immutable-data\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  if (stk === undefined) stk = new StackImmutable<StackOp>();\n\n  const push = (...ops: Array<StackOp>): DrawingStack => {\n    if (stk === undefined) stk = new StackImmutable<StackOp>();\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: ReadonlyArray<Point>,\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: CirclePositioned | ReadonlyArray<CirclePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c);\n  } else {\n    draw(circlesToDraw as CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | ReadonlyArray<Ellipses.EllipsePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: ReadonlyArray<Path> | Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (Lines.isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Path);\n  }\n};\n\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: {\n    readonly lineWidth?: number\n    readonly loop?: boolean\n    readonly fillStyle?: string\n    readonly strokeStyle?: string\n  } = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n\n  throwArrayTest(pts);\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    //eslint-disable-next-line functional/immutable-data\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: { readonly fillStyle?: string } = {},\n  labels?: ReadonlyArray<string>\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Point\n): Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  //eslint-disable-next-line functional/immutable-data\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Point | ReadonlyArray<Point>,\n  opts?: DrawingOpts & {\n    readonly radius?: number;\n    readonly outlined?: boolean;\n    readonly filled?: boolean;\n  }\n) => {\n  if (opts === undefined) opts = {};\n  const radius = opts.radius ?? 10;\n\n  applyOpts(ctx, opts);\n\n  ctx.beginPath();\n\n  // x&y for arc is the center of circle\n  if (Array.isArray(pos)) {\n    for (const p of pos) {\n      ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n    }\n  } else {\n    const p = pos as Point;\n    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  if (opts.filled || !opts.outlined) ctx.fill();\n  if (opts.outlined) ctx.stroke();\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Line | ReadonlyArray<Line>,\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t);\n  } else {\n    draw(toDraw as Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangle | ReadonlyArray<Triangle>,\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rect | RectPositioned | ReadonlyArray<RectPositioned>,\n  opts: DrawingOpts & {\n    readonly filled?: boolean;\n    readonly stroked?: boolean;\n  } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroked = opts.stroked ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: RectPositioned | Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroked ?? true) ctx.strokeRect(x, y, d.width, d.height);\n\n    if (opts.debug) {\n      pointLabels(ctx, RectsCorners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // if (widthMultiple) return roundUpToMultiple(m.width, widthMultiple) + padding;\n  // return m.width + padding;\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rect => {\n  if (text === undefined || text === null || text.length === 0) return RectsEmpty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? roundUpToMultiple(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: ReadonlyArray<string>,\n  opts: DrawingOpts & {\n    readonly anchor: Point;\n    readonly anchorPadding?: number;\n    readonly bounds?: RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  //eslint-disable-next-line functional/prefer-tacit\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  // eslint-disable-next-line functional/no-let\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: ReadonlyArray<string> | string,\n  opts: DrawingOpts & {\n    readonly bounds: RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import { minIndex } from '../collections/arrays/NumericArrays.js';\nimport * as Arrays from '../collections/arrays/index.js';\nimport * as Points from '../geometry/point/index.js';\nimport { clamp } from '../data/Clamp.js';\nimport { flip } from '../data/Flip.js';\nimport { scale } from '../data/Scale.js';\n\nimport { parentSizeCanvas } from '../dom/Util.js';\nimport * as Sg from './SceneGraph.js';\n\nimport { textRect, textWidth } from './Drawing.js';\nimport { ifNaN } from '../Util.js'\nimport { getPaths, getField } from '../Immutable.js';\nimport { throwNumberTest } from '../Guards.js';\nimport type { Rect, RectPositioned, PointCalculableShape } from '../geometry/Types.js';\nimport { subtract as RectsSubtract } from '../geometry/rect/Subtract.js';\nimport { scaleCanvas } from './ScaleCanvas.js';\n\n/**\n * \n *  const dataStream = new DataStream();\n *  dataStream.in({ key: `x`, value: 0.5 }); \n *  const label = (obj:any) => {\n *    if (`key` in obj) return obj;\n *    return { key: randomKey(), ...obj }\n *  }\n *  const stream = pipeline(dataStream, label);\n *  // Actively compute size of window based on window width\n *  const windowSize = ops.divide(rxWindow.innerWidth, pointSize);\n *  const dataWindow = window(stream, windowSize);\n *  const dataToPoints = (value);\n * \n *  const drawPlot = (dataWindow) => {\n *    for (const dataPoint in dataWindow) {\n *    }\n *  }\n */\n\n/**\n * A data source\n */\nexport type DataSource = {\n  dirty: boolean;\n  type: string;\n  get range(): DataRange;\n  add(value: number): void;\n  clear(): void;\n}\n\n/**\n * Plot options\n */\nexport type Opts = {\n  /**\n   * If true, Canvas will be resized to fit parent\n   */\n  autoSize?: boolean;\n  /**\n   * Colour for axis lines & labels\n   */\n  axisStrokeColour?: string;\n\n  axisTextColour?: string\n\n  legendTextColour?: string\n  /**\n   * Width for axis lines\n   */\n  axisStrokeWidth?: number;\n};\n\n/**\n * Series options\n */\nexport type SeriesOpts = {\n  /**\n   * Colour for series\n   */\n  colour: string;\n  /**\n   * Visual width/height (depends on drawingStyle)\n   */\n  width?: number;\n  /**\n   * How series should be rendered\n   */\n  drawingStyle?: `line` | `dotted` | `bar`;\n  /**\n   * Preferred data range\n   */\n  axisRange?: DataRange;\n  /**\n   * If true, range will stay at min/max, rather than continuously adapting\n   * to the current data range.\n   */\n  visualRangeStretch?: boolean;\n};\n\nexport type DataPoint = {\n  value: number;\n  index: number;\n  title?: string;\n};\n\nexport type DataHitPoint = (\n  pt: Points.Point\n) => [ point: DataPoint | undefined, distance: number ];\n\nclass ArrayDataSource implements DataSource {\n  data: Array<number>;\n  series: Series;\n  dirty = false;\n  type = `array`;\n\n  private _range: Arrays.MinMaxAvgTotal | undefined;\n\n  constructor(series: Series) {\n    this.series = series;\n    this.data = [];\n    this.dirty = true;\n  }\n\n  clear() {\n    this.set([]);\n    this._range = undefined;\n  }\n\n  set(data: Array<number>) {\n    this.data = data;\n    this.dirty = true;\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get range(): DataRange {\n    if (!this.dirty && this._range !== undefined) return this._range;\n    this.dirty = false;\n    const updatedRange = Arrays.minMaxAvg(this.data);\n    if (this._range === undefined || updatedRange.max !== this._range.max || updatedRange.min !== this._range.min) {\n      this._range = updatedRange;\n      return { ...this._range, changed: true };\n    } else {\n      return { ...this._range, changed: false };\n\n    }\n  }\n\n  add(value: number) {\n    this.data = [ ...this.data, value ];\n    this.dirty = true;\n  }\n}\n\nclass StreamingDataSource extends ArrayDataSource {\n  desiredDataPointMinWidth = 5;\n\n  add(value: number) {\n    const lastWidth = this.series.lastPxPerPt;\n    if (lastWidth > -1 && lastWidth < this.desiredDataPointMinWidth) {\n      // Remove older data\n      const pts = Math.floor(this.desiredDataPointMinWidth / lastWidth);\n      const d = [ ...this.data.slice(pts), value ];\n      super.set(d);\n    } else super.add(value);\n  }\n}\n\nexport type DataRange = {\n  min: number;\n  max: number;\n  changed?: boolean;\n};\n\nexport class Series {\n  name: string;\n  colour: string;\n  source: DataSource;\n  drawingStyle: `line` | `dotted` | `bar`;\n  width = 3;\n  dataHitPoint: DataHitPoint | undefined;\n  tooltip?: string;\n  precision = 2;\n\n  readonly axisRange: DataRange;\n\n  // How many pixels wide per data point on last draw\n  lastPxPerPt = -1;\n\n  protected _visualRange: DataRange;\n  protected _visualRangeStretch: boolean;\n\n  constructor(\n    name: string,\n    sourceType: `array` | `stream`,\n    private plot: Plot,\n    opts: SeriesOpts\n  ) {\n    this.name = name;\n\n    this.drawingStyle = opts.drawingStyle ?? `line`;\n    this.colour = opts.colour;\n    this.width = opts.width ?? 3;\n    this.axisRange = opts.axisRange ?? { min: Number.NaN, max: Number.NaN };\n    this._visualRange = { ...this.axisRange };\n    this._visualRangeStretch = opts.visualRangeStretch ?? true;\n\n    if (sourceType === `array`) {\n      this.source = new ArrayDataSource(this);\n    } else if (sourceType === `stream`) {\n      this.source = new StreamingDataSource(this);\n    } else throw new Error(`Unknown sourceType. Expected array|stream`);\n  }\n\n  formatValue(v: number) {\n    return v.toFixed(this.precision);\n  }\n\n  get visualRange(): DataRange {\n    let vr = this._visualRange;\n    const sourceRange = this.source.range;\n    let changed = false;\n\n    if (sourceRange.changed) {\n      if (this._visualRangeStretch) {\n        // Stretch range to lowest/highest-seen min/max\n        const rmin = Math.min(ifNaN(vr.min, sourceRange.min), sourceRange.min);\n        const rmax = Math.max(ifNaN(vr.max, sourceRange.max), sourceRange.max);\n        if (rmin !== vr.min || rmax !== vr.max) {\n          // Changed\n          vr = { min: rmin, max: rmax };\n          changed = true;\n        }\n      } else {\n        // Use actual range of data\n        if (!isRangeEqual(sourceRange, vr)) {\n          vr = sourceRange;\n          changed = true;\n        }\n      }\n    }\n    this._visualRange = vr;\n    return { ...vr, changed };\n  }\n\n  scaleValue(value: number): number {\n    if (this.source === undefined) return value;\n    const r = this.visualRange;\n    if (r.changed) {\n      this.plot.notify(`range-change`, this.plot.plotArea);\n    }\n    if (r.min == r.max) {\n      // No real scale - only received the same value for this series\n      return 0.5;\n    }\n    return scale(value, r.min, r.max);\n  }\n\n  add(value: number) {\n    throwNumberTest(value, ``, `value`);\n    this.source.add(value);\n    //this.plot.plotArea.layoutInvalidated(`Series.add`);\n    this.plot.plotArea.drawingInvalidated(`Series.add`);\n  }\n\n  /**\n   * Clears the underlying source\n   * and sets a flag that the plot area needs redrawing\n   */\n  clear() {\n    this.source.clear();\n    this._visualRange = { ...this.axisRange };\n    this.plot.plotArea.layoutInvalidated(`Series.clear`);\n  }\n}\n\nexport class PlotArea extends Sg.CanvasBox {\n  paddingPx = 5;\n  piPi = Math.PI * 2;\n  // If pointer is more than this distance away from a data point, it's ignored\n  pointerDistanceThreshold = 20;\n  lastRangeChange = 0;\n  pointer: Points.Point | undefined;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `PlotArea`, region);\n\n  }\n\n  clear() {\n    this.lastRangeChange = 0;\n    this.pointer = undefined;\n  }\n\n  protected measureSelf(\n    opts: Sg.MeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | string {\n\n    const axisY = opts.getActualSize(`AxisY`);\n    const padding = this.paddingPx;\n    const legend = opts.getActualSize(`Legend`);\n    const legendHeight = legend?.height ?? 0;\n\n    const axisX = opts.getActualSize(`AxisX`);\n    const axisXHeight = axisX?.height ?? 0;\n\n    if (!axisY) return `No AxisY. Measured: ${ opts.whatIsMeasured().join(`, `) }`;\n    if (!legend) return `No Legend`;\n    if (!axisX) return `No AxisX`;\n\n    return {\n      width: opts.bounds.width - axisY.width - this.paddingPx,\n      height: opts.bounds.height - legendHeight - axisXHeight - padding,\n    };\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent: Sg.Layout) {\n    const axisY = measureState.getActualSize(`AxisY`);\n    //const axisX = measureState.getActualSize(`AxisX`);\n    const padding = this.paddingPx;\n\n    //const legend = measureState.getActualSize(`Legend`);\n    //const legendHeight = legend?.height ?? 0;\n\n    //const axisXHeight = axisX?.height ?? 0;\n    const axisYWidth = axisY?.width ?? 0;\n\n    //const height = this._measuredSize?.height ?? 0;\n\n    return {\n      x: axisYWidth,\n      y: padding // layoutState.bounds.height - height - axisXHeight - legendHeight\n    }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(`onNotify message: ${ message } source: ${ source.id }`);\n    if (message === `measureApplied` && source === this.plot.axisY)\n      this.layoutInvalidated(`PlotArea.onNotify measureApplied to axisY`);\n    if (message === `laidout` && source === this.plot.legend)\n      this.layoutInvalidated(`PlotArea.onNotify laidout to legend`);\n  }\n\n  // protected onClick(p: Point): void {\n  //   this.plot.frozen = !this.plot.frozen;\n  // }\n\n  protected onPointerLeave(): void {\n    for (const series of this.plot.series.values()) {\n      series.tooltip = undefined;\n    }\n    this.pointer = undefined;\n    (this.plot.legend as Sg.CanvasBox).drawingInvalidated(`PlotArea.onPointerLeave`);\n  }\n\n  protected onPointerMove(p: Points.Point): void {\n    this.pointer = p;\n    this.plot.legend.drawingInvalidated(`PlotArea.onPointerMove`);\n  }\n\n  protected measurePreflight(): void {\n    this.updateTooltip();\n  }\n\n  updateTooltip() {\n    const p = this.pointer;\n    if (p === undefined) return;\n\n    for (const series of this.plot.series.values()) {\n      if (p === undefined) {\n        series.tooltip = undefined;\n        return;\n      }\n      if (series.dataHitPoint === undefined) return;\n      const v = series.dataHitPoint(p);\n      if (v[ 0 ] === undefined) return;\n      if (v[ 1 ] > this.pointerDistanceThreshold) return; // too far away\n      series.tooltip = series.formatValue(v[ 0 ].value);\n      //this.plot.legend.onLayoutNeeded();\n    }\n    this.plot.legend.drawingInvalidated(`PlotArea.updateTooltip`);\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    if (this.plot.frozen) return;\n    const seriesCopy = this.plot.seriesArray(); // [...this.plot.series.values()];\n    //ctx.fillStyle = `hsla(10,50%,50%,0.5)`;\n    //ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n\n    // Using -1 for y to catch a few random peaks from sharp lines\n    ctx.clearRect(0, -1, this.canvasRegion.width, this.canvasRegion.height);\n\n    for (const series of seriesCopy) {\n      if (series.source.type === `array` || series.source.type === `stream`) {\n        const arraySeries = series.source as ArrayDataSource;\n        if (arraySeries.data === undefined) return;\n        const d = [ ...arraySeries.data ];\n        this.drawDataSet(series, d, ctx);\n      } else console.warn(`Unknown data source type ${ series.source.type }`);\n    }\n  }\n\n  computeY(series: Series, rawValue: number) {\n    const s = series.scaleValue(rawValue);\n    return flip(s) * this.canvasRegion.height + this.paddingPx;\n  }\n\n  drawDataSet(\n    series: Series,\n    d: Array<number>,\n    ctx: CanvasRenderingContext2D\n  ): void {\n    const padding = this.paddingPx + series.width;\n    const v = RectsSubtract(this.canvasRegion, padding * 2, padding * 3.5);\n    const pxPerPt = v.width / d.length;\n\n    series.lastPxPerPt = pxPerPt;\n    let x = padding;\n\n    ctx.strokeStyle = series.colour;\n    ctx.lineWidth = series.width;\n    const shapes: Array<DataPoint & PointCalculableShape> = [];\n\n    series.dataHitPoint = (pt: Points.Point): [ DataPoint, number ] => {\n      const distances = shapes.map((v) => Points.distanceToExterior(pt, v));\n      const index = minIndex(...distances);\n      const closest = shapes[ index ];\n      if (closest === undefined) [ undefined, 0 ];\n      return [ closest, distances[ index ] ];\n    };\n\n    // eslint-disable-next-line unicorn/prefer-switch\n    if (series.drawingStyle === `line`) {\n      let y = 0;\n      ctx.beginPath();\n\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = clamp(series.scaleValue(d[ index ]));\n        y = padding + this.paddingPx + v.height * flip(scaled);\n        shapes.push({ x, y, index: index, value: d[ index ] });\n\n        if (index == 0) ctx.moveTo(x + pxPerPt / 2, y);\n        else ctx.lineTo(x + pxPerPt / 2, y);\n\n        if (y > this.canvasRegion.height)\n          console.warn(`${ y } h: ${ this.canvasRegion.height }`);\n        x += pxPerPt;\n      }\n      ctx.strokeStyle = series.colour;\n      ctx.stroke();\n    } else if (series.drawingStyle === `dotted`) {\n      let y = 0;\n      ctx.fillStyle = series.colour;\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = series.scaleValue(d[ index ]);\n        y = padding + v.height * flip(scaled);\n        ctx.beginPath();\n        ctx.arc(x + pxPerPt / 2, y, series.width, 0, this.piPi);\n        ctx.fill();\n        shapes.push({ radius: series.width, x, y, index: index, value: d[ index ] });\n        x += pxPerPt;\n      }\n    } else if (series.drawingStyle === `bar`) {\n      ctx.fillStyle = series.colour;\n      const interBarPadding = Math.ceil(pxPerPt * 0.1);\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = series.scaleValue(d[ index ]);\n        const h = v.height * scaled;\n        const r = {\n          x: x + interBarPadding,\n          y: v.height - h + padding,\n          width: pxPerPt - interBarPadding,\n          height: h,\n          index: index,\n          value: d[ index ],\n        };\n        ctx.fillRect(r.x, r.y, r.width, r.height);\n        shapes.push(r);\n        x += pxPerPt;\n      }\n    }\n  }\n}\n\nexport class Legend extends Sg.CanvasBox {\n  sampleSize = { width: 10, height: 10 };\n  padding = 3;\n  widthSnapping = 20;\n\n  labelMeasurements = new Map<string, RectPositioned>();\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `Legend`, region);\n  }\n\n  clear() {\n    /** no-op */\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, layoutState: Sg.LayoutState, _parent: Sg.Layout) {\n    const axisY = measureState.getActualSize(`AxisY`);\n    const axisYWidth = axisY?.width ?? 0;\n\n    const height = this._measuredSize?.height ?? 0;\n    return {\n      x: axisYWidth,\n      y: layoutState.bounds.height - height\n    }\n  }\n\n  protected measureSelf(\n    opts: Sg.CanvasMeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | RectPositioned | string {\n    const series = this.plot.seriesArray();\n    const sample = this.sampleSize;\n    const padding = this.padding;\n    const widthSnapping = this.widthSnapping;\n    const ctx = opts.ctx;\n\n    const yAxis = opts.measurements.get(`AxisY`);\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    let x = padding;\n    let y = padding;\n    const availableWidth = opts.bounds.width - yAxisWidth - padding;\n\n    //let rows = 1;\n    let rowHeight = 0;\n    for (const s of series) {\n      const startX = x;\n      x += sample.width + padding;\n      ctx.textBaseline = `middle`;\n\n      const text = textRect(ctx, s.name, padding, widthSnapping);\n\n      x += textWidth(ctx, s.name, padding, widthSnapping);\n\n      if (s.tooltip) {\n        x += textWidth(ctx, s.tooltip, padding, widthSnapping);\n      }\n      const r = { width: 10, height: 10, x: startX, y };\n\n      this.labelMeasurements.set(s.name, r)\n      rowHeight = Math.min(sample.height + padding + padding, text.height + padding + padding);\n      x += padding;\n      if (x > availableWidth) {\n        x = padding;\n        y += rowHeight;\n        //rows++;\n\n      }\n    }\n\n    return {\n      width: availableWidth,\n      height: y + rowHeight\n    }\n    // const ctx = (opts as Sg.CanvasMeasureState).ctx;\n\n    // const usableWidth = opts.bounds.width - yAxisWidth;\n\n    // let width = padding;\n    // for (const s of series) {\n    //   width += sample.width + padding;\n    //   width += textWidth(ctx, s.name, padding, widthSnapping);\n    //   width += textWidth(ctx, s.tooltip, padding, widthSnapping);\n    // }\n\n    // const rows = Math.max(1, Math.ceil(width / usableWidth));\n    // console.log(`rows: ${ rows }`);\n    // const h = rows * (this.sampleSize.height + this.padding + this.padding);\n    // return {\n    //   x: yAxisWidth,\n    //   y: opts.bounds.height - h,\n    //   width: usableWidth,\n    //   height: h,\n    // };\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const series = this.plot.seriesArray();\n    const sample = this.sampleSize;\n    const padding = this.padding;\n    this.debugLog(`drawSelf`);\n\n    ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n    for (const s of series) {\n      const r = this.labelMeasurements.get(s.name);\n      if (r === undefined) continue;\n      let x = r.x;\n\n      // Draw colour chip\n      ctx.fillStyle = s.colour;\n      ctx.fillRect(x, r.y, sample.width, sample.height);\n      x += sample.width + padding;\n\n      // Label\n      ctx.textBaseline = `middle`;\n      ctx.fillStyle = this.plot.legendTextColour;\n      ctx.fillText(s.name, x, r.y + sample.height / 2);\n\n      if (s.tooltip) {\n        ctx.fillStyle = this.plot.legendTextColour;\n        ctx.fillText(s.tooltip, r.x, r.y + sample.height / 2);\n      }\n    }\n    // const series = this.plot.seriesArray();\n    // const sample = this.sampleSize;\n    // const padding = this.padding;\n    // const widthSnapping = this.widthSnapping;\n\n    // let x = padding;\n    // let y = padding;\n\n    // ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n    // let rows = 1;\n    // for (const s of series) {\n    //   ctx.fillStyle = s.colour;\n    //   ctx.fillRect(x, y, sample.width, sample.height);\n    //   x += sample.width + padding;\n    //   ctx.textBaseline = `middle`;\n    //   ctx.fillStyle = this.plot.legendTextColour;\n    //   ctx.fillText(s.name, x, y + sample.height / 2);\n    //   x += textWidth(ctx, s.name, padding, widthSnapping);\n\n    //   if (s.tooltip) {\n    //     ctx.fillStyle = this.plot.legendTextColour;\n    //     ctx.fillText(s.tooltip, x, y + sample.height / 2);\n    //     x += textWidth(ctx, s.tooltip, padding, widthSnapping);\n    //   }\n    //   x += padding;\n    //   if (x > this.canvasRegion.width - 100) {\n    //     x = padding;\n    //     y += sample.height + padding + padding;\n    //     rows++;\n    //     this.debugLog(`drawSelf rows: ${ rows }`);\n    //   }\n    // }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    this.debugLog(`onNotify ${ message } source: ${ source.id }`);\n    if (message === `measureApplied` && source === (this._parent as Plot).axisY) {\n      this.layoutInvalidated(`Legend.onNotify measureApplied to axisY`);\n\n    } else if (message == `range-change`) {\n      //this.layoutInvalidated(`Legend.onNotify range-change`);\n    }\n  }\n}\n\nexport class AxisX extends Sg.CanvasBox {\n  paddingPx = 2;\n  colour?: string;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `AxisX`, region);\n  }\n\n  clear() {\n    /** no-op */\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(message);\n    if (message === `measureApplied` && source === this.plot.axisY) {\n      this.layoutInvalidated(`AxisX.onNotify measureApplied to axisY`);\n    }\n    // if (message === `measureApplied` && source === this.plot.legend) {\n    //   this.layoutInvalidated(`AxisX.onNotify measureApplied to legend`);\n    // }\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const plot = this.plot;\n    const v = this.canvasRegion;\n    const strokeWidth = plot.axisStrokeWidth;\n\n    const colour = this.colour ?? plot.axisStrokeColour;\n    ctx.strokeStyle = colour;\n\n    ctx.clearRect(0, 0, v.width, v.height);\n    //ctx.fillStyle = `hsla(200,50%,50%,0.5)`;\n    //ctx.fillRect(0, 0, v.width, v.height);\n    //this.debugLog(`drawSelf: ${ v.width } x ${ v.height } padding: ${ this.paddingPx }`);\n    ctx.beginPath();\n    ctx.lineWidth = strokeWidth;\n    ctx.moveTo(0, strokeWidth / 2);\n    ctx.lineTo(v.width, strokeWidth / 2);\n    ctx.stroke();\n  }\n\n  protected measureSelf(\n    opts: Sg.CanvasMeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | RectPositioned | string {\n    const plot = this.plot;\n    const padding = this.paddingPx;\n    const yAxis = opts.measurements.get(`AxisY`);\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    // TODO: If we start using x-axis labels\n    const heightOfText = 0;//textHeight(opts.ctx, `100`, padding);\n    const h = plot.axisStrokeWidth + heightOfText + padding + padding;\n\n    return {\n      width: opts.bounds.width - yAxisWidth - padding,\n      height: h,\n    };\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent?: Sg.Layout | undefined): Points.Point | undefined {\n    const yAxis = measureState.measurements.get(`AxisY`);\n    const legend = measureState.getActualSize(`Legend`);\n    const legendHeight = legend?.height ?? 0;\n\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    const height = this._measuredSize?.height ?? 0;\n    return {\n      x: yAxisWidth,\n      y: measureState.bounds.height - height - legendHeight\n    }\n  }\n}\n\nconst isRangeEqual = (a: DataRange, b: DataRange) =>\n  a.max === b.max && a.min === b.min;\nconst isRangeSinglePoint = (a: DataRange) => a.max === a.min;\n\nexport class AxisY extends Sg.CanvasBox {\n  // Number of digits axis will be expected to show as a data legend\n  private _maxDigits = 1;\n\n  seriesToShow: string | undefined;\n  paddingPx = 2;\n  colour?: string;\n\n  lastRange: DataRange;\n  lastPlotAreaHeight = 0;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `AxisY`, region);\n    this.lastRange = { min: 0, max: 0 };\n  }\n\n  clear() {\n    this.lastRange = { min: 0, max: 0 };\n    this.lastPlotAreaHeight = 0;\n  }\n\n  protected measurePreflight(): void {\n    //this.debugLog(`measurePreflight`);\n    // const series = this.getSeries();\n    // if (\n    //   series !== undefined &&\n    //   !isRangeEqual(series.visualRange, this.lastRange)\n    // ) {\n    //   this.layoutInvalidated(`AxisY.measurePreflight`);\n    // }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(message);\n    const pa = this.plot.plotArea;\n    if (message === `range-change`) {\n      // Notification that series range has changed\n      this.drawingInvalidated(`range-change`);\n      return;\n    }\n\n    if (message === `measureApplied` && source === pa && (pa.canvasRegion.height !== this.lastPlotAreaHeight)) {\n      this.lastPlotAreaHeight = pa.canvasRegion.height;\n      this.drawingInvalidated(`AxisY.onNotify height change`);\n    }\n  }\n\n  protected measureSelf(copts: Sg.CanvasMeasureState): Rect {\n    //this.debugLog(`measureSelf. needsLayout: ${ this._needsLayoutX } needsDrawing: ${ this._needsDrawing }`);\n\n    if (copts.ctx === undefined) throw new Error(`opts.ctx is undefined`);\n\n    const paddingPx = this.paddingPx;\n    let width = this.plot.axisStrokeWidth + paddingPx;\n\n    const series = this.getSeries();\n    if (series !== undefined) {\n      const r = series.visualRange;\n      this._maxDigits =\n        Math.ceil(r.max).toString().length + series.precision + 1;\n\n      const textToMeasure = `9`.repeat(this._maxDigits);\n      width += textWidth(copts.ctx, textToMeasure, paddingPx * 2);\n    }\n    const w = copts.resolveToPx(this.desiredRegion?.width, width, width);\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      width: w!,\n      height: copts.bounds.height,\n    };\n  }\n\n  protected layoutSelf(_measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent?: Sg.Layout | undefined): Points.Point {\n    return { x: 0, y: 0 }\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const s = this.getSeries();\n    if (s === undefined) {\n      if (this.seriesToShow === undefined) return;\n      console.warn(`Plot AxisY series '${ this.seriesToShow }' is missing.`);\n    } else {\n      this.seriesAxis(s, ctx);\n    }\n  }\n\n  getSeries(): Series | undefined {\n    return this.seriesToShow === undefined ?\n      // Pick first series\n      this.plot.seriesArray()[ 0 ] :\n      // Try designated series name\n      this.plot.series.get(this.seriesToShow);\n  }\n\n  seriesAxis(series: Series, ctx: CanvasRenderingContext2D) {\n    const plot = this.plot;\n    const plotArea = plot.plotArea;\n    const v = this.canvasRegion;\n    const paddingPx = this.paddingPx;\n    const r = series.visualRange;\n    const strokeWidth = plot.axisStrokeWidth;\n\n    const colour = this.colour ?? plot.axisStrokeColour;\n    ctx.strokeStyle = colour;\n    ctx.fillStyle = colour;\n\n    if (Number.isNaN(r.min) && Number.isNaN(r.max)) return; // Empty\n    this.lastRange = r;\n    ctx.clearRect(0, 0, v.width, v.height);\n\n    // ctx.fillStyle = `yellow`;\n    // ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n\n    ctx.beginPath();\n    ctx.lineWidth = strokeWidth;\n    const lineX = v.width - strokeWidth / 2;\n    ctx.moveTo(lineX, plotArea.paddingPx + strokeWidth);\n    ctx.lineTo(lineX, plotArea.canvasRegion.height + paddingPx + strokeWidth + strokeWidth);\n    ctx.stroke();\n\n    ctx.textBaseline = `top`;\n    const fromRight = v.width - paddingPx * 4;\n\n    ctx.fillStyle = plot.axisTextColour;\n    if (isRangeSinglePoint(r)) {\n      this.debugLog(`rangeSinglePoint`);\n      drawText(ctx, series.formatValue(r.max), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.max) - paddingPx * 4,\n      ]);\n    } else {\n      // Draw min/max data labels\n      drawText(ctx, series.formatValue(r.max), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.max) + strokeWidth / 2,\n      ]);\n      drawText(ctx, series.formatValue(r.min), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.min) - 5,\n      ]);\n    }\n  }\n}\n\nconst drawText = (\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  position: (size: TextMetrics) => [ x: number, y: number ]\n) => {\n  if (ctx === undefined) throw new Error(`ctx is undefined`);\n  const size = ctx.measureText(text);\n  const xy = position(size);\n  ctx.fillText(text, xy[ 0 ], xy[ 1 ]);\n};\n\n/**\n * Canvas-based data plotter.\n *\n * ```\n * const p = new Plot(document.getElementById(`myCanvas`), opts);\n *\n * // Plot 1-5 as series  test'\n * p.createSeries(`test`, `array`, [1,2,3,4,5]);\n *\n * // Create a streaming series, add a random number\n * const s = p.createSeries(`test2`, `stream`);\n * s.add(Math.random());\n * ```\n * `createSeries` returns the {@link Series} instance with properties for fine-tuning\n *\n * For simple usage, use `plot(someData)` which automatically creates\n * series for the properties of an object.\n */\nexport class Plot extends Sg.CanvasBox {\n  plotArea: PlotArea;\n  legend: Legend;\n  axisX: AxisX;\n  axisY: AxisY;\n  axisStrokeColour: string;\n  axisTextColour: string;\n  legendTextColour: string;\n\n  axisStrokeWidth: number;\n  series: Map<string, Series>;\n  private _frozen = false;\n  private _canvasEl: HTMLCanvasElement;\n  private _ctx: CanvasRenderingContext2D;\n\n  defaultSeriesOpts?: SeriesOpts;\n  constructor(canvasElementOrQuery: HTMLCanvasElement | string, opts: Opts = {}) {\n    const { ctx, element, bounds } = scaleCanvas(canvasElementOrQuery);\n    super(undefined, `Plot`);//bounds);\n    this._canvasEl = element;\n    this._ctx = ctx;\n\n    if (opts.autoSize) {\n      parentSizeCanvas(element, (event) => {\n        this.drawingInvalidated(`resize`);\n        this.layoutInvalidated(`resize`);\n        this.update(event.ctx, true);\n      });\n    }\n\n    this.axisStrokeColour = opts.axisStrokeColour ?? `black`;\n    this.axisTextColour = opts.axisTextColour ?? `black`;\n    this.legendTextColour = opts.legendTextColour ?? `black`;\n\n    this.axisStrokeWidth = opts.axisStrokeWidth ?? 3;\n    this.series = new Map();\n    this.plotArea = new PlotArea(this, bounds);\n    this.legend = new Legend(this, bounds);\n    this.axisX = new AxisX(this, bounds);\n    this.axisY = new AxisY(this, bounds);\n\n    // this.plotArea.debugLayout = true;\n    // this.axisX.debugLayout = true;\n    // this.axisY.debugLayout = true;\n    // this.legend.debugLayout = true;\n    // this.debugLayout = true;\n  }\n\n  update(ctx?: CanvasRenderingContext2D, force = false) {\n    if (ctx === undefined) ctx = this._ctx;\n    super.update(ctx, force);\n    // this.plotArea.update(ctx, force);\n    // this.axisX.update(ctx, force);\n    // this.axisY.update(ctx, force);\n    // this.legend.update(ctx, force);\n  }\n\n  /**\n   * Calls 'clear()' on each of the series\n   */\n  clearSeries() {\n    for (const series of this.series.values()) {\n      series.clear();\n    }\n    this.update();\n  }\n\n  /**\n   * Removes all series, plot, legend\n   * and axis data.\n   */\n  clear() {\n    this.series = new Map();\n    this.plotArea.clear();\n    this.legend.clear();\n    this.axisX.clear();\n    this.axisY.clear();\n    this.layoutInvalidated(`Plot.clear`);\n    this.drawingInvalidated(`Plot.clear`);\n    this.update();\n  }\n\n  get frozen(): boolean {\n    return this._frozen;\n  }\n\n  set frozen(v: boolean) {\n    this._frozen = v;\n    if (v) {\n      this._canvasEl.classList.add(`frozen`);\n      this._canvasEl.title = `Plot frozen. Tap to unfreeze`;\n    } else {\n      this._canvasEl.title = ``;\n      this._canvasEl.classList.remove(`frozen`);\n    }\n  }\n\n  seriesArray(): Array<Series> {\n    return [ ...this.series.values() ];\n  }\n\n  get seriesLength(): number {\n    return this.series.size;\n  }\n\n  /**\n   * Plots a simple object, eg `{ x: 10, y: 20, z: 300 }`\n   * Series are automatically created for each property of `o`\n   *\n   * Be sure to call `update()` to visually refresh.\n   * @param o\n   */\n  plot(o: any) {\n    const paths = getPaths(o, true);\n    let seriesCreated = false;\n    for (const p of paths) {\n      let s = this.series.get(p);\n      if (s === undefined) {\n        s = this.createSeries(p, `stream`);\n        s.drawingStyle = `line`;\n        seriesCreated = true;\n      }\n      s.add(getField(o, p));\n    }\n    if (seriesCreated) this.legend.layoutInvalidated(`new series`);\n    this.update();\n  }\n\n  createSeriesFromObject(o: any, prefix = ``): Array<Series> {\n    const keys = Object.keys(o);\n    const create = (key: string): Array<Series> => {\n      const v = o[ key ];\n      if (typeof v === `object`) {\n        return this.createSeriesFromObject(v, `${ prefix }${ key }.`);\n      } else if (typeof v === `number`) {\n        return [ this.createSeries(key, `stream`) ];\n      } else {\n        return [];\n      }\n    };\n    return keys.flatMap(k => create(k));\n  }\n\n  createSeries(\n    name?: string,\n    type: `stream` | `array` = `array`,\n    seriesOpts?: SeriesOpts\n  ): Series {\n    const seriesLength = this.seriesLength;\n\n    if (name === undefined) name = `series-${ seriesLength }`;\n    if (this.series.has(name))\n      throw new Error(`Series name '${ name }' already in use`);\n\n    let opts: SeriesOpts = {\n      colour: `hsl(${ (seriesLength * 25) % 360 }, 70%,50%)`,\n      ...seriesOpts,\n    };\n    if (this.defaultSeriesOpts) opts = { ...this.defaultSeriesOpts, ...opts };\n\n    const s = new Series(name, type, this, opts);\n    // if (type === `array` && initialData !== undefined) {\n    //   (s.source as ArrayDataSource).set(initialData);\n    // }\n\n    this.series.set(name, s);\n    this.setReady(true, true);\n    this.plotArea.drawingInvalidated(`Plot.createSeries`);\n    return s;\n  }\n}\n","import { throwNumberTest } from '../Guards.js';\nimport type { NumberFunction } from './Types.js';\n\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v: number | NumberFunction) => {\n  if (typeof v === `function`) v = v();\n  throwNumberTest(v, `percentage`, `v`);\n  return 1 - v;\n};\n","import { Arrays } from '../collections/index.js';\nimport { Points } from '../geometry/index.js';\nimport * as Rects from '../geometry/rect/index.js';\nimport { intersectsPoint as RectsIntersectsPoint } from '../geometry/rect/Intersects.js';\nimport { isPlaceholder as RectsIsPlaceholder } from '../geometry/rect/Guard.js';\nimport { placeholderPositioned as RectsPlaceholderPositioned, placeholder as RectsPlaceholder, emptyPositioned as RectsEmptyPositioned } from '../geometry/rect/index.js';\nimport { hue as randomHue } from '../random/index.js';\nimport type { Rect, RectPositioned, Point } from '../geometry/Types.js';\n\nexport type Measurement = {\n  actual: Rect;\n  ref: Box;\n  children: Array<Measurement | undefined>;\n};\n\nexport type Layout = {\n  actual: Point;\n  ref: Box;\n  children: Array<Layout | undefined>;\n};\n\nexport type PxUnit = {\n  value: number;\n  type: `px`;\n};\n\nexport type PcUnit = {\n  value: number;\n  type: `pc`;\n};\n\nexport type BoxUnit = PxUnit | PcUnit;\n\nexport type BoxRect = {\n  x?: BoxUnit;\n  y?: BoxUnit;\n  width?: BoxUnit;\n  height?: BoxUnit;\n};\n\nexport const boxUnitFromPx = (v: number): PxUnit => {\n  return { type: `px`, value: v };\n}\nexport const boxRectFromPx = (x: number, y: number, width: number, height: number): BoxRect => {\n  return {\n    x: boxUnitFromPx(x),\n    y: boxUnitFromPx(y),\n    width: boxUnitFromPx(width),\n    height: boxUnitFromPx(height)\n  }\n}\nexport const boxRectFromRectPx = (r: RectPositioned): BoxRect => {\n  return {\n    x: boxUnitFromPx(r.x),\n    y: boxUnitFromPx(r.y),\n    width: boxUnitFromPx(r.width),\n    height: boxUnitFromPx(r.height)\n  }\n}\n\nconst unitIsEqual = (a: BoxUnit, b: BoxUnit): boolean => {\n  if (a.type === `px` && b.type === `px`) {\n    return a.value === b.value;\n  }\n  return false;\n};\n\nconst boxRectIsEqual = (\n  a: BoxRect | undefined,\n  b: BoxRect | undefined\n): boolean => {\n  if (a === undefined && b === undefined) return true;\n  if (a === undefined) return false;\n  if (b === undefined) return false;\n  if (a.x && b.x && !unitIsEqual(a.x, b.x)) return false;\n  if (a.y && b.y && !unitIsEqual(a.y, b.y)) return false;\n  if (a.width && b.width && !unitIsEqual(a.width, b.width)) return false;\n  if (a.height && b.height && !unitIsEqual(a.height, b.height)) return false;\n  return true;\n};\n\nclass BaseState {\n  bounds: RectPositioned;\n  pass: number;\n  constructor(bounds: RectPositioned) {\n    this.bounds = bounds;\n    this.pass = 0;\n  }\n\n  resolveToPx(u: BoxUnit | undefined, maxValue: number, defaultValue?: number): number | undefined {\n    if (u === undefined && defaultValue !== undefined) return defaultValue;\n    if (u === undefined) return; //throw new Error(`unit undefined`);\n    if (u.type === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Type is missing`);\n    if (u.value === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Value is missing`);\n\n\n    if (u.type === `px`) return u.value;\n    if (u.type === `pc`) return u.value * maxValue;\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    // @ts-expect-error\n    throw new Error(`Unknown unit type: ${ u.type }`);\n  }\n\n  resolveBox(box: BoxRect | undefined): Rect | RectPositioned | undefined {\n    if (box === undefined) return undefined;\n    const x = this.resolveToPx(box.x, this.bounds.width);\n    const y = this.resolveToPx(box.y, this.bounds.height);\n    const width = this.resolveToPx(box.width, this.bounds.width);\n    const height = this.resolveToPx(box.height, this.bounds.height);\n    if (!width || !height) throw new TypeError(`Expected width and height`);\n    if (x === undefined && y === undefined) {\n      return Object.freeze({ width, height });\n    } else {\n      if (!x || !y) throw new TypeError(`Expected x and y`);\n      return Object.freeze({\n        x, y, width, height\n      });\n    }\n  }\n}\n\nexport class MeasureState extends BaseState {\n  measurements: Map<string, Measurement>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.measurements = new Map<string, Measurement>();\n  }\n\n  getActualSize(id: string): Rect | undefined {\n    const s = this.measurements.get(id);\n    if (s === undefined) return;\n    if (RectsIsPlaceholder(s.actual)) return;\n    return s.actual;\n  }\n\n  whatIsMeasured(): Array<string> {\n    return [ ...this.measurements.keys() ]\n  }\n}\n\nexport class LayoutState extends BaseState {\n  layouts: Map<string, Layout>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.layouts = new Map<string, Layout>();\n  }\n}\n/**\n * Box\n */\nexport abstract class Box {\n\n  /** Rectangle Box occupies in canvas/etc */\n  canvasRegion: RectPositioned = RectsPlaceholderPositioned;\n\n  private _desiredRect: BoxRect | undefined;\n\n  protected _measuredSize: Rect | undefined;\n  protected _layoutPosition: Point | undefined;\n\n  protected children: Array<Box> = [];\n  protected readonly _parent: Box | undefined;\n  private _idMap = new Map<string, Box>();\n\n  debugLayout = false;\n\n  private _visible = true;\n  protected _ready = true;\n\n  takesSpaceWhenInvisible = false;\n\n  protected _needsMeasuring = true;\n  protected _needsLayoutX = true;\n  protected _needsDrawing = true;\n\n  debugHue = randomHue();\n  readonly id: string;\n\n  /**\n   * Constructor.\n   * \n   * If `parent` is provided, `parent.onChildAdded(this)` is called.\n   * @param parent parent box \n   * @param id id of this box\n   */\n  constructor(parent: Box | undefined, id: string) {\n    this.id = id;\n    this._parent = parent;\n\n    parent?.onChildAdded(this);\n  }\n\n  /**\n   * Returns _true_ if `box` is a child\n   * @param box \n   * @returns \n   */\n  hasChild(box: Box): boolean {\n    const byReference = this.children.find((c) => c === box);\n    const byId = this.children.find((c) => c.id === box.id);\n    return byReference !== undefined || byId !== undefined;\n  }\n\n  /**\n   * Sends a message to all child boxes.\n   * \n   * This first calls `onNotify` on this instance,\n   * before calling `notify()` on each child.\n   * @param message \n   * @param source \n   */\n  notify(message: string, source: Box) {\n    this.onNotify(message, source);\n    for (const c of this.children) c.notify(message, source);\n  }\n\n  *getChildren() {\n    return this.children.entries();\n  }\n\n  /**\n   * Handles a received message\n   * @param _message \n   * @param _source \n   */\n  protected onNotify(_message: string, _source: Box) {\n    /** no-op */\n  }\n\n  /**\n   * Notification a child box has been added\n   * \n   * Throws if\n   * - child has parent as its own child\n   * - child is same as this\n   * - child is already child of this\n   * @param child \n   */\n  protected onChildAdded(child: Box) {\n    if (child.hasChild(this)) throw new Error(`Recursive`);\n    if (child === this) throw new Error(`Cannot add self as child`);\n    if (this.hasChild(child)) throw new Error(`Child already present`);\n\n    this.children.push(child);\n    this._idMap.set(child.id, child);\n\n    this.layoutInvalidated(`Box.onChildAdded`);\n  }\n\n  /**\n   * Sets `_ready` to `ready`. If `includeChildren` is _true_,\n   * `setReady` is called on each child\n   * @param ready \n   * @param includeChildren \n   */\n  setReady(ready: boolean, includeChildren = false) {\n    this._ready = ready;\n    if (includeChildren) {\n      for (const c of this.children) c.setReady(ready, includeChildren);\n    }\n  }\n\n  /**\n   * Gets visible state\n   */\n  get visible(): boolean {\n    return this._visible;\n  }\n\n  /**\n   * Sets visible state\n   */\n  set visible(v: boolean) {\n    if (this._visible === v) return;\n    this._visible = v;\n\n    // Invalidated because we skip measuring when it is invisible\n    this.layoutInvalidated(`Box.set visible`);\n  }\n\n  /**\n   * Gets the box's desired region, or _undefined_\n   */\n  get desiredRegion(): BoxRect | undefined {\n    return this._desiredRect;\n  }\n\n  /**\n   * Sets the box's desired region.\n   * Calls `onLayoutNeeded()`\n   */\n  set desiredRegion(v: BoxRect | undefined) {\n    if (boxRectIsEqual(v, this._desiredRect)) return;\n    this._desiredRect = v;\n    this.layoutInvalidated(`set desiredRegion`);\n  }\n\n  /**\n   * Calls `notifyChildLayoutNeeded`\n   */\n  layoutInvalidated(reason: string) {\n    if (reason === undefined) debugger;\n    this.debugLog(`layoutInvalidated ${ reason }`);\n    this._needsMeasuring = true;\n    this._needsLayoutX = true;\n    // TODO: Only set to true during measuring if it actually changes\n    this._needsDrawing = true;\n    this.notifyChildLayoutNeeded();\n  }\n\n  drawingInvalidated(_reason: string): void {\n    this._needsDrawing = true;\n    //this.debugLog(`drawingInvalidated ${ reason }`);\n  }\n\n  /**\n   * Called from a child, notifying us that\n   * its layout has changed\n   * @returns \n   */\n  private notifyChildLayoutNeeded() {\n    // TODO: Not all layout changes require re-layout higher up\n    this._needsDrawing = true;\n    this._needsLayoutX = true;\n    this._needsMeasuring = true;\n    if (this._parent === undefined) return;\n    this._parent.notifyChildLayoutNeeded();\n  }\n\n  /**\n   * Returns the root box\n   */\n  get root(): Box {\n    if (this._parent === undefined) return this;\n    return this._parent.root;\n  }\n\n  /**\n   * Prepare for measuring\n   */\n  protected measurePreflight() {\n    /** no-up */\n  }\n\n  /**\n   * Applies actual size, returning _true_ if size is different than before\n   * \n   * 1. Sets `_needsLayout` to _false_.\n   * 2. Sets `visual` to `m`\n   * 3. Calls `measureApply` on each child\n   * 4. If there's a change or `force`, sets `needsDrawing` to _true_, and notifies root of `measureApplied`\n   * @param m Measurement for box\n   * @param force If true forces `measureApplied` notify\n   * @returns \n   */\n  protected measureApply(m: Measurement) {\n    this._needsMeasuring = false;\n\n    const different = this._measuredSize === undefined ? true : !Rects.isEqualSize(m.actual, this._measuredSize);\n    if (different) {\n      //this.debugLog(`measureApply: Size is different than previous. Actual: ${ JSON.stringify(m.actual) } current: ${ JSON.stringify(this._measuredSize) }`);\n      this._needsLayoutX = true;\n    }\n\n    this._measuredSize = { width: m.actual.width, height: m.actual.height };\n\n    for (const c of m.children) {\n      if (c !== undefined) c.ref.measureApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`measureApplied`, this);\n    }\n    return different;\n  }\n\n  protected layoutApply(l: Layout) {\n    this._needsLayoutX = false;\n\n    const different = this._layoutPosition === undefined ? true : !Points.isEqual(l.actual, this._layoutPosition);\n    // if (different) {\n    //   this.debugLog(`layoutApply. Position different than previous. ${ JSON.stringify(l.actual) }`);\n    // }\n    this._layoutPosition = { x: l.actual.x, y: l.actual.y };\n\n    for (const c of l.children) {\n      if (c !== undefined) c.ref.layoutApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`layoutApplied`, this);\n    }\n    return different;\n  }\n\n  /**\n   * Debug log from this box context\n   * @param m \n   */\n  debugLog(m: any) {\n    if (!this.debugLayout) return;\n    console.log(this.id, m);\n\n  }\n\n  layoutStart(measureState: MeasureState, layoutState: LayoutState, force: boolean, parent?: Layout): Layout | undefined {\n    const m: Layout = {\n      ref: this,\n      actual: Points.Empty,\n      children: [],\n    };\n    // Stash away measurement by id\n    layoutState.layouts.set(this.id, m);\n\n    const currentPosition = this.layoutSelf(measureState, layoutState, parent);\n    this.root.notify(`laidout`, this);\n\n    // For some reason we can't measure\n    if (currentPosition === undefined) return;\n\n    // Assign\n    m.actual = currentPosition;\n\n    m.children = this.children.map((c) => c.layoutStart(measureState, layoutState, force, m));\n    if (Arrays.withoutUndefined(m.children).length < this.children.length) {\n      return undefined; // One of the children did not resolve\n    }\n    return m;\n  }\n\n  protected layoutSelf(\n    measureState: MeasureState,\n    layoutState: LayoutState,\n    _parent?: Layout\n  ): Point | undefined {\n    // TODO: Proper layout\n    const box = layoutState.resolveBox(this._desiredRect);\n    const x = box === undefined ? 0 : (`x` in box ? box.x : 0);\n    const y = box === undefined ? 0 : (`y` in box ? box.y : 0);\n    if (x === undefined) debugger;\n    if (y === undefined) debugger;\n    return { x, y }\n  }\n\n  /**\n   * Start of measuring\n   * 1. Keeps track of measurements in `opts.measurements`\n   * 2. If this box takes space\n   * 2.1. Measure itself if needed\n   * 2.2. Use size\n   * 2. Calls `measureStart` on each child\n   * @param opts Options\n   * @param force \n   * @param parent Parent's measurement \n   * @returns Measurement\n   */\n  measureStart(\n    opts: MeasureState,\n    force: boolean,\n    parent?: Measurement\n  ): Measurement | undefined {\n    this.measurePreflight();\n\n    const m: Measurement = {\n      ref: this,\n      // So far no known measurement\n      actual: RectsPlaceholder,\n      children: [],\n    };\n    // Stash away measurement by id\n    opts.measurements.set(this.id, m);\n\n    if (!this._visible && !this.takesSpaceWhenInvisible) {\n      // If we're not visible, there's no actual size\n      m.actual = RectsEmptyPositioned;\n    } else {\n      let currentMeasurement: Rect | string | undefined = this._measuredSize;\n\n      // If we need to, measure how big it actually is\n      if (this._needsMeasuring || this._measuredSize === undefined) {\n        currentMeasurement = this.measureSelf(opts, parent);\n        this.root.notify(`measured`, this);\n      }\n\n      // For some reason we can't measure\n      if (typeof currentMeasurement === `string`) {\n        //this.debugLog(`measureStart: measureSelf failed: ${ currentMeasurement }`);\n        return;\n      } else if (currentMeasurement === undefined) {\n        //this.debugLog(`measureStart: measureSelf failed for some other reason`);\n        return;\n      }\n\n      // Assign\n      m.actual = currentMeasurement;\n    }\n\n    m.children = this.children.map((c) => c.measureStart(opts, force, m));\n    if (Arrays.withoutUndefined(m.children).length < this.children.length) {\n      //this.debugLog(`measureStart: Child failed measureStart`);\n      return undefined; // One of the children did not resolve\n    }\n\n    return m;\n  }\n\n  /**\n   * Measure the box\n   * 1. Uses desired rectangle, if possible\n   * 2. Otherwise uses parent's size\n   * @param opts Measure state\n   * @param parent Parent size\n   * @returns \n   */\n  protected measureSelf(\n    opts: MeasureState,\n    parent?: Measurement\n  ): Rect | string {\n    let size = RectsPlaceholder;\n\n    const context = parent ? parent.actual : opts.bounds;\n    const desired = opts.resolveBox(this._desiredRect);\n\n    size = desired ? Rects.clamp(desired, context) : context;\n\n    if (RectsIsPlaceholder(size)) {\n      return `Box.measureSelf - No size for box?`;\n    }\n    return size;\n  }\n\n\n  /**\n   * Gets initial state for a run of measurements & layout.\n   * \n   * Called when update() is called\n   * @param force\n   */\n  protected abstract updateBegin(context: any): [ MeasureState, LayoutState ];\n\n  protected abstract updateComplete(measureChanged: boolean, layoutChanged: boolean): void;\n\n  // protected updateDone(state: MeasureState, force: boolean): void {\n  //   this.onUpdateDone(state, force);\n  //   for (const c of this.children) c.updateDone(state, force);\n  // }\n\n  /**\n   * Update has completed\n   * @param state \n   * @param force \n   */\n  //abstract onUpdateDone(state: MeasureState, force: boolean): void;\n\n  /**\n   * Update\n   * 1. Calls `this.updateBegin()` to initialise measurement state\n   * 2. In a loop, run `measureStart()` and then `measureApply` if possible\n   * 3. Call `updateDone` when finished\n   * @param force \n   * @returns \n   */\n  update(context: object, force = false) {\n    if (context === undefined) throw new Error(`context is undefined`);\n\n    if (!this._needsMeasuring && !this._needsLayoutX && !force) return;\n    const [ measureState, layoutState ] = this.updateBegin(context);\n    let attempts = 5;\n    let measureApplied = false;\n    let layoutApplied = false;\n\n    // Measure everything\n    if (this._needsMeasuring || force) {\n      //this.debugLog(`update: needs measuring (force: ${ force }) bounds: ${ JSON.stringify(measureState.bounds) }`);\n      while (attempts--) {\n        const m = this.measureStart(measureState, force);\n        if (m !== undefined) {\n          // Apply measurements\n          this.measureApply(m);\n          if (!this._ready) return;\n          measureApplied = true;\n        }\n      }\n      //this.updateDone(state, force);\n      if (!measureApplied) this.debugLog(`Ran out of measurement attempts`);\n    }\n\n    // Lay it out\n    if (this._needsLayoutX || force) {\n      const p = this.layoutStart(measureState, layoutState, force);\n      if (p === undefined) {\n        this.debugLog(`Warning: could not layout`);\n      } else {\n        this.layoutApply(p);\n        layoutApplied = true;\n      }\n    }\n    this.updateComplete(measureApplied, layoutApplied);\n  }\n}\n\n/**\n * Canvas measure state\n */\nexport class CanvasMeasureState extends MeasureState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n  }\n}\n\nexport class CanvasLayoutState extends LayoutState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n\n  }\n}\n\n/**\n * A Box that exists on a HTMLCanvasElement\n */\nexport class CanvasBox extends Box {\n  readonly bounds: RectPositioned | undefined;\n  constructor(\n    parent: CanvasBox | undefined,\n    //canvasElement: HTMLCanvasElement,\n    id: string,\n    bounds?: RectPositioned\n  ) {\n    super(parent, id);\n    this.bounds = bounds;\n    this.debugLog(`CanvasBox ctor bounds: ${ JSON.stringify(bounds) }`);\n  }\n\n  static fromCanvas(canvasElement: HTMLCanvasElement): CanvasBox {\n    const box = new CanvasBox(undefined, `canvas-box`, canvasElement.getBoundingClientRect());\n    return box;\n  }\n\n  /**\n   * Called if this is the parent Box\n   */\n  public addEventHandlers(element: HTMLElement) {\n    element.addEventListener(`pointermove`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyPointerMove(p);\n    });\n\n    element.addEventListener(`pointerleave`, (_event) => {\n      this.notifyPointerLeave();\n    });\n\n    element.addEventListener(`click`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyClick(p);\n    });\n  }\n\n  protected onClick(_p: Point) {\n    /** no-up */\n  }\n\n  /**\n   * Click event has happened on canvas\n   * 1. If it's within our range, call `onClick` and pass to all children via `notifyClick`\n   * @param p \n   * @returns \n   */\n  private notifyClick(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = Points.subtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onClick(pp);\n      // TODO: Only call `notifyClick` if child is within range?\n      for (const c of this.children) (c as CanvasBox).notifyClick(pp);\n    }\n  }\n\n  /**\n   * Pointer has left\n   * 1. Pass notification to all children via `notifyPointerLeave`\n   */\n  private notifyPointerLeave() {\n    this.onPointerLeave();\n    for (const c of this.children) (c as CanvasBox).notifyPointerLeave();\n  }\n\n  /**\n   * Pointer has moved\n   * 1. If it's within range `onPointerMove` is called, and pass on to all children via `notifyPointerMove`\n   * @param p \n   * @returns \n   */\n  private notifyPointerMove(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = Points.subtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onPointerMove(pp);\n      for (const c of this.children) (c as CanvasBox).notifyPointerMove(pp);\n    }\n  }\n\n  /**\n   * Handler when pointer has left\n   */\n  protected onPointerLeave() {\n    /** no-up */\n  }\n\n  /**\n   * Handler when pointer moves within our region\n   * @param _p \n   */\n  protected onPointerMove(_p: Point) {\n    /** no-up */\n\n  }\n\n  /**\n   * Performs recalculations and drawing as necessary\n   * If nothing needs to happen, function returns.\n   * @param context \n   * @param force \n   */\n  update(context: CanvasRenderingContext2D, force = false) {\n    super.update(context, force);\n    this.draw(context, force);\n  }\n\n  getBounds(): RectPositioned | undefined {\n    return this.bounds === undefined && this._parent ? (this._parent as CanvasBox).bounds : this.bounds;\n  }\n\n  /**\n   * Update begins.\n   * @returns MeasureState\n   */\n  protected updateBegin(context: CanvasRenderingContext2D): [ MeasureState, LayoutState ] {\n    if (context === undefined) throw new Error(`Context is undefined`);\n    let bounds = this.getBounds();\n    //this.debugLog(`updateBegin bounds: ${ JSON.stringify(bounds) } measured: ${ JSON.stringify(this._measuredSize) }`);\n\n    if (bounds === undefined) {\n      this.debugLog(`No bounds for element or parent, using canvas bounds`);\n      bounds = { x: 0, y: 0, width: context.canvas.width, height: context.canvas.height }\n    }\n    return [\n      new CanvasMeasureState(bounds, context),\n      new CanvasLayoutState(bounds, context)\n    ]\n    // if (this.region) {\n    //   return new CanvasMeasureState(this.region);\n    // } else {\n    //   const s = this.canvasEl.getBoundingClientRect();\n\n    //   return new CanvasMeasureState(\n    //     {\n    //       x: 0,\n    //       y: 0,\n    //       width: s.width,\n    //       height: s.height,\n    //     },\n    //     ctx\n    //   );\n    // }\n  }\n\n  protected updateComplete(_measureChanged: boolean, _layoutChanged: boolean): void {\n    //this.debugLog(`updateComplete. measureChanged: ${ _measureChanged } layoutChanged: ${ _layoutChanged } pos: ${ JSON.stringify(this._layoutPosition) }`);\n    this.canvasRegion = RectsPlaceholderPositioned;\n  }\n\n  protected measureApply(m: Measurement): boolean {\n    const different = super.measureApply(m);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  protected layoutApply(l: Layout): boolean {\n    const different = super.layoutApply(l);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  public draw(ctx: CanvasRenderingContext2D, force = false) {\n    //this.debugLog(`draw. needs drawing: ${ this._needsDrawing } force: ${ force } pos: ${ JSON.stringify(this._layoutPosition) } size: ${ JSON.stringify(this._measuredSize) }`);\n\n    // if (!this._needsDrawing && !force) return;\n\n    if (this._needsDrawing || force) {\n      if (RectsIsPlaceholder(this.canvasRegion)) {\n        if (this._layoutPosition === undefined) return;\n        if (this._measuredSize === undefined) return;\n        this.canvasRegion = {\n          x: this._layoutPosition.x,\n          y: this._layoutPosition.y,\n          width: this._measuredSize.width,\n          height: this._measuredSize.height\n        }\n      }\n\n      //this.debugLog(`draw: canvasRegion: ${ JSON.stringify(this.canvasRegion) }`);\n      if (this._needsLayoutX || this._needsMeasuring) {\n        //this.debugLog(`draw: warning: drawing with outdated layout / measurements`);\n      }\n      ctx.save();\n      const v = this.canvasRegion;\n      ctx.translate(v.x, v.y);\n\n      if (this.debugLayout) {\n        //ctx.clearRect(0,0,v.width,v.height);\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = `hsl(${ this.debugHue }, 100%, 50%)`;\n\n        //ctx.fillStyle = ctx.strokeStyle;\n        //ctx.fillRect(0,0,v.width,v.height);\n\n        ctx.strokeRect(0, 0, v.width, v.height);\n\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fillText(this.id, 10, 10, v.width);\n\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(v.width, v.height);\n        ctx.stroke();\n      }\n\n      this.drawSelf(ctx);\n\n      this._needsDrawing = false;\n      ctx.restore();\n    }\n    for (const c of this.children) {\n      (c as CanvasBox).draw(ctx, force)\n    }\n  }\n\n  /**\n   * Draw this object\n   * @param _ctx \n   */\n  protected drawSelf(_ctx: CanvasRenderingContext2D): void {\n    /** no-up */\n  }\n}\n","import { resolveEl } from \"../dom/Util.js\";\n\n/**\n * Scales a canvas to account for retina displays.\n * \n * ```js\n * const r = scaleCanvas(`#my-canvas`);\n * r.ctx;      // CanvasRendering2D\n * r.element;  // HTMLCanvasElement\n * r.bounds;   // {x:number,y:number,width:number,height:number}\n * ```\n * \n * Eg:\n * ```js\n * const { ctx } = scaleCanvas(`#my-canvas`);\n * ctx.fillStyle = `red`;\n * ctx.fillRect(0,0,100,100);\n * ```\n * \n * Throws an error if `domQueryOrElement` does not resolve.w\n * @param domQueryOrElement \n * @returns \n */\nexport const scaleCanvas = (domQueryOrElement: HTMLCanvasElement | string) => {\n  const canvasElement = resolveEl<HTMLCanvasElement>(domQueryOrElement);\n  const ratio = window.devicePixelRatio;\n  canvasElement.style.width = canvasElement.width + `px`;\n  canvasElement.style.height = canvasElement.height + `px`;\n  canvasElement.width *= devicePixelRatio;\n  canvasElement.height *= devicePixelRatio;\n\n  const getContext = () => {\n    const ctx = canvasElement.getContext(`2d`);\n\n    if (ctx === null) throw new Error(`Could not get drawing context`);\n    ctx.save();\n    ctx.scale(ratio, ratio);\n    return ctx;\n  }\n  return { ctx: getContext(), element: canvasElement, bounds: canvasElement.getBoundingClientRect() };\n}","/**\n * Manage a set of colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type Palette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param colour\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: readonly string[]): Palette =>\n  new PaletteImpl(fallbacks);\n\nclass PaletteImpl {\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #store: Map<string, string> = new Map();\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: readonly string[];\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: readonly string[]) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [`red`, `blue`, `green`, `orange`];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const varName = `--` + key;\n    // eslint-disable-next-line functional/no-let\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(varName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[this.#lastFallback];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import * as Drawing from \"./Drawing.js\";\nimport * as Bipolar from \"../data/Bipolar.js\";\n\n/**\n * Options\n */\nexport type BipolarViewOptions = Readonly<{\n  width?: number,\n  height?: number,\n  labelPrecision?: number\n  labels?: [ string, string ],\n  axisColour?: string,\n  bgColour?: string,\n  whiskerColour?: string,\n  whiskerSize?: number,\n  dotColour?: string,\n  dotRadius?: number,\n  showWhiskers?: boolean,\n  showDot?: boolean,\n  showLabels?: boolean,\n  padding?: number,\n  labelColour?: string,\n  axisWidth?: number,\n  asPercentages?: boolean,\n  /**\n   * Custom rendering for background\n   */\n  renderBackground?: Render\n}>\n\nfunction getNumericAttribute(el: HTMLElement, name: string, defaultValue: number) {\n  const a = el.getAttribute(name);\n  if (a === null) return defaultValue;\n  return Number.parseInt(a);\n}\n\nexport type Render = (ctx: CanvasRenderingContext2D, width: number, height: number) => void;\n/**\n * A function that plots a point on the graph\n */\nexport type BipolarView = (x: number, y: number) => void;\n\n/**\n * Initialises a plotter for bipolar values (-1...1)\n * \n * ```js\n * const p = BipolarView.init(`#my-canvas`);\n * // Shows the dot at 1, 0.5\n * p(1, 0.5);\n * ```\n * @param elementQuery \n * @param opts \n * @returns \n */\nexport const init = (elementQuery: string, opts: BipolarViewOptions = {}): BipolarView => {\n  const element = document.querySelector<HTMLCanvasElement>(elementQuery);\n  if (!element) throw new Error(`Element query could not be found (${ elementQuery })`);\n  const labels = opts.labels ?? [ `x`, `y` ];\n  const labelPrecision = opts.labelPrecision ?? 2;\n  const asPercentages = opts.asPercentages ?? false;\n  // Flags\n  const showWhiskers = opts.showWhiskers ?? true;\n  const showDot = opts.showDot ?? true;\n  const showLabels = opts.showLabels ?? true;\n  // Colours\n  const axisColour = opts.axisColour ?? `silver`;\n  const bgColour = opts.bgColour ?? `white`;\n  const whiskerColour = opts.whiskerColour ?? `black`;\n  const dotColour = opts.dotColour ?? whiskerColour;\n  const labelColour = opts.labelColour ?? axisColour;\n  // Sizes\n  const axisWidth = (opts.axisWidth ?? 1 * window.devicePixelRatio);\n  const dotRadius = (opts.dotRadius ?? 5 * window.devicePixelRatio);\n  const pad = (opts.padding ?? 10 * window.devicePixelRatio);\n  const whiskerSize = (opts.whiskerSize ?? 5 * window.devicePixelRatio);\n  const width = (opts.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio);\n  const height = (opts.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio);\n\n  element.width = width;// * window.devicePixelRatio;\n  element.height = height;// * window.devicePixelRatio;\n  element.style.width = width / window.devicePixelRatio + `px`;\n  element.style.height = height / window.devicePixelRatio + `px`;\n\n  const midY = height / 2;\n  const midX = width / 2;\n  const ctx = element.getContext(`2d`);\n  if (!ctx) throw new Error(`Could not create drawing context`);\n\n  if (window.devicePixelRatio >= 2) {\n    ctx.font = `20px sans-serif`;\n  }\n  const percentageFormat = (v: number) => Math.round(v * 100) + `%`;\n  const fixedFormat = (v: number) => v.toFixed(labelPrecision);\n\n  const valueFormat = asPercentages ? percentageFormat : fixedFormat;\n  if (showLabels) {\n    labels[ 0 ] = labels[ 0 ] + `:`;\n    labels[ 1 ] = labels[ 1 ] + `:`;\n  } else {\n    labels[ 0 ] = ``;\n    labels[ 1 ] = ``;\n  }\n\n  const renderBackground: Render = opts.renderBackground ?? ((ctx, width, height): void => {\n    ctx.fillStyle = bgColour;\n    ctx.fillRect(0, 0, width, height);\n  });\n\n  return (x: number, y: number) => {\n    x = Bipolar.clamp(x);\n    y = Bipolar.clamp(y);\n\n    renderBackground(ctx, width, height);\n\n    // Labels\n    ctx.fillStyle = labelColour;\n    ctx.textBaseline = `top`;\n    ctx.save();\n    ctx.translate(midX, midY);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText((labels[ 1 ] + ` ` + valueFormat(y)).trim(), -midX + pad, 1);\n    ctx.restore();\n    ctx.fillText((labels[ 0 ] + ` ` + valueFormat(x)).trim(), pad, midX + 2);\n\n    // Axes\n    ctx.strokeStyle = axisColour;\n    ctx.lineWidth = axisWidth;\n    ctx.beginPath();\n    ctx.moveTo(pad, midY);\n    ctx.lineTo(width - pad, midY);\n    ctx.moveTo(midX, pad);\n    ctx.lineTo(midX, height - pad);\n    ctx.stroke();\n    ctx.closePath();\n\n    const yy = (height - pad - pad) / 2 * -y;\n    const xx = (width - pad - pad) / 2 * x;\n\n    ctx.save();\n    ctx.translate(midX, midY);\n\n    // Dot\n    if (showDot) {\n      Drawing.circle(ctx, { radius: dotRadius, x: xx, y: yy }, { fillStyle: dotColour });\n    }\n\n    // Whiskers\n    if (showWhiskers) {\n      ctx.strokeStyle = whiskerColour;\n\n      // y line\n      ctx.beginPath();\n      ctx.moveTo(0, yy - whiskerSize);\n      ctx.lineTo(0, yy + whiskerSize);\n\n      // x line\n      ctx.moveTo(xx - whiskerSize, 0);\n      ctx.lineTo(xx + whiskerSize, 0);\n      ctx.stroke();\n      ctx.closePath();\n\n\n    }\n\n    // Restore transform\n    ctx.restore();\n  }\n}\n","\nimport { type RandomOptions, type RandomSource } from '../random/Types.js';\nimport { throwNumberTest } from '../Guards.js';\nimport { interpolate } from './Interpolate.js';\nimport { scaler as numberScaler } from './Scale.js';\nimport { floatSource } from '../random/FloatSource.js';\n\n/**\n * Wrapper around a bipolar value. Immutable.\n * \n * ```js\n * let b = Bipolar.immutable();\n * let b = Bipolar.immutable(0.5);\n * b = b.add(0.1);\n * ```\n */\nexport type BipolarWrapper = {\n  value: number\n  towardZero: (amt: number) => BipolarWrapper\n  add: (amt: number) => BipolarWrapper\n  multiply: (amt: number) => BipolarWrapper\n  inverse: () => BipolarWrapper\n  asScalar: () => number\n  interpolate: (amt: number, b: number) => BipolarWrapper\n  [ Symbol.toPrimitive ]: (hint: string) => number | string | boolean\n}\n\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n * \n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n * \n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n * \n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValue \n * @returns \n */\nexport const immutable = (startingValueOrBipolar: number | BipolarWrapper = 0): BipolarWrapper => {\n  const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n\n  if (startingValue > 1) throw new Error(`Cannot be larger than 1`);\n  if (startingValue < -1) throw new Error(`Cannot be smaller than -1`);\n  if (Number.isNaN(startingValue)) throw new Error(`startingValue is NaN`);\n\n  const v = startingValue;\n  return {\n    [ Symbol.toPrimitive ](hint: string) {\n      if (hint === `number`) return v;\n      else if (hint === `string`) return v.toString();\n      return true;\n    },\n    value: v,\n    towardZero: (amt: number) => {\n      return immutable(towardZero(v, amt));\n    },\n    add: (amt: number) => {\n      return immutable(clamp(v + amt));\n    },\n    multiply: (amt: number) => {\n      return immutable(clamp(v * amt));\n    },\n    inverse: () => {\n      return immutable(-v);\n    },\n    interpolate: (amt: number, b: number) => {\n      return immutable(clamp(interpolate(amt, v, b)));\n    },\n    asScalar: () => {\n      return toScalar(v);\n    }\n  }\n}\n\n/**\n * Converts bipolar value to a scalar\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue: number) => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);\n  return (bipolarValue + 1) / 2;\n}\n\n/**\n * Makes a scalar into a bipolar value.\n * \n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n * \n * Throws an error if `scalarValue` is not on 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue: number) => {\n  throwNumberTest(scalarValue, `percentage`, `v`);\n  return (scalarValue * 2) - 1;\n};\n\n/**\n * Scale a number to -1..1 range\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * \n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue: number, inMin: number, inMax: number) => {\n  return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n}\n\n/**\n * Scale a number, clamped to -1..1 range\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * \n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleClamped = (inputValue: number, inMin: number, inMax: number) => {\n  return numberScaler(inMin, inMax, -1, 1)(inputValue);\n}\n\n/**\n * Source for random bipolar values\n * ```js\n * const r = Bipolar.randomSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n * \n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * Bipolar.randomSource({ max: 0.5 });\n * ```\n * \n * Consider using {@link random} if you just want a one-off random\n * value.\n * @param source \n * @returns \n */\nexport const randomSource = (maxOrOptions?: number | RandomOptions): RandomSource => {\n  const source = floatSource(maxOrOptions);\n  return () => (source() * 2) - 1;\n}\n\n/**\n * Returns a random bipolar value\n * ```js\n * const r = Bipolar.random(); // -1...1 random\n * ```\n * \n * Options can be provided, eg.\n * ```js\n * Bipolar.random({ max: 0.5 }); // -0.5..0.5 random\n * ```\n * \n * Use {@link randomSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions \n * @returns \n */\nexport const random = (maxOrOptions?: number | RandomOptions): number => {\n  const source = randomSource(maxOrOptions);\n  return source();\n}\n/**\n * Clamp a bipolar value\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter must be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`v parameter is NaN`);\n  if (bipolarValue > 1) return 1;\n  if (bipolarValue < -1) return -1;\n  return bipolarValue;\n}\n\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n * \n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n * \n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue: number, amount: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${ typeof bipolarValue }`);\n  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${ typeof amount }`);\n  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);\n  if (bipolarValue < 0) {\n    bipolarValue += amount;\n    if (bipolarValue > 0) bipolarValue = 0;\n  } else if (bipolarValue > 0) {\n    bipolarValue -= amount;\n    if (bipolarValue < 0) bipolarValue = 0;\n  }\n  return bipolarValue;\n}","import { minMaxAvg } from '../collections/arrays/NumericArrays.js';\nimport { type ICircularArray } from '../collections/CircularArray.js';\nimport { resolveEl, parentSizeCanvas } from '../dom/Util.js';\nimport { Colour, Drawing } from './index.js';\nimport {\n  ofArrayMutable,\n  ofCircularMutable,\n  type IMapOfMutableExtended,\n} from '../collections/map/index.js';\nimport type { Rect, Point } from '../geometry/Types.js';\n\nexport type Plotter = {\n  add(value: number, series?: string, skipDrawing?: boolean): void;\n  drawValue(index: number): void;\n  /**\n   * Draws current data. Useful if skipDrawing was true for earlier add() calls.\n   */\n  draw(): void;\n  clear(): void;\n  dispose(): void;\n};\n\n/**\n * Series\n */\nexport type Series = {\n  min: number;\n  max: number;\n  range: number;\n  name: string;\n  colour: string;\n  lastValue?: number;\n  hoverValue?: number;\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = PlotOpts & {\n  x: Axis;\n  y: Axis;\n  ctx: CanvasRenderingContext2D;\n  textHeight: number;\n  capacity: number;\n  coalesce: boolean;\n  margin: number;\n  canvasSize: Rect;\n  clearCanvas: boolean;\n  translucentPlot?: boolean;\n  highlightIndex?: number;\n  leadingEdgeDot: boolean;\n  debug: boolean;\n  digitsPrecision: number;\n  lineWidth: number;\n  defaultSeriesColour: string;\n  defaultSeriesVariable?: string;\n  showLegend: boolean;\n  pointer: { x: number; y: number };\n};\n\n/**\n * Properties for an axis\n */\nexport type Axis = {\n  allowedSeries?: Array<string>;\n  /**\n   * Name of axis, eg `x`\n   */\n  name: string;\n  /**\n   * Colour to use for axis labels\n   */\n  colour?: string;\n  /**\n   * Forced scale for values\n   */\n  scaleRange?: [ number, number ];\n  /**\n   * Forced range for labelling, by default\n   * uses scaleRange\n   */\n  labelRange?: [ number, number ];\n  /**\n   * Width of axis line\n   */\n  lineWidth: number;\n  /**\n   * How line ends\n   */\n  endWith: `none` | `arrow`;\n  /**\n   * Where to place the name of the axis\n   */\n  namePosition: `none` | `end` | `side`;\n  /**\n   * Width for y axis, height for x axis\n   */\n  textSize: number;\n  /**\n   * If true, axis labels (ie numeric scale) are shown. Default: true\n   */\n  showLabels: boolean;\n  /**\n   * If true, a line is drawn to represent axis. Default: true\n   */\n  showLine: boolean;\n};\n\nexport type SeriesColours = Record<string, string | undefined>;\n\n/**\n * Plotter options\n */\nexport type PlotOpts = {\n  debug?: boolean;\n  seriesColours?: SeriesColours;\n  /**\n   * Default: 2\n   */\n  digitsPrecision?: number;\n  x?: Axis;\n  y?: Axis;\n  plotSize?: Rect;\n  autoSizeCanvas?: boolean;\n  style?: `connected` | `dots` | `none`;\n  //palette?: Palette.Palette\n  /**\n   * Number of items to keep in the circular array\n   * Default: 10\n   */\n  capacity?: number;\n  //showYAxis?:boolean\n  //showXAxis?:boolean\n  //yAxes?: string[]|string\n  textHeight?: number;\n  /**\n   * Width of plotted line\n   */\n  lineWidth?: number;\n  /**\n   * If true, sub-pixel data points are ignored\n   */\n  coalesce?: boolean;\n  /**\n   * Fixed range to scale Y values. By default normalises values\n   * as they come in. This will also determine the y-axis labels and drawing\n   */\n  //fixedRange?:[number,number]\n  /**\n   * How many horizontal pixels per data point. If unspecified,\n   * it will scale based on width of canvas and capacity.\n   */\n  //dataXScale?:number\n  defaultSeriesColour?: string;\n  defaultSeriesVariable?: string;\n  showLegend?: boolean;\n};\n\nconst piPi = Math.PI * 2;\n\nexport const defaultAxis = (name: string): Axis => ({\n  endWith: `none`,\n  lineWidth: 1,\n  namePosition: `none`,\n  name: name,\n  showLabels: name === `y`,\n  showLine: true,\n  // For y axis, it's the width, for x axis it's the text height\n  textSize: name === `y` ? 20 : 10,\n});\n\nexport const calcScale = (\n  buffer: BufferType,\n  drawingOpts: DrawingOpts,\n  seriesColours?: SeriesColours\n) => {\n  //const seriesNames = buffer.keys();\n  const scales: Array<Series> = [];\n\n  for (const s of buffer.keys()) {\n    //seriesNames.forEach(s => {\n\n    const series = [ ...buffer.get(s) ];\n    if (series.length === 0) break;\n\n    let { min, max } = minMaxAvg(series);\n    let range = max - min;\n\n    let colour;\n    if (seriesColours !== undefined) {\n      colour = seriesColours[ s ];\n    }\n    if (colour == undefined) {\n      colour = drawingOpts.defaultSeriesVariable ? Colour.getCssVariable(\n        `accent`,\n        drawingOpts.defaultSeriesColour\n      ) : drawingOpts.defaultSeriesColour;\n    }\n\n    if (range === 0) {\n      range = min;\n      min = min - range / 2;\n      max = max + range / 2;\n    }\n    scales.push({\n      min,\n      max,\n      range,\n      name: s,\n      colour: colour,\n    });\n  }\n  return scales;\n};\n\nexport const add = (buffer: BufferType, value: number, series = ``) => {\n  buffer.addKeyedValues(series, value);\n};\n\nexport type BufferType =\n  | IMapOfMutableExtended<number, ICircularArray<number>>\n  | IMapOfMutableExtended<number, ReadonlyArray<number>>;\n\nexport const drawValue = (\n  index: number,\n  buffer: BufferType,\n  drawing: DrawingOpts\n) => {\n  const c = {\n    ...drawing,\n    translucentPlot: true,\n    leadingEdgeDot: false,\n  };\n  draw(buffer, c);\n\n  drawing = {\n    ...drawing,\n    highlightIndex: index,\n    leadingEdgeDot: true,\n    translucentPlot: false,\n    style: `none`,\n    clearCanvas: false,\n  };\n  draw(buffer, drawing);\n};\n\nconst scaleWithFixedRange = (\n  buffer: BufferType,\n  range: [ number, number ],\n  drawing: DrawingOpts\n) =>\n  calcScale(buffer, drawing, drawing.seriesColours).map((s) => ({\n    ...s,\n    range: range[ 1 ] - range[ 0 ],\n    min: range[ 0 ],\n    max: range[ 1 ],\n  }));\n\n/**\n * Draws a `buffer` of data with `drawing` options.\n *\n * @param buffer\n * @param drawing\n */\nexport const draw = (buffer: BufferType, drawing: DrawingOpts) => {\n  const { x: xAxis, y: yAxis, ctx, canvasSize } = drawing;\n  const margin = drawing.margin;\n  // const cap = drawing.capacity === 0 ? buffer.lengthMax : drawing.capacity;\n  const series = drawing.y.scaleRange\n    ? scaleWithFixedRange(buffer, drawing.y.scaleRange, drawing)\n    : calcScale(buffer, drawing, drawing.seriesColours);\n\n  if (drawing.clearCanvas)\n    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `orange`;\n    ctx.strokeRect(0, 0, canvasSize.width, canvasSize.height);\n  }\n\n  // Move in for margin\n  ctx.translate(margin, margin);\n\n  // Calculate/use plot area\n  const plotSize = drawing.plotSize ?? plotSizeFromBounds(canvasSize, drawing);\n\n  // Draw vertical axes\n  const axisSize = {\n    height: plotSize.height + margin + margin,\n    width: plotSize.width,\n  };\n\n  if (yAxis.showLabels || yAxis.showLine) {\n    // Draw the labels for each series\n    for (const s of series) {\n      if (yAxis.allowedSeries !== undefined && !yAxis.allowedSeries.includes(s.name)) continue;\n      drawYSeriesScale(s, axisSize, drawing);\n    }\n\n    // Draw vertical line\n    if (series.length > 0 && yAxis.showLine)\n      drawYLine(axisSize, series[ 0 ], drawing);\n  }\n\n  // Draw x/horizontal axis if needed\n  if ((xAxis.showLabels || xAxis.showLine) && series.length > 0) {\n    const yPos = yAxis.labelRange ? yAxis.labelRange[ 0 ] : series[ 0 ].min;\n    drawXAxis(\n      plotSize.width,\n      calcYForValue(yPos, series[ 0 ], plotSize.height) +\n      margin +\n      xAxis.lineWidth,\n      drawing\n    );\n  }\n\n  const plotDrawing = {\n    ...drawing,\n    plotSize,\n  };\n\n  const ptr = Drawing.translatePoint(ctx, drawing.pointer);\n  // Draw data for each series\n  for (const s of series) {\n    const data = buffer.getSource(s.name);\n    if (data === undefined) continue;\n\n    let leadingEdgeIndex =\n      buffer.typeName === `circular`\n        ? (data as ICircularArray<number>).pointer - 1\n        : data.length - 1;\n    if (drawing.highlightIndex !== undefined)\n      leadingEdgeIndex = drawing.highlightIndex;\n    ctx.save();\n    ctx.translate(0, margin + margin);\n\n    drawSeriesData(s, data, plotSize, plotDrawing, leadingEdgeIndex);\n    ctx.restore();\n  }\n\n  if (drawing.showLegend) {\n    ctx.save();\n    ctx.translate(0, plotSize.height + margin + margin + margin);\n    const legendSize = {\n      width: plotSize.width,\n      height: drawing.x.textSize + margin + margin,\n    };\n    drawLegend(series, drawing, legendSize);\n    ctx.restore();\n  }\n  ctx.resetTransform();\n};\n\n/**\n * Draw vertical axis\n * @param series\n * @param height\n * @param drawing\n */\nconst drawYSeriesScale = (\n  series: Series,\n  plotSize: Rect,\n  drawing: DrawingOpts\n) => {\n  const { ctx, y, digitsPrecision, margin } = drawing;\n  const { height } = plotSize;\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `purple`;\n    ctx.strokeRect(0, 0, y.textSize, height + margin);\n  }\n\n  ctx.fillStyle = series.colour.length > 0 ? series.colour : `white`;\n\n  // Override colour with axis-defined colour\n  if (y.colour) ctx.fillStyle = y.colour;\n\n  // Draw labels\n  const min = y.labelRange ? y.labelRange[ 0 ] : series.min;\n  const max = y.labelRange ? y.labelRange[ 1 ] : series.max;\n  const range = y.labelRange ? max - min : series.range;\n  const mid = min + range / 2;\n  const halfHeight = drawing.textHeight / 2;\n\n  ctx.textBaseline = `top`;\n  ctx.fillText(\n    min.toFixed(digitsPrecision),\n    0,\n    calcYForValue(min, series, height) - halfHeight\n  );\n  ctx.fillText(\n    mid.toFixed(digitsPrecision),\n    0,\n    calcYForValue(mid, series, height) - halfHeight\n  );\n  ctx.fillText(\n    max.toFixed(digitsPrecision),\n    0,\n    calcYForValue(max, series, height) - margin\n  );\n\n  ctx.translate(y.textSize + margin, 0);\n};\n\nconst drawYLine = (plotSize: Rect, series: Series, drawing: DrawingOpts) => {\n  if (series === undefined) throw new Error(`series undefined`);\n  const { ctx, y } = drawing;\n  const { height } = plotSize;\n\n  const min = y.labelRange ? y.labelRange[ 0 ] : series.min;\n  const max = y.labelRange ? y.labelRange[ 1 ] : series.max;\n\n  const minPos = calcYForValue(min, series, height);\n  const maxPos = calcYForValue(max, series, height);\n\n  // Draw line\n  ctx.translate(y.lineWidth, 0);\n  ctx.lineWidth = y.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(0, minPos);\n  ctx.lineTo(0, maxPos);\n  ctx.strokeStyle = series.colour;\n  if (y.colour) ctx.strokeStyle = y.colour;\n  ctx.stroke();\n  ctx.translate(y.lineWidth, 0);\n};\n\nconst drawLegend = (\n  series: Array<Series>,\n  drawing: DrawingOpts,\n  size: { width: number; height: number }\n) => {\n  const { ctx } = drawing;\n  const lineSampleWidth = 10;\n\n  let x = 0;\n  const lineY = drawing.margin * 3;\n  const textY = drawing.margin;\n\n  ctx.lineWidth = drawing.lineWidth;\n\n  for (const s of series) {\n    ctx.moveTo(x, lineY);\n    ctx.strokeStyle = s.colour;\n    ctx.lineTo(x + lineSampleWidth, lineY);\n    ctx.stroke();\n    x += lineSampleWidth + drawing.margin;\n\n    let label = s.name;\n    if (s.lastValue)\n      label += ` ` + s.lastValue.toFixed(drawing.digitsPrecision);\n    const labelSize = ctx.measureText(label);\n\n    ctx.fillStyle = s.colour;\n    ctx.fillText(label, x, textY);\n    x += labelSize.width;\n  }\n};\n\nconst drawXAxis = (width: number, yPos: number, drawing: DrawingOpts) => {\n  const { ctx, x, y } = drawing;\n\n  if (!x.showLine) return;\n\n  if (x.colour) ctx.strokeStyle = x.colour;\n  ctx.lineWidth = x.lineWidth;\n  ctx.beginPath();\n\n  // Assumes ctx is translated after drawing Y axis\n  ctx.moveTo(0, yPos);\n  ctx.lineTo(width, yPos);\n  ctx.stroke();\n};\n\n/**\n * Draw series data\n * @param series\n * @param values\n * @param plotSize\n * @param drawing\n */\nconst drawSeriesData = (\n  series: Series,\n  values: ArrayLike<number>,\n  plotSize: Rect,\n  drawing: DrawingOpts,\n  leadingEdgeIndex: number\n) => {\n  const { ctx, lineWidth, translucentPlot = false, margin, x: xAxis } = drawing;\n  const style = drawing.style ?? `connected`;\n  const height = plotSize.height - margin;\n\n  let dataXScale = 1;\n  if (xAxis.scaleRange) {\n    const xAxisRange = xAxis.scaleRange[ 1 ] - xAxis.scaleRange[ 0 ];\n    dataXScale = plotSize.width / xAxisRange;\n  } else {\n    dataXScale = drawing.capacity === 0 ? plotSize.width / values.length : plotSize.width / drawing.capacity;\n  }\n\n  // Step through data faster if per-pixel density is above one\n  const incrementBy = drawing.coalesce\n    ? (dataXScale < 0\n      ? Math.floor(1 / dataXScale)\n      : 1)\n    : 1;\n\n  let x = 0;\n  let leadingEdge: Point | undefined;\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `green`;\n    ctx.strokeRect(0, 0, plotSize.width, plotSize.height);\n  }\n\n  const colourTransform = (c: string) => {\n    if (translucentPlot) return Colour.opacity(c, 0.2);\n    return c;\n  };\n\n  if (style === `dots`) {\n    ctx.fillStyle = colourTransform(series.colour);\n  } else if (style === `none`) {} else {\n    ctx.beginPath();\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = colourTransform(series.colour);\n  }\n\n  for (let index = 0; index < values.length; index += incrementBy) {\n    const y = calcYForValue(values[ index ], series, height) - 1;\n\n    if (style === `dots`) {\n      ctx.beginPath();\n      ctx.arc(x, y, lineWidth, 0, piPi);\n      ctx.fill();\n    } else if (style === `none`) {} else {\n      if (index == 0) ctx.moveTo(x, y);\n      ctx.lineTo(x, y);\n    }\n\n    if (index === leadingEdgeIndex) {\n      leadingEdge = { x, y };\n      series.lastValue = values[ index ];\n    }\n    x += dataXScale;\n  }\n\n  if (style === `connected`) {\n    ctx.stroke();\n  }\n\n  // Draw a circle at latest data point\n  if (leadingEdge !== undefined && drawing.leadingEdgeDot) {\n    ctx.beginPath();\n    ctx.fillStyle = colourTransform(series.colour); // drawing.palette.getOrAdd(`series${series.name}`));\n    ctx.arc(leadingEdge.x, leadingEdge.y, 3, 0, 2 * Math.PI);\n    ctx.fill();\n  }\n};\n\nconst calcYForValue = (v: number, series: Series, height: number) =>\n  (1 - (v - series.min) / series.range) * height;\n\n/**\n * Calculates lost area, given a margin value, axis settings.\n * @param margin\n * @param x\n * @param y\n * @param showLegend\n * @returns\n */\nconst calcSizing = (margin: number, x: Axis, y: Axis, showLegend: boolean) => {\n  let fromLeft = margin;\n  if (y.showLabels) fromLeft += y.textSize;\n  if (y.showLine) fromLeft += y.lineWidth;\n  if (y.showLabels || y.showLine) fromLeft += margin + margin;\n  const fromRight = margin;\n\n  const fromTop = margin + margin;\n  let fromBottom = margin + margin;\n  fromBottom += x.showLabels ? x.textSize : margin;\n  if (x.showLine) fromBottom += x.lineWidth;\n  if (x.showLabels || x.showLine) fromBottom += margin;\n\n  if (showLegend) fromBottom += x.textSize;\n\n  return {\n    left: fromLeft,\n    right: fromRight,\n    top: fromTop,\n    bottom: fromBottom,\n  };\n};\n\nconst plotSizeFromBounds = (\n  bounds: Rect,\n  opts: { margin: number; y: Axis; x: Axis; showLegend: boolean }\n): Rect => {\n  const { width, height } = bounds;\n  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);\n  return {\n    width: width - sizing.left - sizing.right,\n    height: height - sizing.top - sizing.bottom,\n  };\n};\n\nconst canvasSizeFromPlot = (\n  plot: Rect,\n  opts: { margin: number; y: Axis; x: Axis; showLegend: boolean }\n): Rect => {\n  const { width, height } = plot;\n  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);\n  return {\n    width: width + sizing.left + sizing.right,\n    height: height + sizing.top + sizing.bottom,\n  };\n};\n\n/**\n * Creates a simple horizontal data plot within a DIV.\n *\n * ```\n * const p = plot(`#parentDiv`);\n * p.add(10);\n * p.clear();\n *\n * // Plot data using series\n * p.add(-1, `temp`);\n * p.add(0.4, `humidty`);\n * ```\n *\n * Options can be specified to customise plot\n * ```\n * const p = plot(`#parentDiv`, {\n *  capacity: 100,     // How many data points to store (default: 10)\n *  showYAxis: false,  // Toggle whether y axis is shown (default: true)\n *  lineWidth: 2,      // Width of plot line (default: 2)\n *  yAxes:  [`temp`],  // Only show these y axes (by default all are shown)\n *  coalesce: true,    // If true, sub-pixel data points are skipped, improving performance for dense plots at the expense of plot precision\n * });\n * ```\n *\n * For all `capacity` values other than `0`, a circular array is used to track data. Otherwise an array is used that will\n * grow infinitely.\n *\n * By default, will attempt to use CSS variable `--series[seriesName]` for axis colours.\n *  `--series[name]-axis` for titles. Eg `--seriesX`. For data added without a named series,\n * it will use `--series` and `--series-axis`.\n * @param parentElOrQuery\n * @param opts\n * @return Plotter instance\n */\nexport const plot = (\n  parentElementOrQuery: string | HTMLElement,\n  opts: PlotOpts\n): Plotter => {\n  if (parentElementOrQuery === null)\n    throw new Error(`parentElOrQuery is null. Expected string or element`);\n\n  const parentEl = resolveEl(parentElementOrQuery);\n  let canvasEl: HTMLCanvasElement;\n  let destroyCanvasEl = true;\n  let plotSize: Rect | undefined = opts.plotSize;\n  let canvasSize: Rect;\n  if (parentEl.nodeName === `CANVAS`) {\n    // Use provided canvas\n    canvasEl = parentEl as HTMLCanvasElement;\n    destroyCanvasEl = false;\n    canvasSize = { width: canvasEl.width, height: canvasEl.height };\n  } else {\n    // Create a CANVAS that fills parent\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    parentEl.append(canvasEl);\n    plotSize = opts.plotSize;\n    canvasSize = { width: canvasEl.width, height: canvasEl.height };\n  }\n\n  const pointer = { x: 0, y: 0 };\n\n  const onPointerMove = (event: PointerEvent) => {\n    pointer.x = event.offsetX;\n    pointer.y = event.offsetY;\n  };\n\n  canvasEl.addEventListener(`pointermove`, onPointerMove);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const ctx = canvasEl.getContext(`2d`)!;\n\n  const capacity = opts.capacity ?? 10;\n  const buffer =\n    capacity > 0\n      ? ofCircularMutable<number>({ capacity })\n      : ofArrayMutable<number>();\n  const metrics = ctx.measureText(`Xy`);\n  const coalesce = opts.coalesce ?? true;\n\n  // Sanity-check\n  if (ctx === null) throw new Error(`Drawing context not available`);\n\n  let xAxis = defaultAxis(`x`);\n  if (opts.x) xAxis = { ...xAxis, ...opts.x };\n  let yAxis = defaultAxis(`y`);\n  if (opts.y) yAxis = { ...yAxis, ...opts.y };\n\n  let drawingOpts: DrawingOpts = {\n    ...opts,\n    y: yAxis,\n    x: xAxis,\n    pointer: pointer,\n    capacity,\n    coalesce,\n    plotSize,\n    canvasSize,\n    ctx,\n    textHeight:\n      opts.textHeight ??\n      metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\n    style: opts.style ?? `connected`,\n    defaultSeriesColour: opts.defaultSeriesColour ?? `yellow`,\n    margin: 3,\n    clearCanvas: true,\n    leadingEdgeDot: true,\n    debug: opts.debug ?? false,\n    digitsPrecision: opts.digitsPrecision ?? 2,\n    lineWidth: opts.lineWidth ?? 2,\n    showLegend: opts.showLegend ?? false,\n  };\n\n  if (plotSize) {\n    // Size canvas based on given plot size\n    const canvasSize = canvasSizeFromPlot(plotSize, drawingOpts);\n    canvasEl.width = canvasSize.width;\n    canvasEl.height = canvasSize.height;\n\n    drawingOpts.canvasSize = canvasSize;\n  }\n\n  if (opts.autoSizeCanvas) {\n    parentSizeCanvas(canvasEl, (args) => {\n      const bounds = args.bounds;\n      drawingOpts = {\n        ...drawingOpts,\n        plotSize: plotSizeFromBounds(bounds, drawingOpts),\n        canvasSize: bounds,\n      };\n      draw(buffer, drawingOpts);\n    });\n  }\n\n  return {\n    drawValue: (index: number) => {\n      drawValue(index, buffer, drawingOpts);\n    },\n    dispose: () => {\n      canvasEl.removeEventListener(`pointermove`, onPointerMove);\n      if (destroyCanvasEl) canvasEl.remove();\n    },\n    add: (value: number, series = ``, skipDrawing = false) => {\n      add(buffer, value, series);\n      if (skipDrawing) return;\n      draw(buffer, drawingOpts);\n    },\n    draw: () => {\n      draw(buffer, drawingOpts);\n    },\n    clear: () => {\n      buffer.clear();\n    },\n  };\n};\n"],"mappings":"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","names":["draw","arc","ellipse","corners","rect","line","clamp","getContext","plot","v","paths","create","clamp","scale","clamp","scale","ctx","width","height","clamp","plot","canvasSize"]}