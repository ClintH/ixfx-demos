{"version":3,"sources":["../src/generators/index.ts","../src/Text.ts","../src/modulation/PingPong.ts","../src/generators/chain/index.ts","../src/collections/index.ts","../src/collections/CircularArray.ts","../src/collections/tree/index.ts","../src/collections/tree/TraverseObject.ts","../src/collections/tree/TreeMutable.ts","../src/collections/stack/StackFns.ts","../src/collections/stack/StackMutable.ts","../src/collections/tree/Compare.ts","../src/collections/tree/Pathed.ts","../src/collections/tree/TraversableTree.ts","../src/collections/stack/index.ts","../src/collections/stack/StackImmutable.ts","../src/collections/Map/index.ts","../src/collections/Map/ExpiringMap.ts","../src/collections/Map/MapImmutableFns.ts","../src/collections/Map/Map.ts","../src/collections/Map/MapMutable.ts","../src/collections/Map/MapOfMultiImpl.ts","../src/collections/Map/MapOfSetMutable.ts","../src/collections/Map/MapOfCircularMutable.ts","../src/collections/Map/NumberMap.ts","../src/collections/Map/MapOfArrayMutable.ts","../src/generators/Iterable.ts","../src/generators/chain/Util.ts","../src/generators/chain/Links.ts","../src/generators/chain/Dom.ts"],"sourcesContent":["import { afterMatch } from '../Text.js';\nimport { throwIntegerTest, throwNumberTest } from '../Guards.js';\nexport { pingPong, pingPongPercent } from '../modulation/PingPong.js';\nexport * as Async from './IterableAsync.js';\nexport * as Sync from './IterableSync.js';\nexport * as Chain from './chain/index.js';\n\nexport { interval } from '../flow/Interval.js';\nexport { delayLoop, type DelayOpts } from '../flow/Delay.js';\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsFromEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFromEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using\n * {@link Flow.repeat}.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/generators.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport const count = function* (amount: number, offset = 0) {\n  // Unit tested.\n  throwIntegerTest(amount, ``, `amount`);\n  throwIntegerTest(offset, ``, `offset`);\n\n  if (amount === 0) return;\n\n  let index = 0;\n  do {\n    yield (amount < 0 ? -index + offset : index + offset);\n  } while (index++ < Math.abs(amount) - 1);\n};\n\n/**\n * Returns a number range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};\n\nexport { integerUniqueGen as randomUniqueInteger } from '../random/index.js';","import { integerTest, throwFromResult } from './Guards.js';\nexport { string as random } from './random/String.js';\nexport { stringSegmentsFromEnd as segmentsFromEnd } from './generators/index.js'\n\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n * \n * If `source` is under `maxLength` the original is returned.\n * @param source \n * @param maxLength Maximum length. Defaults to 20\n * @returns \n */\nexport const abbreviate = (source: string, maxLength = 15) => {\n  // ✔️ Unit tested\n  throwFromResult(integerTest(maxLength, `aboveZero`, `maxLength`));\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n\n  if (source.length > maxLength && source.length > 3) {\n    if (maxLength > 15) {\n      const chunk = Math.round((maxLength - 2) / 2);\n      return source.slice(0, chunk) + `...` + source.slice(-chunk);\n    }\n    return source.slice(0, maxLength) + `...`;\n  }\n  return source;\n}\n\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns \n */\nexport const toStringAbbreviate = (source: any, maxLength = 20) => {\n  if (source === undefined) return `(undefined)`;\n  if (source === null) return `(null)`;\n  return abbreviate(JSON.stringify(source), maxLength);\n}\n\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): string | undefined => {\n  // ✔ Unit tested\n\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return;\n\n  return source.slice(startPos + 1, endPos);\n};\n\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): [ source: string, between: string | undefined ] => {\n  // ✔ Unit tested\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);\n  if (end !== undefined && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return [ source, undefined ];\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return [ source, undefined ];\n\n  const between = source.slice(startPos + 1, endPos);\n  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n  return [ sourceResult, between ];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (\n  source: string,\n  code: number,\n  start = 0,\n  end = source.length - 1\n): number => {\n  //eslint-disable-next-line functional/no-let\n  for (let index = start; index <= end; index++) {\n    if (source.codePointAt(index) === code) return index;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (\n  source: string,\n  removeStart: number,\n  removeLength: number\n) =>\n  source.slice(0, removeStart) +\n  source.slice(removeStart + removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (\n  source: string | null,\n  length: number\n): ReadonlyArray<string> => {\n  throwFromResult(integerTest(length, `aboveZero`, `length`));\n  if (source === null) throw new Error(`source parameter null`);\n  if (typeof source !== `string`) {\n    throw new TypeError(`source parameter not a string`);\n  }\n\n  // ✔ Unit tested\n  const chunks = Math.ceil(source.length / length);\n  const returnValue: Array<string> = [];\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n\n  //eslint-disable-next-line functional/no-let\n  for (let c = 0; c < chunks; c++) {\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push(source.slice(start, start + length));\n    start += length;\n  }\n  return returnValue;\n};\n\nexport type UntilMatchOptions = MatchOptions & {\n  ifNoMatch: `throw` | `original` | `fallback`,\n  fallback?: string\n}\n\n/**\n * Returns the `source` string up until (and excluding) `match`. \n * \n * By default, if match is not found, all of `source` is returned.\n *\n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * \n * If match is not found, fallback can be returned instead:\n * ```js\n * // Yields 'lemon'\n * untilMatch(`apple orange mellon`, `kiwi`, { fallback: `lemon` });\n * ```\n * \n * Or an exception thrown\n * ```js\n * // Throws\n * untilMatch(`apple orange mellon`, `kiwi`, { ifNoMatch: `throw` });\n * ```\n * @param source\n * @param match\n * @param startPos If provided, gives the starting offset. Default 0\n */\nexport const untilMatch = (\n  source: string,\n  match: string,\n  options: Partial<UntilMatchOptions> = {}\n): string => {\n  //  ✔️ Unit tested\n  let fallback = options.fallback;\n  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n  if (ifNoMatch === `original`) fallback = source;\n  if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0) {\n    if (ifNoMatch === `throw`) throw new Error(`Match string not found in source`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return fallback!;\n  }\n  return source.slice(startPos ?? 0, m);\n};\n\n\n\nexport type MatchOptions = {\n  readonly startPos?: number;\n  readonly fromEnd?: boolean;\n}\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param startPos\n * @returns\n */\nexport const afterMatch = (\n  source: string,\n  match: string,\n  options: MatchOptions = {}\n): string => {\n  if (source === undefined) throw new Error(`source is undefined`);\n\n  //  ✔️ Unit tested\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0) return source;\n  return source.slice(Math.max(0, m + match.length));\n};\n\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (\n  source: string,\n  ...wrappers: ReadonlyArray<string>\n): string => {\n  //eslint-disable-next-line functional/no-let\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.slice(w.length, source.length - w.length * 2 + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string;\n  /**\n   * Start position, with respect to source text\n   */\n  readonly start: number;\n  /**\n   * End position, with respect to source text\n   */\n  readonly end: number;\n  /**\n   * Index of range. First range is 0\n   */\n  readonly index: number;\n}\n\nexport type LineSpan = {\n  readonly start: number;\n  readonly end: number;\n  readonly length: number;\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (\n  ranges: ReadonlyArray<Range>,\n  start: number,\n  end: number\n): LineSpan => {\n  //eslint-disable-next-line functional/no-let\n  let s = -1;\n  //eslint-disable-next-line functional/no-let\n  let endPos = -1;\n  //eslint-disable-next-line functional/no-let\n  for (const [ index, r ] of ranges.entries()) {\n    s = index;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = s; index < ranges.length; index++) {\n    const r = ranges[ index ];\n    endPos = index;\n    if (end === r.end) {\n      endPos = index + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return { length: endPos - s, start: s, end: endPos };\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (\n  source: string,\n  split: string\n): ReadonlyArray<Range> => {\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n  //eslint-disable-next-line functional/no-let\n  let text = ``;\n  const ranges: Array<Range> = [];\n  //eslint-disable-next-line functional/no-let\n  let index = 0;\n  //eslint-disable-next-line functional/no-let,unicorn/prevent-abbreviations\n  for (let i = 0; i < source.length; i++) {\n    if (source.indexOf(split, i) === i) {\n      //eslint-disable-next-line functional/no-let\n      const end = i;\n      //eslint-disable-next-line functional/immutable-data\n      ranges.push({\n        text,\n        start,\n        end,\n        index,\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(i);\n    }\n  }\n  if (start < source.length) {\n    //eslint-disable-next-line functional/immutable-data\n    ranges.push({ text, start, index, end: source.length });\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (\n  source: string,\n  ...chars: ReadonlyArray<string>\n): number => {\n  //eslint-disable-next-line functional/no-let\n  let counted = 0;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < source.length; index++) {\n    if (chars.includes(source.charAt(index))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (\n  source: string,\n  start: string,\n  end: string = start\n): boolean => source.startsWith(start) && source.endsWith(end);\n\n//eslint-disable-next-line no-useless-escape\nexport const htmlEntities = (source: string): string =>\n  source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${ index.codePointAt(0) };`);\n","import { throwNumberTest } from '../Guards.js';\n\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (\n  interval: number = 0.1,\n  lower?: number,\n  upper?: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) lower = 0;\n  if (upper === undefined) upper = 1;\n  if (start === undefined) start = lower;\n\n  throwNumberTest(interval, `bipolar`, `interval`);\n  throwNumberTest(upper, `bipolar`, `end`);\n  throwNumberTest(start, `bipolar`, `offset`);\n  throwNumberTest(lower, `bipolar`, `start`);\n  return pingPong(interval, lower, upper, start, rounding);\n};\n\n/**\n * Ping-pongs continually back and forth `start` and `end` with a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (\n  interval: number,\n  lower: number,\n  upper: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\n  if (interval === undefined) {\n    throw new Error(`Parameter 'interval' is undefined`);\n  }\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\n\n  if (rounding === undefined && interval <= 1 && interval >= 0) {\n    rounding = 10 / interval;\n  } else if (rounding === undefined) rounding = 1234;\n\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\n\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\n  const distance = upper - lower;\n  if (Math.abs(interval) >= distance) {\n    throw new Error(`Interval should be between -${ distance } and ${ distance }`);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let incrementing = interval > 0;\n\n  // Scale up values by rounding factor\n  upper = Math.floor(upper * rounding);\n  lower = Math.floor(lower * rounding);\n  interval = Math.floor(Math.abs(interval * rounding));\n\n  if (interval === 0) {\n    throw new Error(`Interval is zero (rounding: ${ rounding })`);\n  }\n  if (start === undefined) start = lower;\n  else start = Math.floor(start * rounding);\n  if (start > upper || start < lower) {\n    throw new Error(\n      `Start (${ start / rounding }) must be within lower (${ lower / rounding\n      }) and upper (${ upper / rounding })`\n    );\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let v = start;\n  yield v / rounding;\n  //eslint-disable-next-line functional/no-let\n  let firstLoop = true;\n  while (true) {\n    v = v + (incrementing ? interval : -interval);\n    if (incrementing && v >= upper) {\n      incrementing = false;\n      v = upper;\n      if (v === upper && firstLoop) {\n        // Edge case where we start at upper bound and increment\n        v = lower;\n        incrementing = true;\n      }\n    } else if (!incrementing && v <= lower) {\n      incrementing = true;\n      v = lower;\n      if (v === lower && firstLoop) {\n        // Edge case where we start at lower bound and decrement\n        v = upper;\n        incrementing = false;\n      }\n    }\n    yield v / rounding;\n    firstLoop = false;\n  }\n};\n","/* eslint-disable @typescript-eslint/require-await */\n/* eslint-disable unicorn/prefer-ternary */\nimport { Async } from \"../index.js\";\nimport { Elapsed } from \"../../flow/index.js\";\nimport { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { Queues } from \"../../collections/index.js\";\nimport { resolveToAsyncGen, resolveToGen } from \"./Util.js\";\nimport type { Link, GenFactoryNoInput, LazyChain, GenOrData, LinksWithSource, Gen, TickOptions, DelayOptions, RankArrayOptions, RankFunction, RankOptions } from \"./Types.js\";\nimport * as L from './Links.js';\nexport * as Dom from './Dom.js';\nexport * as Links from './Links.js';\n\nfunction isNoInput<Out>(c: Link<any, any>): c is GenFactoryNoInput<Out> {\n  if (`_allowNoInput` in c) return true;\n  return false;\n}\n\nexport function lazy<In, Out>(): LazyChain<In, Out> {\n  const chained: Array<Link<any, any>> = [];\n  let dataToUse: GenOrData<In> | undefined;\n\n  const asGenerator = <V>(data?: GenOrData<In>) => {\n    if (data === undefined) data = dataToUse;\n    let d = resolveToAsyncGen(data);\n    for (const c of chained) {\n      if (d === undefined) {\n        if (isNoInput<In>(c)) {\n          d = c();\n        } else {\n          throw new Error(`Function '${ getLinkName(c) }' requires input. Provide it to the function, or call 'input' earlier.`)\n        }\n      } else {\n        d = c(d);\n      }\n    }\n    return d as AsyncGenerator<V>\n  }\n\n  const w: LazyChain<In, Out> = {\n    rankArray: (r: RankFunction<In>, options: Partial<RankArrayOptions>): LazyChain<In, Out> => {\n      chained.push(L.rankArray(r, options));\n      return w;\n    },\n    rank: (r: RankFunction<In>, options: Partial<RankOptions>): LazyChain<In, Out> => {\n      chained.push(L.rank(r, options));\n      return w;\n    },\n    transform: (transformer: (v: any) => any) => {\n      chained.push(L.transform(transformer));\n      return w;\n    },\n    flatten: (flattener: (values: Array<any>) => any) => {\n      chained.push(L.flatten(flattener));\n      return w;\n    },\n    drop: (predicate: (v: In) => boolean) => {\n      chained.push(L.drop(predicate));\n      return w;\n    },\n    delay: (options: DelayOptions) => {\n      chained.push(L.delay(options));\n      return w;\n    },\n    duration: (elapsed: Interval) => {\n      chained.push(L.duration(elapsed));\n      return w;\n    },\n    debounce: (rate: Interval) => {\n      chained.push(L.debounce(rate));\n      return w;\n    },\n    fromFunction: (callback: () => any) => {\n      chained.push(fromFunction(callback));\n      return w;\n    },\n    take: (limit: number) => {\n      chained.push(L.take(limit));\n      return w;\n    },\n    chunk: (size: number, returnRemainders = true) => {\n      chained.push(L.chunk(size, returnRemainders))\n      return w;\n    },\n    filter: (predicate: (input: any) => boolean) => {\n      chained.push(L.filter(v => predicate(v)));\n      return w;\n    },\n    min: (): LazyChain<any, number> => {\n      chained.push(L.min());\n      return w as unknown as LazyChain<any, number>;\n    },\n    max: (): LazyChain<any, number> => {\n      chained.push(L.max());\n      return w as unknown as LazyChain<any, number>;\n    },\n    average: (): LazyChain<any, number> => {\n      chained.push(L.average());\n      return w as unknown as LazyChain<any, number>;\n    },\n    total: (): LazyChain<any, number> => {\n      chained.push(L.total());\n      return w as unknown as LazyChain<any, number>;\n    },\n    tally: (): LazyChain<any, number> => {\n      chained.push(L.tally());\n      return w as unknown as LazyChain<any, number>;\n    },\n    input(data: GenOrData<In>) {\n      dataToUse = data;\n      return w\n    },\n    asGenerator,\n    asAsync(data?: GenOrData<In>) {\n      let d = data ?? dataToUse;\n      for (const c of chained) {\n        if (d === undefined && isNoInput<In>(c)) {\n          d = c();\n        } else if (d === undefined) {\n          throw new Error(`Function '${ getLinkName(c) }' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n        } else {\n          d = c(d);\n        }\n      }\n      return w;\n    },\n    asArray: async (data?: GenOrData<In>): Promise<Array<Out>> => {\n      const g = asGenerator<Out>(data);\n      return await Async.toArray<Out>(g);\n    },\n    firstOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      const v = await g.next();\n      return v.value as Out;\n    },\n    lastOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      let lastValue: Out | undefined;\n      for await (const v of g) {\n        lastValue = v as Out;\n      }\n      return lastValue;\n    },\n  }\n  return w as unknown as LazyChain<In, Out>;\n}\n\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever. \n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n * \n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options \n * @returns \n */\nexport function tick(options: TickOptions): GenFactoryNoInput<number> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const asClockTime = options.asClockTime ?? false;\n  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n  let looped = 0;\n  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n\n  async function* ts(): AsyncGenerator<number> {\n    const elapsed = Elapsed.since();\n    while (looped < loops && elapsed() < durationTime) {\n      yield asClockTime ? Date.now() : elapsed();\n\n      // Adjust sleep period so timing errors don't accumulate\n      const expectedTimeDiff = (looped * intervalMs) - elapsed();\n      await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n      looped++;\n    }\n  }\n  ts._name = `timestamp`;\n  return ts;\n}\n\n/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n * \n * ```js\n * const callback = () => Math.random();\n * \n * const f = Chains.fromFunction(callback);\n * f(); // New random number\n * ```\n * \n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.fromFunction(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback \n * @returns \n */\nexport function fromFunction<Out>(callback: () => Promise<Out> | Out): GenFactoryNoInput<Out> {\n  async function* fromFunction(): AsyncGenerator<Out> {\n    while (true) {\n      const v = await callback();\n      if (v === undefined) break;\n      yield v;\n    }\n  }\n  fromFunction._name = `fromFunction`;\n  return fromFunction;\n}\n\nconst oncePromise = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};\n\nexport function fromEvent<Out>(target: EventTarget, name: string) {\n  async function* fromEvent(): AsyncGenerator<Out> {\n    while (true) {\n      yield await oncePromise(target, name) as Out;\n    }\n  }\n  fromEvent._name = `fromEvent`;\n  return fromEvent;\n}\n\n/**\n * Treats the chain/generator as a promise\n * \n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n * \n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap \n * @returns \n */\nexport function asPromise<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>) {\n  let lastValue: V | undefined;\n\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  async function asPromise(): Promise<V | undefined> {\n    const v = await outputType.next();\n    if (v.done) return;\n    lastValue = v.value;\n    return lastValue;\n  }\n  return asPromise;\n}\n\n/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n * \n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n * \n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n * \n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns \n */\nexport function asValue<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>, initialValue?: V) {\n  let lastValue: V | undefined = initialValue;\n  let awaiting = false;\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  function asValue(): V | undefined {\n    if (!awaiting) {\n      awaiting = true;\n      outputType.next().then(v => {\n        lastValue = v.value;\n        awaiting = false;\n      }).catch(error => {\n        awaiting = false;\n        throw error;\n      });\n    }\n    return lastValue;\n  }\n  return asValue;\n}\n\n/**\n * Calls `callback` whenever the chain/generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap \n * @param callback \n */\nexport async function asCallback<V>(valueToWrap: GenOrData<V> | GenFactoryNoInput<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\n\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n * @param valueToWrap \n * @returns \n */\nexport async function asArray<Out>(valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>): Promise<Array<Out>> {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  return Async.toArray(outputType);\n}\n\n/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n * \n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap \n * @param array \n */\nexport async function addToArray<Out>(array: Array<Out>, valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    array.push(value);\n  }\n}\n\n/**\n * Input a single value to the chain, return a single result\n * @param f \n * @param input \n * @returns \n */\nexport async function single<In, Out>(f: Link<In, Out>, input: In): Promise<Out | undefined> {\n  const iterator = await f([ input ]).next();\n  return iterator.value as Out | undefined;\n}\n\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n * \n * Alternatively:\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link synchronise} which releases a set of results when all inputs have emitted a value\n * @param sources \n */\nexport async function* mergeFlat<Out>(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Out> {\n  const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n  const buffer = Queues.mutable<Out>();\n  let completed = 0;\n\n  const schedule = async (source: AsyncGenerator<any> | undefined) => {\n    if (source === undefined) {\n      completed++;\n      return;\n    }\n\n    const x = await source.next();\n    if (x.done) {\n      completed++;\n    } else {\n      buffer.enqueue(x.value as Out);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(() => schedule(source), 1);\n    }\n  }\n\n  for (const source of sourcesInput) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(() => schedule(source), 1);\n  }\n\n  const loopSpeed = 10;\n  let loopFactor = 1;\n  while (completed < sourcesInput.length) {\n    const d = buffer.dequeue();\n    if (d === undefined) {\n      // Grow loop factor up to 10\n      loopFactor = Math.min(loopFactor + 1, 10);\n    } else {\n      yield d;\n      // Reset loop factor\n      loopFactor = 1;\n    }\n    await sleep(loopSpeed * loopFactor);\n  }\n}\n\n/**\n * Generate values for each source, returning results as an array.  \n * If a source finishes before another, null will be used at its position in the results.\n * Use {@link synchronise} instead to only release results when all sources have yielded a value.\n * \n * Finishes when all generators finish.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link synchronise} only return results when all sourcse have yielded a value\n * @param sources \n */\nexport async function* mergeAsArray(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingProduced = true;\n  while (somethingProduced) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingProduced = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (!v.done) {\n        data[ index ] = v.value;\n        somethingProduced = true;\n      }\n    }\n    if (somethingProduced) {\n      // Send data\n      yield data;\n      data = [];\n    }\n  }\n}\n\n/**\n * Synchronise several sources, releasing a set of results when every\n * source has produced something. Finishes as soon as _any_ source finishes.\n * \n * ie. the rate of emitting data is determined by the slowest source.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * @param sources \n */\nexport async function* synchronise(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingStopped = false;\n  while (!somethingStopped) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingStopped = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (v.done) {\n        somethingStopped = true;\n        break;\n      } else {\n        data[ index ] = v.value;\n      }\n    }\n\n    if (somethingStopped) break;\n    yield data;\n    data = [];\n  }\n}\n\nconst getLinkName = (c: Link<any, any>): string => {\n  if (`_name` in c) {\n    return c._name as string;\n  } else {\n    return c.name;\n  }\n}\n\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param functions \n * @returns \n */\nexport async function* runN<In, Out>(...functions: LinksWithSource<In, Out>): AsyncGenerator<Out> {\n  let input: Gen<In> | undefined;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v as Out;\n  }\n}\n\nexport function run<T1>(gen: GenOrData<T1> | GenFactoryNoInput<T1>): AsyncGenerator<T1>;\nexport function run<T1, T2>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>): AsyncGenerator<T2>;\nexport function run<T1, T2, T3>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>): AsyncGenerator<T3>;\nexport function run<T1, T2, T3, T4>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>): AsyncGenerator<T4>;\nexport function run<T1, T2, T3, T4, T5>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>): AsyncGenerator<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>): AsyncGenerator<T6>;\nexport function run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>, l5: Link<T6, T7>): AsyncGenerator<T7>;\n\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param gen \n * @param l0 \n * @param l1 \n * @param l2 \n * @param l3 \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0?: Link<T1, T2>, l1?: Link<T2, T3>, l2?: Link<T3, T4>, l3?: Link<T4, T5>, l4?: Link<T5, T6>, l5?: Link<T6, T7>): AsyncGenerator<T1> {\n  let input: Gen<any> | undefined;\n  // eslint-disable-next-line prefer-rest-params\n  const functions = arguments;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v;\n  }\n}\n\n\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\n// export function prepare<In, Out>(...functions: Links<In, Out>) {\n//   const r = (source: GenOrData<In> | GenFactoryNoInput<Out>) => {\n//     return run(source);\n//   }\n//   return r;\n// }\n","export type ArrayKeys<K, V> = ReadonlyArray<readonly [ key: K, value: V ]>;\nexport type ObjectKeys<K, V> = ReadonlyArray<{\n  readonly key: K;\n  readonly value: V;\n}>;\nexport type EitherKey<K, V> = ArrayKeys<K, V> | ObjectKeys<K, V>;\n\nexport {\n  circularArray,\n  type ICircularArray as CircularArray,\n} from './CircularArray.js';\nexport * as Trees from './tree/index.js';\n\nexport * as Iterables from './Iterables.js';\n\n/**\n * Stacks store items in order.\n *\n * Stacks and queues can be helpful for processing data in order. They each have slightly different behaviour.\n *\n * Like a stack of plates, the newest item (on top) is removed\n * before the oldest items (at the bottom). {@link Queues} operate differently, with\n * the oldest items (at the front of the queue) removed before the newest items (at the end of the queue).\n *\n * Create stacks with {@link Stacks.immutable} or {@link Stacks.mutable}. These return a {@link IStackImmutable} or {@link IStackMutable} respectively.\n *\n * The ixfx implementation allow you to set a capacity limit with three {@link StackDiscardPolicy |policies} for\n * how items are evicted.\n *\n */\nexport * as Stacks from './stack/index.js';\n\nexport { StackMutable } from './stack/StackMutable.js';\nexport { StackImmutable } from './stack/StackImmutable.js';\n\n/**\n * Arrays are a list of data. ixfx provides a number of functions for working with arrays in an immutable manner.\n * This means that the input array is not changed.\n *\n * Import example:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * ```\n * \n * For arrays of numbers:\n * * {@link average}, {@link max}, {@link min}, {@link total}: Calculate average/max/min/total\n * * {@link averageWeighted}: Calculate average, but applies a weighting function, eg to favour items at beginning of array\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * {@link maxIndex}, {@link minIndex}: Return index of largest/smallest value\n * * {@link dotProduct}: Returns the dot-product between two arrays\n * * {@link weight}: Applies a weighting function to all values based on their index\n *\n * Randomisation\n * * {@link randomIndex}: Return a random array index\n * * {@link randomElement}: Return a random value\n * * {@link randomPluck}: Remove a random element from an array, returning it and the new array\n * * {@link shuffle}: Returns a randomly-sorted copy of arra\n *\n * Finding/accessing\n * * {@link filterBetween}: Same as `Array.filter` but only looks within a specified index range\n * * {@link sample}: Returns a new array with a random sampling of input\n * * {@link valuesEqual}: Returns true if all the values in the array are identical\n *\n * Changing the shape\n * * {@link ensureLength}: Returns a copy of array with designated length, either padding it out or truncating as necessary\n * * {@link groupBy}: Groups data into a new Map\n * * {@link interleave}: Flattens several arrays into one, interleaving their values.\n * * {@link remove}: Remove an item by index\n * * {@link without}: Returns an array with specified value omitted\n * * {@link zip}: Groups together elements from several arrays based on their index\n */\nexport * as Arrays from './arrays/index.js';\n\n/**\n * Sets store unique items.\n *\n * ixfx's {@link ISetImmutable} (or {@link ISetMutable}) compares items by value rather than reference, unlike the default JS implementation.\n *\n * Create using {@link Sets.immutable} or {@link Sets.mutable}\n */\nexport * as Sets from './set/index.js';\n\n\nexport { SetStringMutable } from './set/SetMutable.js';\nexport { SetStringImmutable } from './set/SetImmutable.js';\n\n\n/**\n * Queues store items in the order in which they are added.\n *\n * Stacks and queues can be helpful when it's necessary to process data in order, but each one has slightly different behaviour.\n *\n * Like lining up at a bakery, the oldest items (at the front of the queue) are removed\n * before the newest items (at the end of the queue). This is different to {@link Stacks},\n * where the newest item (on top) is removed before the oldest items (at the bottom).\n *\n * The ixfx implementations allow you to set a capacity limit with three {@link QueueDiscardPolicy | policies} for\n * how items are evicted.\n *\n * Create queues with {@link Queues.immutable} or {@link Queues.mutable}. These return a {@link IQueueImmutable} or {@link IQueueMutable} respectively.\n */\nexport * as Queues from './queue/index.js';\n\nexport { QueueMutable } from './queue/QueueMutable.js';\nexport { QueueImmutable } from './queue/QueueImmutable.js';\n\n\n/**\n * Maps associate keys with values. Several helper functions are provided\n * for working with the standard JS Map class.\n *\n * Import example\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/collections.js';\n * ```\n * \n * ixfx also includes {@link Maps.IMapMutable}, {@link Maps.IMapImmutable}\n *\n * Overview:\n * * {@link getOrGenerate}: Solves a common scenario of wanting a value by a particular key, or generating it if it doesn't exist\n * * {@link filter}: Yields values in map that match a predicate\n * * {@link find}: Finds the first value that matches a predicate, or _undefined_ if nothing found\n * * {@link hasAnyValue}: Searches through all keys, returning true if any occurence of _value_ was found\n *\n * Transformations:\n * * {@link toArray}: Returns the values of the map as an array\n * * {@link mapToArray}: Applies a function to convert a map's values to an array\n * * {@link toObject}: Coverts a Map to a plain object, useful for JSON serialising.\n * * {@link mapToObjectTransform}: Converts a map to a plain object, but applying a function to values\n * * {@link transformMap}: Like `Array.map`, but for Maps. Useful for generating a map as a transform of an input map.\n * * {@link zipKeyValue}: Given an array of keys and values, combines them together into a map\n */\nexport * as Maps from './map/index.js';\n\n\n","import { throwIntegerTest } from '../Guards.js';\n\n/**\n * The circular array is immutable. It keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n * @example\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`); // Because it's immutable, capture the return result of `add`\n * a.isFull;  // True if circular array is full\n * a.pointer; // The current position in array it will write to\n * ```\n * @class CircularArray\n * @extends Array\n */\nexport interface ICircularArray<V> extends Array<V> {\n  /**\n   * Returns true if the array has filled to capacity and is now\n   * recycling array indexes.\n   */\n  get isFull(): boolean;\n\n  /**\n   * Returns a new Circular with item added\n   *\n   * Items are added at `pointer` position, which automatically cycles through available array indexes.\n   *\n   * @param v Thing to add\n   * @returns Circular with item added\n   * @memberof Circular\n   */\n  add(v: V): ICircularArray<V>;\n\n  get length(): number;\n\n  /**\n   * Returns the current add position of array.\n   */\n  get pointer(): number;\n}\n\nclass CircularArray<V> extends Array {\n  // ✔ Class is unit tested!\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  #capacity: number;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  #pointer: number;\n\n  constructor(capacity = 0) {\n    super();\n    // Allowed to create with capacity zero\n    throwIntegerTest(capacity, `positive`, `capacity`);\n\n    // Can't throw because .filter won't use ctor proprly\n    this.#capacity = capacity;\n    this.#pointer = 0;\n  }\n\n  /**\n   * Add to array\n   * @param thing Thing to add\n   * @returns \n   */\n  add(thing: V): CircularArray<V> {\n    const ca = CircularArray.from(this) as CircularArray<V>;\n    /* eslint-disable-next-line functional/immutable-data */\n    ca[ this.#pointer ] = thing;\n    /* eslint-disable-next-line functional/immutable-data */\n    ca.#capacity = this.#capacity;\n    if (this.#capacity > 0) {\n      /* eslint-disable-next-line functional/immutable-data */\n      ca.#pointer =\n        this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n    } else {\n      /* eslint-disable-next-line functional/immutable-data */\n      ca.#pointer = this.#pointer + 1;\n    }\n    return ca;\n  }\n\n  get pointer(): number {\n    return this.#pointer;\n  }\n\n  get isFull(): boolean {\n    if (this.#capacity === 0) return false;\n    return this.length === this.#capacity;\n  }\n}\n\n/**\n * Returns a new circular array. Immutable. A circular array only keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = circularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport const circularArray = <V>(capacity: number): ICircularArray<V> =>\n  new CircularArray<V>(capacity);\n","import { asDynamicTraversable as ObjectToTraversable } from './TraverseObject.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './TreeMutable.js';\nimport type { TraversableTree, TreeNode } from './Types.js';\n\nexport * as Mutable from './TreeMutable.js';\nexport * as Pathed from './Pathed.js'\nexport * as FromObject from './TraverseObject.js';\nexport * as Traverse from './TraversableTree.js';\nexport * from './Compare.js';\nexport type * from './Types.js';\n\nexport const toTraversable = <T>(node: TreeNode<T> | TraversableTree<T> | object) => {\n  if (isTraversable(node)) return node;\n  if (isTreeNode(node)) return TreeNodeToTraversable(node);\n  if (typeof node === `object`) return ObjectToTraversable(node);\n  throw new Error(`Parameter 'node' not convertible`);\n}\n\nexport const isTreeNode = (node: any): node is TreeNode<any> => {\n  if (`parent` in node && `childrenStore` in node && `value` in node) {\n    // eslint-disable-next-line unicorn/no-lonely-if\n    if (Array.isArray(node.childrenStore)) return true;\n  }\n  return false;\n}\n\nexport const isTraversable = (node: any): node is TraversableTree<any> => {\n  return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n}","import { toStringAbbreviate } from '../../Text.js';\nimport { nullUndef } from '../../Guards.js';\nimport { last } from '../../generators/IterableSync.js';\nimport * as TreeArrayBacked from './TreeMutable.js';\nimport { isPrimitive } from '../../KeyValue.js';\nimport type { TraversableTree, TreeNode, SimplifiedNode } from './Types.js';\nexport type Entry = Readonly<{ name: string, sourceValue: any, nodeValue: any }>;\nexport type EntryWithAncestors = Readonly<{ name: string, sourceValue: any, nodeValue: any, ancestors: Array<string> }>;\nexport type EntryStatic = Readonly<{ name: string, value: any, ancestors?: Array<string> }>\n\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n  /**\n   * Separator for path, eg '.'\n   */\n  readonly separator?: string;\n\n};\n\nexport function prettyPrintEntries(entries: ReadonlyArray<Entry>) {\n  if (entries.length === 0) return `(empty)`;\n  let t = ``;\n  for (const [ index, entry ] of entries.entries()) {\n    t += `  `.repeat(index);\n    t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n  }\n  return t;\n}\n\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param defaultName\n * @returns\n */\nexport const prettyPrint = (\n  node: object,\n  indent = 0,\n  options: Partial<ChildrenOptions> = {}\n): string => {\n  nullUndef(node, `node`);\n  const defaultName = options.name ?? `node`;\n  const entry = getNamedEntry(node, defaultName);\n  const t = `${ `  `.repeat(indent) } + name: ${ entry.name } value: ${ JSON.stringify(entry.nodeValue) }`;\n  const childrenAsArray = [ ...children(node, options) ];\n  return childrenAsArray.length > 0 ? (\n    t +\n    `\\n` +\n    childrenAsArray.map((d) => prettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)\n  ) : t;\n};\n\nexport const toStringDeep = (node: TreeNode<Entry | EntryStatic>, indent = 0) => {\n  let t = ` `.repeat(indent) + ` ` + node.value?.name;\n  if (node.value !== undefined) {\n    if (`sourceValue` in node.value && `nodeValue` in node.value) {\n      let sourceValue = toStringAbbreviate(node.value?.sourceValue, 20);\n      const nodeValue = toStringAbbreviate(node.value?.nodeValue, 20);\n      sourceValue = sourceValue === nodeValue ? `` : `source: ` + sourceValue;\n      t += ` = ${ nodeValue } ${ sourceValue }`\n    } else if (`value` in node.value && node.value.value !== undefined) t += ` = ${ node.value.value }`;\n\n    if (`ancestors` in node.value) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      t += ` (ancestors: ${ (node.value.ancestors!).join(`, `) })`;\n    }\n  }\n  t += `\\n`\n  for (const c of node.childrenStore) {\n    t += toStringDeep(c, indent + 1);\n  }\n  return t;\n}\n\nexport type ChildrenOptions = Readonly<{\n  filter: `none` | `leaves` | `branches`\n  name: string\n}>;\n\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays. \n * \n * Sub-children are included as an object blob.\n * \n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n * \n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n * \n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children: \n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n * \n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node \n * @param options  \n */\nexport function* children<T extends object>(\n  node: T,\n  options: Partial<ChildrenOptions> = {}\n): IterableIterator<Entry> {\n  // ✔️ Unit tested\n  nullUndef(node, `node`);\n  //let defaultName = options.name;\n\n  const filter = options.filter ?? `none`;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  //const valueFor = (v: any) => v;// options.valuesAtLeaves ? (v: any) => { if (isPrimitive(v)) return v; } : (v: any) => v;\n\n  const filterByValue = (v: any): [ filter: boolean, isPrimitive: boolean ] => {\n    if (filter === `none`) return [ true, isPrimitive(v) ];\n    else if (filter === `leaves` && isPrimitive(v)) return [ true, true ];\n    else if (filter === `branches` && !isPrimitive(v)) return [ true, false ];\n    return [ false, isPrimitive(v) ];\n  }\n\n  if (Array.isArray(node)) {\n    //if (options.name === undefined) defaultName = `array`;\n    for (const [ index, element ] of node.entries()) {\n      const f = filterByValue(element);\n      if (f[ 0 ]) {\n        yield { name: index.toString(), sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n        //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n      }\n    }\n  } else if (typeof node === `object`) {\n    const entriesIter = (`entries` in node) ? (node as any as Map<any, any>).entries() : Object.entries(node);\n    for (const [ name, value ] of entriesIter) {\n      //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n      const f = filterByValue(value);\n      if (f[ 0 ]) {\n        yield { name: name, sourceValue: value, nodeValue: f[ 1 ] ? value : undefined };\n      }\n    }\n  }\n}\n\nexport function* depthFirst<T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: Array<string> = []): IterableIterator<EntryWithAncestors> {\n  for (const c of children(node, options)) {\n    //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n    yield { ...c, ancestors: [ ...ancestors ] };\n    yield* depthFirst(c.sourceValue, options, [ ...ancestors, c.name ]);\n  }\n}\n\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName<T extends object>(\n  name: string,\n  node: T\n): Entry | undefined {\n  for (const d of children(node)) {\n    if (d.name === name) return d;\n  }\n}\n\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param opts Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath<T extends object>(\n  path: string,\n  node: T,\n  opts: PathOpts = {}\n): Entry {\n  // ✔️ Unit tested\n  const v = last(traceByPath(path, node, opts));\n  if (!v) throw new Error(`Could not trace path: ${ path } `);\n  return v;\n}\n\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n * \n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n * \n * @param path Path to traverse\n * @param node Starting node\n * @param opts Options for path traversal logic\n * @returns\n */\nexport function* traceByPath<T extends object>(\n  path: string,\n  node: T,\n  opts: PathOpts = {}\n): Iterable<EntryWithAncestors> {\n  // ✔️ Unit tested\n  nullUndef(path, `path`);\n  nullUndef(node, `node`);\n\n  const separator = opts.separator ?? `.`;\n  // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n  const pathSplit = path.split(separator);\n\n  const ancestors: Array<string> = [];\n  for (const p of pathSplit) {\n    const entry = childByName(p, node);\n    //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n    // if (allowArrayIndexes) {\n    //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n    //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n    //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n    //   if (arrayIndex >= 0) {\n    //     // Get array by name without the []\n    //     entry = childByName(withoutBrackets, node);\n    //     //onsole.log(`  entry: ${ entry?.name }`);\n    //     if (entry && Array.isArray(entry.sourceValue)) {\n    //       // Result was array as expected\n    //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], nodeValue: entry.sourceValue[ arrayIndex ] };\n    //     }\n    //   }\n    // }\n\n    if (!entry) {\n      yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n      return;\n    }\n    node = entry.sourceValue;\n    yield { ...entry, ancestors: [ ...ancestors ] };\n    ancestors.push(p);\n  }\n}\n\n/**\n * Returns a projection of `node` as a dynamic traversable.\n\n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n * \n * ```js\n  * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n * \n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n * \n * Instead .getIdentity() to get a stable identity:\n * ```js\n  * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n * @param node \n * @param defaultName \n * @param parent \n * @returns \n */\nexport const asDynamicTraversable = <T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: Array<string> = [], parent?: TraversableTree<EntryStatic> | undefined,): TraversableTree<EntryStatic> => {\n  const name = options.name ?? `object`;\n  const t: TraversableTree<EntryStatic> = {\n    *children() {\n      for (const c of children(node, options)) {\n        yield asDynamicTraversable(c.sourceValue, { ...options, name: c.name }, [ ...ancestors, name ], t);\n      }\n    },\n    getParent() {\n      return parent;\n    },\n    getValue() {\n      return { name, value: node, ancestors };\n    },\n    getIdentity() {\n      return node;\n    }\n  }\n  return t;\n}\n\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node \n * @param defaultName \n * @returns \n */\nexport const createWrapped = <T extends object>(node: T, options: Partial<CreateOptions>): TreeArrayBacked.WrappedNode<any> => {\n  return TreeArrayBacked.wrap(create(node, options));\n};\n\nexport type CreateOptions = {\n  name: string\n  /**\n   * If _true_, only leaf nodes have values. This avoids repetition (important\n   * when comparing trees), with semantics being in the tree itself.\n   * \n   * When _false_ (default) values get decomposed down the tree. This\n   * makes it easy to get all the data for a branch of the tree.\n   * \n   * \n   * Eg if storing { person: { address { state: `qld` } } }\n   * When _true_, the tree would be:\n   * ```\n   * person, value: undefined\n   *  + address, value: undefined\n   *    + state, value: 'qld'\n   * ```\n   * But when _false_, the tree would be:\n   * ```\n   * person, value: { address: { state: `qld } }\n   *  + address, value: { state: `qld` }\n   *    + state, value: `qld`\n   * ```\n   */\n  valuesAtLeaves: boolean\n}\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure\n * @param node \n * @param defaultName \n * @returns \n */\nexport const create = <T extends object>(node: T, options: Partial<CreateOptions> = {}): TreeNode<EntryStatic> => {\n  const valuesAtLeaves = options.valuesAtLeaves ?? false;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  const valueFor = valuesAtLeaves ? (v: any) => { if (isPrimitive(v)) return v; } : (v: any) => v;\n  return createImpl(node, valueFor(node), options, []);\n}\n\nconst createImpl = <T extends object>(sourceValue: T, nodeValue: T, options: Partial<CreateOptions> = {}, ancestors: Array<string>): TreeNode<EntryStatic> => {\n  const defaultName = options.name ?? `object_ci`;\n  //onsole.log(`createImpl name: ${ defaultName } nodeValue: ${ JSON.stringify(nodeValue) }`);\n  const r = TreeArrayBacked.root<EntryStatic>({ name: defaultName, value: nodeValue, ancestors: [ ...ancestors ] });\n  ancestors = [ ...ancestors, defaultName ];\n  for (const c of children(sourceValue, options)) {\n    const v = options.valuesAtLeaves ? c.nodeValue : c.sourceValue;\n    TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n  }\n  return r;\n}\n\nexport const createSimplified = <T extends object>(node: T, options: Partial<CreateOptions> = {}): SimplifiedNode<EntryStatic> => {\n  return TreeArrayBacked.stripParentage(create(node, options));\n}\n\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry<T extends object>(node: T, defaultName = ``): Entry {\n  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node as Entry;\n  if (`name` in node) {\n    return { name: node.name as string, nodeValue: node, sourceValue: node };\n  }\n  return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n\n\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }","import { isEqualDefault, type IsEqual } from \"../../IsEqual.js\"\nimport { containsDuplicateInstances, without } from \"../arrays/index.js\"\nimport { QueueMutable } from \"../queue/QueueMutable.js\"\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { compare as treeCompare } from './Compare.js';\nimport { toStringAbbreviate } from \"../../Text.js\"\nimport type { LabelledSingleValue, TreeNode, SimplifiedNode, TraversableTree } from \"./Types.js\"\n\n/**\n * Compares two nodes.\n * \n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a \n * @param b \n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = <T>(a: TreeNode<T>, b: TreeNode<T>, eq?: IsEqual<T>) => {\n  return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n}\n\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n * @param node \n * @returns \n */\nexport const stripParentage = <T>(node: TreeNode<T>): SimplifiedNode<T> => {\n  const n: SimplifiedNode<T> = {\n    value: node.value,\n    childrenStore: node.childrenStore.map(c => stripParentage(c))\n  }\n  return n;\n}\n/**\n * Wraps a {@link TreeNode} for a more object-oriented means of access.\n */\nexport type WrappedNode<T> = TraversableTree<T> & {\n  /**\n   * Underlying Node\n   */\n  wraps: TreeNode<T>,\n  /**\n   * Gets value, if defined\n   * @returns Value of Node\n   */\n  getValue: () => T | undefined\n  /**\n   * Remove node and its children from tree\n   * @returns \n   */\n  remove: () => void\n  /**\n   * Adds a child node\n   * @param child \n   * @returns \n   */\n  add: (child: WrappedNode<T> | TreeNode<T>) => WrappedNode<T>\n  /**\n   * Adds a new child node, with `value` as its value\n   * @param value \n   * @returns \n   */\n  addValue: (value: T) => WrappedNode<T>\n  /**\n   * Returns _true_ if `child` is an immediate child of this node\n   * @param child \n   * @returns \n   */\n  hasChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  queryValue: (value: T) => IterableIterator<WrappedNode<T>>\n  /**\n   * Returns _true_ if `child` is contained any any descendant\n   * @param child\n   * @returns \n   */\n  hasAnyChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate parent for this node\n   * @param parent \n   * @returns \n   */\n  hasParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate or ancestor parent for this node\n   * @param parent \n   * @returns \n   */\n  hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n}\n\nconst unwrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node : wrap(node);\n\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns \n */\nexport const wrap = <T>(n: TreeNode<T>): WrappedNode<T> => {\n  return {\n    *children() {\n      for (const c of n.childrenStore) {\n        yield wrap(c)\n      }\n    },\n    getValue: () => n.value as T,\n    getIdentity: () => n,\n    *queryValue(value: T): IterableIterator<WrappedNode<T>> {\n      for (const v of queryByValue(value, unwrapped(n))) {\n        yield wrap(v);\n      }\n    },\n    getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n    hasParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasParent(n, unwrapped(parent));\n    },\n    hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyParent(n, unwrapped(parent));\n    },\n    hasChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasChild(unwrapped(child), n);\n    },\n    hasAnyChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyChild(unwrapped(child), n);\n    },\n    remove: () => {\n      remove(n);\n    },\n    addValue: (value: T): WrappedNode<T> => {\n      const nodeValue = addValue(value, n);\n      return wrap(nodeValue);\n    },\n    add: (child: WrappedNode<T> | TreeNode<T>): WrappedNode<T> => {\n      add(unwrapped(child), n);\n      return wrapped(child);\n    },\n    wraps: n\n  }\n}\n\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child \n * @returns \n */\nexport const remove = <T>(child: TreeNode<T>) => {\n  const p = child.parent;\n  if (p === undefined) return;\n  child.parent = undefined;\n  p.childrenStore = without(p.childrenStore, child);\n};\n\n/**\n * Depth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* depthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!root) return;\n  const stack = new StackMutable<TreeNode<T>>();\n  stack.push(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = stack.pop();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      stack.push(...entry.childrenStore);\n    }\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n  }\n}\n\n/**\n * Breadth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* breadthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!node) return;\n  const queue = new QueueMutable<TreeNode<T>>();\n  queue.enqueue(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = queue.dequeue();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      queue.enqueue(...entry.childrenStore);\n    }\n    if (queue.isEmpty) break;\n    entry = queue.dequeue();\n  }\n}\n\n/**\n * Validates the tree from `root` downwards.\n * @param root \n * @param seen \n * @returns \n */\nexport function treeTest<T>(root: TreeNode<T>, seen: Array<TreeNode<T>> = []): [ ok: boolean, msg: string, node: TreeNode<T> ] {\n  if (root.parent === root) return [ false, `Root has itself as parent`, root ];\n  if (seen.includes(root)) return [ false, `Same node instance is appearing further in tree`, root ];\n  seen.push(root);\n  if (containsDuplicateInstances(root.childrenStore)) return [ false, `Children list contains duplicates`, root ];\n\n  for (const c of root.childrenStore) {\n    if (c.parent !== root) return [ false, `Member of childrenStore does not have .parent set`, c ];\n    if (hasAnyChild(root, c)) return [ false, `Child has parent as its own child`, c ];\n    const v = treeTest(c, seen);\n    if (!v[ 0 ]) return v;\n  }\n  return [ true, ``, root ];\n}\n\n/**\n * Throws an exception if `root` fails tree validation\n * @param root \n * @returns \n */\nexport function throwTreeTest<T>(root: TreeNode<T>) {\n  const v = treeTest(root);\n  if (v[ 0 ]) return;\n  throw new Error(`${ v[ 1 ] } Node: ${ toStringAbbreviate(v[ 2 ].value, 30) }`, { cause: v[ 2 ] })\n}\n/**\n * Iterate over direct children of `root`\n * @param root \n */\nexport function* children<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  for (const c of root.childrenStore) {\n    yield c;\n  }\n}\n\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root \n */\nexport function* parents<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  let p = root.parent;\n  while (p) {\n    yield p;\n    p = p.parent;\n  }\n}\n\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node \n * @returns \n */\nexport function nodeDepth(node: TreeNode<any>): number {\n  const p = [ ...parents(node) ];\n  return p.length;\n}\n\nexport const hasChild = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of parent.childrenStore) {\n    if (c === child) return true;\n  }\n  return false;\n}\n\nexport const findChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): TreeNode<T> | undefined => {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) return c;\n  }\n}\n\nexport function* queryByValue<T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): IterableIterator<TreeNode<T>> {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) yield c;\n  }\n}\n\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n * \n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild \n * @param parent \n * @returns \n */\nexport const hasAnyChild = <T>(prospectiveChild: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of breadthFirst(parent)) {\n    if (c === prospectiveChild) return true;\n  }\n  return false;\n}\n\nexport const findAnyChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault) => {\n  for (const c of breadthFirst(parent)) {\n    if (eq(c.value as T, value)) return c;\n  }\n}\n\nexport const getRoot = <T>(node: TreeNode<T>): TreeNode<T> => {\n  if (node.parent) return getRoot(node.parent);\n  return node;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n * \n * Use {@link hasParent} to only check immediate parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasAnyParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  for (const p of parents(child)) {\n    if (p === prospectiveParent) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n * \n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  return child.parent === prospectiveParent;\n}\n\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root); \n * ```\n * @param node \n * @returns \n */\nexport const computeMaxDepth = <T>(node: TreeNode<T>) => {\n  return computeMaxDepthImpl(node, 0);\n}\n\nconst computeMaxDepthImpl = <T>(node: TreeNode<T>, startingDepth = 0) => {\n  let depth = startingDepth;\n  for (const c of node.childrenStore) {\n    depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n  }\n  return depth;\n}\n\nexport const add = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  throwAttemptedChild(child, parent);\n  //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n  //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n  const p = child.parent;\n  parent.childrenStore = [ ...parent.childrenStore, child ];\n  child.parent = parent;\n  if (p) {\n    p.childrenStore = without(p.childrenStore, child);\n  }\n}\n\nexport const addValue = <T>(value: T | undefined, parent: TreeNode<T>) => {\n  return createNode(value, parent);\n}\n\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value \n * @returns \n */\nexport const root = <T>(value?: T | undefined) => {\n  return createNode(value);\n}\n\nexport const fromPlainObject = (value: Record<string, any>, label = ``, parent?: TreeNode<any>, seen: Array<any> = []): TreeNode<LabelledSingleValue<any>> => {\n  const entries = Object.entries(value);\n  parent = parent === undefined ? root() : addValue<LabelledSingleValue<any>>({ label, value }, parent);\n  for (const entry of entries) {\n    const value = entry[ 1 ];\n    // Avoid circular references\n    if (seen.includes(value)) continue;\n    seen.push(value);\n\n    if (typeof entry[ 1 ] === `object`) {\n      fromPlainObject(value, entry[ 0 ], parent, seen);\n    } else {\n      addValue<LabelledSingleValue<any>>({ label: entry[ 0 ], value: value }, parent);\n    }\n  }\n  return parent;\n}\n\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link root} alternatively.\n * @param value \n * @returns \n */\nexport const rootWrapped = <T>(value: T | undefined) => {\n  return wrap(createNode(value));\n}\n\nexport const createNode = <T>(value: T | undefined, parent?: TreeNode<T> | undefined): TreeNode<T> => {\n  const n: TreeNode<T> = {\n    childrenStore: [],\n    parent: parent,\n    value: value\n  }\n  if (parent !== undefined) {\n    parent.childrenStore = [ ...parent.childrenStore, n ];\n  }\n  return n;\n}\n\nexport const childrenLength = <T>(node: TreeNode<T>): number => {\n  return node.childrenStore.length;\n}\n\nexport const value = <T>(node: TreeNode<T>): T | undefined => {\n  return node.value;\n}\n\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node \n * @returns \n */\nexport const asDynamicTraversable = <T>(node: TreeNode<T>): TraversableTree<T> => {\n  const t: TraversableTree<T> = {\n    *children() {\n      for (const c of node.childrenStore) {\n        yield asDynamicTraversable(c);\n      }\n    },\n    getParent() {\n      if (node.parent === undefined) return;\n      return asDynamicTraversable(node.parent);\n    },\n    getValue(): any {\n      return node.value;\n    },\n    getIdentity() {\n      return node;\n    },\n  }\n  return t;\n}\n\nconst throwAttemptedChild = <T>(c: TreeNode<T>, parent: TreeNode<T>) => {\n  if (parent === c) throw new Error(`Cannot add self as child`);\n  if (c.parent === parent) return; // skip if it's already a child\n  if (hasAnyParent(parent, c)) throw new Error(`Child contains parent (1)`, { cause: c });\n  if (hasAnyParent(c, parent)) throw new Error(`Parent already contains child`, { cause: c });\n  if (hasAnyChild(parent, c)) throw new Error(`Child contains parent (2)`, { cause: c });\n}\n\nexport const setChildren = <T>(parent: TreeNode<T>, children: Array<TreeNode<T>>) => {\n  // Verify children are legit\n  for (const c of children) {\n    throwAttemptedChild(c, parent);\n  }\n\n  parent.childrenStore = [ ...children ];\n  for (const c of children) {\n    c.parent = parent;\n  }\n}\n\nexport const toStringDeep = <T>(node: TreeNode<T>, indent = 0): string => {\n  const t = `${ `  `.repeat(indent) } + ${ node.value ? JSON.stringify(node.value) : `-` }`;\n  return node.childrenStore.length > 0 ? (\n    t +\n    `\\n` +\n    node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)\n  ) : t;\n}\n\nexport function* followValue<T>(root: TreeNode<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T | undefined> {\n  for (const c of root.childrenStore) {\n    const value = c.value;\n    if (value === undefined) continue;\n    if (continuePredicate(value, depth)) {\n      yield c.value;\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }","import type { StackOpts } from './index.js';\n\nexport const trimStack = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = stack.length + toAdd.length;\n  const policy = opts.discardPolicy ?? `additions`;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  if (opts.debug) {\n    console.log(\n      `Stack.push: stackLen: ${ stack.length } potentialLen: ${ potentialLength } toRemove: ${ toRemove } policy: ${ policy }`\n    );\n  }\n  switch (policy) {\n    case `additions`: {\n      if (opts.debug) {\n        console.log(\n          `Stack.push:DiscardAdditions: stackLen: ${ stack.length } slice: ${ potentialLength - capacity\n          } toAddLen: ${ toAdd.length }`\n        );\n      }\n\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (stack.length === opts.capacity) {\n        return stack; // Completely full\n      } else {\n        // Only add some from the new array\n        return [ ...stack, ...toAdd.slice(0, toAdd.length - toRemove) ];\n      }\n    }\n    case `newer`: {\n      if (toRemove >= stack.length) {\n        // New items will completely flush out old\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n      } else {\n        // Keep some of the old (from 0)\n        //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n        if (opts.debug) {\n          console.log(` from orig: ${ JSON.stringify(stack.slice(0, stack.length - toRemove)) }`);\n        }\n        return [\n          ...stack.slice(0, stack.length - toRemove),\n          ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n        ];\n      }\n    }\n    case `older`: {\n      // Oldest item in stack is position 0\n      return [ ...stack, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown discard policy ${ policy }`);\n    }\n  }\n};\n\n// Add to top (last index)\nexport const push = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\n  //const mutated = [...stack, ...toAdd];\n  const potentialLength = stack.length + toAdd.length;\n\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n  const toReturn = overSize\n    ? trimStack(opts, stack, toAdd)\n    : [ ...stack, ...toAdd ];\n  return toReturn;\n};\n\n// Remove from top (last index)\nexport const pop = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (stack.length === 0) throw new Error(`Stack is empty`);\n  return stack.slice(0, - 1);\n};\n\n/**\n * Peek at the top of the stack (end of array)\n *\n * @template V\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): V | undefined => stack.at(-1);\n\nexport const isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean =>\n  stack.length === 0;\n\nexport const isFull = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return stack.length >= opts.capacity;\n  }\n  return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\n\nimport type { IStackMutable } from './IStackMutable.js';\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\nimport type { StackOpts } from './index.js';\n\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable<V> implements IStackMutable<V> {\n  readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  /**\n   * Push data onto the stack.\n   * If `toAdd` is empty, nothing happens\n   * @param toAdd Data to add\n   * @returns Length of stack\n   */\n  push(...toAdd: ReadonlyArray<V>): number {\n    if (toAdd.length === 0) return this.data.length;\n    this.data = push(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  pop(): V | undefined {\n    const v = peek(this.opts, this.data);\n    this.data = pop(this.opts, this.data);\n    return v;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = <V>(\n  opts: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackMutable<V> => new StackMutable({ ...opts }, [ ...startingItems ]);\n","import { type IsEqual, isEqualValueIgnoreOrder } from \"../../IsEqual.js\";\nimport * as TreeMutable from './TreeMutable.js';\nimport type { TreeNode, TraversableTree } from './Types.js';\n\nexport type DiffAnnotation<T> = {\n  /**\n   * In the case of changes, this is old value\n   */\n  a: TraversableTree<T>\n  /**\n   * In the case of changes, this is the new value\n   */\n  b: TraversableTree<T>\n  /**\n   * If true, this node's value has been modified\n   */\n  valueChanged: boolean\n  /**\n   * If true, one of the child values has changed\n   */\n  childChanged: boolean\n  /**\n   * List of new children\n   */\n  added: Array<TraversableTree<T>>\n  /**\n   * List of removed children\n   */\n  removed: Array<TraversableTree<T>>\n}\n\nexport type DiffNode<T> = TreeNode<DiffAnnotation<T>> & {\n  toString: () => string\n};\n\nexport const compare = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder, parent?: DiffNode<T> | undefined): DiffNode<T> => {\n  const valueEqual = valueOrIdentityEqual(a, b, eq);\n  // if (!valueEqual) {\n  //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n  // }\n  const childrenCompare = compareChildren(a, b, eq);\n\n  const diff: DiffAnnotation<T> = {\n    valueChanged: !valueEqual, a, b,\n    added: childrenCompare.added,\n    removed: childrenCompare.removed,\n    childChanged: false\n  }\n  const diffNode: DiffNode<T> = {\n    value: diff,\n    childrenStore: [],\n    parent\n  }\n\n  const childrenDiff = childrenCompare.identical.map(c => compare(c[ 0 ], c[ 1 ], eq, diffNode));\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value!));\n  TreeMutable.setChildren(diffNode, childrenDiff);\n  //diffNode.childrenStore = childrenDiff;\n\n  diffNode.toString = () => toString(diffNode, 0);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  diffNode.value!.childChanged = someChildChange;\n  TreeMutable.throwTreeTest(diffNode);\n\n  return diffNode;\n}\n\nconst hasChange = (vv: DiffAnnotation<any>): boolean => {\n  if (vv === undefined) return false;\n  if (vv.valueChanged) return true;\n  if (vv.childChanged) return true;\n  if (vv.added.length > 0) return true;\n  if (vv.removed.length > 0) return true;\n  return false;\n}\n\n\nconst compareChildren = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder) => {\n  const childrenOfA = [ ...a.children() ];\n  const childrenOfB = [ ...b.children() ];\n\n  const identical: Array<[ a: TraversableTree<T>, b: TraversableTree<T> ]> = []\n  const removed: Array<TraversableTree<T>> = [];\n  for (const childA of childrenOfA) {\n    let foundIndex = -1;\n    for (const [ index, childOfB ] of childrenOfB.entries()) {\n      const d = valueOrIdentityEqual(childA, childOfB, eq);\n      if (d) {\n        identical.push([ childA, childOfB ]);\n        foundIndex = index;\n        break;\n      }\n    }\n    if (foundIndex === -1) {\n      // A's child not found in B's children\n      removed.push(childA);\n    } else {\n      // Found, remove it from list of B's children\n      childrenOfB.splice(foundIndex, 1);\n    }\n  }\n  const added = [ ...childrenOfB ];\n  return { added, identical, removed }\n}\n\nconst valueOrIdentityEqual = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T>): boolean => {\n  if (a.getIdentity() === b.getIdentity()) return true;\n  if (eq(a.getValue(), b.getValue())) return true;\n  return false;\n}\n\nconst toStringSingle = <T>(n: TraversableTree<T>) => {\n  return JSON.stringify(n.getValue());\n}\n\nconst toString = <T>(n: DiffNode<T>, indent = 0): string => {\n  if (n === undefined) return `(undefined)`;\n  let t = toStringDiff(n.value, indent);\n  for (const c of n.childrenStore) {\n    t += toString(c, indent + 2);\n  }\n  return t;\n}\n\nconst toStringDiff = <T>(n: DiffAnnotation<T> | undefined, indent: number): string => {\n  const spaces = ` `.repeat(indent);\n  if (n === undefined) return `${ spaces }(undefined)`;\n  const t = [];\n  t.push(`a: ${ toStringSingle(n.a) } b: ${ toStringSingle(n.b) }`);\n  if (n.valueChanged) t.push(`Value changed. Child changed: ${ n.childChanged }`);\n  else t.push(`Value unchanged. Child changed: ${ n.childChanged }`);\n\n  if (n.added.length > 0) {\n    t.push(`Added:`);\n    for (const c of n.added) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  if (n.removed.length > 0) {\n    t.push(`Removed: ${ n.removed.length }`);\n    for (const c of n.removed) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  t.push(`----\\n`)\n  return t.map(line => spaces + line).join(`\\n`);\n}","import * as TreeArrayBacked from \"./TreeMutable.js\";\nimport type { LabelledValue, LabelledNode, TreeNode } from \"./Types.js\";\n/**\n * Options for parsing a path\n */\nexport type PathOpts = Readonly<{\n  /**\n   * Separator for path, eg '.'\n   */\n  separator: string;\n  /**\n   * If two values are stored at same path, what to do? Default: overwrite\n   * * overwrite: last-write wins\n   * * ignore: first-write wins\n   * * allow: allow multiple values\n   */\n  duplicates: `overwrite` | `allow` | `ignore`\n}>;\n\n\n\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n * \n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n * \n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n * \n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n * \n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts \n * @returns \n */\nexport const create = <T>(pathOpts: Partial<PathOpts> = {}) => {\n  let root: TreeNode<LabelledValue<T>> | undefined;\n\n  const add = (value: T, path: string) => {\n    const n = addValueByPath(value, path, root, pathOpts);\n    if (root === undefined) {\n      root = TreeArrayBacked.getRoot(n);\n    }\n  }\n\n  const prettyPrint = () => {\n    if (root === undefined) return `(empty)`;\n    return TreeArrayBacked.toStringDeep(root);\n  }\n\n  const getValue = (path: string): T | undefined => {\n    if (root === undefined) return;\n    return valueByPath(path, root, pathOpts);\n  }\n\n  const remove = (path: string): boolean => {\n    if (root === undefined) return false;\n    return removeByPath(path, root, pathOpts);\n  }\n\n  const hasPath = (path: string): boolean => {\n    if (root === undefined) return false;\n    const c = findChildByPath(path, root, pathOpts);\n    return c !== undefined;\n  }\n\n  const getNode = (path: string): LabelledNode<T> | undefined => {\n    if (root === undefined) return;\n    const c = findChildByPath(path, root, pathOpts);\n    return c;\n  }\n\n  const childrenLength = (path: string): number => {\n    if (root === undefined) return 0;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined) return 0;\n    return c.childrenStore.length;\n  }\n\n  const getValues = (path: string): Array<T> => {\n    if (root === undefined) return [];\n    return valuesByPath(path, root, pathOpts);\n  }\n\n  const clearValues = (path: string): boolean => {\n    if (root === undefined) return false;\n    return clearValuesByPath(path, root, pathOpts);\n  }\n  return { add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues }\n}\n\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n * \n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = <T>(value: T, path: string, node?: LabelledNode<T> | undefined, pathOpts: Partial<PathOpts> = {}): LabelledNode<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n  const split = path.split(separator);\n  let count = 0;\n  for (const p of split) {\n    const lastEntry = count === split.length - 1;\n    //onsole.log(`p: ${ p }`);\n    const found = findChildByLabel(p, node);\n    if (found === undefined) {\n      //onsole.log(`  - not found`);\n      const labelled: LabelledValue<T> = {\n        value: (lastEntry ? value : undefined),\n        label: p\n      };\n      node = TreeArrayBacked.createNode(labelled, node);\n    } else {\n      node = found;\n      if (lastEntry) {\n        switch (duplicatePath) {\n          case `ignore`: {\n            break;\n          }\n          case `allow`: {\n            const existing = getValuesFromNode(node);\n            node.value = {\n              values: [ ...existing, value ],\n              label: p\n            }\n            break;\n          }\n          case `overwrite`: {\n            node.value = {\n              value,\n              label: p\n            }\n            break;\n          }\n        }\n      } else {\n        //onsole.log(`  - found!`, found.value);\n        node = found;\n      }\n    }\n    count++;\n  }\n  if (node === undefined) throw new Error(`Could not create tree`);\n  return node;\n}\n\nexport const removeByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  TreeArrayBacked.remove(c);\n  return true;\n}\n\nexport const clearValuesByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  c.value = {\n    label: c.value?.label ?? ``,\n    value: undefined\n  }\n  return true;\n}\nexport const childrenLengthByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): number => {\n  if (node === undefined) return 0;\n  const c = findChildByPath(path, node, pathOpts);\n  if (c === undefined) return 0;\n  return c.childrenStore.length;\n}\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = <T>(label: string, node: LabelledNode<T> | undefined): LabelledNode<T> | undefined => {\n  if (node === undefined) return undefined;\n  if (label === undefined) throw new Error(`Parameter 'label' cannot be undefined`);\n  if (node.value?.label === label) return node;\n  for (const c of node.childrenStore) {\n    if (c.value?.label === label) return c;\n  }\n}\n\nexport const valueByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): T | undefined => {\n  const values = valuesByPath(path, node, pathOpts);\n  if (values.length === 0) return undefined;\n  if (values.length > 1) throw new Error(`Multiple values at path. Use getValues instead`);\n  return values[ 0 ];\n}\n\nconst getValuesFromNode = <T>(c: LabelledNode<T>): Array<T> => {\n  if (c.value === undefined) return [];\n  if (`values` in c.value) return c.value.values;\n  if (`value` in c.value) {\n    if (c.value.value === undefined) return [];\n    return [ c.value.value ];\n  }\n  return [];\n}\n\nconst findChildByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}) => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      return;\n    }\n  }\n  return c;\n}\n\nexport const valuesByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): Array<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    //onsole.log(`getValue p: ${ p }`);\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n      return [];\n    }\n  }\n  return getValuesFromNode(c);\n}","import { toStringAbbreviate } from \"../../Text.js\";\nimport { isEqualDefault, type IsEqual } from \"../../IsEqual.js\";\nimport { QueueMutable } from \"../queue/QueueMutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport type { TraversableTree } from \"./Types.js\";\n\nexport const childrenLength = <T>(tree: TraversableTree<T>): number => {\n  return [ ...tree.children() ].length;\n}\n\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = <T>(\n  child: TraversableTree<T>,\n  possibleParent: TraversableTree<T>,\n  eq?: IsEqual<TraversableTree<T>>\n): boolean => {\n  return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyParentValue = <T>(\n  child: TraversableTree<T>,\n  possibleParentValue: T,\n  eq?: IsEqual<T>\n): boolean => {\n  return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findAnyParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq?: IsEqual<TValue>\n): TraversableTree<TValue> | undefined => {\n  return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = <T>(\n  child: TraversableTree<T>,\n  possibleParent: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault<TraversableTree<T>>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = child.getParent();\n  if (p === undefined) return false;\n  if (eq(p, possibleParent)) return true;\n  if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n  return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\n\nexport const hasParentValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault<TValue>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = child.getParent();\n  if (p === undefined) return false;\n  if (eq(p.getValue(), possibleParentValue)) return true;\n  return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\nexport const findParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault<TValue>,\n  maxDepth = 0\n): TraversableTree<TValue> | undefined => {\n  if (maxDepth < 0) return;\n  const p = child.getParent();\n  if (p === undefined) return;\n  if (eq(p.getValue(), possibleParentValue)) return p;\n  return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = <T>(\n  parent: TraversableTree<T>,\n  prospectiveChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n) => {\n\n  if (eq(parent, prospectiveChild)) throw new Error(`Child equals parent`);\n  if (hasAnyChild(parent, prospectiveChild, eq)) {\n    throw new Error(`Circular. Parent already has child`);\n  }\n  if (hasAnyChild(prospectiveChild, parent, eq)) {\n    throw new Error(`Prospective child has parent as child relation`);\n  }\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = <T>(\n  parent: TraversableTree<T>,\n  possibleChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n): boolean => {\n  return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleChildValue: T,\n  eq: IsEqual<T> = isEqualDefault\n): boolean => {\n  return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = <T>(\n  parent: TraversableTree<T>,\n  possibleChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent, possibleChild)) return true;\n  if (eq(parent.getIdentity(), possibleChild.getIdentity())) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c, possibleChild)) return true;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    if (eq(c.getIdentity(), possibleChild.getIdentity())) return true;\n  }\n  return false;\n};\n\nexport const hasChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleValue: T,\n  eq: IsEqual<T> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent.getValue(), possibleValue)) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c.getValue(), possibleValue)) return true;\n  }\n  return false;\n};\n\n/**\n * Iterates over siblings of `node`.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* siblings<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  const p = node.getParent();\n  if (p === undefined) return;\n  for (const s of p.children()) {\n    if (s === node) continue;\n    yield s;\n  }\n}\n\n/**\n * Iterates over parents of `node`, starting with immediate parent\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  let p = node.getParent();\n  while (p !== undefined) {\n    yield p;\n    p = p.getParent();\n  }\n}\n\n\nexport const findAnyChildByValue = <TValue>(parent: TraversableTree<TValue>,\n  possibleValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault\n): TraversableTree<TValue> | undefined => {\n  return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findChildByValue = <TValue>(parent: TraversableTree<TValue>,\n  possibleValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault,\n  maxDepth = 0\n): TraversableTree<TValue> | undefined => {\n\n  if (maxDepth < 0) return;\n  if (eq(parent.getValue(), possibleValue)) return parent;\n\n  for (const d of breadthFirst(parent, maxDepth)) {\n    // This child matches\n    if (eq(d.getValue(), possibleValue)) return d;\n  }\n  return;\n};\n\n/**\n * Iterates over children of `root`, depth-first.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node \n * @returns \n */\nexport function* depthFirst<T>(root: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  if (!root) return;\n  const stack = new StackMutable<TraversableTree<T>>();\n  let entry: TraversableTree<T> | undefined = root;\n  while (entry) {\n    stack.push(...entry.children());\n    entry = stack.pop();\n    if (entry) yield entry;\n  }\n}\n\n/**\n * Iterates over the children of `root`, breadth-first\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @param depth How many levels to traverse \n * @returns \n */\nexport function* breadthFirst<T>(root: TraversableTree<T>, depth = Number.MAX_SAFE_INTEGER): IterableIterator<TraversableTree<T>> {\n  if (!root) return;\n  const queue = new QueueMutable<TraversableTree<T>>();\n  let entry: TraversableTree<T> | undefined = root;\n  while (entry) {\n    if (depth < 0) return;\n    for (const c of entry.children()) {\n      yield c;\n      queue.enqueue(c);\n    }\n    entry = queue.dequeue();\n    depth--;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function find<T>(root: TraversableTree<T>, predicate: (node: TraversableTree<T>) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root)) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n  for (const c of iter(root)) {\n    if (predicate(c)) return c;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n * \n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function findByValue<T>(root: TraversableTree<T>, predicate: (nodeValue: T) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root.getValue())) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n\n  for (const c of iter(root)) {\n    if (predicate(c.getValue())) return c;\n  }\n}\n\n/**\n * Search through children in a path-like manner.\n * \n * It finds the first child of `root` that matches `continuePredicate`. \n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n * \n * If it can't find a child, it stops.\n * \n * This is different to 'find' functions, which exhausively search all possible child nodes, regardless of position in tree.\n * \n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n * \n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root \n * @param continuePredicate \n * @param depth \n */\nexport function* followValue<T>(root: TraversableTree<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T> {\n  for (const c of root.children()) {\n    if (continuePredicate(c.getValue(), depth)) {\n      yield c.getValue();\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\nexport function toStringDeep<T>(node: TraversableTree<T>, depth = 0) {\n  if (node === undefined) return `(undefined)`;\n  if (node === null) return `(null)`;\n  const v = node.getValue();\n  let type: string = typeof v;\n  if (Array.isArray(v)) type = `array`;\n  let t = `  `.repeat(depth) + `value: ${ JSON.stringify(v) } (${ type })\\n`;\n  for (const n of node.children()) {\n    t += toStringDeep(n, depth + 1);\n  }\n  return t;\n}\n\nexport function toString(...nodes: Array<TraversableTree<any>>) {\n  let t = ``;\n  for (const node of nodes) {\n    const v = node.getValue();\n    const vString = toStringAbbreviate(v);\n    const children = [ ...node.children() ];\n    const parent = node.getParent();\n    let type: string = typeof v;\n    if (Array.isArray(v)) type = `array`;\n    t += `value: ${ vString } (${ type }) kids: ${ children.length } parented: ${ parent ? `y` : `n` }\\n`;\n  }\n  return t;\n}","export type { IStack } from './IStack.js';\nexport type { IStackMutable } from './IStackMutable.js';\nexport type { IStackImmutable } from './IStackImmutable.js';\n\n// ✔ Unit tested!\nexport type StackDiscardPolicy = `older` | `newer` | `additions`;\n\nexport type StackOpts = {\n  readonly debug?: boolean;\n  readonly capacity?: number;\n  readonly discardPolicy?: StackDiscardPolicy;\n};\n\nexport { immutable } from './StackImmutable.js';\nexport { mutable } from './StackMutable.js';\n","// -------------------------\n// Immutable\n// -------------------------\nimport type { IStackImmutable } from './IStackImmutable.js';\nimport { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nimport type { StackOpts } from './index.js';\n\nexport class StackImmutable<V> implements IStackImmutable<V> {\n  private readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  push(...toAdd: ReadonlyArray<V>): StackImmutable<V> {\n    return new StackImmutable<V>(\n      this.opts,\n      push(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  pop(): IStackImmutable<V> {\n    return new StackImmutable<V>(this.opts, pop(this.opts, this.data));\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [...this.data].reverse().forEach(fn);\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param opts Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = <V>(\n  opts: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackImmutable<V> => new StackImmutable({ ...opts }, [...startingItems]);\n","export { create as expiringMap, ExpiringMap } from './ExpiringMap.js';\nexport type {\n  ExpiringMapEvent,\n  ExpiringMapEvents,\n  Opts as ExpiringMapOpts,\n} from './ExpiringMap.js';\n\nexport type { IMapOf } from './IMapOf.js';\nexport { immutable, type IMapImmutable } from './Map.js';\nexport { mutable, type IMapMutable } from './MapMutable.js';\nexport { ofSetMutable } from './MapOfSetMutable.js';\nexport { ofCircularMutable } from './MapOfCircularMutable.js';\nexport type { MapCircularOpts } from './MapOfCircularMutable.js';\nexport type { IMapOfMutable } from './IMapOfMutable.js';\nexport type { IMappish, IWithEntries } from './IMappish.js';\nexport type { MapArrayOpts } from './MapOfArrayMutable.js';\nexport { NumberMap } from './NumberMap.js';\nexport * from './MapMulti.js';\nexport * from './MapFns.js';\nexport * from './GetOrGenerate.js';","import { SimpleEventEmitter } from '../../Events.js';\nimport { sortByValueProperty } from './MapFns.js';\nimport { throwIntegerTest } from '../../Guards.js';\n\n/**\n * Expiring map options\n */\nexport type Opts = {\n  /**\n   * Capacity limit\n   */\n  readonly capacity?: number;\n  /**\n   * Policy for evicting items if capacity is reached\n   */\n  readonly evictPolicy?: `none` | `oldestGet` | `oldestSet`;\n  /**\n   * Automatic deletion policy.\n   * none: no automatic deletion (default)\n   * get/set: interval based on last get/set\n   * either: if either interval has elapsed\n   */\n  readonly autoDeletePolicy?: `none` | `get` | `set` | `either`;\n  /**\n   * Automatic deletion interval\n   */\n  readonly autoDeleteElapsedMs?: number;\n};\n\ntype Item<V> = {\n  readonly value: V;\n  readonly lastSet: number;\n  readonly lastGet: number;\n};\n\n/**\n * Event from the ExpiringMap\n */\nexport type ExpiringMapEvent<K, V> = {\n  readonly key: K;\n  readonly value: V;\n};\n\nexport type ExpiringMapEvents<K, V> = {\n  /**\n   * Fires when an item is removed due to eviction\n   * or automatic expiry\n   */\n  readonly expired: ExpiringMapEvent<K, V>;\n  /**\n   * Fires when a item with a new key is added\n   */\n  readonly newKey: ExpiringMapEvent<K, V>;\n\n  /**\n   * Fires when an item is manually removed,\n   * removed due to eviction or automatic expiry\n   */\n  readonly removed: ExpiringMapEvent<K, V>;\n};\n\n/**\n * Create a ExpiringMap instance\n * @param opts\n * @returns\n */\nexport const create = <K, V>(opts: Opts = {}): ExpiringMap<K, V> =>\n  new ExpiringMap(opts);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using `touch(key)`.\n *\n *\n * Events:\n * * `expired`: when an item is automatically removed.\n * * `removed`: when an item is manually or automatically removed.\n * * `newKey`: when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example Automatically delete the oldest item if we reach a capacity limit\n * ```\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n */\nexport class ExpiringMap<K, V> extends SimpleEventEmitter<\n  ExpiringMapEvents<K, V>\n> {\n  private capacity: number;\n  private store: Map<K, Item<V>>;\n  private keyCount: number;\n  private evictPolicy;\n\n  private autoDeleteElapsedMs: number;\n  private autoDeletePolicy;\n\n  constructor(opts: Opts = {}) {\n    super();\n    this.capacity = opts.capacity ?? -1;\n\n    throwIntegerTest(this.capacity, `nonZero`, `capacity`);\n    this.store = new Map();\n    this.keyCount = 0;\n\n    if (opts.evictPolicy && this.capacity <= 0) {\n      throw new Error(`evictPolicy is set, but no capacity limit is set`);\n    }\n    this.evictPolicy = opts.evictPolicy ?? `none`;\n    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n\n    if (this.autoDeleteElapsedMs > 0) {\n      setInterval(\n        () => this.#maintain(),\n        Math.max(1000, this.autoDeleteElapsedMs * 2)\n      );\n    }\n  }\n\n  /**\n   * Returns the number of keys being stored.\n   */\n  get keyLength() {\n    return this.keyCount;\n  }\n\n  *entries(): IterableIterator<[ k: K, v: V ]> {\n    for (const entry of this.store.entries()) {\n      yield [ entry[ 0 ], entry[ 1 ].value ];\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const v of this.store.values()) {\n      yield v.value;\n    }\n  }\n\n  *keys(): IterableIterator<K> {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was set. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedSet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (!v) return v;\n    return Date.now() - v.lastSet;\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was accessed. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedGet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (!v) return v;\n    return Date.now() - v.lastGet;\n  }\n\n  /**\n   * Returns true if `key` is stored.\n   * Does not affect the key's last access time.\n   * @param key\n   * @returns\n   */\n  has(key: K): boolean {\n    return this.store.has(key);\n  }\n\n  /**\n   * Gets an item from the map by key, returning\n   * undefined if not present\n   * @param key Key\n   * @returns Value, or undefined\n   */\n  get(key: K): V | undefined {\n    const v = this.store.get(key);\n    if (v) {\n      return v.value;\n    }\n  }\n\n  /**\n   * Deletes the value under `key`, if present.\n   *\n   * Returns _true_ if something was removed.\n   * @param key\n   * @returns\n   */\n  delete(key: K): boolean {\n    const val = this.store.get(key);\n    if (!val) return false;\n    const d = this.store.delete(key);\n    this.keyCount = this.keyCount - 1;\n    this.fireEvent(`removed`, {\n      key,\n      value: val.value,\n    });\n    return d;\n  }\n\n  /**\n   * Updates the lastSet/lastGet time for a value\n   * under `k`.\n   *\n   * Returns false if key was not found\n   * @param key\n   * @returns\n   */\n  touch(key: K): boolean {\n    const v = this.store.get(key);\n    if (!v) return false;\n    this.store.set(key, {\n      ...v,\n      lastSet: Date.now(),\n      lastGet: Date.now(),\n    });\n    return true;\n  }\n\n  private findEvicteeKey() {\n    if (this.evictPolicy === `none`) return null;\n    //eslint-disable-next-line functional/no-let\n    let sortBy = ``;\n    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;\n    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;\n    else throw Error(`Unknown eviction policy ${ this.evictPolicy }`);\n    const sorted = sortByValueProperty(this.store, sortBy);\n    return sorted[ 0 ][ 0 ];\n  }\n\n  #maintain() {\n    if (this.autoDeletePolicy === `none`) return;\n    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n  }\n\n  /**\n   * Deletes all values where elapsed time has past\n   * for get/set or either.\n   *\n   * Remove items are returned\n   * @param time\n   * @param prop get/set/either\n   */\n  deleteWithElapsed(\n    time: number,\n    prop: `get` | `set` | `either`\n  ): [ k: K, v: V ][] {\n    const entries = [ ...this.store.entries() ];\n    const prune: [ k: K, v: V ][] = [];\n    const now = Date.now();\n    for (const e of entries) {\n      const elapsedGet = now - e[ 1 ].lastGet;\n      const elapsedSet = now - e[ 1 ].lastSet;\n      const elapsed =\n        prop === `get`\n          ? elapsedGet\n          : prop === `set`\n            ? elapsedSet\n            : Math.max(elapsedGet, elapsedSet);\n      if (elapsed >= time) {\n        prune.push([ e[ 0 ], e[ 1 ].value ]);\n      }\n    }\n\n    for (const e of prune) {\n      this.store.delete(e[ 0 ]);\n      this.keyCount = this.keyCount - 1;\n      const eventArgs = {\n        key: e[ 0 ],\n        value: e[ 1 ],\n      };\n      this.fireEvent(`expired`, eventArgs);\n      this.fireEvent(`removed`, eventArgs);\n    }\n    return prune;\n  }\n\n  /**\n   * Sets the `key` to be `value`.\n   *\n   * If the key already exists, it is updated.\n   *\n   * If the map is full, according to its capacity,\n   * another value is selected for removal.\n   * @param key\n   * @param value\n   * @returns\n   */\n  set(key: K, value: V) {\n    const existing = this.store.get(key);\n\n    if (existing) {\n      // Update set time\n      this.store.set(key, {\n        ...existing,\n        lastSet: performance.now(),\n      });\n      return;\n    }\n\n    // New key\n    if (this.keyCount === this.capacity && this.capacity > 0) {\n      // Evict first\n      const key = this.findEvicteeKey();\n      if (!key) {\n        throw new Error(`ExpiringMap full (capacity: ${ this.capacity })`);\n      }\n      const existing = this.store.get(key);\n      this.store.delete(key);\n      this.keyCount = this.keyCount - 1;\n      if (existing) {\n        const eventArgs = { key, value: existing.value };\n        this.fireEvent(`expired`, eventArgs);\n        this.fireEvent(`removed`, eventArgs);\n      }\n    }\n\n    this.keyCount++;\n    this.store.set(key, {\n      lastGet: 0,\n      lastSet: Date.now(),\n      value: value,\n    });\n\n    this.fireEvent(`newKey`, { key, value });\n  }\n}\n","import type { ArrayKeys, EitherKey, ObjectKeys } from '../index.js';\n\n/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ArrayKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d[ 0 ] === undefined) throw new Error(`key cannot be undefined`);\n    if (d[ 1 ] === undefined) throw new Error(`value cannot be undefined`);\n    x.set(d[ 0 ], d[ 1 ]);\n  }\n  return x;\n};\n\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ObjectKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\n\n    x.set(d.key, d.value);\n  }\n  return x;\n};\n\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = <K, V>(map: ReadonlyMap<K, V>, key: K): boolean =>\n  map.has(key);\n\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = <K, V>(\n  map: ReadonlyMap<K, V>,\n  ...data: EitherKey<K, V>\n): ReadonlyMap<K, V> => {\n  if (map === undefined) throw new Error(`map parameter is undefined`);\n  if (data === undefined) throw new Error(`data parameter i.s undefined`);\n  if (data.length === 0) return map;\n\n  const firstRecord = data[ 0 ];\n  const isObject =\n    typeof (firstRecord as { readonly key: K; readonly value: V }).key !==\n    `undefined` &&\n    typeof (firstRecord as { readonly key: K; readonly value: V }).value !==\n    `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n  return isObject\n    ? addObjects(map, data as ObjectKeys<K, V>)\n    : addArray(map, data as ArrayKeys<K, V>);\n};\n\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key: K, value: V) => {\n  const x = new Map<K, V>(map.entries());\n  x.set(key, value);\n  return x;\n};\n\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  x.delete(key);\n  return x;\n};\n","import { type EitherKey } from '../index.js';\nimport type { IMapBase } from './IMapBase.js';\nimport { add, del, set } from './MapImmutableFns.js';\n\n/**\n * An immutable map. Rather than changing the map, functions like `add` and `delete`\n * return a new map reference which must be captured.\n *\n * Immutable data is useful because as it gets passed around your code, it never\n * changes from underneath you. You have what you have.\n *\n * @example\n * ```js\n * let m = map(); // Create\n * let m2 = m.set(`hello`, `samantha`);\n * // m is still empty, only m2 contains a value.\n * ```\n *\n * @template K Type of map keys. Typically `string`\n * @template V Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapImmutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items, returning the changed map.\n   *\n   * Can add items in the form of `[key,value]` or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): IMapImmutable<K, V>;\n  /**\n   * Deletes an item by key, returning the changed map\n   * @param key\n   */\n  delete(key: K): IMapImmutable<K, V>;\n  /**\n   * Returns an empty map\n   */\n  clear(): IMapImmutable<K, V>;\n\n\n  /**\n   * Sets `key` to be `value`, overwriting anything existing.\n   * Returns a new map with added key.\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): IMapImmutable<K, V>;\n\n}\n\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = <K, V>(\n  dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>\n): IMapImmutable<K, V> => {\n  if (dataOrMap === undefined) return immutable([]);\n  if (Array.isArray(dataOrMap)) return immutable<K, V>(add(new Map(), ...dataOrMap));\n\n  const data = dataOrMap as ReadonlyMap<K, V>;\n  return {\n    add: (...itemsToAdd: EitherKey<K, V>) => {\n      const s = add(data, ...itemsToAdd);\n      return immutable(s);\n    },\n    set: (key: K, value: V) => {\n      const s = set(data, key, value);\n      return immutable(s);\n    },\n    get: (key: K) => data.get(key),\n    delete: (key: K) => immutable(del(data, key)),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    clear: () => immutable(),\n    has: (key: K) => data.has(key),\n    entries: () => data.entries(),\n    values: () => data.values(),\n    isEmpty: () => data.size === 0,\n  };\n};\n","import { type EitherKey } from '../index.js';\nimport type { IMapBase } from './IMapBase.js';\nimport { add, del, set, has } from './MapImmutableFns.js';\n\n/**\n * A mutable map.\n *\n * It is a wrapper around the in-built Map type, but adds roughly the same API as {@link IMapImmutable}.\n *\n * @template K Type of map keys. Typically `string`\n * @template V Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapMutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items to map\n   *\n   * Can add items in the form of [key,value] or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): void;\n  /**\n   * Sets a value to a specified key\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): void;\n  /**\n   * Deletes an item by key\n   * @param key\n   */\n  delete(key: K): void;\n  /**\n   * Clears map\n   */\n  clear(): void;\n}\n\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = <K, V>(...data: EitherKey<K, V>): IMapMutable<K, V> => {\n  // eslint-disable-next-line functional/no-let\n  let m = add(new Map<K, V>(), ...data);\n  return {\n    add: (...data: EitherKey<K, V>) => {\n      m = add(m, ...data);\n    },\n    delete: (key: K) => {\n      m = del(m, key);\n    },\n    clear: () => {\n      m = add(new Map<K, V>());\n    },\n    set: (key: K, value: V): void => {\n      m = set(m, key, value);\n    },\n    get: (key: K): V | undefined => m.get(key),\n    entries: () => m.entries(),\n    values: () => m.values(),\n    isEmpty: () => m.size === 0,\n    has: (key: K) => has(m, key),\n  };\n};\n","import {\n  type IsEqual,\n  isEqualDefault\n} from '../../IsEqual.js';\nimport type {\n  MapArrayEvents,\n  IMapOfMutableExtended,\n} from './IMapOfMutableExtended.js';\nimport type { MapMultiOpts, MultiValue } from './MapMulti.js';\nimport { SimpleEventEmitter } from '../../Events.js';\nimport type { IMapOf } from './IMapOf.js';\nimport { toStringDefault, type ToString } from '../../Util.js';\n\n/**\n * @internal\n */\nexport class MapOfMutableImpl<V, M>\n  extends SimpleEventEmitter<MapArrayEvents<V>>\n  implements IMapOfMutableExtended<V, M>\n{\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #map = new Map<string, M>();\n  readonly groupBy: ToString<V>;\n  readonly type: MultiValue<V, M>;\n\n  constructor(type: MultiValue<V, M>, opts: MapMultiOpts<V> = {}) {\n    super();\n    this.type = type;\n    this.groupBy = opts.groupBy ?? toStringDefault;\n  }\n\n  /**\n   * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n   */\n  get typeName() {\n    return this.type.name;\n  }\n\n  /**\n   * Returns the number of keys\n   */\n  get lengthKeys(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns the length of the longest child list\n   */\n  get lengthMax() {\n    //eslint-disable-next-line functional/no-let\n    let m = 0;\n    for (const v of this.#map.values()) {\n      m = Math.max(m, this.type.count(v));\n    }\n    return m;\n  }\n\n  debugString(): string {\n    const keys = [ ...this.#map.keys() ];\n    // eslint-disable-next-line functional/no-let\n    let r = `Keys: ${ keys.join(`, `) }\\r\\n`;\n    for (const k of keys) {\n      const v = this.#map.get(k);\n      if (v === undefined) {\n        r += ` - ${ k } (undefined)\\r\\n`\n      } else {\n        const asArray = this.type.toArray(v);\n        if (asArray !== undefined) {\n          r += ` - ${ k } (${ this.type.count(v) }) = ${ JSON.stringify(\n            asArray\n          ) }\\r\\n`;\n        }\n      }\n    };\n    return r;\n  }\n\n  get isEmpty(): boolean {\n    return this.#map.size === 0;\n  }\n\n  clear() {\n    this.#map.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  addKeyedValues(key: string, ...values: Array<V>) {\n    const set = this.#map.get(key);\n    if (set === undefined) {\n      this.#map.set(key, this.type.add(undefined, values));\n      super.fireEvent(`addedKey`, { key: key });\n      super.fireEvent(`addedValues`, { values: values });\n    } else {\n      // eslint-disable-next-line functional/immutable-data\n      this.#map.set(key, this.type.add(set, values));\n      super.fireEvent(`addedValues`, { values: values });\n    }\n  }\n  //eslint-disable-next-line functional/prefer-immutable-types\n  set(key: string, values: Array<V>) {\n    this.addKeyedValues(key, ...values);\n    return this;\n  }\n\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) this.addKeyedValues(this.groupBy(v), v);\n  }\n\n  hasKeyValue(key: string, value: V, eq: IsEqual<V>): boolean {\n    const m = this.#map.get(key);\n    if (m === undefined) return false;\n    return this.type.has(m, value, eq);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.#map.has(key);\n  }\n\n  deleteKeyValue(key: string, value: V): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    return this.deleteKeyValueFromMap(a, key, value);\n  }\n\n  private deleteKeyValueFromMap(map: M, key: string, value: V): boolean {\n    const preCount = this.type.count(map);\n    const filtered = this.type.without(map, value);\n    const postCount = filtered.length;\n    this.#map.set(key, this.type.add(undefined, filtered));\n    return preCount > postCount;\n  }\n\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let something = false;\n    [ ...this.#map.keys() ].filter((key) => {\n      const a = this.#map.get(key);\n      if (!a) throw new Error(`Bug: map could not be accessed`);\n      if (this.deleteKeyValueFromMap(a, key, value)) {\n        something = true; // note that something was deleted\n\n        // If key is empty, delete it\n        if (this.count(key) === 0) this.delete(key);\n      }\n    });\n    return something;\n  }\n\n  delete(key: string): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    this.#map.delete(key);\n    this.fireEvent(`deleteKey`, { key: key });\n    return true;\n  }\n\n  firstKeyByValue(\n    value: V,\n    eq: IsEqual<V> = isEqualDefault\n  ): string | undefined {\n    const keys = [ ...this.#map.keys() ];\n    const found = keys.find((key) => {\n      const a = this.#map.get(key);\n      if (a === undefined) throw new Error(`Bug: map could not be accessed`);\n      const r = this.type.has(a, value, eq);\n      return r;\n    });\n    return found;\n  }\n\n  count(key: string): number {\n    const entry = this.#map.get(key);\n    if (entry === undefined) return 0;\n    return this.type.count(entry);\n  }\n\n  /**\n   * Iterates over values stored under `key`\n   * An empty array is returned if there are no values\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  /**\n   * Iterate over the values stored under `key`.\n   * If key does not exist, iteration is essentially a no-op\n   * @param key\n   * @returns\n   */\n  *valuesFor(key: string) {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  getSource(key: string): M | undefined {\n    return this.#map.get(key);\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keys(): IterableIterator<string> {\n    yield* this.#map.keys();\n    //return Array.from(this.#map.keys());\n  }\n\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const entry of this.#map.entries()) {\n      for (const v of this.type.iterable(entry[ 1 ])) {\n        yield [ entry[ 0 ], v ];\n      }\n    }\n  }\n\n  *valuesFlat(): IterableIterator<V> {\n    for (const entry of this.#map.entries()) {\n      yield* this.type.iterable(entry[ 1 ]);\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: Array<V> ]> {\n    //yield* this.#map.entries();\n    for (const [ k, v ] of this.#map.entries()) {\n      const temporary = [ ...this.type.iterable(v) ];\n      yield [ k, temporary ];\n    }\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    //const keys = this.keys();\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    //const r = keys.map(k => [k, this.count(k)]) as Array<[string, number]>;\n    //return r;\n\n    for (const key of this.keys()) {\n      yield [ key, this.count(key) ];\n    }\n  }\n\n  merge(other: IMapOf<V>) {\n    // const keys = other.keys();\n    // keys.forEach(key => {\n    //   const data = other.get(key);\n    //   if (data !== undefined) this.addKeyedValues(key, ...data);\n    // });\n    for (const key of other.keys()) {\n      const data = other.get(key);\n      this.addKeyedValues(key, ...data);\n    }\n  }\n\n  get size() {\n    return this.#map.size;\n  }\n  /*\n    forEach_(\n      fn: (\n        value: ReadonlyArray<V>,\n        key: string,\n        //eslint-disable-next-line functional/prefer-immutable-types\n        map: Map<string, ReadonlyArray<V>>\n      ) => void,\n      _?: any\n    ) {\n      // for (const [key,value] of this.#map.entries()) {\n      //   value\n      // }\n      // @ts-expect-error\n      this.#map.forEach(fn);\n    }\n    */\n\n  get [ Symbol.toStringTag ]() {\n    return this.#map[ Symbol.toStringTag ];\n  }\n\n  // [Symbol.iterator]() {\n  //   return this.type[Symbol.iterator]();\n  // }\n}\n","import { toStringDefault } from '../../Util.js';\nimport { without } from '../arrays/index.js';\nimport type { MapSetOpts, MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\nimport {\n  hasAnyValue as mapHasAnyValue,\n  toArray as mapToArray,\n  find as mapFind,\n  filter as mapFilter,\n  addKeepingExisting,\n} from './MapFns.js';\nimport type { IMapOfMutableExtended } from './IMapOfMutableExtended.js';\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is a {@link Util.ToString} function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = mapOfSetMutable();\n * map.add(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = mapOfSetMutable(hash);\n * map.add(`hello`, {age:40, name: `Mary`});\n * map.add(`hello`, {age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param opts\n * @returns\n */\nexport const ofSetMutable = <V>(\n  opts?: MapSetOpts<V>\n): IMapOfMutableExtended<V, ReadonlyMap<string, V>> => {\n  const hash = opts?.hash ?? toStringDefault;\n  const comparer = (a: V, b: V) => hash(a) === hash(b);\n\n  const t: MultiValue<V, ReadonlyMap<string, V>> = {\n    get name() {\n      return `set`;\n    },\n    iterable: (source) => source.values(),\n    add: (dest, values) => addKeepingExisting(dest, hash, ...values),\n    count: (source) => source.size,\n    find: (source, predicate) => mapFind(source, predicate),\n    filter: (source, predicate) => mapFilter(source, predicate),\n    toArray: (source) => mapToArray(source),\n    has: (source, value) => mapHasAnyValue(source, value, comparer),\n    without: (source, value) => without(mapToArray(source), value, comparer),\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyMap<string, V>>(t, opts);\n  return m;\n};\n","import { isEqualDefault } from '../../IsEqual.js';\nimport { type ICircularArray, circularArray } from '../CircularArray.js';\nimport type { MapMultiOpts, MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\nimport type { IMapOfMutableExtended } from './IMapOfMutableExtended.js';\n\nexport type MapCircularOpts<V> = MapMultiOpts<V> & {\n  readonly capacity: number;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param opts\n * @returns\n */\nexport const ofCircularMutable = <V>(\n  opts: MapCircularOpts<V>\n): IMapOfMutableExtended<V, ICircularArray<V>> => {\n  const comparer = isEqualDefault;\n\n  const t: MultiValue<V, ICircularArray<V>> = {\n    get name() {\n      return `circular`;\n    },\n    add: (dest, values) => {\n      if (dest === undefined) dest = circularArray<V>(opts.capacity);\n      for (const v of values) {\n        //values.forEach(v => dest = dest?.add(v));\n        dest = dest.add(v);\n      }\n      return dest;\n    },\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(predicate),\n    filter: (source, predicate) => source.filter(predicate),\n    toArray: (source) => source,\n    iterable: (source) => source.values(),\n    has: (source, value) =>\n      source.find((v) => comparer(v, value)) !== undefined,\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n  };\n  return new MapOfMutableImpl<V, ICircularArray<V>>(t, opts);\n};\n","/**\n * Simple map for numbers.\n * \n * Keys not present in map return the `defaultValue` given in the constructor\n * ```js\n * // All keys default to zero.\n * const map = new NumberMap();\n * map.get(`hello`); // 0\n * ```\n * \n * To check if a key is present, use `has`:\n * ```js\n * map.has(`hello`); // false\n * ```\n * \n * Math:\n * ```js\n * // Adds 1 by default to value of `hello`\n * map.add(`hello`);         // 1\n * map.multiply(`hello`, 2); // 2 \n * \n * // Reset key to default value\n * map.reset(`hello`); // 0\n * ```\n * \n * Different default value:\n * ```js\n * const map = new NumberMap(10);\n * map.get(`hello`); // 10\n * ```\n * \n * Regular `set` works as well:\n * ```js\n * map.set(`hello`, 5);\n * map.add(`hello`, 2); // 7\n * ```\n */\nexport class NumberMap<K> extends Map<K, number> {\n  readonly defaultValue: number;\n\n  constructor(defaultValue = 0) {\n    super();\n    this.defaultValue = defaultValue;\n  }\n\n  get(key: K): number {\n    const v = super.get(key);\n    if (v === undefined) return this.defaultValue;\n    return v;\n  }\n\n  reset(key: K): number {\n    super.set(key, this.defaultValue);\n    return this.defaultValue;\n  }\n\n  multiply(key: K, amount: number): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value *= amount;\n    super.set(key, value);\n    return value;\n  }\n\n  add(key: K, amount = 1): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value += amount;\n    super.set(key, value);\n    return value;\n  }\n\n  subtract(key: K, amount = 1): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value -= amount;\n    super.set(key, value);\n    return value;\n  }\n}","import type { ToString } from '../../Util.js';\nimport { type IsEqual, isEqualDefault } from '../../IsEqual.js';\nimport { type IMapOfMutableExtended } from './IMapOfMutableExtended.js';\nimport { type MapMultiOpts, type MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\n\n/**\n * Map of array options\n */\nexport type MapArrayOpts<V> = MapMultiOpts<V> & {\n  /**\n   * Comparer to use\n   */\n  readonly comparer?: IsEqual<V>;\n  /**\n   * Key function\n   */\n  readonly convertToString?: ToString<V>;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: {@link Util.ToString}\n *\n * A custom {@link Util.ToString} function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param opts\n * @template V Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = <V>(\n  opts: MapArrayOpts<V> = {}\n): IMapOfMutableExtended<V, ReadonlyArray<V>> => {\n  // const toStringFunction = opts.toString === undefined ?  \n  // const comparer =\n  //   opts.comparer === undefined\n  //     ? (opts.toString === undefined\n  //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n  //       : isEqualDefault)\n  //     : opts.comparer;\n  // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n  //   const r = opts.convertToString(a) === opts.convertToString(b)\n  //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n  //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n  //   return r;\n  // };\n\n  const convertToString = opts.convertToString;\n  const toStringFunction: IsEqual<V> = typeof convertToString === `undefined` ? isEqualDefault : (a: V, b: V) => convertToString(a) === convertToString(b)\n\n  const comparer = opts.comparer ?? toStringFunction;\n\n  const t: MultiValue<V, ReadonlyArray<V>> = {\n    get name() {\n      return `array`;\n    },\n    add: (destination, values) => {\n      if (destination === undefined) return [ ...values ];\n      return [ ...destination, ...values ];\n    },\n    iterable: (source) => source.values(),\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(f => predicate(f)),\n    filter: (source, predicate) => source.filter(f => predicate(f)),\n    toArray: (source) => source,\n    has: (source, value) => source.some((v) => comparer(v, value)),\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n    //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyArray<V>>(t, opts);\n  return m;\n};\n","type WithEvents = {\n  addEventListener(type: string, callbackfn: any): void;\n  removeEventListener(type: string, callbackfn: any): void;\n}\n\n//export { eachInterval } from './flow/Interval.js';\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> =>\n  Symbol.asyncIterator in new Object(v);\n\nexport const isIterable = (v: any): v is Iterable<any> =>\n  Symbol.iterator in new Object(v);\n\nexport const eventsToIterable = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(error),\n      };\n    },\n  };\n  return r;\n};\n","import { Async } from \"../index.js\";\nimport type { GenOrData, GenFactoryNoInput, Gen } from \"./Types.js\";\nimport { isAsyncIterable } from \"../Iterable.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\n/**\n * Wrap the primitive value as generator\n * @param value \n */\nfunction* primitiveToGenerator(value: number | boolean | string) {\n  yield value;\n}\n\n/**\n * Wrap the primitive value as an async generator\n * @param value \n */\nasync function* primitiveToAsyncGenerator(value: number | boolean | string) {\n  yield value;\n  await sleep(1);\n}\n\n/**\n * Resolve the array, data or function to a Generator\n * @param input \n * @returns \n */\nexport function resolveToGen<V>(input: GenOrData<V> | GenFactoryNoInput<V>): Gen<V> {\n  if (Array.isArray(input)) {\n    const a = input.values();\n    (a as any)._name = `arrayInput`;\n    return a;\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToGenerator(input) as Gen<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  }\n  return input;\n}\n\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input \n * @returns \n */\nexport function resolveToAsyncGen<V>(input: GenOrData<V> | GenFactoryNoInput<V> | undefined): AsyncGenerator<V> | undefined {\n  if (input === undefined) return;\n  if (Array.isArray(input)) {\n    return Async.fromArray(input);\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToAsyncGenerator(input) as AsyncGenerator<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  } else if (isAsyncIterable(input)) {\n    return input;\n  }\n  return Async.fromIterable(input);\n}\n","import { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport type { Link, GenOrData, DelayOptions, RankFunction, RankOptions, RankArrayOptions } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { Elapsed } from \"../../flow/index.js\";\nimport { throwIntegerTest } from \"../../Guards.js\";\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (v: In) => Out): Link<In, Out> {\n  async function* transform(input: GenOrData<In>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield transformer(value);\n    }\n  }\n  transform._name = `transform`;\n  return transform;\n}\n\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit \n * @returns \n */\nexport function take<In>(limit: number): Link<In, In> {\n  async function* take(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let yielded = 0;\n    for await (const value of input) {\n      if (++yielded > limit) break;\n      yield value;\n    }\n  }\n  take._name = `take`;\n  return take;\n}\n\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `flattener` function.\n * \n * ```js\n * // Create a chain that flattens values\n * const flatten = Chains.flatten(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(flatten, [ 1, 2, 3]); // 3\n * ```\n * @param flattener Function to flatten array of values to a single value\n * @returns \n */\nexport function flatten<In, Out>(flattener: (v: Array<In>) => Out): Link<Array<In>, Out> {\n  async function* flatten(input: GenOrData<Array<In>>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield flattener(value);\n    }\n  }\n  flatten._name = `flatten`;\n  return flatten;\n}\n\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed \n * @returns \n */\nexport function duration<In>(elapsed: Interval): Link<In, In> {\n  const durationMs = intervalToMs(elapsed, 0);\n\n  async function* duration(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    const elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() > durationMs) break;\n      yield value;\n    }\n  }\n  duration._name = `duration`;\n  return duration;\n}\n\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options \n * @returns \n */\nexport function delay<In>(options: DelayOptions): Link<In, In> {\n  const before = intervalToMs(options.before, 0);\n  const after = intervalToMs(options.after, 0);\n\n  async function* delay(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (before > 0) {\n        await sleep(before);\n      }\n      yield value;\n      if (after > 0) {\n        await sleep(after);\n      }\n    }\n  }\n  delay._name = `delay`;\n  return delay;\n}\n\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n * \n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.chain(\n *  // Produce values every 10ms for 350ms\n *  Chains.tick({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.debounce(100)\n * );\n * ```\n * @param rate \n * @returns \n */\nexport function debounce<In>(rate: Interval): Link<In, In> {\n  const rateMs = intervalToMs(rate, 0);\n\n  async function* debounce(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() < rateMs) continue;\n      yield value;\n      elapsed = Elapsed.since();\n    }\n  }\n  debounce._name = `debounce`;\n  return debounce;\n}\n\n\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * \n * This is different than {@link total} which adds up numeric values\n * @returns \n */\nexport function tally<In>(): Link<In, number> {\n  async function* tally(input: GenOrData<In>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let count = 0;\n    for await (const _ of input) {\n      yield ++count;\n    }\n  }\n  tally._name = `tally`;\n  return tally;\n}\n\n/**\n * Returns the smallest value from the input.\n * Can work with numbers or number[] as input.\n * Non-numeric data is filtered out.\n * @returns \n */\nexport function min(): Link<number | Array<number>, number> {\n  async function* min(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let min = Number.MAX_SAFE_INTEGER;\n    for await (const value of input) {\n      const arrayValue = Array.isArray(value) ? value : [ value ]\n      for (const subValue of arrayValue) {\n        if (typeof subValue !== `number`) break;\n        min = Math.min(subValue, min);\n        yield min;\n      }\n\n      // if (typeof value !== `number`) break;\n      // min = Math.min(value, min);\n      // yield min;\n    }\n  }\n  min._name = `min`;\n  return min;\n}\n\n/**\n * Returns the largest value from the input\n * Non-numeric data is filtered out\n * @returns \n */\nexport function max(): Link<number | Array<number>, number> {\n  async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let max = Number.MIN_SAFE_INTEGER;\n    for await (const value of input) {\n      const valueArray = Array.isArray(value) ? value : [ value ];\n      for (const subValue of valueArray) {\n        if (typeof subValue !== `number`) break;\n        max = Math.max(subValue, max);\n        yield max;\n      }\n    }\n  }\n  max._name = `max`;\n  return max;\n}\n\n/**\n * Emits the currently ranked 'highest' value from a stream. Only\n * values exceeding the current highest are emitted.\n * \n * eg, if we are ranking on numerical value, an input stream of:\n * ```\n * 4, 1, 6, 10, 2, 4\n * ```\n * \n * Results in the output stream of:\n * ```\n * 4, 6, 10\n * ```\n * \n * @example \n * ```js\n * // Rank based on a field\n * Chains.Links.rank((a,b) => {\n *  if (a.size > b.size) return `a`;\n *  if (a.size < b.size) return `b`;\n *  return `eq`;\n * });\n * ```\n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}): Link<In, In> {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  async function* rank(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let best: In | undefined;\n    for await (const value of input) {\n      let emit = false;\n      if (includeType && typeof value !== includeType) continue;\n      if (best === undefined) {\n        best = value;\n        emit = true;\n      } else {\n        const result = r(value, best);\n        //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n        if (result == `a`) {\n          // New value is the current best\n          best = value;\n          emit = true;\n        } else if (result === `eq` && emitEqualRanked) {\n          // New value is same rank as previous, but we have flag on\n          emit = true;\n        } else if (emitRepeatHighest) {\n          // Emit current highest due to flag\n          emit = true;\n        }\n      }\n      if (emit) yield best;\n    }\n  }\n  rank._name = `rank`;\n  return rank;\n}\n\n/**\n * Emits the highest-ranked value from amongst an array of values.\n * \n * By default, it tracks the highest-ranked _between_ arrays.\n * \n * For example:\n * ```js\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Outputs:\n * [ 6 ]\n * ```\n * \n * This behaviour can be modified with an option to only compare _within_ arrays.\n * ```\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Output:\n * [ 6, 3 ]\n * ```\n * \n * Uses the `rank` option to determine which is more highly ranked.\n * ```js\n * Chains.Links.rankArray(\n *  (a, b) => {\n *    if (a > b) return `a`; // a is higher\n *    else if (b > a) return `b`; // b is higher\n *    return `eq`; // same\n *  }\n * )\n * ```\n * @param options \n * @returns \n */\nexport function rankArray<In>(r: RankFunction<In>, options: Partial<RankArrayOptions> = {}): Link<Array<In>, In> {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  const withinArrays = options.withinArrays ?? false;\n\n  async function* rankArray(input: GenOrData<Array<In>>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let best: In | undefined;\n    for await (const value of input) {\n      let emit = false;\n      if (withinArrays) best = undefined; // Reset\n      for (const subValue of value) {\n        if (includeType && typeof subValue !== includeType) continue;\n        if (best === undefined) {\n          best = subValue;\n          emit = true;\n        } else {\n          const result = r(subValue, best);\n          if (result == `a`) {\n            // New value is the current best\n            best = subValue;\n            emit = true;\n          } else if (result === `eq` && emitEqualRanked) {\n            // New value is same rank as previous, but we have flag on\n            emit = true;\n          } else if (emitRepeatHighest) {\n            // Emit current highest due to flag\n            emit = true;\n          }\n        }\n      }\n\n      if (emit && best) yield best;\n    }\n  }\n  rankArray._name = `rankArray`;\n  return rankArray;\n}\n\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function average(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    let count = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      count++;\n      total += value;\n      yield total / count;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function total(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      total += value;\n      yield total;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Chunks an input stream into `size` chunks.\n * \n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n * \n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size \n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns \n */\nexport function chunk<In>(size: number, returnRemainders = true): Link<In, Array<In>> {\n  throwIntegerTest(size, `aboveZero`, `size`);\n  async function* chunk(input: GenOrData<In>): AsyncGenerator<Array<In>> {\n    input = resolveToGen(input);\n    let buffer: Array<In> = [];\n    for await (const value of input) {\n      buffer.push(value);\n      if (buffer.length >= size) {\n        yield buffer;\n        buffer = []\n      }\n    }\n    if (returnRemainders && buffer.length > 0) yield buffer;\n  }\n  chunk._name = `chunk`;\n  return chunk;\n}\n\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n * \n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate \n * @returns \n */\nexport function filter<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* filter(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  filter._name = `filter`;\n  return filter;\n}\n\n\n\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n * \n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate \n * @returns \n */\nexport function drop<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* drop(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (!predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  drop._name = `drop`;\n  return drop;\n}\n","//import { query as DomQuery } from \"../../dom/Query.js\";\n\nimport type { GenOrData, Link } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { resolveEl } from \"../../dom/ResolveEl.js\";\nimport { toStringDefault } from \"../../Util.js\";\n\nexport type QueryOptions = {\n  baseElement: HTMLElement;\n}\n\nexport type CreateOptions<In> = {\n  /**\n   * Parent element to create elements in. Defaults to `document.body`.\n   */\n  parentEl: string | HTMLElement\n  /**\n   * When set, provide a custom function to return a unique key for a value.\n   * This is used for matching values with elements when using immutable data.\n   * \n   * By default uses the\n   * JSON.stringify() representation.\n   * \n   * To match elements with values by reference, set `byReference` instead.\n   * \n   * @param value \n   * @returns \n   */\n  key: (value: In) => string\n  /**\n   * Default: _false_. When _true_, associate created elements\n   * to values by reference rather than value. This can be useful with mutable values.\n   * \n   * Use this _or_ the `key` option.\n   */\n  byReference: boolean\n  /**\n   * What kind of HTML element to make, defaults to DIV\n   */\n  tagName: string\n  /**\n   * Called whenever an element is created but not yet added to parent element\n   * @param element \n   * @returns \n   */\n  beforeInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element is inserted to the parent element\n   */\n  afterInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element has been removed\n   * @param element \n   * @returns \n   */\n  beforeRemove: (element: HTMLElement) => void\n}\n\nconst createMap = <T, TValue>(key?: (value: T) => string) => {\n  const keyFunction = key ?? ((value: T) => value);\n\n  const map = new Map<ReturnType<typeof keyFunction>, TValue>();\n  return {\n    has(key: T) {\n      return map.has(keyFunction(key));\n    },\n    get(key: T) {\n      return map.get(keyFunction(key));\n    },\n    set(key: T, value: TValue) {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      //console.log(`Chains.Dom.createMap: key: ${ keyFunction(key) } value: ${ value }`);\n      map.set(keyFunction(key), value);\n    },\n    entries() {\n      return map.entries();\n    },\n    delete(key: T | string) {\n      map.delete(key);\n    }\n  }\n\n}\n\nexport type ElementWithValue<T> = {\n  el: HTMLElement\n  value: T\n}\n\n/**\n * Creates a HTML element per value. By default compares\n * values by `JSON.stringify`. Set `byReference:true` to\n * compare values based on reference. Or provide a toString\n * function via `key`.\n * \n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n * \n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n * ```\n */\nexport function perValue<In>(options: Partial<CreateOptions<In>> = {}): Link<In, ElementWithValue<In>> {\n  const byReference = options.byReference;\n  const tagName = options.tagName ?? `div`;\n  if (byReference && options.key) throw new Error(`byReference and key options are mutually exclusive`);\n  const keyFunction = byReference ? undefined : options.key ?? toStringDefault;\n  const map = createMap<In, HTMLElement>(keyFunction);\n  const parentElementOrQuery = options.parentEl ?? document.body;\n  const parentEl = resolveEl(parentElementOrQuery);\n\n  const usedElements = new Set<HTMLElement>();\n\n  async function* perValue(input: GenOrData<In>): AsyncGenerator<ElementWithValue<In>> {\n    for await (const value of resolveToGen(input)) {\n      let el = map.get(value);\n      if (!el) {\n        el = document.createElement(tagName);\n        map.set(value, el);\n        if (options.beforeInsert) options.beforeInsert(el);\n        parentEl.append(el);\n        if (options.afterInsert) options.afterInsert(el);\n      }\n      usedElements.add(el);\n      yield { el, value };\n    }\n\n    // Remove unused elements\n    for (const [ id, el ] of map.entries()) {\n      if (usedElements.has(el)) continue;\n      if (options.beforeRemove) options.beforeRemove(el);\n      el.remove();\n      map.delete(id);\n    }\n  }\n  perValue._name = `dom.perValue`;\n  return perValue;\n}\n\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options \n * @returns \n */\nexport function query(options: Partial<QueryOptions> = {}): Link<string, HTMLElement> {\n  const baseElement = options.baseElement ?? document;\n\n  async function* query(input: GenOrData<string>): AsyncGenerator<HTMLElement> {\n    const gen = resolveToGen(input);\n    for await (const value of gen) {\n      for (const element of baseElement.querySelectorAll(value)) {\n        yield element as HTMLElement;\n      }\n    }\n  }\n  query._name = `dom.query`;\n  return query;\n}\n\n"],"mappings":"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","names":["chunk","between","interval","asDynamicTraversable","children","depthFirst","toStringDeep","compare","compare","value","root","children","children","toStringDeep","filter","value","depthFirst","asDynamicTraversable","create","create","root","add","value","prettyPrint","remove","childrenLength","count","breadthFirst","childrenLength","depthFirst","find","findAnyChildByValue","findChildByValue","followValue","hasAnyChild","hasAnyParent","hasChild","hasParent","parents","toString","toStringDeep","childrenLength","hasAnyParent","hasParent","hasAnyChild","hasChild","breadthFirst","parents","findAnyChildByValue","findChildByValue","depthFirst","root","find","followValue","toStringDeep","toString","children","asDynamicTraversable","create","immutable","mutable","create","value","key","existing","add","value","immutable","add","value","mutable","add","data","value","asArray","set","value","value","value","value","value","value","filter","transform","value","take","flatten","duration","elapsed","delay","debounce","tally","count","min","max","rank","rankArray","average","total","chunk","filter","drop","value","key","perValue","query","filter","fromFunction","fromEvent","asPromise","asValue","value","interval"]}