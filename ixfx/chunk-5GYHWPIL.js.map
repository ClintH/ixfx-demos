{"version":3,"sources":["../src/collections/Map/index.ts","../src/collections/Map/ExpiringMap.ts","../src/collections/index.ts","../src/collections/CircularArray.ts","../src/collections/stack/index.ts","../src/collections/stack/StackImmutable.ts","../src/collections/Map/MapImmutableFns.ts","../src/collections/Map/Map.ts","../src/collections/Map/MapMutable.ts","../src/collections/Map/MapOfMultiImpl.ts","../src/collections/Map/MapOfSetMutable.ts","../src/collections/Map/MapOfCircularMutable.ts","../src/collections/Map/NumberMap.ts","../src/collections/Map/MapOfArrayMutable.ts"],"sourcesContent":["export { create as expiringMap, ExpiringMap } from './ExpiringMap.js';\nexport type {\n  ExpiringMapEvent,\n  ExpiringMapEvents,\n  Opts as ExpiringMapOpts,\n} from './ExpiringMap.js';\n\nexport type { IMapOf } from './IMapOf.js';\nexport { immutable, type IMapImmutable } from './Map.js';\nexport { mutable, type IMapMutable } from './MapMutable.js';\nexport { ofSetMutable } from './MapOfSetMutable.js';\nexport { ofCircularMutable } from './MapOfCircularMutable.js';\nexport type { MapCircularOpts } from './MapOfCircularMutable.js';\nexport type { IMapOfMutable } from './IMapOfMutable.js';\nexport type { IMappish, IWithEntries } from './IMappish.js';\nexport type { MapArrayOpts } from './MapOfArrayMutable.js';\nexport { NumberMap } from './NumberMap.js';\nexport * from './MapMulti.js';\nexport * from './MapFns.js';\nexport * from './GetOrGenerate.js';","import { SimpleEventEmitter } from '../../Events.js';\nimport { sortByValueProperty } from './MapFns.js';\nimport { throwIntegerTest } from '../../Guards.js';\n\n/**\n * Expiring map options\n */\nexport type Opts = {\n  /**\n   * Capacity limit\n   */\n  readonly capacity?: number;\n  /**\n   * Policy for evicting items if capacity is reached\n   */\n  readonly evictPolicy?: `none` | `oldestGet` | `oldestSet`;\n  /**\n   * Automatic deletion policy.\n   * none: no automatic deletion (default)\n   * get/set: interval based on last get/set\n   * either: if either interval has elapsed\n   */\n  readonly autoDeletePolicy?: `none` | `get` | `set` | `either`;\n  /**\n   * Automatic deletion interval\n   */\n  readonly autoDeleteElapsedMs?: number;\n};\n\ntype Item<V> = {\n  readonly value: V;\n  readonly lastSet: number;\n  readonly lastGet: number;\n};\n\n/**\n * Event from the ExpiringMap\n */\nexport type ExpiringMapEvent<K, V> = {\n  readonly key: K;\n  readonly value: V;\n};\n\nexport type ExpiringMapEvents<K, V> = {\n  /**\n   * Fires when an item is removed due to eviction\n   * or automatic expiry\n   */\n  readonly expired: ExpiringMapEvent<K, V>;\n  /**\n   * Fires when a item with a new key is added\n   */\n  readonly newKey: ExpiringMapEvent<K, V>;\n\n  /**\n   * Fires when an item is manually removed,\n   * removed due to eviction or automatic expiry\n   */\n  readonly removed: ExpiringMapEvent<K, V>;\n};\n\n/**\n * Create a ExpiringMap instance\n * @param opts\n * @returns\n */\nexport const create = <K, V>(opts: Opts = {}): ExpiringMap<K, V> =>\n  new ExpiringMap(opts);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using `touch(key)`.\n *\n *\n * Events:\n * * `expired`: when an item is automatically removed.\n * * `removed`: when an item is manually or automatically removed.\n * * `newKey`: when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example Automatically delete the oldest item if we reach a capacity limit\n * ```\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n */\nexport class ExpiringMap<K, V> extends SimpleEventEmitter<\n  ExpiringMapEvents<K, V>\n> {\n  private capacity: number;\n  private store: Map<K, Item<V>>;\n  private keyCount: number;\n  private evictPolicy;\n\n  private autoDeleteElapsedMs: number;\n  private autoDeletePolicy;\n\n  constructor(opts: Opts = {}) {\n    super();\n    this.capacity = opts.capacity ?? -1;\n\n    throwIntegerTest(this.capacity, `nonZero`, `capacity`);\n    this.store = new Map();\n    this.keyCount = 0;\n\n    if (opts.evictPolicy && this.capacity <= 0) {\n      throw new Error(`evictPolicy is set, but no capacity limit is set`);\n    }\n    this.evictPolicy = opts.evictPolicy ?? `none`;\n    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n\n    if (this.autoDeleteElapsedMs > 0) {\n      setInterval(\n        () => this.#maintain(),\n        Math.max(1000, this.autoDeleteElapsedMs * 2)\n      );\n    }\n  }\n\n  /**\n   * Returns the number of keys being stored.\n   */\n  get keyLength() {\n    return this.keyCount;\n  }\n\n  *entries(): IterableIterator<[ k: K, v: V ]> {\n    for (const entry of this.store.entries()) {\n      yield [ entry[ 0 ], entry[ 1 ].value ];\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const v of this.store.values()) {\n      yield v.value;\n    }\n  }\n\n  *keys(): IterableIterator<K> {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was set. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedSet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (!v) return v;\n    return Date.now() - v.lastSet;\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was accessed. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedGet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (!v) return v;\n    return Date.now() - v.lastGet;\n  }\n\n  /**\n   * Returns true if `key` is stored.\n   * Does not affect the key's last access time.\n   * @param key\n   * @returns\n   */\n  has(key: K): boolean {\n    return this.store.has(key);\n  }\n\n  /**\n   * Gets an item from the map by key, returning\n   * undefined if not present\n   * @param key Key\n   * @returns Value, or undefined\n   */\n  get(key: K): V | undefined {\n    const v = this.store.get(key);\n    if (v) {\n      return v.value;\n    }\n  }\n\n  /**\n   * Deletes the value under `key`, if present.\n   *\n   * Returns _true_ if something was removed.\n   * @param key\n   * @returns\n   */\n  delete(key: K): boolean {\n    const val = this.store.get(key);\n    if (!val) return false;\n    const d = this.store.delete(key);\n    this.keyCount = this.keyCount - 1;\n    this.fireEvent(`removed`, {\n      key,\n      value: val.value,\n    });\n    return d;\n  }\n\n  /**\n   * Updates the lastSet/lastGet time for a value\n   * under `k`.\n   *\n   * Returns false if key was not found\n   * @param key\n   * @returns\n   */\n  touch(key: K): boolean {\n    const v = this.store.get(key);\n    if (!v) return false;\n    this.store.set(key, {\n      ...v,\n      lastSet: Date.now(),\n      lastGet: Date.now(),\n    });\n    return true;\n  }\n\n  private findEvicteeKey() {\n    if (this.evictPolicy === `none`) return null;\n    //eslint-disable-next-line functional/no-let\n    let sortBy = ``;\n    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;\n    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;\n    else throw Error(`Unknown eviction policy ${ this.evictPolicy }`);\n    const sorted = sortByValueProperty(this.store, sortBy);\n    return sorted[ 0 ][ 0 ];\n  }\n\n  #maintain() {\n    if (this.autoDeletePolicy === `none`) return;\n    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n  }\n\n  /**\n   * Deletes all values where elapsed time has past\n   * for get/set or either.\n   *\n   * Remove items are returned\n   * @param time\n   * @param prop get/set/either\n   */\n  deleteWithElapsed(\n    time: number,\n    prop: `get` | `set` | `either`\n  ): [ k: K, v: V ][] {\n    const entries = [ ...this.store.entries() ];\n    const prune: [ k: K, v: V ][] = [];\n    const now = Date.now();\n    for (const e of entries) {\n      const elapsedGet = now - e[ 1 ].lastGet;\n      const elapsedSet = now - e[ 1 ].lastSet;\n      const elapsed =\n        prop === `get`\n          ? elapsedGet\n          : prop === `set`\n            ? elapsedSet\n            : Math.max(elapsedGet, elapsedSet);\n      if (elapsed >= time) {\n        prune.push([ e[ 0 ], e[ 1 ].value ]);\n      }\n    }\n\n    for (const e of prune) {\n      this.store.delete(e[ 0 ]);\n      this.keyCount = this.keyCount - 1;\n      const eventArgs = {\n        key: e[ 0 ],\n        value: e[ 1 ],\n      };\n      this.fireEvent(`expired`, eventArgs);\n      this.fireEvent(`removed`, eventArgs);\n    }\n    return prune;\n  }\n\n  /**\n   * Sets the `key` to be `value`.\n   *\n   * If the key already exists, it is updated.\n   *\n   * If the map is full, according to its capacity,\n   * another value is selected for removal.\n   * @param key\n   * @param value\n   * @returns\n   */\n  set(key: K, value: V) {\n    const existing = this.store.get(key);\n\n    if (existing) {\n      // Update set time\n      this.store.set(key, {\n        ...existing,\n        lastSet: performance.now(),\n      });\n      return;\n    }\n\n    // New key\n    if (this.keyCount === this.capacity && this.capacity > 0) {\n      // Evict first\n      const key = this.findEvicteeKey();\n      if (!key) {\n        throw new Error(`ExpiringMap full (capacity: ${ this.capacity })`);\n      }\n      const existing = this.store.get(key);\n      this.store.delete(key);\n      this.keyCount = this.keyCount - 1;\n      if (existing) {\n        const eventArgs = { key, value: existing.value };\n        this.fireEvent(`expired`, eventArgs);\n        this.fireEvent(`removed`, eventArgs);\n      }\n    }\n\n    this.keyCount++;\n    this.store.set(key, {\n      lastGet: 0,\n      lastSet: Date.now(),\n      value: value,\n    });\n\n    this.fireEvent(`newKey`, { key, value });\n  }\n}\n","export type ArrayKeys<K, V> = ReadonlyArray<readonly [ key: K, value: V ]>;\nexport type ObjectKeys<K, V> = ReadonlyArray<{\n  readonly key: K;\n  readonly value: V;\n}>;\nexport type EitherKey<K, V> = ArrayKeys<K, V> | ObjectKeys<K, V>;\n\nexport {\n  circularArray,\n  type ICircularArray as CircularArray,\n} from './CircularArray.js';\nexport * as Trees from './tree/index.js';\n\nexport * as Iterables from './Iterables.js';\n\n/**\n * Stacks store items in order.\n *\n * Stacks and queues can be helpful for processing data in order. They each have slightly different behaviour.\n *\n * Like a stack of plates, the newest item (on top) is removed\n * before the oldest items (at the bottom). {@link Queues} operate differently, with\n * the oldest items (at the front of the queue) removed before the newest items (at the end of the queue).\n *\n * Create stacks with {@link Stacks.immutable} or {@link Stacks.mutable}. These return a {@link IStackImmutable} or {@link IStackMutable} respectively.\n *\n * The ixfx implementation allow you to set a capacity limit with three {@link StackDiscardPolicy |policies} for\n * how items are evicted.\n *\n */\nexport * as Stacks from './stack/index.js';\n\nexport { StackMutable } from './stack/StackMutable.js';\nexport { StackImmutable } from './stack/StackImmutable.js';\n\n/**\n * Arrays are a list of data. ixfx provides a number of functions for working with arrays in an immutable manner.\n * This means that the input array is not changed.\n *\n * Import example:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * ```\n * \n * For arrays of numbers:\n * * {@link average}, {@link max}, {@link min}, {@link total}: Calculate average/max/min/total\n * * {@link averageWeighted}: Calculate average, but applies a weighting function, eg to favour items at beginning of array\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * {@link maxIndex}, {@link minIndex}: Return index of largest/smallest value\n * * {@link dotProduct}: Returns the dot-product between two arrays\n * * {@link weight}: Applies a weighting function to all values based on their index\n *\n * Randomisation\n * * {@link randomIndex}: Return a random array index\n * * {@link randomElement}: Return a random value\n * * {@link randomPluck}: Remove a random element from an array, returning it and the new array\n * * {@link shuffle}: Returns a randomly-sorted copy of arra\n *\n * Finding/accessing\n * * {@link filterBetween}: Same as `Array.filter` but only looks within a specified index range\n * * {@link sample}: Returns a new array with a random sampling of input\n * * {@link valuesEqual}: Returns true if all the values in the array are identical\n *\n * Changing the shape\n * * {@link ensureLength}: Returns a copy of array with designated length, either padding it out or truncating as necessary\n * * {@link groupBy}: Groups data into a new Map\n * * {@link interleave}: Flattens several arrays into one, interleaving their values.\n * * {@link remove}: Remove an item by index\n * * {@link without}: Returns an array with specified value omitted\n * * {@link zip}: Groups together elements from several arrays based on their index\n */\nexport * as Arrays from './arrays/index.js';\n\n/**\n * Sets store unique items.\n *\n * ixfx's {@link ISetImmutable} (or {@link ISetMutable}) compares items by value rather than reference, unlike the default JS implementation.\n *\n * Create using {@link Sets.immutable} or {@link Sets.mutable}\n */\nexport * as Sets from './set/index.js';\n\n\nexport { SetStringMutable } from './set/SetMutable.js';\nexport { SetStringImmutable } from './set/SetImmutable.js';\n\n\n/**\n * Queues store items in the order in which they are added.\n *\n * Stacks and queues can be helpful when it's necessary to process data in order, but each one has slightly different behaviour.\n *\n * Like lining up at a bakery, the oldest items (at the front of the queue) are removed\n * before the newest items (at the end of the queue). This is different to {@link Stacks},\n * where the newest item (on top) is removed before the oldest items (at the bottom).\n *\n * The ixfx implementations allow you to set a capacity limit with three {@link QueueDiscardPolicy | policies} for\n * how items are evicted.\n *\n * Create queues with {@link Queues.immutable} or {@link Queues.mutable}. These return a {@link IQueueImmutable} or {@link IQueueMutable} respectively.\n */\nexport * as Queues from './queue/index.js';\n\nexport { QueueMutable } from './queue/QueueMutable.js';\nexport { QueueImmutable } from './queue/QueueImmutable.js';\n\n\n/**\n * Maps associate keys with values. Several helper functions are provided\n * for working with the standard JS Map class.\n *\n * Import example\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/collections.js';\n * ```\n * \n * ixfx also includes {@link Maps.IMapMutable}, {@link Maps.IMapImmutable}\n *\n * Overview:\n * * {@link getOrGenerate}: Solves a common scenario of wanting a value by a particular key, or generating it if it doesn't exist\n * * {@link filter}: Yields values in map that match a predicate\n * * {@link find}: Finds the first value that matches a predicate, or _undefined_ if nothing found\n * * {@link hasAnyValue}: Searches through all keys, returning true if any occurence of _value_ was found\n *\n * Transformations:\n * * {@link toArray}: Returns the values of the map as an array\n * * {@link mapToArray}: Applies a function to convert a map's values to an array\n * * {@link toObject}: Coverts a Map to a plain object, useful for JSON serialising.\n * * {@link mapToObjectTransform}: Converts a map to a plain object, but applying a function to values\n * * {@link transformMap}: Like `Array.map`, but for Maps. Useful for generating a map as a transform of an input map.\n * * {@link zipKeyValue}: Given an array of keys and values, combines them together into a map\n */\nexport * as Maps from './map/index.js';\n\n\n","import { throwIntegerTest } from '../Guards.js';\n\n/**\n * The circular array is immutable. It keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n * @example\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`); // Because it's immutable, capture the return result of `add`\n * a.isFull;  // True if circular array is full\n * a.pointer; // The current position in array it will write to\n * ```\n * @class CircularArray\n * @extends Array\n */\nexport interface ICircularArray<V> extends Array<V> {\n  /**\n   * Returns true if the array has filled to capacity and is now\n   * recycling array indexes.\n   */\n  get isFull(): boolean;\n\n  /**\n   * Returns a new Circular with item added\n   *\n   * Items are added at `pointer` position, which automatically cycles through available array indexes.\n   *\n   * @param v Thing to add\n   * @returns Circular with item added\n   * @memberof Circular\n   */\n  add(v: V): ICircularArray<V>;\n\n  get length(): number;\n\n  /**\n   * Returns the current add position of array.\n   */\n  get pointer(): number;\n}\n\nclass CircularArray<V> extends Array {\n  // ✔ Class is unit tested!\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  #capacity: number;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  #pointer: number;\n\n  constructor(capacity = 0) {\n    super();\n    // Allowed to create with capacity zero\n    throwIntegerTest(capacity, `positive`, `capacity`);\n\n    // Can't throw because .filter won't use ctor proprly\n    this.#capacity = capacity;\n    this.#pointer = 0;\n  }\n\n  /**\n   * Add to array\n   * @param thing Thing to add\n   * @returns \n   */\n  add(thing: V): CircularArray<V> {\n    const ca = CircularArray.from(this) as CircularArray<V>;\n    /* eslint-disable-next-line functional/immutable-data */\n    ca[ this.#pointer ] = thing;\n    /* eslint-disable-next-line functional/immutable-data */\n    ca.#capacity = this.#capacity;\n    if (this.#capacity > 0) {\n      /* eslint-disable-next-line functional/immutable-data */\n      ca.#pointer =\n        this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n    } else {\n      /* eslint-disable-next-line functional/immutable-data */\n      ca.#pointer = this.#pointer + 1;\n    }\n    return ca;\n  }\n\n  get pointer(): number {\n    return this.#pointer;\n  }\n\n  get isFull(): boolean {\n    if (this.#capacity === 0) return false;\n    return this.length === this.#capacity;\n  }\n}\n\n/**\n * Returns a new circular array. Immutable. A circular array only keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = circularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport const circularArray = <V>(capacity: number): ICircularArray<V> =>\n  new CircularArray<V>(capacity);\n","export type { IStack } from './IStack.js';\nexport type { IStackMutable } from './IStackMutable.js';\nexport type { IStackImmutable } from './IStackImmutable.js';\n\n// ✔ Unit tested!\nexport type StackDiscardPolicy = `older` | `newer` | `additions`;\n\nexport type StackOpts = {\n  readonly debug?: boolean;\n  readonly capacity?: number;\n  readonly discardPolicy?: StackDiscardPolicy;\n};\n\nexport { immutable } from './StackImmutable.js';\nexport { mutable } from './StackMutable.js';\n","// -------------------------\n// Immutable\n// -------------------------\nimport type { IStackImmutable } from './IStackImmutable.js';\nimport { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nimport type { StackOpts } from './index.js';\n\nexport class StackImmutable<V> implements IStackImmutable<V> {\n  private readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  push(...toAdd: ReadonlyArray<V>): StackImmutable<V> {\n    return new StackImmutable<V>(\n      this.opts,\n      push(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  pop(): IStackImmutable<V> {\n    return new StackImmutable<V>(this.opts, pop(this.opts, this.data));\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [...this.data].reverse().forEach(fn);\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param opts Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = <V>(\n  opts: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackImmutable<V> => new StackImmutable({ ...opts }, [...startingItems]);\n","import type { ArrayKeys, EitherKey, ObjectKeys } from '../index.js';\n\n/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ArrayKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d[ 0 ] === undefined) throw new Error(`key cannot be undefined`);\n    if (d[ 1 ] === undefined) throw new Error(`value cannot be undefined`);\n    x.set(d[ 0 ], d[ 1 ]);\n  }\n  return x;\n};\n\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ObjectKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\n\n    x.set(d.key, d.value);\n  }\n  return x;\n};\n\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = <K, V>(map: ReadonlyMap<K, V>, key: K): boolean =>\n  map.has(key);\n\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = <K, V>(\n  map: ReadonlyMap<K, V>,\n  ...data: EitherKey<K, V>\n): ReadonlyMap<K, V> => {\n  if (map === undefined) throw new Error(`map parameter is undefined`);\n  if (data === undefined) throw new Error(`data parameter i.s undefined`);\n  if (data.length === 0) return map;\n\n  const firstRecord = data[ 0 ];\n  const isObject =\n    typeof (firstRecord as { readonly key: K; readonly value: V }).key !==\n    `undefined` &&\n    typeof (firstRecord as { readonly key: K; readonly value: V }).value !==\n    `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n  return isObject\n    ? addObjects(map, data as ObjectKeys<K, V>)\n    : addArray(map, data as ArrayKeys<K, V>);\n};\n\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key: K, value: V) => {\n  const x = new Map<K, V>(map.entries());\n  x.set(key, value);\n  return x;\n};\n\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  x.delete(key);\n  return x;\n};\n","import { type EitherKey } from '../index.js';\nimport type { IMapBase } from './IMapBase.js';\nimport { add, del, set } from './MapImmutableFns.js';\n\n/**\n * An immutable map. Rather than changing the map, functions like `add` and `delete`\n * return a new map reference which must be captured.\n *\n * Immutable data is useful because as it gets passed around your code, it never\n * changes from underneath you. You have what you have.\n *\n * @example\n * ```js\n * let m = map(); // Create\n * let m2 = m.set(`hello`, `samantha`);\n * // m is still empty, only m2 contains a value.\n * ```\n *\n * @template K Type of map keys. Typically `string`\n * @template V Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapImmutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items, returning the changed map.\n   *\n   * Can add items in the form of `[key,value]` or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): IMapImmutable<K, V>;\n  /**\n   * Deletes an item by key, returning the changed map\n   * @param key\n   */\n  delete(key: K): IMapImmutable<K, V>;\n  /**\n   * Returns an empty map\n   */\n  clear(): IMapImmutable<K, V>;\n\n\n  /**\n   * Sets `key` to be `value`, overwriting anything existing.\n   * Returns a new map with added key.\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): IMapImmutable<K, V>;\n\n}\n\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = <K, V>(\n  dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>\n): IMapImmutable<K, V> => {\n  if (dataOrMap === undefined) return immutable([]);\n  if (Array.isArray(dataOrMap)) return immutable<K, V>(add(new Map(), ...dataOrMap));\n\n  const data = dataOrMap as ReadonlyMap<K, V>;\n  return {\n    add: (...itemsToAdd: EitherKey<K, V>) => {\n      const s = add(data, ...itemsToAdd);\n      return immutable(s);\n    },\n    set: (key: K, value: V) => {\n      const s = set(data, key, value);\n      return immutable(s);\n    },\n    get: (key: K) => data.get(key),\n    delete: (key: K) => immutable(del(data, key)),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    clear: () => immutable(),\n    has: (key: K) => data.has(key),\n    entries: () => data.entries(),\n    values: () => data.values(),\n    isEmpty: () => data.size === 0,\n  };\n};\n","import { type EitherKey } from '../index.js';\nimport type { IMapBase } from './IMapBase.js';\nimport { add, del, set, has } from './MapImmutableFns.js';\n\n/**\n * A mutable map.\n *\n * It is a wrapper around the in-built Map type, but adds roughly the same API as {@link IMapImmutable}.\n *\n * @template K Type of map keys. Typically `string`\n * @template V Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapMutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items to map\n   *\n   * Can add items in the form of [key,value] or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): void;\n  /**\n   * Sets a value to a specified key\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): void;\n  /**\n   * Deletes an item by key\n   * @param key\n   */\n  delete(key: K): void;\n  /**\n   * Clears map\n   */\n  clear(): void;\n}\n\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = <K, V>(...data: EitherKey<K, V>): IMapMutable<K, V> => {\n  // eslint-disable-next-line functional/no-let\n  let m = add(new Map<K, V>(), ...data);\n  return {\n    add: (...data: EitherKey<K, V>) => {\n      m = add(m, ...data);\n    },\n    delete: (key: K) => {\n      m = del(m, key);\n    },\n    clear: () => {\n      m = add(new Map<K, V>());\n    },\n    set: (key: K, value: V): void => {\n      m = set(m, key, value);\n    },\n    get: (key: K): V | undefined => m.get(key),\n    entries: () => m.entries(),\n    values: () => m.values(),\n    isEmpty: () => m.size === 0,\n    has: (key: K) => has(m, key),\n  };\n};\n","import {\n  type IsEqual,\n  isEqualDefault\n} from '../../IsEqual.js';\nimport type {\n  MapArrayEvents,\n  IMapOfMutableExtended,\n} from './IMapOfMutableExtended.js';\nimport type { MapMultiOpts, MultiValue } from './MapMulti.js';\nimport { SimpleEventEmitter } from '../../Events.js';\nimport type { IMapOf } from './IMapOf.js';\nimport { toStringDefault, type ToString } from '../../Util.js';\n\n/**\n * @internal\n */\nexport class MapOfMutableImpl<V, M>\n  extends SimpleEventEmitter<MapArrayEvents<V>>\n  implements IMapOfMutableExtended<V, M>\n{\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #map = new Map<string, M>();\n  readonly groupBy: ToString<V>;\n  readonly type: MultiValue<V, M>;\n\n  constructor(type: MultiValue<V, M>, opts: MapMultiOpts<V> = {}) {\n    super();\n    this.type = type;\n    this.groupBy = opts.groupBy ?? toStringDefault;\n  }\n\n  /**\n   * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n   */\n  get typeName() {\n    return this.type.name;\n  }\n\n  /**\n   * Returns the number of keys\n   */\n  get lengthKeys(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns the length of the longest child list\n   */\n  get lengthMax() {\n    //eslint-disable-next-line functional/no-let\n    let m = 0;\n    for (const v of this.#map.values()) {\n      m = Math.max(m, this.type.count(v));\n    }\n    return m;\n  }\n\n  debugString(): string {\n    const keys = [ ...this.#map.keys() ];\n    // eslint-disable-next-line functional/no-let\n    let r = `Keys: ${ keys.join(`, `) }\\r\\n`;\n    for (const k of keys) {\n      const v = this.#map.get(k);\n      if (v === undefined) {\n        r += ` - ${ k } (undefined)\\r\\n`\n      } else {\n        const asArray = this.type.toArray(v);\n        if (asArray !== undefined) {\n          r += ` - ${ k } (${ this.type.count(v) }) = ${ JSON.stringify(\n            asArray\n          ) }\\r\\n`;\n        }\n      }\n    };\n    return r;\n  }\n\n  get isEmpty(): boolean {\n    return this.#map.size === 0;\n  }\n\n  clear() {\n    this.#map.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  addKeyedValues(key: string, ...values: Array<V>) {\n    const set = this.#map.get(key);\n    if (set === undefined) {\n      this.#map.set(key, this.type.add(undefined, values));\n      super.fireEvent(`addedKey`, { key: key });\n      super.fireEvent(`addedValues`, { values: values });\n    } else {\n      // eslint-disable-next-line functional/immutable-data\n      this.#map.set(key, this.type.add(set, values));\n      super.fireEvent(`addedValues`, { values: values });\n    }\n  }\n  //eslint-disable-next-line functional/prefer-immutable-types\n  set(key: string, values: Array<V>) {\n    this.addKeyedValues(key, ...values);\n    return this;\n  }\n\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) this.addKeyedValues(this.groupBy(v), v);\n  }\n\n  hasKeyValue(key: string, value: V, eq: IsEqual<V>): boolean {\n    const m = this.#map.get(key);\n    if (m === undefined) return false;\n    return this.type.has(m, value, eq);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.#map.has(key);\n  }\n\n  deleteKeyValue(key: string, value: V): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    return this.deleteKeyValueFromMap(a, key, value);\n  }\n\n  private deleteKeyValueFromMap(map: M, key: string, value: V): boolean {\n    const preCount = this.type.count(map);\n    const filtered = this.type.without(map, value);\n    const postCount = filtered.length;\n    this.#map.set(key, this.type.add(undefined, filtered));\n    return preCount > postCount;\n  }\n\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let something = false;\n    [ ...this.#map.keys() ].filter((key) => {\n      const a = this.#map.get(key);\n      if (!a) throw new Error(`Bug: map could not be accessed`);\n      if (this.deleteKeyValueFromMap(a, key, value)) {\n        something = true; // note that something was deleted\n\n        // If key is empty, delete it\n        if (this.count(key) === 0) this.delete(key);\n      }\n    });\n    return something;\n  }\n\n  delete(key: string): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    this.#map.delete(key);\n    this.fireEvent(`deleteKey`, { key: key });\n    return true;\n  }\n\n  firstKeyByValue(\n    value: V,\n    eq: IsEqual<V> = isEqualDefault\n  ): string | undefined {\n    const keys = [ ...this.#map.keys() ];\n    const found = keys.find((key) => {\n      const a = this.#map.get(key);\n      if (a === undefined) throw new Error(`Bug: map could not be accessed`);\n      const r = this.type.has(a, value, eq);\n      return r;\n    });\n    return found;\n  }\n\n  count(key: string): number {\n    const entry = this.#map.get(key);\n    if (entry === undefined) return 0;\n    return this.type.count(entry);\n  }\n\n  /**\n   * Iterates over values stored under `key`\n   * An empty array is returned if there are no values\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  /**\n   * Iterate over the values stored under `key`.\n   * If key does not exist, iteration is essentially a no-op\n   * @param key\n   * @returns\n   */\n  *valuesFor(key: string) {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  getSource(key: string): M | undefined {\n    return this.#map.get(key);\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keys(): IterableIterator<string> {\n    yield* this.#map.keys();\n    //return Array.from(this.#map.keys());\n  }\n\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const entry of this.#map.entries()) {\n      for (const v of this.type.iterable(entry[ 1 ])) {\n        yield [ entry[ 0 ], v ];\n      }\n    }\n  }\n\n  *valuesFlat(): IterableIterator<V> {\n    for (const entry of this.#map.entries()) {\n      yield* this.type.iterable(entry[ 1 ]);\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: Array<V> ]> {\n    //yield* this.#map.entries();\n    for (const [ k, v ] of this.#map.entries()) {\n      const temporary = [ ...this.type.iterable(v) ];\n      yield [ k, temporary ];\n    }\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    //const keys = this.keys();\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    //const r = keys.map(k => [k, this.count(k)]) as Array<[string, number]>;\n    //return r;\n\n    for (const key of this.keys()) {\n      yield [ key, this.count(key) ];\n    }\n  }\n\n  merge(other: IMapOf<V>) {\n    // const keys = other.keys();\n    // keys.forEach(key => {\n    //   const data = other.get(key);\n    //   if (data !== undefined) this.addKeyedValues(key, ...data);\n    // });\n    for (const key of other.keys()) {\n      const data = other.get(key);\n      this.addKeyedValues(key, ...data);\n    }\n  }\n\n  get size() {\n    return this.#map.size;\n  }\n  /*\n    forEach_(\n      fn: (\n        value: ReadonlyArray<V>,\n        key: string,\n        //eslint-disable-next-line functional/prefer-immutable-types\n        map: Map<string, ReadonlyArray<V>>\n      ) => void,\n      _?: any\n    ) {\n      // for (const [key,value] of this.#map.entries()) {\n      //   value\n      // }\n      // @ts-expect-error\n      this.#map.forEach(fn);\n    }\n    */\n\n  get [ Symbol.toStringTag ]() {\n    return this.#map[ Symbol.toStringTag ];\n  }\n\n  // [Symbol.iterator]() {\n  //   return this.type[Symbol.iterator]();\n  // }\n}\n","import { toStringDefault } from '../../Util.js';\nimport { without } from '../arrays/index.js';\nimport type { MapSetOpts, MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\nimport {\n  hasAnyValue as mapHasAnyValue,\n  toArray as mapToArray,\n  find as mapFind,\n  filter as mapFilter,\n  addKeepingExisting,\n} from './MapFns.js';\nimport type { IMapOfMutableExtended } from './IMapOfMutableExtended.js';\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is a {@link Util.ToString} function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = mapOfSetMutable();\n * map.add(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = mapOfSetMutable(hash);\n * map.add(`hello`, {age:40, name: `Mary`});\n * map.add(`hello`, {age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param opts\n * @returns\n */\nexport const ofSetMutable = <V>(\n  opts?: MapSetOpts<V>\n): IMapOfMutableExtended<V, ReadonlyMap<string, V>> => {\n  const hash = opts?.hash ?? toStringDefault;\n  const comparer = (a: V, b: V) => hash(a) === hash(b);\n\n  const t: MultiValue<V, ReadonlyMap<string, V>> = {\n    get name() {\n      return `set`;\n    },\n    iterable: (source) => source.values(),\n    add: (dest, values) => addKeepingExisting(dest, hash, ...values),\n    count: (source) => source.size,\n    find: (source, predicate) => mapFind(source, predicate),\n    filter: (source, predicate) => mapFilter(source, predicate),\n    toArray: (source) => mapToArray(source),\n    has: (source, value) => mapHasAnyValue(source, value, comparer),\n    without: (source, value) => without(mapToArray(source), value, comparer),\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyMap<string, V>>(t, opts);\n  return m;\n};\n","import { isEqualDefault } from '../../IsEqual.js';\nimport { type ICircularArray, circularArray } from '../CircularArray.js';\nimport type { MapMultiOpts, MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\nimport type { IMapOfMutableExtended } from './IMapOfMutableExtended.js';\n\nexport type MapCircularOpts<V> = MapMultiOpts<V> & {\n  readonly capacity: number;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param opts\n * @returns\n */\nexport const ofCircularMutable = <V>(\n  opts: MapCircularOpts<V>\n): IMapOfMutableExtended<V, ICircularArray<V>> => {\n  const comparer = isEqualDefault;\n\n  const t: MultiValue<V, ICircularArray<V>> = {\n    get name() {\n      return `circular`;\n    },\n    add: (dest, values) => {\n      if (dest === undefined) dest = circularArray<V>(opts.capacity);\n      for (const v of values) {\n        //values.forEach(v => dest = dest?.add(v));\n        dest = dest.add(v);\n      }\n      return dest;\n    },\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(predicate),\n    filter: (source, predicate) => source.filter(predicate),\n    toArray: (source) => source,\n    iterable: (source) => source.values(),\n    has: (source, value) =>\n      source.find((v) => comparer(v, value)) !== undefined,\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n  };\n  return new MapOfMutableImpl<V, ICircularArray<V>>(t, opts);\n};\n","/**\n * Simple map for numbers.\n * \n * Keys not present in map return the `defaultValue` given in the constructor\n * ```js\n * // All keys default to zero.\n * const map = new NumberMap();\n * map.get(`hello`); // 0\n * ```\n * \n * To check if a key is present, use `has`:\n * ```js\n * map.has(`hello`); // false\n * ```\n * \n * Math:\n * ```js\n * // Adds 1 by default to value of `hello`\n * map.add(`hello`);         // 1\n * map.multiply(`hello`, 2); // 2 \n * \n * // Reset key to default value\n * map.reset(`hello`); // 0\n * ```\n * \n * Different default value:\n * ```js\n * const map = new NumberMap(10);\n * map.get(`hello`); // 10\n * ```\n * \n * Regular `set` works as well:\n * ```js\n * map.set(`hello`, 5);\n * map.add(`hello`, 2); // 7\n * ```\n */\nexport class NumberMap<K> extends Map<K, number> {\n  readonly defaultValue: number;\n\n  constructor(defaultValue = 0) {\n    super();\n    this.defaultValue = defaultValue;\n  }\n\n  get(key: K): number {\n    const v = super.get(key);\n    if (v === undefined) return this.defaultValue;\n    return v;\n  }\n\n  reset(key: K): number {\n    super.set(key, this.defaultValue);\n    return this.defaultValue;\n  }\n\n  multiply(key: K, amount: number): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value *= amount;\n    super.set(key, value);\n    return value;\n  }\n\n  add(key: K, amount = 1): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value += amount;\n    super.set(key, value);\n    return value;\n  }\n\n  subtract(key: K, amount = 1): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value -= amount;\n    super.set(key, value);\n    return value;\n  }\n}","import type { ToString } from '../../Util.js';\nimport { type IsEqual, isEqualDefault } from '../../IsEqual.js';\nimport { type IMapOfMutableExtended } from './IMapOfMutableExtended.js';\nimport { type MapMultiOpts, type MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\n\n/**\n * Map of array options\n */\nexport type MapArrayOpts<V> = MapMultiOpts<V> & {\n  /**\n   * Comparer to use\n   */\n  readonly comparer?: IsEqual<V>;\n  /**\n   * Key function\n   */\n  readonly convertToString?: ToString<V>;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: {@link Util.ToString}\n *\n * A custom {@link Util.ToString} function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param opts\n * @template V Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = <V>(\n  opts: MapArrayOpts<V> = {}\n): IMapOfMutableExtended<V, ReadonlyArray<V>> => {\n  // const toStringFunction = opts.toString === undefined ?  \n  // const comparer =\n  //   opts.comparer === undefined\n  //     ? (opts.toString === undefined\n  //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n  //       : isEqualDefault)\n  //     : opts.comparer;\n  // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n  //   const r = opts.convertToString(a) === opts.convertToString(b)\n  //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n  //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n  //   return r;\n  // };\n\n  const convertToString = opts.convertToString;\n  const toStringFunction: IsEqual<V> = typeof convertToString === `undefined` ? isEqualDefault : (a: V, b: V) => convertToString(a) === convertToString(b)\n\n  const comparer = opts.comparer ?? toStringFunction;\n\n  const t: MultiValue<V, ReadonlyArray<V>> = {\n    get name() {\n      return `array`;\n    },\n    add: (destination, values) => {\n      if (destination === undefined) return [ ...values ];\n      return [ ...destination, ...values ];\n    },\n    iterable: (source) => source.values(),\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(f => predicate(f)),\n    filter: (source, predicate) => source.filter(f => predicate(f)),\n    toArray: (source) => source,\n    has: (source, value) => source.some((v) => comparer(v, value)),\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n    //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyArray<V>>(t, opts);\n  return m;\n};\n"],"mappings":"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","names":["immutable","mutable","key","existing","immutable","mutable","data","set"]}