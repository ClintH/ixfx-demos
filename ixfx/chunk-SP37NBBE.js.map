{"version":3,"sources":["../src/collections/tree/index.ts","../src/collections/tree/TraverseObject.ts","../src/iterables/IterableSync.ts","../src/iterables/Iterable.ts","../src/iterables/sync/Reduce.ts","../src/collections/tree/TreeMutable.ts","../src/collections/stack/StackFns.ts","../src/collections/stack/StackMutable.ts","../src/collections/tree/Compare.ts","../src/IsPrimitive.ts","../src/collections/tree/Pathed.ts","../src/collections/tree/TraversableTree.ts"],"sourcesContent":["import { asDynamicTraversable as ObjectToTraversable } from './TraverseObject.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './TreeMutable.js';\nimport type { TraversableTree, TreeNode } from './Types.js';\n\nexport * as Mutable from './TreeMutable.js';\nexport * as Pathed from './Pathed.js'\nexport * as FromObject from './TraverseObject.js';\nexport * as Traverse from './TraversableTree.js';\nexport * from './Compare.js';\nexport type * from './Types.js';\n\nexport const toTraversable = <T>(node: TreeNode<T> | TraversableTree<T> | object) => {\n  if (isTraversable(node)) return node;\n  if (isTreeNode(node)) return TreeNodeToTraversable(node);\n  if (typeof node === `object`) return ObjectToTraversable(node);\n  throw new Error(`Parameter 'node' not convertible`);\n}\n\nexport const isTreeNode = (node: any): node is TreeNode<any> => {\n  if (`parent` in node && `childrenStore` in node && `value` in node) {\n    // eslint-disable-next-line unicorn/no-lonely-if\n    if (Array.isArray(node.childrenStore)) return true;\n  }\n  return false;\n}\n\nexport const isTraversable = (node: any): node is TraversableTree<any> => {\n  return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n}","import { toStringAbbreviate } from '../../Text.js';\n\nimport { last } from '../../iterables/IterableSync.js';\nimport * as TreeArrayBacked from './TreeMutable.js';\nimport { isPrimitive } from '../../IsPrimitive.js';\nimport type { TraversableTree, TreeNode, SimplifiedNode } from './Types.js';\nimport { throwNullUndef } from '../../util/GuardEmpty.js';\nexport type Entry = Readonly<{ name: string, sourceValue: any, nodeValue: any }>;\nexport type EntryWithAncestors = Readonly<{ name: string, sourceValue: any, nodeValue: any, ancestors: Array<string> }>;\nexport type EntryStatic = Readonly<{ name: string, value: any, ancestors?: Array<string> }>\n\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n  /**\n   * Separator for path, eg '.'\n   */\n  readonly separator?: string;\n\n};\n\nexport function prettyPrintEntries(entries: ReadonlyArray<Entry>) {\n  if (entries.length === 0) return `(empty)`;\n  let t = ``;\n  for (const [ index, entry ] of entries.entries()) {\n    t += `  `.repeat(index);\n    t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n  }\n  return t;\n}\n\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const prettyPrint = (\n  node: object,\n  indent = 0,\n  options: Partial<ChildrenOptions> = {}\n): string => {\n  throwNullUndef(node, `node`);\n  const defaultName = options.name ?? `node`;\n  const entry = getNamedEntry(node, defaultName);\n  const t = `${ `  `.repeat(indent) } + name: ${ entry.name } value: ${ JSON.stringify(entry.nodeValue) }`;\n  const childrenAsArray = [ ...children(node, options) ];\n  return childrenAsArray.length > 0 ? (\n    t +\n    `\\n` +\n    childrenAsArray.map((d) => prettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)\n  ) : t;\n};\n\nexport const toStringDeep = (node: TreeNode<Entry | EntryStatic>, indent = 0) => {\n  let t = ` `.repeat(indent) + ` ${ node.value?.name }`;\n  if (node.value !== undefined) {\n    if (`sourceValue` in node.value && `nodeValue` in node.value) {\n      let sourceValue = toStringAbbreviate(node.value?.sourceValue, 20);\n      const nodeValue = toStringAbbreviate(node.value?.nodeValue, 20);\n      sourceValue = sourceValue === nodeValue ? `` : `source: ` + sourceValue;\n      t += ` = ${ nodeValue } ${ sourceValue }`\n    } else if (`value` in node.value && node.value.value !== undefined) t += ` = ${ node.value.value }`;\n\n    if (`ancestors` in node.value) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      t += ` (ancestors: ${ (node.value.ancestors!).join(`, `) })`;\n    }\n  }\n  t += `\\n`\n  for (const c of node.childrenStore) {\n    t += toStringDeep(c, indent + 1);\n  }\n  return t;\n}\n\nexport type ChildrenOptions = Readonly<{\n  filter: `none` | `leaves` | `branches`\n  name: string\n}>;\n\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays. \n * \n * Sub-children are included as an object blob.\n * \n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n * \n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n * \n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children: \n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n * \n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node \n * @param options  \n */\nexport function* children<T extends object>(\n  node: T,\n  options: Partial<ChildrenOptions> = {}\n): IterableIterator<Entry> {\n  throwNullUndef(node, `node`);\n\n  const filter = options.filter ?? `none`;\n\n  const filterByValue = (v: any): [ filter: boolean, isPrimitive: boolean ] => {\n    if (filter === `none`) return [ true, isPrimitive(v) ];\n    else if (filter === `leaves` && isPrimitive(v)) return [ true, true ];\n    else if (filter === `branches` && !isPrimitive(v)) return [ true, false ];\n    return [ false, isPrimitive(v) ];\n  }\n\n  if (Array.isArray(node)) {\n    //if (options.name === undefined) defaultName = `array`;\n    for (const [ index, element ] of node.entries()) {\n      const f = filterByValue(element);\n      if (f[ 0 ]) {\n        yield { name: index.toString(), sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n        //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n      }\n    }\n  } else if (typeof node === `object`) {\n    const entriesIter = (`entries` in node) ? (node as any as Map<any, any>).entries() : Object.entries(node);\n    for (const [ name, value ] of entriesIter) {\n      //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n      const f = filterByValue(value);\n      if (f[ 0 ]) {\n        yield { name: name, sourceValue: value, nodeValue: f[ 1 ] ? value : undefined };\n      }\n    }\n  }\n}\n\nexport function* depthFirst<T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: Array<string> = []): IterableIterator<EntryWithAncestors> {\n  for (const c of children(node, options)) {\n    //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n    yield { ...c, ancestors: [ ...ancestors ] };\n    yield* depthFirst(c.sourceValue, options, [ ...ancestors, c.name ]);\n  }\n}\n\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName<T extends object>(\n  name: string,\n  node: T\n): Entry | undefined {\n  for (const d of children(node)) {\n    if (d.name === name) return d;\n  }\n}\n\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Entry {\n  // ✔️ Unit tested\n  const v = last(traceByPath(path, node, options));\n  if (!v) throw new Error(`Could not trace path: ${ path } `);\n  return v;\n}\n\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n * \n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n * \n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Iterable<EntryWithAncestors> {\n  // ✔️ Unit tested\n  throwNullUndef(path, `path`);\n  throwNullUndef(node, `node`);\n\n  const separator = options.separator ?? `.`;\n  // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n  const pathSplit = path.split(separator);\n\n  const ancestors: Array<string> = [];\n  for (const p of pathSplit) {\n    const entry = childByName(p, node);\n    //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n    // if (allowArrayIndexes) {\n    //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n    //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n    //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n    //   if (arrayIndex >= 0) {\n    //     // Get array by name without the []\n    //     entry = childByName(withoutBrackets, node);\n    //     //onsole.log(`  entry: ${ entry?.name }`);\n    //     if (entry && Array.isArray(entry.sourceValue)) {\n    //       // Result was array as expected\n    //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], nodeValue: entry.sourceValue[ arrayIndex ] };\n    //     }\n    //   }\n    // }\n\n    if (!entry) {\n      yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n      return;\n    }\n    node = entry.sourceValue;\n    yield { ...entry, ancestors: [ ...ancestors ] };\n    ancestors.push(p);\n  }\n}\n\n/**\n * Returns a projection of `node` as a dynamic traversable.\n\n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n * \n * ```js\n  * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n * \n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n * \n * Instead .getIdentity() to get a stable identity:\n * ```js\n  * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n * @param node \n * @param options\n * @param ancestors \n * @param parent \n * @returns \n */\nexport const asDynamicTraversable = <T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: Array<string> = [], parent?: TraversableTree<EntryStatic> | undefined): TraversableTree<EntryStatic> => {\n  const name = options.name ?? `object`;\n  const t: TraversableTree<EntryStatic> = {\n    *children() {\n      for (const c of children(node, options)) {\n        yield asDynamicTraversable(c.sourceValue, { ...options, name: c.name }, [ ...ancestors, name ], t);\n      }\n    },\n    getParent() {\n      return parent;\n    },\n    getValue() {\n      return { name, value: node, ancestors };\n    },\n    getIdentity() {\n      return node;\n    }\n  }\n  return t;\n}\n\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node \n * @param options \n * @returns \n */\nexport const createWrapped = <T extends object>(node: T, options: Partial<CreateOptions>): TreeArrayBacked.WrappedNode<any> => {\n  return TreeArrayBacked.wrap(create(node, options));\n};\n\nexport type CreateOptions = {\n  name: string\n  /**\n   * If _true_, only leaf nodes have values. This avoids repetition (important\n   * when comparing trees), with semantics being in the tree itself.\n   * \n   * When _false_ (default) values get decomposed down the tree. This\n   * makes it easy to get all the data for a branch of the tree.\n   * \n   * \n   * Eg if storing { person: { address { state: `qld` } } }\n   * When _true_, the tree would be:\n   * ```\n   * person, value: undefined\n   *  + address, value: undefined\n   *    + state, value: 'qld'\n   * ```\n   * But when _false_, the tree would be:\n   * ```\n   * person, value: { address: { state: `qld } }\n   *  + address, value: { state: `qld` }\n   *    + state, value: `qld`\n   * ```\n   */\n  valuesAtLeaves: boolean\n}\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure\n * @param node \n * @param options \n * @returns \n */\nexport const create = <T extends object>(node: T, options: Partial<CreateOptions> = {}): TreeNode<EntryStatic> => {\n  const valuesAtLeaves = options.valuesAtLeaves ?? false;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  const valueFor = valuesAtLeaves ? (v: any) => { if (isPrimitive(v)) return v; } : (v: any) => v;\n  return createImpl(node, valueFor(node), options, []);\n}\n\nconst createImpl = <T extends object>(sourceValue: T, nodeValue: T, options: Partial<CreateOptions> = {}, ancestors: Array<string>): TreeNode<EntryStatic> => {\n  const defaultName = options.name ?? `object_ci`;\n  //onsole.log(`createImpl name: ${ defaultName } nodeValue: ${ JSON.stringify(nodeValue) }`);\n  const r = TreeArrayBacked.root<EntryStatic>({ name: defaultName, value: nodeValue, ancestors: [ ...ancestors ] });\n  ancestors = [ ...ancestors, defaultName ];\n  for (const c of children(sourceValue, options)) {\n    const v = options.valuesAtLeaves ? c.nodeValue : c.sourceValue;\n    TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n  }\n  return r;\n}\n\nexport const createSimplified = <T extends object>(node: T, options: Partial<CreateOptions> = {}): SimplifiedNode<EntryStatic> => {\n  return TreeArrayBacked.stripParentage(create(node, options));\n}\n\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry<T extends object>(node: T, defaultName = ``): Entry {\n  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node as Entry;\n  if (`name` in node) {\n    return { name: node.name as string, nodeValue: node, sourceValue: node };\n  }\n  return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n\n\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }","import { type ToString, toStringDefault } from '../util/index.js';\nimport { type IsEqual } from '../util/IsEqual.js';\nimport { isIterable } from './Iterable.js';\nimport { intervalToMs } from '../flow/IntervalType.js';\nimport type { ToArrayOptions } from './Types.js';\nexport { slice } from './sync/Slice.js';\nexport { reduce } from './sync/Reduce.js';\n\nexport function* uniqueByValue<T>(input: Iterable<T>, toString: ToString<T> = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> {\n  for (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(\n  generator: Generator<number>,\n  defaultValue?: number\n) {\n\n  return (): number | undefined => {\n    const v: number | undefined = generator.next().value as number | undefined;\n    if (v === undefined) return defaultValue;\n    return v;\n  };\n}\n\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first<V>(it: Iterable<V>): V | undefined {\n  for (const value of it) {\n    return value;\n  }\n}\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last<V>(it: Iterable<V>): V | undefined {\n  //eslint-disable-next-line functional/no-let\n  let returnValue: V | undefined;\n  for (const value of it) {\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping<V>(it: Iterable<V>, size: number) {\n  if (size <= 1) throw new Error(`Size should be at least 2`);\n\n  //eslint-disable-next-line functional/no-let\n  let buffer: Array<V> = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      buffer = [ buffer.at(-1)! ];\n    }\n  }\n  if (buffer.length <= 1) return;\n\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport function* chunks<V>(it: Iterable<V>, size: number) {\n  //eslint-disable-next-line functional/no-let\n  let buffer = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\nexport function* concat<V>(...its: ReadonlyArray<Iterable<V>>) {\n  for (const it of its) yield* it;\n}\n\nexport function* dropWhile<V>(\n  it: Iterable<V>,\n  f: (v: V) => boolean\n) {\n  for (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it: Iterable<any>, callback: () => (void | boolean | never)) => {\n  for (const _ of it) {\n    const value = callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\nexport const next = <T>(it: Generator<T>) => {\n  return () => {\n    const r = it.next();\n    if (r.done) return;\n    return r.value;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(\n  it1: IterableIterator<V>,\n  it2: IterableIterator<V>,\n  equality?: IsEqual<V>\n) {\n  //it1 = it1[Symbol.iterator]();\n  //it2 = it2[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const index1 = it1.next(),\n      index2 = it2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport function every<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  for (const v of it) {\n    const result = f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\n\nexport function* fill<V>(it: Iterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n\n  //eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const _ of it) yield v;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach<V>(it: Iterable<V>, f: (v: V) => boolean | void) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    const result = f(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\nexport function find<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return v;\n  }\n}\n\nexport function* flatten<V>(it: Iterable<V>) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport function* map<V, X>(it: Iterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    yield f(v);\n  }\n}\n\nexport function* max<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b): Generator<V> {\n  let max: V | undefined;\n  for (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield max;\n      continue;\n    }\n    if (gt(v, max)) {\n      max = v;\n      yield max;\n    }\n  }\n  return max;\n}\n\nexport function* min<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n    }\n    if (gt(min, v)) {\n      min = v;\n      yield min;\n    }\n  }\n}\n\n\n\nexport function some<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return true;\n  }\n  return false;\n}\n\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\nexport function* repeat<T>(genCreator: () => Iterable<T>, repeatsOrSignal: number | AbortSignal): Generator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n\nexport function* unique<V>(\n  iterable: Iterable<V> | Array<Iterable<V>>\n) {\n  // Adapted from https://surma.github.io/underdash/\n  const buffer: Array<any> = [];\n  let itera: Array<Iterable<V>> = [];\n  itera = Array.isArray(iterable) ? iterable : [ iterable ];\n  for (const it of itera) {\n    for (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function* zip<V>(...its: ReadonlyArray<Iterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.iterator ]());\n\n  while (true) {\n    const vs = iits.map((it) => it.next());\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n\nexport function* fromIterable<T>(iterable: Iterable<T>) {\n  for (const v of iterable) {\n    yield v;\n  }\n}\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function toArray<V>(\n  it: Iterable<V>,\n  options: Partial<ToArrayOptions> = {}\n): Array<V> {\n  const result: Array<V> = [];\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n  for (const v of it) {\n    if (result.length >= maxItems) break;\n    if (Date.now() - started > maxElapsed) break;\n    result.push(v);\n  }\n  return result;\n}\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray<V>(array: Array<V>): Generator<V> {\n  for (const v of array) {\n    yield v;\n  }\n}","export type WithEvents = {\n  addEventListener(type: string, callbackfn: any): void;\n  removeEventListener(type: string, callbackfn: any): void;\n}\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> =>\n  Symbol.asyncIterator in new Object(v);\n\nexport const isIterable = (v: any): v is Iterable<any> =>\n  Symbol.iterator in new Object(v);\n\nexport const fromEvent = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(new Error(error)),\n      };\n    },\n  };\n  return r;\n};","export function reduce<V>(\n  it: Iterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) start = f(start, v);\n  return start;\n}\n","import { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\"\nimport { without } from '../../data/arrays/Filter.js';\nimport { containsDuplicateInstances } from \"../../data/arrays/ContainsDuplicateInstances.js\";\nimport { QueueMutable } from \"../queue/QueueMutable.js\"\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { compare as treeCompare } from './Compare.js';\nimport { toStringAbbreviate } from \"../../Text.js\"\nimport type { LabelledSingleValue, TreeNode, SimplifiedNode, TraversableTree } from \"./Types.js\"\n\n/**\n * Compares two nodes.\n * \n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a \n * @param b \n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = <T>(a: TreeNode<T>, b: TreeNode<T>, eq?: IsEqual<T>) => {\n  return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n}\n\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n * @param node \n * @returns \n */\nexport const stripParentage = <T>(node: TreeNode<T>): SimplifiedNode<T> => {\n  const n: SimplifiedNode<T> = {\n    value: node.value,\n    childrenStore: node.childrenStore.map(c => stripParentage(c))\n  }\n  return n;\n}\n/**\n * Wraps a {@link TreeNode} for a more object-oriented means of access.\n */\nexport type WrappedNode<T> = TraversableTree<T> & {\n  /**\n   * Underlying Node\n   */\n  wraps: TreeNode<T>,\n  /**\n   * Gets value, if defined\n   * @returns Value of Node\n   */\n  getValue: () => T | undefined\n  /**\n   * Remove node and its children from tree\n   * @returns \n   */\n  remove: () => void\n  /**\n   * Adds a child node\n   * @param child \n   * @returns \n   */\n  add: (child: WrappedNode<T> | TreeNode<T>) => WrappedNode<T>\n  /**\n   * Adds a new child node, with `value` as its value\n   * @param value \n   * @returns \n   */\n  addValue: (value: T) => WrappedNode<T>\n  /**\n   * Returns _true_ if `child` is an immediate child of this node\n   * @param child \n   * @returns \n   */\n  hasChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  queryValue: (value: T) => IterableIterator<WrappedNode<T>>\n  /**\n   * Returns _true_ if `child` is contained any any descendant\n   * @param child\n   * @returns \n   */\n  hasAnyChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate parent for this node\n   * @param parent \n   * @returns \n   */\n  hasParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate or ancestor parent for this node\n   * @param parent \n   * @returns \n   */\n  hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n}\n\nconst unwrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node : wrap(node);\n\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns \n */\nexport const wrap = <T>(n: TreeNode<T>): WrappedNode<T> => {\n  return {\n    *children() {\n      for (const c of n.childrenStore) {\n        yield wrap(c)\n      }\n    },\n    getValue: () => n.value as T,\n    getIdentity: () => n,\n    *queryValue(value: T): IterableIterator<WrappedNode<T>> {\n      for (const v of queryByValue(value, unwrapped(n))) {\n        yield wrap(v);\n      }\n    },\n    getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n    hasParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasParent(n, unwrapped(parent));\n    },\n    hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyParent(n, unwrapped(parent));\n    },\n    hasChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasChild(unwrapped(child), n);\n    },\n    hasAnyChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyChild(unwrapped(child), n);\n    },\n    remove: () => {\n      remove(n);\n    },\n    addValue: (value: T): WrappedNode<T> => {\n      const nodeValue = addValue(value, n);\n      return wrap(nodeValue);\n    },\n    add: (child: WrappedNode<T> | TreeNode<T>): WrappedNode<T> => {\n      add(unwrapped(child), n);\n      return wrapped(child);\n    },\n    wraps: n\n  }\n}\n\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child \n * @returns \n */\nexport const remove = <T>(child: TreeNode<T>) => {\n  const p = child.parent;\n  if (p === undefined) return;\n  child.parent = undefined;\n  p.childrenStore = without(p.childrenStore, child);\n};\n\n/**\n * Depth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* depthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!root) return;\n  const stack = new StackMutable<TreeNode<T>>();\n  stack.push(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = stack.pop();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      stack.push(...entry.childrenStore);\n    }\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n  }\n}\n\n/**\n * Breadth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* breadthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!node) return;\n  const queue = new QueueMutable<TreeNode<T>>();\n  queue.enqueue(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = queue.dequeue();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      queue.enqueue(...entry.childrenStore);\n    }\n    if (queue.isEmpty) break;\n    entry = queue.dequeue();\n  }\n}\n\n/**\n * Validates the tree from `root` downwards.\n * @param root \n * @param seen \n * @returns \n */\nexport function treeTest<T>(root: TreeNode<T>, seen: Array<TreeNode<T>> = []): [ ok: boolean, msg: string, node: TreeNode<T> ] {\n  if (root.parent === root) return [ false, `Root has itself as parent`, root ];\n  if (seen.includes(root)) return [ false, `Same node instance is appearing further in tree`, root ];\n  seen.push(root);\n  if (containsDuplicateInstances(root.childrenStore)) return [ false, `Children list contains duplicates`, root ];\n\n  for (const c of root.childrenStore) {\n    if (c.parent !== root) return [ false, `Member of childrenStore does not have .parent set`, c ];\n    if (hasAnyChild(root, c)) return [ false, `Child has parent as its own child`, c ];\n    const v = treeTest(c, seen);\n    if (!v[ 0 ]) return v;\n  }\n  return [ true, ``, root ];\n}\n\n/**\n * Throws an exception if `root` fails tree validation\n * @param root \n * @returns \n */\nexport function throwTreeTest<T>(root: TreeNode<T>) {\n  const v = treeTest(root);\n  if (v[ 0 ]) return;\n  throw new Error(`${ v[ 1 ] } Node: ${ toStringAbbreviate(v[ 2 ].value, 30) }`, { cause: v[ 2 ] })\n}\n/**\n * Iterate over direct children of `root`\n * @param root \n */\nexport function* children<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  for (const c of root.childrenStore) {\n    yield c;\n  }\n}\n\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root \n */\nexport function* parents<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  let p = root.parent;\n  while (p) {\n    yield p;\n    p = p.parent;\n  }\n}\n\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node \n * @returns \n */\nexport function nodeDepth(node: TreeNode<any>): number {\n  const p = [ ...parents(node) ];\n  return p.length;\n}\n\nexport const hasChild = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of parent.childrenStore) {\n    if (c === child) return true;\n  }\n  return false;\n}\n\nexport const findChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): TreeNode<T> | undefined => {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) return c;\n  }\n}\n\nexport function* queryByValue<T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): IterableIterator<TreeNode<T>> {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) yield c;\n  }\n}\n\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n * \n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild \n * @param parent \n * @returns \n */\nexport const hasAnyChild = <T>(prospectiveChild: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of breadthFirst(parent)) {\n    if (c === prospectiveChild) return true;\n  }\n  return false;\n}\n\nexport const findAnyChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault) => {\n  for (const c of breadthFirst(parent)) {\n    if (eq(c.value as T, value)) return c;\n  }\n}\n\nexport const getRoot = <T>(node: TreeNode<T>): TreeNode<T> => {\n  if (node.parent) return getRoot(node.parent);\n  return node;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n * \n * Use {@link hasParent} to only check immediate parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasAnyParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  for (const p of parents(child)) {\n    if (p === prospectiveParent) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n * \n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  return child.parent === prospectiveParent;\n}\n\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root); \n * ```\n * @param node \n * @returns \n */\nexport const computeMaxDepth = <T>(node: TreeNode<T>) => {\n  return computeMaxDepthImpl(node, 0);\n}\n\nconst computeMaxDepthImpl = <T>(node: TreeNode<T>, startingDepth = 0) => {\n  let depth = startingDepth;\n  for (const c of node.childrenStore) {\n    depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n  }\n  return depth;\n}\n\nexport const add = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  throwAttemptedChild(child, parent);\n  //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n  //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n  const p = child.parent;\n  parent.childrenStore = [ ...parent.childrenStore, child ];\n  child.parent = parent;\n  if (p) {\n    p.childrenStore = without(p.childrenStore, child);\n  }\n}\n\nexport const addValue = <T>(value: T | undefined, parent: TreeNode<T>) => {\n  return createNode(value, parent);\n}\n\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value \n * @returns \n */\nexport const root = <T>(value?: T | undefined) => {\n  return createNode(value);\n}\n\nexport const fromPlainObject = (value: Record<string, any>, label = ``, parent?: TreeNode<any>, seen: Array<any> = []): TreeNode<LabelledSingleValue<any>> => {\n  const entries = Object.entries(value);\n  parent = parent === undefined ? root() : addValue<LabelledSingleValue<any>>({ label, value }, parent);\n  for (const entry of entries) {\n    const value = entry[ 1 ];\n    // Avoid circular references\n    if (seen.includes(value)) continue;\n    seen.push(value);\n\n    if (typeof entry[ 1 ] === `object`) {\n      fromPlainObject(value, entry[ 0 ], parent, seen);\n    } else {\n      addValue<LabelledSingleValue<any>>({ label: entry[ 0 ], value: value }, parent);\n    }\n  }\n  return parent;\n}\n\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link root} alternatively.\n * @param value \n * @returns \n */\nexport const rootWrapped = <T>(value: T | undefined) => {\n  return wrap(createNode(value));\n}\n\nexport const createNode = <T>(value: T | undefined, parent?: TreeNode<T> | undefined): TreeNode<T> => {\n  const n: TreeNode<T> = {\n    childrenStore: [],\n    parent: parent,\n    value: value\n  }\n  if (parent !== undefined) {\n    parent.childrenStore = [ ...parent.childrenStore, n ];\n  }\n  return n;\n}\n\nexport const childrenLength = <T>(node: TreeNode<T>): number => {\n  return node.childrenStore.length;\n}\n\nexport const value = <T>(node: TreeNode<T>): T | undefined => {\n  return node.value;\n}\n\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node \n * @returns \n */\nexport const asDynamicTraversable = <T>(node: TreeNode<T>): TraversableTree<T> => {\n  const t: TraversableTree<T> = {\n    *children() {\n      for (const c of node.childrenStore) {\n        yield asDynamicTraversable(c);\n      }\n    },\n    getParent() {\n      if (node.parent === undefined) return;\n      return asDynamicTraversable(node.parent);\n    },\n    getValue(): any {\n      return node.value;\n    },\n    getIdentity() {\n      return node;\n    },\n  }\n  return t;\n}\n\nconst throwAttemptedChild = <T>(c: TreeNode<T>, parent: TreeNode<T>) => {\n  if (parent === c) throw new Error(`Cannot add self as child`);\n  if (c.parent === parent) return; // skip if it's already a child\n  if (hasAnyParent(parent, c)) throw new Error(`Child contains parent (1)`, { cause: c });\n  if (hasAnyParent(c, parent)) throw new Error(`Parent already contains child`, { cause: c });\n  if (hasAnyChild(parent, c)) throw new Error(`Child contains parent (2)`, { cause: c });\n}\n\nexport const setChildren = <T>(parent: TreeNode<T>, children: Array<TreeNode<T>>) => {\n  // Verify children are legit\n  for (const c of children) {\n    throwAttemptedChild(c, parent);\n  }\n\n  parent.childrenStore = [ ...children ];\n  for (const c of children) {\n    c.parent = parent;\n  }\n}\n\nexport const toStringDeep = <T>(node: TreeNode<T>, indent = 0): string => {\n  const t = `${ `  `.repeat(indent) } + ${ node.value ? JSON.stringify(node.value) : `-` }`;\n  return node.childrenStore.length > 0 ? (\n    t +\n    `\\n` +\n    node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)\n  ) : t;\n}\n\nexport function* followValue<T>(root: TreeNode<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T | undefined> {\n  for (const c of root.childrenStore) {\n    const value = c.value;\n    if (value === undefined) continue;\n    if (continuePredicate(value, depth)) {\n      yield c.value;\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }","import type { StackOpts } from './Types.js';\n\nexport const trimStack = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = stack.length + toAdd.length;\n  const policy = opts.discardPolicy ?? `additions`;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  if (opts.debug) {\n    console.log(\n      `Stack.push: stackLen: ${ stack.length } potentialLen: ${ potentialLength } toRemove: ${ toRemove } policy: ${ policy }`\n    );\n  }\n  switch (policy) {\n    case `additions`: {\n      if (opts.debug) {\n        console.log(\n          `Stack.push:DiscardAdditions: stackLen: ${ stack.length } slice: ${ potentialLength - capacity\n          } toAddLen: ${ toAdd.length }`\n        );\n      }\n\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (stack.length === opts.capacity) {\n        return stack; // Completely full\n      } else {\n        // Only add some from the new array\n        return [ ...stack, ...toAdd.slice(0, toAdd.length - toRemove) ];\n      }\n    }\n    case `newer`: {\n      if (toRemove >= stack.length) {\n        // New items will completely flush out old\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n      } else {\n        // Keep some of the old (from 0)\n        //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n        if (opts.debug) {\n          console.log(` from orig: ${ JSON.stringify(stack.slice(0, stack.length - toRemove)) }`);\n        }\n        return [\n          ...stack.slice(0, stack.length - toRemove),\n          ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n        ];\n      }\n    }\n    case `older`: {\n      // Oldest item in stack is position 0\n      return [ ...stack, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown discard policy ${ policy }`);\n    }\n  }\n};\n\n// Add to top (last index)\nexport const push = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\n  //const mutated = [...stack, ...toAdd];\n  const potentialLength = stack.length + toAdd.length;\n\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n  const toReturn = overSize\n    ? trimStack(opts, stack, toAdd)\n    : [ ...stack, ...toAdd ];\n  return toReturn;\n};\n\n// Remove from top (last index)\nexport const pop = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (stack.length === 0) throw new Error(`Stack is empty`);\n  return stack.slice(0, - 1);\n};\n\n/**\n * Peek at the top of the stack (end of array)\n *\n * @template V\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): V | undefined => stack.at(-1);\n\nexport const isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean =>\n  stack.length === 0;\n\nexport const isFull = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return stack.length >= opts.capacity;\n  }\n  return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\n\nimport type { IStackMutable } from './IStackMutable.js';\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\nimport type { StackOpts } from './Types.js';\n\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable<V> implements IStackMutable<V> {\n  readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  /**\n   * Push data onto the stack.\n   * If `toAdd` is empty, nothing happens\n   * @param toAdd Data to add\n   * @returns Length of stack\n   */\n  push(...toAdd: ReadonlyArray<V>): number {\n    if (toAdd.length === 0) return this.data.length;\n    this.data = push(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  pop(): V | undefined {\n    const v = peek(this.opts, this.data);\n    this.data = pop(this.opts, this.data);\n    return v;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = <V>(\n  opts: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackMutable<V> => new StackMutable({ ...opts }, [ ...startingItems ]);\n","import { type IsEqual, isEqualValueIgnoreOrder } from \"../../util/IsEqual.js\";\nimport * as TreeMutable from './TreeMutable.js';\nimport type { TreeNode, TraversableTree } from './Types.js';\n\nexport type DiffAnnotation<T> = {\n  /**\n   * In the case of changes, this is old value\n   */\n  a: TraversableTree<T>\n  /**\n   * In the case of changes, this is the new value\n   */\n  b: TraversableTree<T>\n  /**\n   * If true, this node's value has been modified\n   */\n  valueChanged: boolean\n  /**\n   * If true, one of the child values has changed\n   */\n  childChanged: boolean\n  /**\n   * List of new children\n   */\n  added: Array<TraversableTree<T>>\n  /**\n   * List of removed children\n   */\n  removed: Array<TraversableTree<T>>\n}\n\nexport type DiffNode<T> = TreeNode<DiffAnnotation<T>> & {\n  toString: () => string\n};\n\nexport const compare = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder, parent?: DiffNode<T> | undefined): DiffNode<T> => {\n  const valueEqual = valueOrIdentityEqual(a, b, eq);\n  // if (!valueEqual) {\n  //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n  // }\n  const childrenCompare = compareChildren(a, b, eq);\n\n  const diff: DiffAnnotation<T> = {\n    valueChanged: !valueEqual, a, b,\n    added: childrenCompare.added,\n    removed: childrenCompare.removed,\n    childChanged: false\n  }\n  const diffNode: DiffNode<T> = {\n    value: diff,\n    childrenStore: [],\n    parent\n  }\n\n  const childrenDiff = childrenCompare.identical.map(c => compare(c[ 0 ], c[ 1 ], eq, diffNode));\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value!));\n  TreeMutable.setChildren(diffNode, childrenDiff);\n  //diffNode.childrenStore = childrenDiff;\n\n  diffNode.toString = () => toString(diffNode, 0);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  diffNode.value!.childChanged = someChildChange;\n  TreeMutable.throwTreeTest(diffNode);\n\n  return diffNode;\n}\n\nconst hasChange = (vv: DiffAnnotation<any>): boolean => {\n  if (vv === undefined) return false;\n  if (vv.valueChanged) return true;\n  if (vv.childChanged) return true;\n  if (vv.added.length > 0) return true;\n  if (vv.removed.length > 0) return true;\n  return false;\n}\n\n\nconst compareChildren = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder) => {\n  const childrenOfA = [ ...a.children() ];\n  const childrenOfB = [ ...b.children() ];\n\n  const identical: Array<[ a: TraversableTree<T>, b: TraversableTree<T> ]> = []\n  const removed: Array<TraversableTree<T>> = [];\n  for (const childA of childrenOfA) {\n    let foundIndex = -1;\n    for (const [ index, childOfB ] of childrenOfB.entries()) {\n      const d = valueOrIdentityEqual(childA, childOfB, eq);\n      if (d) {\n        identical.push([ childA, childOfB ]);\n        foundIndex = index;\n        break;\n      }\n    }\n    if (foundIndex === -1) {\n      // A's child not found in B's children\n      removed.push(childA);\n    } else {\n      // Found, remove it from list of B's children\n      childrenOfB.splice(foundIndex, 1);\n    }\n  }\n  const added = [ ...childrenOfB ];\n  return { added, identical, removed }\n}\n\nconst valueOrIdentityEqual = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T>): boolean => {\n  if (a.getIdentity() === b.getIdentity()) return true;\n  if (eq(a.getValue(), b.getValue())) return true;\n  return false;\n}\n\nconst toStringSingle = <T>(n: TraversableTree<T>) => {\n  return JSON.stringify(n.getValue());\n}\n\nconst toString = <T>(n: DiffNode<T>, indent = 0): string => {\n  if (n === undefined) return `(undefined)`;\n  let t = toStringDiff(n.value, indent);\n  for (const c of n.childrenStore) {\n    t += toString(c, indent + 2);\n  }\n  return t;\n}\n\nconst toStringDiff = <T>(n: DiffAnnotation<T> | undefined, indent: number): string => {\n  const spaces = ` `.repeat(indent);\n  if (n === undefined) return `${ spaces }(undefined)`;\n  const t = [];\n  t.push(`a: ${ toStringSingle(n.a) } b: ${ toStringSingle(n.b) }`);\n  if (n.valueChanged) t.push(`Value changed. Child changed: ${ n.childChanged }`);\n  else t.push(`Value unchanged. Child changed: ${ n.childChanged }`);\n\n  if (n.added.length > 0) {\n    t.push(`Added:`);\n    for (const c of n.added) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  if (n.removed.length > 0) {\n    t.push(`Removed: ${ n.removed.length }`);\n    for (const c of n.removed) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  t.push(`----\\n`)\n  return t.map(line => spaces + line).join(`\\n`);\n}","import type { Primitive, PrimitiveOrObject } from \"./PrimitiveTypes.js\";\n\n/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value: any): value is Primitive {\n  if (typeof value === `number`) return true;\n  if (typeof value === `string`) return true;\n  if (typeof value === `bigint`) return true;\n  if (typeof value === `boolean`) return true;\n  return false;\n}\n\nexport function isPrimitiveOrObject(value: any): value is PrimitiveOrObject {\n  if (isPrimitive(value)) return true;\n  if (typeof value === `object`) return true;\n  return false;\n}","import * as TreeArrayBacked from \"./TreeMutable.js\";\nimport type { LabelledValue, LabelledNode, TreeNode } from \"./Types.js\";\n/**\n * Options for parsing a path\n */\nexport type PathOpts = Readonly<{\n  /**\n   * Separator for path, eg '.'\n   */\n  separator: string;\n  /**\n   * If two values are stored at same path, what to do? Default: overwrite\n   * * overwrite: last-write wins\n   * * ignore: first-write wins\n   * * allow: allow multiple values\n   */\n  duplicates: `overwrite` | `allow` | `ignore`\n}>;\n\n\n\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n * \n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n * \n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n * \n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n * \n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts \n * @returns \n */\nexport const create = <T>(pathOpts: Partial<PathOpts> = {}) => {\n  let root: TreeNode<LabelledValue<T>> | undefined;\n\n  const add = (value: T, path: string) => {\n    const n = addValueByPath(value, path, root, pathOpts);\n    if (root === undefined) {\n      root = TreeArrayBacked.getRoot(n);\n    }\n  }\n\n  const prettyPrint = () => {\n    if (root === undefined) return `(empty)`;\n    return TreeArrayBacked.toStringDeep(root);\n  }\n\n  const getValue = (path: string): T | undefined => {\n    if (root === undefined) return;\n    return valueByPath(path, root, pathOpts);\n  }\n\n  const remove = (path: string): boolean => {\n    if (root === undefined) return false;\n    return removeByPath(path, root, pathOpts);\n  }\n\n  const hasPath = (path: string): boolean => {\n    if (root === undefined) return false;\n    const c = findChildByPath(path, root, pathOpts);\n    return c !== undefined;\n  }\n\n  const getNode = (path: string): LabelledNode<T> | undefined => {\n    if (root === undefined) return;\n    const c = findChildByPath(path, root, pathOpts);\n    return c;\n  }\n\n  const childrenLength = (path: string): number => {\n    if (root === undefined) return 0;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined) return 0;\n    return c.childrenStore.length;\n  }\n\n  const getValues = (path: string): Array<T> => {\n    if (root === undefined) return [];\n    return valuesByPath(path, root, pathOpts);\n  }\n\n  const clearValues = (path: string): boolean => {\n    if (root === undefined) return false;\n    return clearValuesByPath(path, root, pathOpts);\n  }\n  return { add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues }\n}\n\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n * \n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = <T>(value: T, path: string, node?: LabelledNode<T> | undefined, pathOpts: Partial<PathOpts> = {}): LabelledNode<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n  const split = path.split(separator);\n  let count = 0;\n  for (const p of split) {\n    const lastEntry = count === split.length - 1;\n    //onsole.log(`p: ${ p }`);\n    const found = findChildByLabel(p, node);\n    if (found === undefined) {\n      //onsole.log(`  - not found`);\n      const labelled: LabelledValue<T> = {\n        value: (lastEntry ? value : undefined),\n        label: p\n      };\n      node = TreeArrayBacked.createNode(labelled, node);\n    } else {\n      node = found;\n      if (lastEntry) {\n        switch (duplicatePath) {\n          case `ignore`: {\n            break;\n          }\n          case `allow`: {\n            const existing = getValuesFromNode(node);\n            node.value = {\n              values: [ ...existing, value ],\n              label: p\n            }\n            break;\n          }\n          case `overwrite`: {\n            node.value = {\n              value,\n              label: p\n            }\n            break;\n          }\n        }\n      } else {\n        //onsole.log(`  - found!`, found.value);\n        node = found;\n      }\n    }\n    count++;\n  }\n  if (node === undefined) throw new Error(`Could not create tree`);\n  return node;\n}\n\nexport const removeByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  TreeArrayBacked.remove(c);\n  return true;\n}\n\nexport const clearValuesByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  c.value = {\n    label: c.value?.label ?? ``,\n    value: undefined\n  }\n  return true;\n}\nexport const childrenLengthByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): number => {\n  if (node === undefined) return 0;\n  const c = findChildByPath(path, node, pathOpts);\n  if (c === undefined) return 0;\n  return c.childrenStore.length;\n}\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = <T>(label: string, node: LabelledNode<T> | undefined): LabelledNode<T> | undefined => {\n  if (node === undefined) return undefined;\n  if (label === undefined) throw new Error(`Parameter 'label' cannot be undefined`);\n  if (node.value?.label === label) return node;\n  for (const c of node.childrenStore) {\n    if (c.value?.label === label) return c;\n  }\n}\n\nexport const valueByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): T | undefined => {\n  const values = valuesByPath(path, node, pathOpts);\n  if (values.length === 0) return undefined;\n  if (values.length > 1) throw new Error(`Multiple values at path. Use getValues instead`);\n  return values[ 0 ];\n}\n\nconst getValuesFromNode = <T>(c: LabelledNode<T>): Array<T> => {\n  if (c.value === undefined) return [];\n  if (`values` in c.value) return c.value.values;\n  if (`value` in c.value) {\n    if (c.value.value === undefined) return [];\n    return [ c.value.value ];\n  }\n  return [];\n}\n\nconst findChildByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}) => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      return;\n    }\n  }\n  return c;\n}\n\nexport const valuesByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): Array<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    //onsole.log(`getValue p: ${ p }`);\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n      return [];\n    }\n  }\n  return getValuesFromNode(c);\n}","import { toStringAbbreviate } from \"../../Text.js\";\nimport { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { QueueMutable } from \"../queue/QueueMutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport type { TraversableTree } from \"./Types.js\";\n\nexport const childrenLength = <T>(tree: TraversableTree<T>): number => {\n  return [ ...tree.children() ].length;\n}\n\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = <T>(\n  child: TraversableTree<T>,\n  possibleParent: TraversableTree<T>,\n  eq?: IsEqual<TraversableTree<T>>\n): boolean => {\n  return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyParentValue = <T>(\n  child: TraversableTree<T>,\n  possibleParentValue: T,\n  eq?: IsEqual<T>\n): boolean => {\n  return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findAnyParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq?: IsEqual<TValue>\n): TraversableTree<TValue> | undefined => {\n  return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = <T>(\n  child: TraversableTree<T>,\n  possibleParent: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault<TraversableTree<T>>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = child.getParent();\n  if (p === undefined) return false;\n  if (eq(p, possibleParent)) return true;\n  if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n  return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\n\nexport const hasParentValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault<TValue>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = child.getParent();\n  if (p === undefined) return false;\n  if (eq(p.getValue(), possibleParentValue)) return true;\n  return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\nexport const findParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault<TValue>,\n  maxDepth = 0\n): TraversableTree<TValue> | undefined => {\n  if (maxDepth < 0) return;\n  const p = child.getParent();\n  if (p === undefined) return;\n  if (eq(p.getValue(), possibleParentValue)) return p;\n  return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = <T>(\n  parent: TraversableTree<T>,\n  prospectiveChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n) => {\n\n  if (eq(parent, prospectiveChild)) throw new Error(`Child equals parent`);\n  if (hasAnyChild(parent, prospectiveChild, eq)) {\n    throw new Error(`Circular. Parent already has child`);\n  }\n  if (hasAnyChild(prospectiveChild, parent, eq)) {\n    throw new Error(`Prospective child has parent as child relation`);\n  }\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = <T>(\n  parent: TraversableTree<T>,\n  possibleChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n): boolean => {\n  return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleChildValue: T,\n  eq: IsEqual<T> = isEqualDefault\n): boolean => {\n  return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = <T>(\n  parent: TraversableTree<T>,\n  possibleChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent, possibleChild)) return true;\n  if (eq(parent.getIdentity(), possibleChild.getIdentity())) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c, possibleChild)) return true;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    if (eq(c.getIdentity(), possibleChild.getIdentity())) return true;\n  }\n  return false;\n};\n\nexport const hasChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleValue: T,\n  eq: IsEqual<T> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent.getValue(), possibleValue)) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c.getValue(), possibleValue)) return true;\n  }\n  return false;\n};\n\n/**\n * Iterates over siblings of `node`.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* siblings<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  const p = node.getParent();\n  if (p === undefined) return;\n  for (const s of p.children()) {\n    if (s === node) continue;\n    yield s;\n  }\n}\n\n/**\n * Iterates over parents of `node`, starting with immediate parent\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  let p = node.getParent();\n  while (p !== undefined) {\n    yield p;\n    p = p.getParent();\n  }\n}\n\n\nexport const findAnyChildByValue = <TValue>(parent: TraversableTree<TValue>,\n  possibleValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault\n): TraversableTree<TValue> | undefined => {\n  return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findChildByValue = <TValue>(parent: TraversableTree<TValue>,\n  possibleValue: TValue,\n  eq: IsEqual<TValue> = isEqualDefault,\n  maxDepth = 0\n): TraversableTree<TValue> | undefined => {\n\n  if (maxDepth < 0) return;\n  if (eq(parent.getValue(), possibleValue)) return parent;\n\n  for (const d of breadthFirst(parent, maxDepth)) {\n    // This child matches\n    if (eq(d.getValue(), possibleValue)) return d;\n  }\n  return;\n};\n\n/**\n * Iterates over children of `root`, depth-first.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node \n * @returns \n */\nexport function* depthFirst<T extends TraversableTree<any>>(root: T): Generator<T> {\n  if (!root) return;\n  const stack = new StackMutable<T>();\n  let entry: T | undefined = root;\n  while (entry) {\n    const entries = [ ...entry.children() ] as Array<T>;\n    stack.push(...entries);\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n    if (entry) yield entry;\n  }\n}\n\n/**\n * Iterates over the children of `root`, breadth-first\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @param depth How many levels to traverse \n * @returns \n */\nexport function* breadthFirst<T>(root: TraversableTree<T>, depth = Number.MAX_SAFE_INTEGER): IterableIterator<TraversableTree<T>> {\n  if (!root) return;\n  const queue = new QueueMutable<TraversableTree<T>>();\n  let entry: TraversableTree<T> | undefined = root;\n  while (entry) {\n    if (depth < 0) return;\n    for (const c of entry.children()) {\n      yield c;\n      queue.enqueue(c);\n    }\n    entry = queue.dequeue();\n    depth--;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function find<T>(root: TraversableTree<T>, predicate: (node: TraversableTree<T>) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root)) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n  for (const c of iter(root)) {\n    if (predicate(c)) return c;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n * \n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function findByValue<T>(root: TraversableTree<T>, predicate: (nodeValue: T) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root.getValue())) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n\n  for (const c of iter(root)) {\n    if (predicate(c.getValue())) return c;\n  }\n}\n\n/**\n * Search through children in a path-like manner.\n * \n * It finds the first child of `root` that matches `continuePredicate`. \n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n * \n * If it can't find a child, it stops.\n * \n * This is different to 'find' functions, which exhausively search all possible child nodes, regardless of position in tree.\n * \n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n * \n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root \n * @param continuePredicate \n * @param depth \n */\nexport function* followValue<T>(root: TraversableTree<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T> {\n  for (const c of root.children()) {\n    if (continuePredicate(c.getValue(), depth)) {\n      yield c.getValue();\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\nexport function toStringDeep<T>(node: TraversableTree<T>, depth = 0) {\n  if (node === undefined) return `(undefined)`;\n  if (node === null) return `(null)`;\n  const v = node.getValue();\n  let type: string = typeof v;\n  if (Array.isArray(v)) type = `array`;\n  let t = `  `.repeat(depth) + `value: ${ JSON.stringify(v) } (${ type })\\n`;\n  for (const n of node.children()) {\n    t += toStringDeep(n, depth + 1);\n  }\n  return t;\n}\n\nexport function toString(...nodes: Array<TraversableTree<any>>) {\n  let t = ``;\n  for (const node of nodes) {\n    const v = node.getValue();\n    const vString = toStringAbbreviate(v);\n    const children = [ ...node.children() ];\n    const parent = node.getParent();\n    let type: string = typeof v;\n    if (Array.isArray(v)) type = `array`;\n    t += `value: ${ vString } (${ type }) kids: ${ children.length } parented: ${ parent ? `y` : `n` }\\n`;\n  }\n  return t;\n}"],"mappings":"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","names":["asDynamicTraversable","children","depthFirst","toStringDeep","toString","value","max","min","compare","compare","value","root","children","value","children","toStringDeep","filter","value","depthFirst","asDynamicTraversable","create","create","root","add","value","prettyPrint","remove","childrenLength","breadthFirst","childrenLength","depthFirst","find","findAnyChildByValue","findChildByValue","followValue","hasAnyChild","hasAnyParent","hasChild","hasParent","parents","toString","toStringDeep","childrenLength","hasAnyParent","hasParent","hasAnyChild","hasChild","breadthFirst","parents","findAnyChildByValue","findChildByValue","depthFirst","root","find","followValue","toStringDeep","toString","children","asDynamicTraversable"]}