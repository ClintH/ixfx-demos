{"version":3,"sources":["../src/data/Table.ts","../src/data/Reactive.ts","../src/data/ReactiveDom.ts","../src/data/ReactiveOps.ts","../src/data/graphs/DirectedGraph.ts","../src/data/ReactiveGraph.ts","../src/dom/DomRx.ts","../src/dom/CanvasSizing.ts"],"sourcesContent":["\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs, type Interval } from \"../flow/IntervalType.js\";\nimport { DispatchList, type Dispatch } from \"../flow/DispatchList.js\"\nimport * as Immutable from '../Immutable.js';\nimport { continuously } from \"../flow/Continuously.js\";\nexport * as Dom from './ReactiveDom.js';\nexport * from './ReactiveOps.js';\nexport * from './ReactiveGraph.js';\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: `done`\n  context: string\n}\n\nexport type EventOptions<V> = {\n  process: (args?: Event | undefined) => V\n  lazy?: boolean\n  /**\n   * If true, log messages are emitted\n   * when event handlers are added/removed\n   */\n  debugLifecycle?: boolean\n  /**\n   * If true, log messages are emitted\n   * when the source event fires\n   */\n  debugFiring?: boolean\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `value` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): () => void\n  value(handler: (value: V) => void): () => void\n}\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\nexport type ReactiveWritable<V> = {\n  set(value: V): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveDisposable = {\n  dispose(reason: string): void\n  isDisposed(): boolean\n}\n\nexport type ReactiveDiff<V> = ReactiveDisposable & ReactiveWritable<V> & {\n  /**\n   * Diff information\n   * @param handler \n   */\n  onDiff(handler: (changes: Passed<Array<Immutable.Change<any>>>) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   */\n  update(changedPart: Record<string, any>): void\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\nexport type ReactiveStream<V> = Reactive<V> & ReactiveDisposable & ReactiveWritable<V> & {\n  through(message: Passed<V>): void\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  reset(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\n\n/**\n * Options when creating a reactive object.\n */\nexport type ObjectOptions<V> = {\n  /**\n   * _false_ by default.\n   * If _true_, inherited fields are included. This is necessary for event args, for example.\n   */\n  deepEntries: boolean\n  /**\n   * Uses JSON.stringify() by default.\n   * Fn that returns _true_ if two values are equal, given a certain path.\n   */\n  eq: Immutable.IsEqualContext<V>\n}\n\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V>): rx is ReactiveInitial<V> => {\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\nexport const isDisposable = (v: object): v is ReactiveDisposable => {\n  return (`isDisposed` in v && `dispose` in v);\n}\n\n\nexport function number(initialValue: number): ReactiveDisposable & ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveDisposable & ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveDisposable & ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    value: events.value,\n    set\n  }\n}\n\nexport function fromEvent<V extends Record<string, any>>(target: EventTarget, name: string, options: EventOptions<V>): ReactiveInitial<V> & ReactiveDisposable;\n\nexport function fromEvent<V extends Record<string, any>>(target: EventTarget, name: string, options?: Optional<EventOptions<V>, `process`>): ReactiveNonInitial<V> & ReactiveDisposable;\n\n/**\n * Subscribes to an event, emitting data\n * @param target Event emitter\n * @param name Event name\n * @param options Options\n * @returns \n */\nexport function fromEvent<V extends Record<string, any>>(target: EventTarget, name: string, options: Partial<EventOptions<V>> = {}): (ReactiveInitial<V> | ReactiveNonInitial<V>) & ReactiveDisposable {\n  const process = options.process;\n  const initialValue = process ? process() : undefined;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const rxObject = initialValue ? fromObject<V>(initialValue, { deepEntries: true }) : fromObject<V>(undefined, { deepEntries: true });\n  const lazy = options.lazy ?? false;\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(process ? process(args) : args);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Reactive.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Reactive.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<V>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    value: (handler: (v: V) => void) => {\n      if (lazy) add();\n      return rxObject.value(handler);\n    }\n  }\n}\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as Array<HTMLElement>;\n\n  return fromObject(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    value: events.value\n  };\n}\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.value(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined) {\n  const ow = observableWritable(init);\n  return {\n    on: ow.on,\n    value: ow.value\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined) {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    value: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n\nexport function fromObject<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\n\nexport function fromObject<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link fromProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = fromObject({ name: `bob`, level: 2 });\n * o.on(value => {\n *  const changed = value.value;\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `on` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = fromObject({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function fromObject<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDisposable & ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? Immutable.isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Array<Immutable.Change<any>>>();\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    if (value !== undefined) {\n      const diff = Immutable.compareData(value, v, { ...options, includeMissingFromA: true });\n      //console.log(`fromObject.set diff`, diff);\n      if (diff.length === 0) return;\n      diffEvent.set(diff);\n    }\n\n    value = v;\n    setEvent.set(v);\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //const pd = Immutable.getPathsAndData(toMerge);\n    //console.log(`pd: ${ JSON.stringify(pd) }`);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (value === undefined) {\n      value = toMerge as V;\n    } else {\n      const diff = Immutable.compareData(toMerge, value);\n      //console.log(`Reactive.fromObject value: ${ JSON.stringify(value) } diff: ${ JSON.stringify(diff) }`);\n      if (diff.length === 0) return; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      diffEvent.set(diff);\n      //diffEvent.notify(pd);\n    }\n    setEvent.set(value);\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`updateField value: ${ JSON.stringify(value) }`);\n    const existing = Immutable.getField<any>(value, path);\n    if (eq(existing, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existig: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    const o = Immutable.updateByPath(value, path, valueForField);\n    value = o;\n    diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n    setEvent.set(o);\n    //console.log(`Rx.object.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    value: setEvent.value,\n    onDiff: diffEvent.on,\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\nexport function fromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n  const rx = initStream<V>();\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  setTimeout(async () => {\n    try {\n      for await (const value of gen) {\n        rx.set(value);\n      }\n      rx.dispose(`Source generator complete`);\n    } catch (error) {\n      console.error(error);\n      rx.dispose(`Error while iterating`);\n    }\n  }, 1);\n  return rx;\n}\n\nexport type InitStreamOptions = {\n  onFirstSubscribe: () => void\n  onNoSubscribers: () => void\n}\n\n/**\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      //console.log(`initEvent:dispose (${ reason }) disposed: ${ disposed }`);\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    reset: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`Disposed`);\n      dispatcher?.notify({ value: v });\n    },\n    through: (pass: Passed<V>) => {\n      if (disposed) throw new Error(`Disposed`);\n      dispatcher?.notify(pass)\n    },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`Disposed`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    value: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: boolean\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n}\n\n/**\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport const initUpstream = <In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>) => {\n  const lazy = options.lazy ?? true;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n\n  const start = () => {\n    if (unsub !== undefined) return;\n\n    if (options.onStart) options.onStart();\n    unsub = source.on(value => {\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          stop();\n          if (disposeIfSourceDone) events.dispose(`Source is completed`);\n        } else {\n          events.through(value);\n        }\n      } else if (messageHasValue(value)) {\n        onValue(value.value);\n      }\n    });\n  }\n\n  const stop = () => {\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const initOpts: InitStreamOptions = {\n    onFirstSubscribe() {\n      if (lazy) start();\n    },\n    onNoSubscribers() {\n      if (lazy) stop();\n    },\n  }\n  if (!lazy) start();\n  const events = initStream<Out>(initOpts);\n  return events;\n}\n\nexport type GeneratorOptions = {\n  /**\n   * By default (true) only accesses the generator if there is a subscriber.\n   */\n  lazy: boolean\n}\n/**\n * Creates a readable reactive based on a generator\n * ```js\n * // Generators that makes a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Reactive.generator(time);\n * // Get notified when there is a new value\n * r.on(v => {\n *   console.log(v.value);\n * });\n * ```\n * @param generator \n */\nexport function generator<V>(generator: IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): ReactiveDisposable & Reactive<V> {\n  const lazy = options.lazy ?? true;\n  let reading = false;\n\n  const eventOpts: InitStreamOptions = {\n    onFirstSubscribe() {\n      if (lazy && !reading) {\n        readingStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy && reading) {\n        reading = false;\n      }\n    },\n  }\n  const events = initStream<V>(eventOpts);\n\n  const read = async () => {\n    try {\n      const v = await generator.next();\n      if (v.done) {\n        events.dispose(`Generator complete`);\n        return;\n      }\n      if (!reading) return;\n      events.set(v.value);\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    if (events.isDisposed()) return;\n    if (!reading) return;\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(read);\n  }\n\n  const readingStart = () => {\n    if (reading) return;\n    reading = true;\n    void read();\n  }\n  if (!lazy) readingStart();\n\n  return {\n    on: events.on,\n    value: events.value,\n    dispose: events.dispose,\n    isDisposed: events.isDisposed\n  }\n}\n\nexport type ReactiveOrSource<V> = Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V>\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>): Reactive<V> => {\n  if (`on` in source) return source;\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return generator(source.values(), { lazy: true });\n  } else {\n    return generator(source, { lazy: true });\n  }\n}\n\nexport type FromArrayOptions = {\n  /**\n   * Interval between each item being read. 5ms by default.\n   */\n  intervalMs: Interval\n  /**\n   * If _true_, only starts after first subscriber. _False_ by default.\n   */\n  lazy: boolean\n  /**\n   * Governs behaviour if all subscribers are removed AND lazy=true. By default continues\n   * iteration.\n   * \n   * * pause: stop at last array index\n   * * reset: go back to 0\n   * * empty: continue, despite there being no listeners (default)\n   */\n  idle: `` | `pause` | `reset`\n}\n\nexport const fromArray = <V>(array: Array<V>, options: Partial<FromArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? false;\n  const idle = options.idle ?? ``;\n  const intervalMs = intervalToMs(options.intervalMs, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initStream<V>({\n    onFirstSubscribe() {\n      //console.log(`Rx.fromArray onFirstSubscribe. Lazy: ${ lazy } reader state: ${ c.runState }`);\n      // Start if in lazy mode and not running\n      if (lazy && c.runState === `idle`) c.start();\n    },\n    onNoSubscribers() {\n      //console.log(`Rx.fromArray onNoSubscribers. Lazy: ${ lazy } reader state: ${ c.runState } on idle: ${ idle }`);\n      if (lazy) {\n        if (idle === `pause`) {\n          c.cancel();\n        } else if (idle === `reset`) {\n          c.cancel();\n          index = 0;\n        }\n      }\n    }\n  });\n\n  const c = continuously(() => {\n    //console.log(`Rx.fromArray loop index ${ index } lazy: ${ lazy }`);\n\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      //console.log(`Rx.fromArray exiting continuously`);\n      return false;\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    on: s.on,\n    value: s.value\n  }\n}\n\n/**\n * Reads the values of a reactive into an array.\n * Use the `limit` or `elapsed` to limit how many\n * items to read, and/or for how long.\n * @param reactive \n * @param options \n * @returns \n */\n// export const toArray = async <V>(reactiveSource: ReactiveOrSource<V>, options: Partial<ToArrayOptions> = {}): Promise<Array<V>> => {\n//   const source = resolveSource(reactiveSource);\n//   const maxValues = options.limit ?? Number.MAX_SAFE_INTEGER;\n//   const maxDuration = options.elapsed ?? Number.MAX_SAFE_INTEGER;\n//   let buffer: Array<V> = [];\n\n//   let start = -1;\n//   const promise = new Promise<Array<V>>((resolve, _reject) => {\n//     const done = () => {\n//       off();\n//       resolve(buffer);\n//       buffer = []\n//     }\n\n//     const off = source.on(value => {\n//       if (start === -1) start = Date.now();\n//       if (messageIsSignal(value) && value.signal === `done`) {\n//         done();\n//       } else if (messageHasValue(value)) {\n//         buffer.push(value.value);\n//         if (buffer.length >= maxValues) {\n//           done();\n//         }\n//       }\n//       if (Date.now() - start > maxDuration) {\n//         done();\n//       }\n//     });\n//   })\n//   return promise;\n// }\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as Array<V>;\n\n}\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V | undefined>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: Array<V | undefined> = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<Array<V | undefined>>((resolve, reject) => {\n\n    const done = () => {\n      clearTimeout(maxWait)\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) read[ index ] = options.fillValue;\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target`, so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = fromProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.value(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `fromProxy` instead of {@link fromObject} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = fromProxy({ colour: `red` });\n * ```\n * \n * See also:\n * * {@link fromProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * @param target \n * @returns \n */\nexport const fromProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n  const rx = fromObject(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n      if (typeof p === `string`) {\n        //console.log(`Rx.fromProxy set: ${ JSON.stringify(p) } to: ${ JSON.stringify(newValue) }`);\n        rx.updateField(p, newValue);\n      }\n\n      (target as any)[ p ] = newValue;\n      return true;\n    },\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link fromProxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const fromProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = fromProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}\n\n// wrap(event<{ x: number, y: number }>(document.body, `pointerup`))\n//   .batch({ elapsed: 200 })\n//   .transform(v => v.length)\n//   .value(v => { console.log(v) });","import * as Immutable from \"../Immutable.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport * as Rx from \"./Reactive.js\";\n\nexport type DomBindOptions<V> = {\n  /**\n   * If set, this DOM element field is set. Eg 'textContent'\n   */\n  elField?: string\n  /**\n   * If set, this DOM attribute is set, Eg 'width'\n   */\n  attribName?: string\n  /**\n   * If set, this CSS variable is set, Eg 'hue' (sets '--hue')\n   */\n  cssVariable?: string\n  /**\n   * If set, this CSS property is set, Eg 'background-color'\n   */\n  cssProperty?: string\n  /**\n   * Field from source value to pluck and use.\n   * This will also be the value passed to the transform\n   */\n  sourceField?: keyof V\n  transform?: (input: V) => string\n  transformValue?: (input: any) => string\n  query?: string\n  element?: HTMLElement\n}\n\nexport type DomBindOptionsWithElement<V> = DomBindOptions<V> & {\n  element: HTMLElement\n}\n\nexport type DomCreateOptions = {\n  tagName: string\n  parentEl: string | HTMLElement\n}\n\nexport type PipeDomBinding = {\n  /**\n   * Remove binding and optionally delete element(s) (false by default)\n   */\n  remove(deleteElements: boolean): void\n\n}\n/**\n * Updates an element's `textContent` when the source value changes\n * ```js\n * bindTextContent(`#blah`, source);\n * // Use function to get text value from source value\n * bindTextContent(myEl, source, v => v.name);\n * ```\n * \n * Uses {@link bind}, with `{field:'textContent'}` as the options\n * @param elOrQuery \n * @param source \n * @param transformer \n */\nexport const bindTextContent = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Shortcut to bind to innerHTML\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtmlContent = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns a {@link PipeDomBinding} to control binding\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove(); // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindElement = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, ...binds: Array<Partial<DomBindOptions<V>>>): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n  if (binds.length === 0) {\n    binds.push({ elField: `textContent` });\n  }\n  binds.map(bind => {\n    if (bind.element !== undefined) return bind;\n    return { ...bind, element: el }\n  });\n  return bind(source, ...(binds as Array<DomBindOptionsWithElement<V>>));\n}\n\n/**\n * Binds `source` to one or more element(s).\n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <V>(source: Rx.Reactive<V>, ...bindsUnresolvedElements: Array<DomBindOptions<V>>): PipeDomBinding => {\n  const binds = bindsUnresolvedElements.map(bind => {\n    if (bind.element) return bind;\n    if (bind.query) return { ...bind, element: resolveEl(bind.query) }\n    throw new Error(`Unable to resolve element`);\n  }) as Array<DomBindOptionsWithElement<V>>;\n\n  const resolveTransform = (bind: DomBindOptionsWithElement<V>) => {\n    if (!bind.transform && !bind.transformValue) return;\n    if (bind.transformValue) {\n      if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n      return (value: V) => {\n        const fieldValue = (value as any)[ bind.sourceField ]\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return bind.transformValue!(fieldValue);\n      }\n    } else if (bind.transform) {\n      if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return (value: V) => bind.transform!(value);\n    }\n  }\n\n  const resolveBindUpdater = (bind: DomBindOptionsWithElement<V>): (value: any) => void => {\n    if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined)) {\n      const field = bind.elField ?? `textContent`;\n      return (v: any) => {\n        (bind.element as any)[ field ] = v;\n      }\n    }\n    if (bind.attribName !== undefined) {\n      const attrib = bind.attribName;\n      return (v: any) => {\n        bind.element.setAttribute(attrib, v);\n      }\n    }\n    if (bind.cssVariable !== undefined) {\n      let css = bind.cssVariable;\n      if (!css.startsWith(`--`)) css = `--` + css;\n      return (v: any) => {\n        bind.element.style.setProperty(css, v);\n      }\n    }\n    if (bind.cssProperty !== undefined) {\n      return (v: any) => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        (bind.element.style as any)[ bind.cssProperty! ] = v;\n      }\n    }\n    return (_: any) => {\n      /** no-op */\n    }\n  }\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: V) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (Rx.messageHasValue(message)) {\n      update(message.value);\n    } else if (Rx.messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (Rx.messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\nexport type BindUpdateOpts<V> = {\n  initial: (v: V, el: HTMLElement) => void\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\n// export const bindDiffUpdate = <V>(\n//   elOrQuery: string | HTMLElement,\n//   source: Rx.ReactiveDiff<V>,\n//   updater: (diffs: Array<Change<any>>, el: HTMLElement) => void,\n//   opts: Partial<BindUpdateOpts<V>> = {}\n// ): PipeDomBinding & { refresh: () => void } => {\n//   const el = resolveEl(elOrQuery);\n\n//   const update = (value: Array<Change<any>>) => {\n//     updater(value, el);\n//   }\n\n//   const unsub = source.onDiff(message => {\n//     if (Rx.messageHasValue(message)) {\n//       update(message.value);\n//     } else {\n//       console.warn(message);\n//     }\n//   });\n\n//   const init = () => {\n//     if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n//   }\n\n//   init();\n\n//   return {\n//     refresh: () => {\n//       init();\n//     },\n//     remove: (removeElement: boolean) => {\n//       unsub();\n//       if (removeElement) {\n//         el.remove();\n//       }\n//     }\n//   }\n// }\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\nexport type ElementsOptions = {\n  container: HTMLElement | string\n  defaultTag: string\n}\n\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n\n  const elByField = new Map<string, HTMLElement>();\n\n  const create = (path: string, value: any) => {\n    // Create\n    const el = document.createElement(defaultTag);\n    el.setAttribute(`data-path`, path);\n    update(el, value);\n    containerEl.append(el);\n    elByField.set(path, el);\n  }\n\n  const update = (el: HTMLElement, value: any) => {\n    console.log(`update`, value);\n    el.textContent = value;\n  }\n\n  const changes = (changes: Array<Immutable.Change<any>>) => {\n    for (const d of changes) {\n      if (d.previous === undefined) {\n        create(d.path, d.value);\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(d.path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ d.path }`);\n        } else {\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(d.path);\n        if (el === undefined) {\n          //console.warn(`No element to update? ${ d.path }`);\n          create(d.path, d.value);\n        } else {\n          update(el, d.value);\n        }\n      }\n    }\n  }\n\n  source.onDiff(message => {\n    console.log(`diff`, message);\n    if (message.value) {\n      changes(message.value);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    const last = source.last();\n    console.log(`last`, last);\n    changes(Immutable.getPathsAndData(last as object));\n  }\n};\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = Rx.fromEvent(window, `resize`, {\n    lazy: true,\n    process: () => generateRect(),\n  });\n  const pointer = Rx.fromEvent(window, `pointermove`, {\n    lazy: true,\n    process: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { type Interval, intervalToMs } from \"../flow/IntervalType.js\";\nimport { type Reactive, type ReactiveWritable, messageHasValue, messageIsSignal, isDisposable, initStream, type InitStreamOptions, type ReactiveOrSource, initUpstream, messageIsDoneSignal, type ReactiveDisposable, type Passed, type ReactiveStream, resolveSource, toArray, type ToArrayOptions, toArrayOrThrow } from \"./Reactive.js\";\nimport { QueueMutable } from \"../collections/index.js\";\nimport { continuously } from \"../flow/Continuously.js\";\nimport { isPlainObjectOrPrimitive } from \"../Util.js\";\nimport { shuffle } from \"../collections/arrays/index.js\";\nimport { timeout } from \"../flow/Timeout.js\";\nimport { map as ImmutableMap } from \"../Immutable.js\";\n\nexport type TransformOpts = InitStreamOptions;\n\nexport type BatchOptions = InitStreamOptions & {\n  /**\n   * If _true_ (default) remaining results are yielded\n   * if source closes. If _false_, only 'complete' batches are yielded.\n   */\n  returnRemainder: boolean\n  elapsed: Interval\n  quantity: number\n}\n\nexport type FieldOptions<V> = InitStreamOptions & {\n\n  /**\n   * If `field` is missing on a value, this value is used in its place.\n   * If not set, the value is skipped.\n   */\n  missingFieldDefault: V\n};\n\n/**\n * Connects reactive A to B, passing through a transform function.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      b.set(transform(message.value));\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        if (isDisposable(b)) {\n          b.dispose(`Source closed (${ message.context })`);\n        } else {\n          console.warn(`Reactive.to cannot close 'b' reactive since it is not disposable`);\n        }\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      console.warn(`Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}\n\nexport type SplitOptions = {\n  quantity: number\n}\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param source \n * @param quantity \n * @returns \n */\nexport const split = <T>(options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  return (r: ReactiveOrSource<T>) => {\n    const outputs: Array<ReactiveStream<T>> = [];\n    const source = resolveSource(r);\n    for (let index = 0; index < quantity; index++) {\n      outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: true }));\n    }\n    return outputs;\n  }\n}\n\n/**\n * Splits `source` into several duplicated streams. Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const [a,b,c] = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param source \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(...labels: Array<K>) => {\n  return (r: ReactiveOrSource<T>): Record<K, Reactive<T>> => {\n    const source = resolveSource(r);\n    const t: Partial<Record<K, Reactive<T>>> = {}\n    for (const label of labels) {\n      t[ label ] = initUpstream(source, { lazy: true, disposeIfSourceDone: true });\n    }\n    return t as Record<K, Reactive<T>>;\n  }\n}\n\n/**\n * Switcher options.\n * \n * match (default: 'first')\n * * 'first': Outputs to first case where predicate is _true_\n * * 'all': Outputs to all cases where predicate is _true_\n */\nexport type SwitcherOptions = {\n  match: `first` | `all`\n}\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   console.log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   console.log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the console outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param source \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n  return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n    const match = options.match ?? `first`;\n    const source = resolveSource(r);\n    let disposed = false;\n    // Setup output streams\n    const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n    for (const label of Object.keys(cases)) {\n      (t as any)[ label ] = initStream<TValue>();\n    }\n\n    const performDispose = () => {\n      if (disposed) return;\n      unsub();\n      disposed = true;\n      for (const stream of Object.values(t)) {\n        (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n      }\n    }\n\n    // Listen to source\n    const unsub = source.on(message => {\n      // Got a value\n      if (messageHasValue(message)) {\n        for (const [ lbl, pred ] of Object.entries(cases)) {\n          if (pred(message.value)) {\n            ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n            if (match === `first`) break;\n          }\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose();\n      }\n    })\n    return t as Record<TLabel, Reactive<TValue>>;\n  }\n}\n\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...Array<Reactive<any> & ReactiveWritable<any>>,\n  ReactiveWritable<Out> & Reactive<any>\n]\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> & ReactiveDisposable => {\n  const event = initStream<TOutput>();\n  const unsubs: Array<() => void> = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (isDisposable(s) && !s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    value: event.value,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source.\n * \n * @param values \n * @returns \n */\nexport function mergeAsArray<V>(...values: Array<Reactive<V>>): Reactive<Array<V | undefined>> {\n  const event = initStream<Array<V | undefined>>();\n  const data: Array<V | undefined> = [];\n\n  for (const [ index, v ] of values.entries()) {\n    data[ index ] = undefined;\n    v.on(valueChanged => {\n      if (!messageIsSignal(valueChanged)) {\n        data[ index ] = valueChanged.value;\n      }\n      event.set(data);\n    });\n  }\n\n  return {\n    on: event.on,\n    value: event.value\n  }\n}\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send a value.\n * \n * Each source's latest value is returned, in the case of some sources producing results\n * faster than others.\n * \n * If a value completes, we won't wait for it and the result set gets smaller.\n * \n */\nexport function synchronise<V>() {\n  return (...sources: Array<ReactiveOrSource<V>>): Reactive<Array<V | undefined>> => {\n    const event = initStream<Array<V>>();\n    let data: Array<V | undefined> = [];\n\n    for (const [ index, source ] of sources.entries()) {\n      data[ index ] = undefined;\n      const v = resolveSource(source);\n      v.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            sources.splice(index, 1);\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (!data.includes(undefined)) {\n          // All array elements contain values\n          event.set(data as Array<V>);\n          data = [];\n        }\n      });\n    }\n\n    return {\n      on: event.on,\n      value: event.value\n    }\n  }\n}\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n  /**\n   * If _true_, resolution only starts after first subscriber. Looping, if active,\n   * stops if there are no subscribers.\n   * \n   * _False_ by default.\n   * \n   */\n  lazy: boolean\n}\n\n\n/**\n * Wraps a function or value as a reactive. Can optionally wait for a given period or continually produce the value.\n * \n * ```js\n * const rx = resolve('hello', { interval: 5000 });\n * rx.on(msg => {\n *  // 'hello' after 5 seconds\n *  console.log(msg.value);\n * });\n * ```\n * \n * ```js\n * // Produces a random number every second, but only\n * // when there is a subscriber.\n * const rx = resolve(() => Math.floor(Math.random()*100), { interval: 1000, infinite: true, lazy: true });\n * ```\n * \n * Options:\n * - Set _loops_ or _infinite_. If neither of these are set, it runs once.\n * - _interval_ is 0 by default.\n * @param callbackOrValue \n * @param options \n * @returns \n */\nexport function resolve<V>(callbackOrValue: V | (() => V), options: Partial<ResolveOptions> = {}): Reactive<V> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const lazy = options.lazy ?? false;\n  const event = initStream<V>({\n    onFirstSubscribe() {\n      if (lazy && c.runState === `idle`) c.start();\n    },\n    onNoSubscribers() {\n      if (lazy) {\n        c.cancel();\n      }\n    }\n  });\n\n  const loops = options.infinite ? Number.MAX_SAFE_INTEGER : options.loops ?? 1;\n  let remaining = loops;\n\n  const c = continuously(() => {\n    if (typeof callbackOrValue === `function`) {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      const value = (callbackOrValue as (Function))();\n      event.set(value);\n    } else {\n      event.set(callbackOrValue);\n    }\n    remaining--;\n    if (remaining === 0) return false; // Stop loop\n  }, intervalMs);\n\n\n  if (!lazy) c.start();\n\n  return {\n    on: event.on,\n    value: event.value\n  };\n}\n\n/**\n * From a source value, yields a field from it.\n * \n * If a source value doesn't have that field, it is skipped.\n\n * @returns \n */\nexport function field<TIn, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TFieldType>> = {}): ReactiveOp<TIn, TFieldType> {\n  return (fieldSource: ReactiveOrSource<TIn>): Reactive<TFieldType> => {\n    const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n      disposeIfSourceDone: true,\n      ...options,\n      onValue(value) {\n        let t = (value)[ fieldName ];\n        if (t === undefined && options.missingFieldDefault !== undefined) {\n          // @ts-expect-error\n          t = options.missingFieldDefault as TFieldType;\n        }\n        upstream.set(t as TFieldType);\n      },\n    })\n\n    return toReadable(upstream);\n  }\n}\n\nexport type FilterPredicate<In> = (value: In) => boolean;\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): ReactiveOp<In, In> {\n  return (input: ReactiveOrSource<In>): Reactive<In> => {\n    const upstream = initUpstream<In, In>(input, {\n      ...options,\n      onValue(value) {\n        if (predicate(value)) {\n          upstream.set(value);\n        }\n      },\n    })\n\n    return toReadable(upstream);\n  }\n}\n\nconst toReadable = <V>(upstream: ReactiveStream<V>) => ({ on: upstream.on, value: upstream.value });\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): ReactiveOp<In, Out> {\n  return (input: ReactiveOrSource<In>): Reactive<Out> => {\n    const upstream = initUpstream<In, Out>(input, {\n      ...options,\n      onValue(value) {\n        const t = transformer(value);\n        upstream.set(t);\n      },\n    })\n\n    return toReadable(upstream);\n  }\n}\n\n\n/**\n * Annotates values from `source`, appending new fields to values.\n * Output stream will be the type `In & Out`.\n */\nexport function annotate<In, TAnnotation>(transformer: (value: In) => In & TAnnotation, options: Partial<TransformOpts> = {}): ReactiveOp<In, In & TAnnotation> {\n  return (input: ReactiveOrSource<In>): Reactive<In & TAnnotation> => {\n    const upstream = initUpstream<In, In & TAnnotation>(input, {\n      ...options,\n      onValue(value) {\n        const t = transformer(value);\n        upstream.set(t);\n      },\n    })\n\n    return toReadable(upstream);\n  }\n}\n\nexport type AnnotationElapsed = {\n  elapsedMs: number\n}\n\n/**\n * Annotates values from `source`, adding a `elapsedMs` field to values.\n * Elapsed will be the time in milliseconds since the last value. If it is the first value, -1 is used.\n * @param input \n * @param transformer \n * @param options \n * @returns \n */\nexport const annotateElapsed = <In>() => {\n  return (input: ReactiveOrSource<In>) => {\n    let last = 0;\n    const a = annotate<In, AnnotationElapsed>((value) => {\n      const elapsed = last === 0 ? 0 : Date.now() - last;\n      last = Date.now();\n      return { ...value, elapsedMs: elapsed };\n    })(input);\n    return a;\n  }\n}\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param input \n * @returns \n */\nexport const cloneFromFields = <In>(): ReactiveOp<In, In> => transform<In, In>((v): In => {\n  const entries: Array<[ key: string, value: any ]> = [];\n  for (const field in v) {\n    const value = (v as any)[ field ];\n    if (isPlainObjectOrPrimitive(value as unknown)) {\n      entries.push([ field, value ]);\n    }\n  }\n  return Object.fromEntries(entries) as In;\n})\n\nexport type SingleFromArrayOptions<V> = {\n  /**\n   * Function to select a single value from array\n   * @param value \n   * @returns \n   */\n  predicate: (value: V) => boolean\n  /**\n   * `default`: leave array in same order (default option)\n   * `random`: shuffles array before further processing\n   * function: function that sorts values\n   */\n  order: `default` | `random` | ((a: V, b: V) => number)\n  /**\n   * Selects an index from array. 0 being first, 1 being second.\n   * Reverse indexing also works: -1 being last, -2 being second last...\n   * \n   * If index exceeds length of array, _undefined_ is returned\n   */\n  at: number\n}\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<Array<V>>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: Array<V>) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<Array<V>, V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n\n/**\n * Batches values from `source`, and then emits a single value according to the selection logic.\n * @param source \n * @param options \n * @returns \n */\n// export function batchAndSingle<V>(options: Partial<SingleFromArrayOptions<V> & BatchOptions>): ReactiveOp<V, V> {\n//   const b = batch(options);\n//   return (source: ReactiveOrSource<V>) => {\n//     const batched = batch(source, options);\n//     const single = singleFromArray(batched, options);\n//     return single;\n//   }\n// }\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  source: Reactive<TIn>,\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn>>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn | undefined>>\n  /**\n   * Accumulate a batch of values, emitted as an array\n   * @param options \n   * @returns \n   */\n  batch: (options: Partial<BatchOptions>) => Wrapped<Array<TIn>>\n  /**\n   * Annotate values with a timestamp of elapsed time\n   * (uses `annotate`)\n   * @returns \n   */\n  annotateElapsed: () => Wrapped<TIn & AnnotationElapsed>\n  /**\n   * Annotate values with some additional field(s)\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TIn & TAnnotation) => Wrapped<TIn & TAnnotation>\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options: Partial<SplitOptions>) => Array<Wrapped<TIn>>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n  /**\n   * Emits values when this stream and any additional streams produce a value.\n   * Outputted values captures the last value from each stream.\n   * @returns \n   */\n  synchronise: (...additionalSources: Array<ReactiveOrSource<TIn> | Wrapped<TIn>>) => Wrapped<Array<TIn | undefined>>\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => Record<K, Wrapped<TIn>>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  value: (callback: (value: TIn) => void) => void\n}\n\n/**\n * Wrap a reactive source in a OOP wrapper to allow for chained\n * function calls.\n * \n * For every `pointerup` event on the body, batch the events over\n * periods of 200ms, and then get the number of events in that period,\n * finally printing it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(event<{ x: number, y: number }>(document.body, `pointerup`))\n *  .batch({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .value(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    value: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    },\n    batch: (options: Partial<BatchOptions>): Wrapped<Array<TIn>> => {\n      const w = wrap<Array<TIn>>(batch(source, options));\n      return w;\n    },\n    annotate: <TAnnotation>(transformer: (value: TIn) => TIn & TAnnotation): Wrapped<TIn & TAnnotation> => {\n      const a = annotate<TIn, TAnnotation>(transformer)(source);\n      return wrap(a);\n    },\n    annotateElapsed: () => {\n      return wrap(annotateElapsed<TIn>()(source));\n    },\n    field: <TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TFieldType>> = {}) => {\n      const f = field<TIn, TFieldType>(fieldName, options)(source);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(filter(predicate, options)(source));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = split<TIn>(options)(source).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => {\n      const l = splitLabelled<TIn, keyof TIn>(...labels)(source);\n      const m = ImmutableMap<typeof l, Wrapped<TIn>>(l, v => wrap(v)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = switcher<TIn, TRec, TLabel>(cases, options)(source);\n      const m = ImmutableMap<typeof s, Wrapped<TIn>>(s, v => wrap(v));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    synchronise: (...additionalSources: Array<Wrapped<TIn> | ReactiveOrSource<TIn>>) => {\n      const unwrapped: Array<Reactive<TIn>> = additionalSources.map(v => {\n        return `source` in v ? v.source : resolveSource(v);\n      });\n      return wrap(synchronise<TIn>()(source, ...unwrapped));\n    },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(debounce<TIn>(source, options));\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(transform(transformer, options)(source));\n    }\n  }\n}\n\n// export function batchOp<V>(options: Partial<BatchOptions>): ReactiveOp<V, Array<V>> {\n//   return (source: ReactiveOrSource<V>) => {\n//     return batch(source, options);\n//   }\n// }\n\nconst opify = <V>(fn: (source: ReactiveOrSource<V>, ...args: Array<any>) => Reactive<V>, ...args: Array<any>) => {\n  return (source: ReactiveOrSource<V>) => {\n    return fn(source, ...args);\n  }\n}\n\nexport const Ops = {\n  batch: <V>(options: Partial<BatchOptions>): ReactiveOp<V, Array<V>> => {\n    return (source: ReactiveOrSource<V>) => {\n      return batch(source, options);\n    }\n  },\n  debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return debounce(source, options);\n    }\n  },\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(throttle, options)\n  // throttle: <V>(options: Partial<ThrottleOptions>): ReactiveOp<V, V> => {\n  //   return (source: ReactiveOrSource> V >)\n  // }\n} as const;\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...Array<ReactiveOp<any, any>>,\n  ReactiveOp<any, Out>\n]\n\n/**\n * Connects all the `ops` together, ready for a source.\n * Returns a function that takes a `source`.\n * @param ops \n * @returns \n */\nconst prepareOps = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    for (const op of ops) {\n      // @ts-expect-error\n      source = op(source);\n    }\n    return source as any as Reactive<TOut>;\n  }\n}\n\n/**\n * Connects `source` to serially-connected set of ops. Values thus\n * flow from `source` to each op in turn.\n * \n * Returned result is the final reactive.\n * \n * @param source \n * @param ops \n * @returns \n */\nexport function run<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>) {\n  const raw = prepareOps<TIn, TOut>(...ops);\n  return raw(source);\n}\n\n/**\n * Queue from `source`, emitting when thresholds are reached. Returns a new Reactive\n * which produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in batches of 5 items\n * batch(source, { quantity: 5 });\n * // Emit data every second\n * batch(source, { elapsed: 1000 });\n * ```\n * @param batchSource \n * @param options \n * @returns \n */\nexport function batch<V>(batchSource: ReactiveOrSource<V>, options: Partial<BatchOptions> = {}): Reactive<Array<V>> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  //const logic = options.logic ?? `or`;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  //let lastFire = performance.now();\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      //console.log(`Reactive.batch onValue. Queue len: ${ queue.length } quantity: ${ quantity } timer state: '${ timer?.runState }'`);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      //console.log(timer?.isDone);\n      if (timer !== undefined && timer.runState === `idle`) {\n        //console.log(`Reactive.batch timer started`);\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(batchSource, upstreamOpts);\n\n  const send = () => {\n    //console.log(`Reactive.batch send`);\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    upstream.set(data);\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n\nexport type DebounceOptions = InitStreamOptions & {\n  /**\n   * Minimum time between events. Default 50ms\n   */\n  elapsed: Interval\n}\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n\nexport type ThrottleOptions = InitStreamOptions & {\n  elapsed: Interval\n}\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { QueueMutable, StackMutable } from \"../../collections/index.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport { Sync } from \"../../Generators.js\"\nimport { Table } from \"../Table.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. By default unidirectional.\n * Returns a new graph with the connection\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n  }\n\n  if (!bidi) return graph;\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n  }\n  return graph;\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    `${ v.id }`\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","import { initStream, type Reactive } from \"./Reactive.js\"\n\nimport * as DiGraph from \"./graphs/DirectedGraph.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\nfunction isReactive(o: object): o is Reactive<any> {\n  if (typeof o !== `object`) return false;\n  if (`on` in o) {\n    return (typeof o.on === `function`);\n  }\n  return false;\n}\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param rx \n */\nexport function prepare<V extends Record<string, any>>(rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Reactive.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Reactive.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    value: events.value\n  }\n  return returnValue;\n}\n\n","import type { Interval } from 'src/flow/IntervalType.js';\nimport * as Rx from '../data/Reactive.js';\n\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param timeoutMs\n * @returns\n */\nexport const windowResize = (elapsed?: Interval) => Rx.Ops.debounce<UIEvent>({ elapsed: elapsed ?? 100 })(Rx.fromEvent(window, `resize`));\n\n/**\n * Observe when document's class changes\n *\n * ```js\n * const c = themeChangeObservable();\n * c.on(msg => {\n *  // do something...\n * });\n * ```\n * @returns\n */\nexport const themeChange = () => {\n  const m = Rx.observable<Array<MutationRecord>>(stream => {\n    const ro = new MutationObserver((entries) => {\n      stream.set(entries);\n    });\n    const opts: MutationObserverInit = {\n      attributeFilter: [ `class` ],\n      attributes: true,\n    };\n    ro.observe(document.documentElement, opts);\n\n    return () => {\n      ro.disconnect();\n    }\n  });\n  return m;\n}\n\n/**\n * Observe when element resizes. Specify `timeoutMs` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param timeoutMs Tiemout before event gets triggered\n * @returns\n */\nexport const resizeObservable = (\n  elem: Readonly<Element>,\n  timeout?: Interval\n) => {\n  if (elem === null) {\n    throw new Error(`elem parameter is null. Expected element to observe`);\n  }\n  if (elem === undefined) {\n    throw new Error(`elem parameter is undefined. Expected element to observe`);\n  }\n\n  const m = Rx.observable<Array<ResizeObserverEntry>>(stream => {\n    const ro = new ResizeObserver((entries) => {\n      stream.set(entries);\n    });\n    ro.observe(elem);\n\n    return () => {\n      ro.unobserve(elem);\n    };\n  });\n  return Rx.Ops.debounce<Array<ResizeObserverEntry>>({ elapsed: timeout ?? 100 })(m);\n}\n\n\n\n//elements(Rx.fromObject([ `a`, `b`, `c` ]));\n","import { resizeObservable, windowResize } from \"./DomRx.js\";\nimport type { ElementResizeArgs as ElementResizeArguments } from \"./ElementSizing.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\n\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport type CanvasResizeArgs = ElementResizeArguments<HTMLCanvasElement> & {\n  readonly ctx: CanvasRenderingContext2D;\n};\n\n\n/**\n * Resizes given canvas to its parent element.\n * To resize canvas to match the viewport, use {@link fullSizeCanvas}.\n *\n * Provide a callback for when resize happens.\n * @param domQueryOrEl Query string or reference to canvas element\n * @param onResized Callback for when resize happens, eg for redrawing canvas\n * @returns Observable\n */\nexport const parentSizeCanvas = (\n  domQueryOrEl: Readonly<string | HTMLCanvasElement>,\n  onResized?: (args: CanvasResizeArgs) => void,\n  timeoutMs = 100\n) => {\n  const el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n  if (el.nodeName !== `CANVAS`) {\n    throw new Error(\n      `Expected HTML element with node name CANVAS, not ${ el.nodeName }`\n    );\n  }\n  const parent = el.parentElement;\n  if (parent === null) throw new Error(`Element has no parent`);\n\n  const ctx = (el).getContext(`2d`);\n  if (ctx === null) throw new Error(`Could not create drawing context`);\n\n  //const safetyMargin = 4;\n\n  el.style.width = `100%`;\n  el.style.height = `100%`;\n\n\n  const ro = resizeObservable(parent, timeoutMs).value(\n    entries => {\n      const entry = entries.find((v) => v.target === parent);\n      if (entry === undefined) return;\n\n      const width = entry.contentRect.width;\n      const height = entry.contentRect.height;\n      //console.log(`contentH: ${e.contentRect.height} current: ${el.getBoundingClientRect().height}`);\n\n      // el.setAttribute(`width`, width-safetyMargin + `px`);\n      // el.setAttribute(`height`, height-safetyMargin + `px`);\n      el.setAttribute(`width`, el.offsetWidth + `px`);\n      el.setAttribute(`height`, el.offsetHeight + `px`);\n\n      if (onResized !== undefined) {\n        const bounds = {\n          min: Math.min(width, height),\n          max: Math.max(width, height),\n          width,\n          height,\n          center: { x: width / 2, y: height / 2 },\n        };\n        onResized({ ctx, el, bounds });\n      }\n    }\n  );\n\n  return ro;\n};\n\n\n/**\n * Resizes given canvas element to match window size.\n * To resize canvas to match its parent, use {@link parentSizeCanvas}.\n *\n * To make the canvas appear propery, it sets the following CSS:\n * ```css\n * {\n *  top: 0;\n *  left: 0;\n *  zIndex: -1;\n *  position: fixed;\n * }\n * ```\n * Pass _true_ for `skipCss` to avoid this.\n *\n * Provide a callback for when resize happens.\n * @param domQueryOrEl Query string or reference to canvas element\n * @param onResized Callback for when resize happens, eg for redrawing canvas\n * @param skipCss if true, style are not added\n * @returns Observable\n */\nexport const fullSizeCanvas = (\n  domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>,\n  onResized?: (args: CanvasResizeArgs) => void,\n  skipCss = false\n) => {\n  if (domQueryOrEl === null || domQueryOrEl === undefined) {\n    throw new Error(`domQueryOrEl is null or undefined`);\n  }\n  const el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n  if (el.nodeName !== `CANVAS`) {\n    throw new Error(\n      `Expected HTML element with node name CANVAS, not ${ el.nodeName }`\n    );\n  }\n  const ctx = el.getContext(`2d`);\n  if (ctx === null) throw new Error(`Could not create drawing context`);\n\n  const update = () => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    el.width = width;\n    el.height = height;\n\n    if (onResized !== undefined) {\n      const bounds = {\n        min: Math.min(width, height),\n        max: Math.max(width, height),\n        width,\n        height,\n        center: { x: width / 2, y: height / 2 },\n      };\n      onResized({ ctx, el, bounds });\n    }\n  };\n\n  // Setup\n  if (!skipCss) {\n    el.style.top = `0`;\n    el.style.left = `0`;\n    el.style.zIndex = `-100`;\n    el.style.position = `fixed`;\n  }\n\n  const r = windowResize();\n  r.value(update);\n\n  update();\n  return r;\n};\n"],"mappings":"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","names":["bind","field","changes","transform","field","graph","vertices","to","elements","generator","resolve","target","timeout"]}