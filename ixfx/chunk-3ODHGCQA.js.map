{"version":3,"sources":["../src/flow/StateMachine.ts","../src/flow/Execute.ts","../src/flow/StateMachineDriver.ts","../src/flow/StateMachineWithEvents.ts"],"sourcesContent":["import { unique } from '../collections/arrays/index.js';\n\n\n\n/**\n * State machine driver\n */\nexport { init as driver } from './StateMachineDriver.js';\nexport type {\n  DriverOpts,\n  StatesHandler as DriverHandler,\n  Runner,\n  ExpressionOrResult as DriverExpression,\n  Result as DriverResult,\n} from './StateMachineDriver.js';\n\n/**\n * Transition result\n * * 'Ok': transition valid\n * * 'FromNotFound': the from state is missing from machine definition\n * * 'ToNotFound': the 'to' state is missing from machine definition\n * * 'Invalid': not allowed to transition to target state from the current state\n * * 'Terminal':  not allowed to transition because from state is the final state\n */\nexport type TransitionResult =\n  | `Ok`\n  | `FromNotFound`\n  | `ToNotFound`\n  | `Invalid`\n  | `Terminal`;\n\nexport type TransitionCondition<V extends Transitions> = {\n  readonly hasPriorState: ReadonlyArray<StateNames<V>>;\n  readonly isInState: StateNames<V>;\n};\n\nexport type StateTargetStrict<V extends Transitions> = {\n  readonly state: StateNames<V> | null;\n  readonly preconditions?: ReadonlyArray<TransitionCondition<V>>;\n};\n\n/**\n * Possible state transitions, or _null_ if final state.\n */\n//export type StateTarget<V extends Transitions> = StateTargetExt<V> | null;\n\nexport type StateTarget<V extends Transitions> =\n  | string\n  //eslint-disable-next-line functional/prefer-readonly-type\n  | Array<string>\n  | ReadonlyArray<string>\n  | null\n  | StateTargetStrict<V>;\n//eslint-disable-next-line functional/prefer-readonly-type\n// | StateTargetStrict<V>[]\n// | readonly StateTargetStrict<V>[];\n\n/**\n * Maps state to allowable next states\n */\nexport type Transitions = {\n  readonly [ key: string ]: StateTarget<Transitions>;\n};\n\nexport type TransitionsStrict = Readonly<Record<string, ReadonlyArray<StateTargetStrict<Transitions>>>>;\n/**\n * List of possible states\n */\nexport type StateNames<V extends Transitions> = keyof V & string;\n\nexport type Machine<V extends Transitions> = {\n  /**\n   * Allowable state transitions\n   */\n  readonly states: V;\n};\n\n/**\n * Encapsulation of a 'running' machine description and state.\n *\n * See:\n * - {@link cloneState}\n */\nexport type MachineState<V extends Transitions> = {\n  /**\n   * Current state\n   */\n  readonly value: StateNames<V>;\n  /**\n   * List of unique states visited. Won't contain the current\n   * state unless it has already been visited.\n   */\n  readonly visited: ReadonlyArray<StateNames<V>>;\n\n  //readonly machine: Machine<V>;\n  readonly machine: {\n    readonly [ key in StateNames<V> ]: ReadonlyArray<StateTargetStrict<V>>;\n  };\n};\n\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = <V extends Transitions>(\n  toClone: MachineState<V>\n): MachineState<V> => {\n  return Object.freeze({\n    value: toClone.value,\n    visited: [ ...toClone.visited ],\n    machine: toClone.machine,\n  });\n};\n/**\n * Initialises a state machine\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * StateMachineLight.done(sm); // false\n * StateMachineLight.possible(sm); // [ 'shirt' ]\n * ```\n * @param sm\n * @param initialState\n * @returns\n */\nexport const init = <V extends Transitions>(\n  stateMachine: Machine<V> | Transitions | TransitionsStrict,\n  initialState?: StateNames<V>\n): MachineState<V> => {\n  const [ machine, machineValidationError ] = validateMachine(stateMachine);\n  if (!machine) throw new Error(machineValidationError);\n\n  const state: StateNames<V> =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState!) ?? Object.keys(machine.states)[ 0 ];\n  if (machine.states[ state ] === undefined) {\n    throw new TypeError(`Initial state not found`);\n  }\n\n  // Normalise states\n  const transitions = validateAndNormaliseTransitions(machine.states);\n  if (transitions === undefined) {\n    throw new Error(`Could not normalise transitions`);\n  }\n  // @ts-expect-error\n  return Object.freeze({\n    value: state,\n    visited: [],\n    machine: Object.fromEntries(transitions),\n  });\n};\n\nexport const reset = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  // @ts-expect-error\n  return init<V>(sm.machine);\n};\n\nexport const validateMachine = <V extends Transitions>(\n  smOrTransitions: Machine<V> | Transitions | TransitionsStrict\n): [ machine: Machine<V> | undefined, msg: string ] => {\n  if (smOrTransitions === undefined) {\n    return [ undefined, `Parameter undefined` ];\n  }\n  if (smOrTransitions === null) {\n    return [ undefined, `Parameter null` ];\n  }\n  if (`states` in smOrTransitions) {\n    // Assume Machine type\n    return [ smOrTransitions as Machine<V>, `` ];\n  }\n  if (typeof smOrTransitions === `object`) {\n    return [\n      {\n        // @ts-expect-error\n        states: smOrTransitions,\n      },\n      ``,\n    ];\n  }\n  return [\n    undefined,\n    `Unexpected type: ${ typeof smOrTransitions }. Expected object`,\n  ];\n};\n\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n\n/**\n * Returns _true_ if `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const done = <V extends Transitions>(sm: MachineState<V>): boolean => {\n  return possible(sm).length === 0;\n};\n\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = <V extends Transitions>(\n  sm: MachineState<V>\n): ReadonlyArray<StateTargetStrict<V>> => {\n  // Validate current state\n  validateMachineState(sm);\n  // get list of possible targets\n  const fromS = sm.machine[ sm.value ];\n\n  if (fromS.length === 1 && fromS[ 0 ].state === null) return [];\n  return fromS;\n};\n\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = <V extends Transitions>(\n  sm: MachineState<V>\n): Array<StateNames<V> | null> => {\n  const targets = possibleTargets(sm);\n  return targets.map((v) => v.state);\n};\n\nexport const normaliseTargets = <V extends Transitions>(\n  targets:\n    | StateTarget<V>\n    | ReadonlyArray<StateTargetStrict<V>>\n    //eslint-disable-next-line functional/prefer-readonly-type\n    | StateTargetStrict<V>\n): Array<StateTargetStrict<V>> | null | undefined => {\n  const normaliseSingleTarget = (\n    target: string | undefined | null | object\n  ): StateTargetStrict<V> | undefined => {\n    // Terminal target\n    if (target === null) return { state: null };\n    // String is the target state\n    if (typeof target === `string`) {\n      return {\n        state: target,\n      };\n    } else if (typeof target === `object` && `state` in target) {\n      const targetState = target.state;\n      if (typeof targetState !== `string`) {\n        throw new TypeError(\n          `Target 'state' field is not a string. Got: ${ typeof targetState }`\n        );\n      }\n      if (`preconditions` in target) {\n        return {\n          state: targetState,\n          preconditions: target.preconditions as Array<TransitionCondition<V>>,\n        };\n      }\n      return { state: targetState };\n    } else {\n      throw new Error(\n        `Unexpected type: ${ typeof target }. Expected string or object with 'state' field.`\n      );\n    }\n  };\n\n  // Array of targets (either strings or objects)\n  if (Array.isArray(targets)) {\n    //eslint-disable-next-line functional/no-let\n    let containsNull = false;\n    const mapResults = targets.map((t) => {\n      const r = normaliseSingleTarget(t);\n      if (!r) throw new Error(`Invalid target`);\n      containsNull = containsNull || r.state === null;\n      return r;\n    });\n    if (containsNull && mapResults.length > 1) {\n      throw new Error(`Cannot have null as an possible state`);\n    }\n    return mapResults;\n  } else {\n    const target = normaliseSingleTarget(targets);\n    if (!target) return;\n    return [ target ];\n  }\n};\n\nconst validateAndNormaliseTransitions = (\n  d: Transitions\n): Map<string, Array<StateTargetStrict<typeof d>>> | undefined => {\n  const returnMap = new Map<string, Array<StateTargetStrict<typeof d>>>();\n\n  // 1. Index top-level states\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    if (typeof topLevelState === `undefined`) {\n      throw new TypeError(`Top-level undefined state`);\n    }\n    if (typeof topLevelTargets === `undefined`) {\n      throw new TypeError(`Undefined target state for ${ topLevelState }`);\n    }\n    if (returnMap.has(topLevelState)) {\n      throw new Error(`State defined twice: ${ topLevelState }`);\n    }\n    if (topLevelState.includes(` `)) {\n      throw new Error(`State names cannot contain spaces`);\n    }\n    returnMap.set(topLevelState, []);\n  }\n\n  // 2. Normalise target\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    const targets = normaliseTargets(topLevelTargets);\n    if (targets === undefined) throw new Error(`Could not normalise target`);\n    if (targets !== null) {\n      // Check that they all exist as top-level states\n      const seenStates = new Set();\n      for (const target of targets) {\n        if (seenStates.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' already exists for '${ topLevelState }'`\n          );\n        }\n        seenStates.add(target.state);\n        if (target.state === null) continue;\n        if (!returnMap.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' is not defined as a top-level state. Defined under: '${ topLevelState }'`\n          );\n        }\n      }\n      returnMap.set(topLevelState, targets);\n    }\n  }\n  return returnMap;\n};\n\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = <V extends Transitions>(\n  state: MachineState<V>\n): void => {\n  if (state === undefined) {\n    throw new TypeError(`Parameter 'state' is undefined`);\n  }\n  if (typeof state.value !== `string`) {\n    throw new TypeError(`Existing state is not a string`);\n  }\n};\n\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): MachineState<V> => {\n  validateMachineState(sm); // throws if not OK\n  validateTransition(sm, toState); // throws if not OK\n  return Object.freeze({\n    value: toState,\n    machine: sm.machine,\n    visited: unique<string>([ sm.visited as Array<string>, [ sm.value ] as Array<string> ]),\n  });\n};\n\nexport const next = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  //validateMachineState(sm);\n  const first = possibleTargets(sm).at(0);\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (!first || first.state === null) {\n    throw new Error(\n      `Not possible to move to a next state from '${ sm.value }`\n    );\n  }\n  return to(sm, first.state);\n};\n\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): boolean => {\n  try {\n    validateTransition(sm, toState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const validateTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): void => {\n  if (toState === null) throw new Error(`Cannot transition to null state`);\n  if (toState === undefined) {\n    throw new Error(`Cannot transition to undefined state`);\n  }\n  if (typeof toState !== `string`) {\n    throw new TypeError(\n      `Parameter 'toState' should be a string. Got: ${ typeof toState }`\n    );\n  }\n\n  //const toS = sm.machine[toState];\n  //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n\n  const p = possible(sm);\n  if (p.length === 0) throw new Error(`Machine is in terminal state`);\n  if (!p.includes(toState)) {\n    throw new Error(\n      `Target state '${ toState }' not available at current state '${ sm.value\n      }'. Possible states: ${ p.join(`, `) }`\n    );\n  }\n};\n\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n * \n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states: ReadonlyArray<string>): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length <= 2) throw new Error(`Expects at least two states`);\n  for (let index = 0; index < states.length; index++) {\n    const s = states[ index ];\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index }`\n      );\n    }\n    // @ts-expect-error\n    t[ s ] = index === states.length - 1 ? null : states[ index + 1 ];\n  }\n  return t;\n};\n\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n * \n * See also {@link fromList}.\n * \n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (\n  ...states: ReadonlyArray<string>\n): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length < 2) throw new Error(`Expects at least two states`);\n\n  for (const [ index, s ] of states.entries()) {\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index }`\n      );\n    }\n\n    /** @ts-expect-error */\n    //eslint-disable-next-line functional/immutable-data\n    t[ s ] = [];\n  }\n\n  for (let index = 0; index < states.length; index++) {\n    /** @ts-expect-error */\n    const v = t[ states[ index ] ] as Array<string>;\n    if (index === states.length - 1) {\n      if (states.length > 1) {\n        //eslint-disable-next-line functional/immutable-data\n        v.push(states[ index - 1 ]);\n      } else {\n        /** @ts-expect-error */\n        //eslint-disable-next-line functional/immutable-data\n        t[ states[ index ] ] = null;\n      }\n    } else {\n      //eslint-disable-next-line functional/immutable-data\n      v.push(states[ index + 1 ]);\n      //eslint-disable-next-line functional/immutable-data\n      if (index > 0) v.push(states[ index - 1 ]);\n    }\n  }\n  return t;\n};\n\nexport { StateMachineWithEvents as WithEvents, type Opts as StateMachineWithEventsOpts, type StateMachineEventMap, type StopEvent } from './StateMachineWithEvents.js';","import { defaultComparer, type Comparer } from '../util/index.js';\nimport { shuffle } from '../collections/arrays/index.js';\n\nexport type ExpressionOrResult<ArgsType, ResultType> =\n  | ResultType\n  | ((\n    args: ArgsType | undefined\n  ) => Promise<ResultType | undefined> | ResultType | undefined | void);\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type RunOpts<ResultType> = {\n  /**\n   * If provided, filters the set of results prior to returning.\n   * @param result\n   * @returns\n   */\n  readonly filter?: (result: ResultType) => boolean;\n  /**\n   * If true, execution order is shuffled each time\n   */\n  readonly shuffle?: boolean;\n  /**\n   * Function to rank results. By default uses {@link defaultComparer} which orders\n   * by numeric value or alphabetical.\n   */\n  readonly rank?: Comparer<ResultType>;\n  /**\n   * If provided, stops execution if _true_ is returned.\n   * Result(s) include most recent execution.\n   * @param latest Latest result\n   * @param sorted Sorted list of current results, not including latest\n   * @returns\n   */\n  readonly stop?: (\n    latest: ResultType | undefined,\n    sorted: readonly ResultType[]\n  ) => boolean;\n};\n\nexport type RunSingleOpts<V> = RunOpts<V> & {\n  readonly at?: number;\n};\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = run([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async <ArgsType, ResultType>(\n  expressions: //eslint-disable-next-line functional/prefer-readonly-type\n    | ExpressionOrResult<ArgsType, ResultType>[]\n    | ExpressionOrResult<ArgsType, ResultType>\n    | readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType[]> => {\n  const results: ResultType[] = [];\n  const compareFn = opts.rank ?? defaultComparer;\n  //eslint-disable-next-line functional/no-let\n  let expressionsArray = Array.isArray(expressions)\n    ? (expressions as ExpressionOrResult<ArgsType, ResultType>[])\n    : [ expressions as ExpressionOrResult<ArgsType, ResultType> ];\n  if (opts.shuffle) expressionsArray = shuffle(expressionsArray);\n\n  for (let i = 0; i < expressionsArray.length; i++) {\n    const exp = expressionsArray[ i ];\n    //eslint-disable-next-line functional/no-let\n    let r: ResultType;\n    if (typeof exp === 'function') {\n      // @ts-ignore\n      r = await exp(args);\n    } else {\n      r = exp;\n    }\n    if (r !== undefined) {\n      //eslint-disable-next-line functional/immutable-data\n      results.push(r);\n      //eslint-disable-next-line functional/immutable-data\n      results.sort(compareFn);\n    }\n\n    if (typeof opts.stop !== 'undefined') {\n      if (opts.stop(r, results)) {\n        break;\n      }\n    }\n  }\n\n  if (opts.filter) {\n    return results.filter(opts.filter);\n  }\n  return results;\n};\n\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async <ArgsType, ResultType>(\n  expressions: readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunSingleOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType | undefined> => {\n  const results = await run(expressions, opts, args);\n  if (!results) return;\n  if (results.length === 0) return;\n  const at = opts.at ?? -1;\n  return results.at(at);\n};\n","import * as StateMachine from './StateMachine.js';\nimport * as Execute from './Execute.js';\nimport { type MachineState } from './StateMachine.js';\nimport { defaultComparer } from '../util/index.js';\nimport { randomElement } from '../collections/arrays/index.js';\nimport * as Logger from '../debug/Logger.js';\n\nexport type Result<V extends StateMachine.Transitions> = {\n  /**\n   * Score of this result. This is used when a state\n   * has multiple handlers returning results separately.\n   * If not defined, 0 is used.\n   */\n  readonly score?: number;\n\n  //readonly state?: StateMachine.StateNames<V>;\n  /**\n   * If specified,the state to transition to. Use\n   * _true_ to attempt to automatically advance machine.\n   * This field is 2nd priority.\n   */\n  readonly next?: StateMachine.StateNames<V> | boolean;\n  /**\n   * If true, resets the machine.\n   * This flag is 1st priority, taking precedence over the `next` field.\n   */\n  readonly reset?: boolean;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type Runner<V extends StateMachine.Transitions> = {\n  readonly run: () => Promise<StateMachine.MachineState<V> | undefined>;\n  readonly getValue: () => StateMachine.StateNames<V>;\n  readonly reset: () => void;\n  readonly to: (\n    state: StateMachine.StateNames<V>\n  ) => StateMachine.MachineState<V>;\n};\n\nexport type StatesHandler<V extends StateMachine.Transitions> = {\n  readonly if:\n  | ReadonlyArray<StateMachine.StateNames<V>>\n  //eslint-disable-next-line functional/prefer-readonly-type\n  | Array<StateMachine.StateNames<V>>\n  | StateMachine.StateNames<V>;\n  readonly then: ReadonlyArray<ExpressionOrResult<V>> | ExpressionOrResult<V>;\n  /**\n   * Logic for choosing which result, if there are multiple expressions.\n   * By default 'highest' (for highest ranked result)\n   */\n  readonly resultChoice?: `first` | `highest` | `lowest` | `random`;\n};\n\n// export type Prerequisite<V extends StateMachine.Transitions> =\n//   | readonly StateMachine.StateNames<V>[]\n//   | ((\n//       potentialState: StateMachine.StateNames<V>,\n//       state: StateMachine.MachineState<V>\n//     ) => boolean);\n\n// export type StatePrerequisites<V extends StateMachine.Transitions> = {\n//   readonly states:\n//     | readonly StateMachine.StateNames<V>[]\n//     | StateMachine.StateNames<V>;\n//   readonly condition?: Prerequisite<V>;\n// };\n\nexport type DriverOpts<V extends StateMachine.Transitions> = {\n  readonly handlers: ReadonlyArray<StatesHandler<V>>;\n  //readonly prereqs?: StatePrerequisites<V>;\n  readonly debug?: Logger.LogOption;\n  /**\n   * If _true_ execution of handlers is shuffled each time\n   */\n  readonly shuffleHandlers?: boolean;\n};\n\n// async function run<V extends StateMachine.Transitions>(\n//   machine: StateMachine.Machine<V>,\n//   handlers: readonly StatesHandler<V>[]\n// );\n\nexport type ExpressionOrResult<Transitions extends StateMachine.Transitions> =\n  | Result<Transitions>\n  | ((\n    machine?: MachineState<Transitions>\n    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n  ) => Result<Transitions> | undefined | void);\n\n/**\n * Drives a state machine.\n *\n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function init<V extends StateMachine.Transitions>(\n  machine: StateMachine.Machine<V> | StateMachine.Transitions,\n  handlersOrOpts: ReadonlyArray<StatesHandler<V>> | DriverOpts<V>\n): Promise<Runner<V>> {\n  const opts: DriverOpts<V> = Array.isArray(handlersOrOpts)\n    ? {\n      handlers: handlersOrOpts as ReadonlyArray<StatesHandler<V>>,\n    }\n    : (handlersOrOpts as DriverOpts<V>);\n\n  const debug = Logger.resolveLogOption(opts.debug, {\n    category: `StateMachineDriver`,\n  });\n\n  // Index handlers by state, making sure there are not multiple\n  // handlers for a given state.\n  const byState = new Map<string, StatesHandler<V>>();\n  for (const h of opts.handlers) {\n    const ifBlock = Array.isArray(h.if) ? h.if : [ h.if ];\n    for (const state of ifBlock) {\n      if (typeof state !== `string`) {\n        throw new TypeError(\n          `Expected single or array of strings for the 'if' field. Got: '${ typeof state }'.`\n        );\n      }\n\n      if (byState.has(state)) {\n        throw new Error(\n          `Multiple handlers defined for state '${ state\n          }'. There should be at most one.`\n        );\n      }\n      byState.set(state, h);\n    }\n  }\n\n  // const expressions: Expression<V>[] = [\n  //   (_machine) => {\n  //     const r: Result<V> = {\n  //       next: 'hello',\n  //     };\n  //     return r;\n  //   },\n  // ];\n\n  const runOpts: Execute.RunOpts<Result<V>> = {\n    // Rank results by score\n    rank: (a, b) => {\n      return defaultComparer(a.score ?? 0, b.score ?? 0);\n    },\n    shuffle: opts.shuffleHandlers ?? false,\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let sm = StateMachine.init(machine);\n\n  // Check that all 'if' states are actually defined on machine\n  for (const [ ifState ] of byState) {\n    // Check if state is defined\n    if (\n      typeof sm.machine[ ifState ] === `undefined` &&\n      ifState !== `__fallback`\n    ) {\n      throw new Error(\n        `StateMachineDriver handler references a state ('${ ifState }') which is not defined on the machine. Therefore this handler will never run.'`\n      );\n    }\n  }\n\n  const run = async (): Promise<StateMachine.MachineState<V> | undefined> => {\n    debug(`Run. State: ${ sm.value }`);\n    const state = sm.value;\n    //eslint-disable-next-line functional/no-let\n    let handler = byState.get(state);\n    if (handler === undefined) {\n      debug(`  No handler for state '${ state }', trying __fallback`);\n\n      // Is there a fallback?\n      handler = byState.get(`__fallback`);\n    }\n    if (handler === undefined) {\n      debug(`  No __fallback handler`);\n      return;\n    }\n\n    // If the `first` option is given, stop executing fns as soon as we get\n    // a valid result.\n    const runOptionsForHandler =\n      handler.resultChoice === `first`\n        ? {\n          ...runOpts,\n          stop: (latest: Result<V> | undefined) => {\n            if (!latest) return false;\n            if (`reset` in latest) return true;\n            if (`next` in latest && latest.next !== undefined) return true;\n            return false;\n          },\n        }\n        : runOpts;\n\n    const results = await Execute.run<MachineState<V>, Result<V>>(\n      handler.then,\n      runOptionsForHandler,\n      sm\n    );\n    debug(\n      `  In state '${ sm.value }' results: ${ results.length }. Choice: ${ handler.resultChoice\n      }`\n    );\n\n    // Apply selection logic\n    //eslint-disable-next-line functional/no-let\n    let r: Result<V> | undefined;\n    switch (handler.resultChoice ?? `highest`) {\n      case `highest`: {\n        r = results.at(-1);\n        break;\n      }\n      case `first`: {\n        r = results[ 0 ]; // Since we break on the first result\n        break;\n      }\n      case `lowest`: {\n        r = results.at(0);\n        break;\n      }\n      case `random`: {\n        r = randomElement(results);\n        break;\n      }\n      default: {\n        throw new Error(\n          `Unknown 'resultChoice' option: ${ handler.resultChoice }. Expected highest, first, lowest or random`\n        );\n      }\n    }\n\n    debug(`  Chosen result: ${ JSON.stringify(r) }`);\n    // Apply result\n    if (r?.reset) {\n      sm = StateMachine.reset(sm);\n    } else if (r && r.next) {\n      if (typeof r.next === `boolean`) {\n        sm = StateMachine.next(sm);\n      } else {\n        debug(JSON.stringify(results));\n        sm = StateMachine.to(sm, r.next);\n      }\n    }\n    return sm;\n  };\n\n  return {\n    reset: () => {\n      sm = StateMachine.reset(sm);\n    },\n    getValue: () => sm.value,\n    run,\n    to: (state: StateMachine.StateNames<V>) => {\n      sm = StateMachine.to(sm, state);\n      return sm;\n    },\n  };\n}\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as StateMachine from './StateMachine.js';\nimport * as Elapsed from './Elapsed.js';\nimport type { StateNames, Transitions, MachineState } from './StateMachine.js';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type Opts<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\n/**\n * A state machine that fires events when state changes.\n * \n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = Elapsed.infinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param m Machine description\n   * @param opts Options for machine (defaults to `{debug:false}`)\n   */\n  constructor(m: V, opts: Opts<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): ReadonlyArray<StateNames<V> | null> {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): ReadonlyArray<StateNames<V>> {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   * @memberof StateMachine\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[ 0 ]!;\n    return p[ 0 ]!;\n  }\n\n  /**\n   * Returns _true_ if state machine is in its final state\n   *\n   * @returns\n   */\n  get isDone(): boolean {\n    return StateMachine.done(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n\n    //eslint-disable-next-line functional/immutable-data\n    this.#changedAt = Elapsed.since();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `isValid()` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   *\n   * @memberof StateMachine\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${ priorState } -> ${ newState }`);\n    }\n    this.#changedAt = Elapsed.since();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.done(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n"],"mappings":"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","names":["init","init","run"]}