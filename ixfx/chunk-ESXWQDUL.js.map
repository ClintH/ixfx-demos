{"version":3,"sources":["../src/Util.ts","../src/iterables/IterableAsync.ts","../src/IsEqual.ts","../src/flow/IntervalType.ts","../src/flow/Sleep.ts","../src/iterables/Iterable.ts"],"sourcesContent":["import { numberTest, throwFromResult } from './Guards.js';\nexport * as IterableAsync from './iterables/IterableAsync.js';\n\n\nexport type ArrayLengthMutationKeys = `splice` | `push` | `pop` | `shift` | `unshift` | number\nexport type ArrayItems<T extends Array<any>> = T extends Array<infer TItems> ? TItems : never\nexport type FixedLengthArray<T extends Array<any>> =\n  Pick<T, Exclude<keyof T, ArrayLengthMutationKeys>>\n  & { [ Symbol.iterator ]: () => IterableIterator<ArrayItems<T>> }\n\nexport const isFunction = (object: unknown): object is (...args: Array<any>) => any => object instanceof Function;\n\n/**\n * Returns _true_ if `value` is a plain object\n * \n * ```js\n * isPlainObject(`text`); // false\n * isPlainObject(document); // false\n * isPlainObject({ hello: `there` }); // true\n * ```\n * @param value \n * @returns \n */\nexport const isPlainObject = (value: unknown) => {\n  if (typeof value !== `object` || value === null) return false;\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\n\n/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n * \n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n * \n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value \n * @returns \n */\nexport const isInteger = (value: string | number) => {\n  if (value === undefined) return false;\n  if (typeof value === `string`) {\n    const v = Number.parseInt(value);\n    if (Number.isNaN(v)) return false;\n    if (v.toString() === value.toString()) return true;\n    return false;\n  }\n  if (typeof value === `number`) {\n    if (Number.isNaN(value)) return false;\n    if (!Number.isFinite(value)) return false;\n    if (Math.round(value) === value) return true;\n    return false;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `value` is primitive value or plain object\n * @param value \n * @returns \n */\nexport const isPlainObjectOrPrimitive = (value: unknown) => {\n  const t = typeof value;\n  if (t === `symbol`) return false;\n  if (t === `function`) return false;\n  if (t === `bigint`) return true;\n  if (t === `number`) return true;\n  if (t === `string`) return true;\n  if (t === `boolean`) return true;\n  return isPlainObject(value);\n}\n/**\n * Returns `fallback` if `v` is NaN, otherwise returns `v`.\n *\n * Throws if `v` is not a number type.\n * @param v\n * @param fallback\n * @returns\n */\nexport const ifNaN = (v: number, fallback: number): number => {\n  // ✔️ Unit tested\n\n  if (Number.isNaN(v)) return fallback;\n  if (typeof v !== `number`) {\n    throw new TypeError(`v is not a number. Got: ${ typeof v }`);\n  }\n  return v;\n};\n\n\n/**\n * Returns true if `x` is a power of two\n * @param x\n * @returns True if `x` is a power of two\n */\nexport const isPowerOfTwo = (x: number) => Math.log2(x) % 1 === 0;\n\n/**\n * Returns the relative difference from the `initial` value\n * ```js\n * const rel = relativeDifference(100);\n * rel(100); // 1\n * rel(150); // 1.5\n * rel(50);  // 0.5\n * ```\n *\n * The code for this is simple:\n * ```js\n * const relativeDifference = (initial) => (v) => v/initial\n * ```\n * @param {number} initial\n * @returns\n */\nexport const relativeDifference = (initial: number) => (v: number) =>\n  v / initial;\n\n/**\n * Rounds `v` up to the nearest multiple of `multiple`\n * ```\n * roundMultiple(19, 20); // 20\n * roundMultiple(21, 20); // 40\n * ```\n * @param v\n * @param multiple\n * @returns\n */\nexport const roundUpToMultiple = (v: number, multiple: number): number => {\n  throwFromResult(numberTest(v, `nonZero`, `v`));\n  throwFromResult(numberTest(multiple, `nonZero`, `multiple`));\n  return Math.ceil(v / multiple) * multiple;\n};\n\nexport type ToString<V> = (itemToMakeStringFor: V) => string;\n\n// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n//eslint-disable-next-line functional/functional-parameters\nexport const runningiOS = () =>\n  [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n  ].includes(navigator.platform) ||\n  // iPad on iOS 13 detection\n  (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);\n\nexport type CompareResult = number; // 0 | 1 | -1;\nexport type Comparer<V> = (a: V, b: V) => CompareResult;\n\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * @param x\n * @param y\n * @returns\n */\nexport const numericComparer = (x: number, y: number): CompareResult => {\n  // ✔️ Unit tested\n  if (x === y) return 0;\n  if (x > y) return 1;\n  return -1;\n};\n\n// /**\n//  * Sorts numbers in descending order\n//  * @param x\n//  * @param y\n//  * @returns\n//  */\n// export const numericComparerInverse = (x: number, y: number): CompareResult => {\n//   // ✔️ Unit tested\n//   if (x === y) return 0;\n//   if (x > y) return -1;\n//   return 1;\n// };\n\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n * @param x\n * @param y\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const jsComparer = (x: any, y: any): CompareResult => {\n  // ✔️ Unit tested\n\n  // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n  if (x === undefined && y === undefined) return 0;\n  if (x === undefined) return 1;\n  if (y === undefined) return -1;\n\n  const xString = defaultToString(x);\n  const yString = defaultToString(y);\n\n  if (xString < yString) return -1;\n  if (xString > yString) return 1;\n  return 0;\n};\n\n// export const jsComparerInverse = (x: any, y: any): CompareResult =>\n//   jsComparer(x, y) * -1;\n\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n *  b, a, c -> a, b, c\n *  10, 5, 100 -> 5, 10, 100\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultComparer = (x: any, y: any): CompareResult => {\n  if (typeof x === `number` && typeof y === `number`) {\n    return numericComparer(x, y);\n  }\n  return jsComparer(x, y);\n};\n\n// /**\n//  * Compares numbers by numeric value, otherwise uses the default\n//  * logic of string comparison.\n//  *\n//  * Is an descending sort:\n//  *  b, a, c -> c, a, b\n//  *  10, 5, 100 -> 100, 10, 5\n//  * @param x\n//  * @param y\n//  * @returns\n//  * @see {@link defaultComparer} Asending\n//  */\n// export const defaultComparerInverse = (x: any, y: any): CompareResult => {\n//   if (typeof x === `number` && typeof y === `number`) {\n//     return numericComparerInverse(x, y);\n//   }\n//   return jsComparerInverse(x, y);\n// };\n\n/**\n * Inverts the source comparer.\n * @param fn\n * @returns\n */\nexport const comparerInverse = <V>(comparer: Comparer<V>): Comparer<V> => {\n  return (x: V, y: V) => {\n    const v = comparer(x, y);\n    return v * -1;\n  };\n};\n\n/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultToString = (object: any): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (object === null) return `null`;\n  if (typeof object === `boolean` || typeof object === `number`) {\n    return object.toString();\n  }\n\n  if (typeof object === `string`) return object;\n  if (typeof object === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  return JSON.stringify(object);\n};\n\n// try {\n//   if (typeof window !== `undefined`) {\n//     //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n//     (window as any).ixfx = {\n//       //eslint-disable-next-line @typescript-eslint/no-explicit-any\n//       ...(window as any).ixfx,\n//       getFieldByPath,\n//       getFieldPaths,\n//     };\n//   }\n// } catch {\n//   /* no-op */\n// }\n\n","import type { Interval } from '../flow/IntervalType.js';\nimport { toStringDefault, type IsEqual } from '../IsEqual.js';\nimport { sleep } from '../flow/Sleep.js';\nimport { isAsyncIterable, isIterable } from './Iterable.js';\nimport type { ToString } from 'src/Util.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: Array<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in a number or AbortSignal as a second parameter.\n * ```js\n * repeat(generator, 5); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, ac.signal); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param gen \n * @param maximumRepeats \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    const result = await f(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, count = Number.POSITIVE_INFINITY): Promise<Array<V>> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n\n  while (result.length < count) {\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | Array<AsyncIterable<V>>\n) {\n  const buffer: Array<any> = [];\n  const itera: Array<AsyncIterable<V>> = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: ToString<T> = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","\n/**\n * If input is a string, it is returned.\n * If input is a primitive type, in-built string coersion is used.\n * Otherwise, it returns the result of `JSON.stringify()`.\n * \n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringDefault = (itemToMakeStringFor: any): string => {\n  switch (typeof itemToMakeStringFor) {\n    case `string`: {\n      return itemToMakeStringFor;\n    }\n    case `object`: {\n      return JSON.stringify(itemToMakeStringFor);\n    }\n    default: {\n      return `` + itemToMakeStringFor;\n    }\n  }\n}\n// typeof itemToMakeStringFor === `string`\n//   ? itemToMakeStringFor\n//   : JSON.stringify(itemToMakeStringFor);\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: any) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  JSON.stringify(itemToMakeStringFor, (key: string, value: any) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = <T1 extends Record<string, any>, T2 extends Record<string, any>>(a: T1, b: T2, fieldComparer?: IsEqual<any>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Parameter 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Parameter 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueA = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueA === `object` && typeof valueB === `object`) {\n      if (!comparer(valueA, valueB)) {\n        return false;\n      }\n    } else {\n      if (valueA !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};","import { numberTest } from '../Guards.js';\n\n/**\n * Interval types allows for more expressive coding, rather than embedding millisecond values.\n * \n * That is, we can use `{ mins: 5 }` to mean 5 minutes rather than 5*60*1000 \n * or worse, 300000, for the same value.\n *\n * Examples:\n * ```js\n * { hours: 1 };  // 1 hour\n * { mins: 5 };   // 5 mins\n * { secs: 5 };   // 5 secs\n * { millis: 5 }; // 5 milliseconds\n * ```\n * \n * Fields are be combined, adding the value.\n * ```js\n * { secs: 2, millis: 1 }; // equal 2001 milliseconds.\n * ```\n * \n * Wherever ixfx takes an Interval, you can also just provide a number instead.\n * This will be taken as a millisecond value.\n * \n * Use {@link intervalToMs} to convert to milliseconds. Use {@link Elapsed.toString} to get a human-readable representation of the Interval.s\n */\nexport type Interval =\n  | number\n  | {\n    readonly millis?: number;\n    readonly secs?: number;\n    readonly hours?: number;\n    readonly mins?: number;\n  };\n\nexport function intervalToMs(interval: Interval | undefined): number | undefined;\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber: number\n): number;\n\n\n/**\n * Return the millisecond value of an Interval.\n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * undefined or invalid input.\n *\n * ```js\n * intervalToMs(undefined); // undefined\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `i` is undefined\n * @returns Milliseconds, or undefined\n */\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber?: number\n): number | undefined {\n  if (isInterval(interval)) {\n    // Number given, must be millis?\n    if (typeof interval === `number`) return interval;\n\n    //eslint-disable-next-line functional/no-let\n    let ms = interval.millis ?? 0;\n    ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n    ms += (interval.mins ?? 0) * 60 * 1000;\n    ms += (interval.secs ?? 0) * 1000;\n    return ms;\n  } else {\n    if (typeof defaultNumber !== `undefined`) return defaultNumber;\n    throw new Error(`Not a valid interval: ${ interval }`);\n  }\n}\n\nexport function isInterval(interval: number | Interval | undefined): interval is Interval {\n  if (interval === undefined) return false;\n  if (interval === null) return false;\n  if (typeof interval === `number`) {\n    if (Number.isNaN(interval)) return false;\n    if (!Number.isFinite(interval)) return false;\n    return true;\n  } else if (typeof interval !== `object`) return false;\n\n  const hasMillis = `millis` in interval;\n  const hasSecs = `secs` in interval;\n  const hasMins = `mins` in interval;\n  const hasHours = `hours` in interval;\n  if (hasMillis && !numberTest(interval.millis)[ 0 ]) return false;\n  if (hasSecs && !numberTest(interval.secs)[ 0 ]) return false;\n  if (hasMins && !numberTest(interval.mins)[ 0 ]) return false;\n  if (hasHours && !numberTest(interval.hours)[ 0 ]) return false;\n  if (hasMillis || hasSecs || hasHours || hasMins) return true;\n  return false;\n}\n","import { throwNumberTest } from '../Guards.js';\nimport { type Interval, intervalToMs } from './IntervalType.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n  // eslint-disable-next-line unicorn/no-lonely-if\n  if (typeof window === `undefined`) {\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @param signal\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  throwNumberTest(timeoutMs, `positive`, `timeoutMs`);\n\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        //console.log(`Flow.sleep added to abort signal`);\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      setTimeout(() => {\n        if (signal && signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n\n        signal?.removeEventListener(`abort`, onAbortSignal);\n\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n","type WithEvents = {\n  addEventListener(type: string, callbackfn: any): void;\n  removeEventListener(type: string, callbackfn: any): void;\n}\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> =>\n  Symbol.asyncIterator in new Object(v);\n\nexport const isIterable = (v: any): v is Iterable<any> =>\n  Symbol.iterator in new Object(v);\n\n\n\nexport const eventsToIterable = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(new Error(error)),\n      };\n    },\n  };\n  return r;\n};"],"mappings":"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","names":["toStringDefault","max","min","toStringDefault"]}