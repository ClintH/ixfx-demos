{"version":3,"sources":["../src/rx/Util.ts","../src/data/Resolve.ts"],"sourcesContent":["import { isIterable } from \"../iterables/Iterable.js\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactivePingable, ReactiveWritable, Wrapped } from \"./Types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./sources/Types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport const isPingable = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactivePingable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`ping` in rx) {\n    return true;\n  }\n  return false;\n}\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx \n * @returns \n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx \n * @returns \n */\nexport const isWritable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveWritable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`set` in rx) return true;\n  return false;\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotateElapsed` in v)) return false;\n  return true;\n}\n\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\n\nexport const opify = <TIn, TRxOut = Reactive<TIn>>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => TRxOut, ...args: Array<any>) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    return fn(source, ...args);\n  }\n}\n\n\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { hasLast, isReactive } from \"../rx/Util.js\";\nimport type { ReactiveNonInitial } from \"../rx/Types.js\";\nimport type { ValueType } from \"./Types.js\";\nimport { getErrorMessage } from \"../debug/GetErrorMessage.js\";\n\n/**\n * Something that can resolve to a value\n */\nexport type ResolveToValueSync<V> = ValueType | ReactiveNonInitial<V> | Generator<V> | IterableIterator<V> | ((args: any) => V)\nexport type ResolveToValueAsync<V> = AsyncGenerator<V> | AsyncIterableIterator<V> | Promise<V>;\nexport type ResolveToValue<V> = ResolveToValueAsync<V> | ResolveToValueSync<V>;\n\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n * \n * To resolve an object's properties, use {@link resolveFields}.\n * \n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r \n * @param args \n * @returns \n */\nexport async function resolve<V extends ValueType>(r: ResolveToValue<V>, ...args: any): Promise<V> {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      //console.log(tag);\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        const v = await r.next() as IteratorResult<V>;\n        //console.log(`  hasDone: ${ `done` in v } value:`, v);\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last();\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    const v = await r(args) as V;\n    return v;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\nexport function resolveSync<V extends ValueType>(r: ResolveToValueSync<V>, ...args: any): V {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        throw new Error(`resolveSync cannot work with an async generator`);\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last();\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    return r(args) as V;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_ \n * or NaN, `fallbackValue` is returned instead.\n * \n * `null` is an allowed return value.\n * \n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallbackValue Fallback value if an error happens, undefined or NaN\n * @param args \n * @returns \n */\nexport async function resolveWithFallback<T extends ValueType>(p: ResolveToValue<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = await resolve(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport function resolveWithFallbackSync<T extends ValueType>(p: ResolveToValueSync<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = resolveSync(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport type ResolveFallbackOpts<T> = { value: T, overrideWithLast?: boolean }"],"mappings":";;;;;;;;AAIO,SAAS,gBAAmB,SAA4D;AAC7F,MAAI,QAAQ,UAAU,OAAW,QAAO;AACxC,MAAI,YAAY,WAAW,QAAQ,WAAW,OAAW,QAAO;AAChE,SAAO;AACT;AAEO,SAAS,oBAAuB,SAA4C;AACjF,MAAI,QAAQ,UAAU,OAAW,QAAO;AACxC,MAAI,YAAY,WAAW,QAAQ,WAAW,OAAQ,QAAO;AAC7D,SAAO;AACT;AAQO,SAAS,gBAAmB,GAAkD;AACnF,MAAI,EAAE,UAAU,OAAW,QAAO;AAClC,SAAO;AACT;AAEO,IAAM,aAAa,CAAI,OAA0E;AACtG,MAAI,CAAC,WAAW,EAAE,EAAG,QAAO;AAC5B,MAAI,UAAU,IAAI;AAChB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAEO,IAAM,UAAU,CAAI,OAAyE;AAClG,MAAI,CAAC,WAAW,EAAE,EAAG,QAAO;AAC5B,MAAI,UAAU,IAAI;AAEhB,UAAM,IAAK,GAAW,KAAK;AAC3B,QAAI,MAAM,OAAW,QAAO;AAAA,EAC9B;AACA,SAAO;AACT;AAOO,IAAM,aAAa,CAAI,OAAkC;AAC9D,MAAI,OAAO,OAAO,SAAU,QAAO;AACnC,MAAI,OAAO,KAAM,QAAO;AACxB,SAAQ,QAAQ,MAAM,aAAa;AACrC;AAiBO,IAAM,aAAa,CAAI,OAAqE;AACjG,MAAI,CAAC,WAAW,EAAE,EAAG,QAAO;AAC5B,MAAI,SAAS,GAAI,QAAO;AACxB,SAAO;AACT;AAEO,IAAM,YAAY,CAAI,MAA4B;AACvD,MAAI,OAAO,MAAM,SAAU,QAAO;AAClC,MAAI,EAAE,YAAY,GAAI,QAAO;AAC7B,MAAI,EAAE,qBAAqB,GAAI,QAAO;AACtC,SAAO;AACT;AAQO,IAAM,QAAQ,CAA8B,OAAuE,SAAqB;AAC7I,SAAO,CAAC,WAAkC;AACxC,WAAO,GAAG,QAAQ,GAAG,IAAI;AAAA,EAC3B;AACF;AAGO,IAAM,iBAAiB,CAAI,MAAyC,WAAW;AAC/E,IAAM,oBAAoB,CAAI,MAA4C,QAAQ;AAClF,IAAM,qBAAqB,CAAI,MAA4C,WAAW,CAAC;AACvF,IAAM,YAAY,CAAI,MAA4B;AACvD,MAAI,OAAO,MAAM,SAAU,QAAO;AAClC,MAAI,eAAe,CAAC,EAAG,QAAO;AAC9B,MAAI,kBAAkB,CAAC,EAAG,QAAO;AACjC,MAAI,mBAAmB,CAAC,EAAG,QAAO;AAClC,SAAO;AACT;AAiBO,SAAS,oBAAuB,GAA4D;AACjG,MAAI,eAAe,CAAC,EAAG,QAAO,CAAE,EAAE,OAAO,KAAM;AAC/C,MAAI,kBAAkB,CAAC,GAAG;AACxB,UAAM,IAAI,EAAE,GAAG;AACf,QAAI,MAAM,OAAW,QAAO,CAAE,QAAW,IAAK;AAC9C,WAAO,CAAE,GAAG,KAAM;AAAA,EACpB;AACA,MAAI,mBAAmB,CAAC,GAAG;AACzB,UAAM,IAAI,EAAE,IAAI,KAAK;AACrB,QAAI,EAAE,KAAM,QAAO,CAAE,QAAW,IAAK;AACrC,WAAO,CAAE,EAAE,OAAO,KAAM;AAAA,EAC1B;AACA,QAAM,IAAI,MAAM,iDAAiD;AACnE;;;ACrGA,eAAsB,QAA6B,MAAyB,MAAuB;AACjG,MAAI,OAAO,MAAM,UAAU;AACzB,QAAI,UAAU,GAAG;AACf,YAAM,MAAO,EAAW,OAAO,WAAY;AAE3C,UAAI,QAAQ,eAAe,OAAO,kBAAkB;AAClD,cAAM,IAAI,EAAE,KAAK;AACjB,YAAI,UAAU,KAAK,WAAW,EAAG,QAAO,EAAE;AAC1C,eAAO;AAAA,MACT,WAAW,QAAQ,kBAAkB;AACnC,cAAM,IAAI,MAAM,EAAE,KAAK;AAEvB,YAAI,UAAU,KAAK,WAAW,EAAG,QAAO,EAAE;AAC1C,eAAO;AAAA,MACT,OAAO;AACL,cAAM,IAAI,MAAM,wHAAyH,GAAI,GAAG;AAAA,MAClJ;AAAA,IACF,WAAW,WAAc,CAAC,GAAG;AAC3B,UAAI,QAAQ,CAAC,EAAG,QAAO,EAAE,KAAK;AAC9B,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD,OAAO;AAEL,aAAO;AAAA,IACT;AAAA,EACF,WAAW,OAAO,MAAM,YAAY;AAClC,UAAM,IAAI,MAAM,EAAE,IAAI;AACtB,WAAO;AAAA,EACT,OAAO;AAEL,WAAO;AAAA,EACT;AACF;AAEO,SAAS,YAAiC,MAA6B,MAAc;AAC1F,MAAI,OAAO,MAAM,UAAU;AACzB,QAAI,UAAU,GAAG;AACf,YAAM,MAAO,EAAW,OAAO,WAAY;AAC3C,UAAI,QAAQ,eAAe,OAAO,kBAAkB;AAClD,cAAM,IAAI,EAAE,KAAK;AACjB,YAAI,UAAU,KAAK,WAAW,EAAG,QAAO,EAAE;AAC1C,eAAO;AAAA,MACT,WAAW,QAAQ,kBAAkB;AACnC,cAAM,IAAI,MAAM,iDAAiD;AAAA,MACnE,OAAO;AACL,cAAM,IAAI,MAAM,sGAAuG,GAAI,GAAG;AAAA,MAChI;AAAA,IACF,WAAW,WAAc,CAAC,GAAG;AAC3B,UAAI,QAAQ,CAAC,EAAG,QAAO,EAAE,KAAK;AAC9B,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD,OAAO;AAEL,aAAO;AAAA,IACT;AAAA,EACF,WAAW,OAAO,MAAM,YAAY;AAClC,WAAO,EAAE,IAAI;AAAA,EACf,OAAO;AAEL,WAAO;AAAA,EACT;AACF;AAuBA,eAAsB,oBAAyC,GAAsB,aAAqC,MAAW;AACnI,MAAI,UAAU;AACd,MAAI,gBAAgB,SAAS;AAC7B,QAAM,mBAAmB,SAAS,oBAAoB;AACtD,MAAI,kBAAkB,OAAW,OAAM,IAAI,MAAM,wBAAwB;AAEzE,MAAI;AACF,UAAM,IAAI,MAAM,QAAQ,GAAG,GAAG,IAAI;AAClC,QAAI,OAAO,MAAM,YAAa,QAAO;AACrC,QAAI,OAAO,MAAM,YAAY,OAAO,MAAM,CAAC,EAAG,QAAO;AACrD,QAAI,iBAAkB,iBAAgB;AACtC,WAAO;AAAA,EACT,SAAS,OAAO;AACd,QAAI,CAAC,SAAS;AACZ,gBAAU;AACV,cAAQ,KAAK,2EAA2E,gBAAgB,KAAK,CAAC;AAAA,IAChH;AACA,WAAO;AAAA,EACT;AACF;AAEO,SAAS,wBAA6C,GAA0B,aAAqC,MAAW;AACrI,MAAI,UAAU;AACd,MAAI,gBAAgB,SAAS;AAC7B,QAAM,mBAAmB,SAAS,oBAAoB;AACtD,MAAI,kBAAkB,OAAW,OAAM,IAAI,MAAM,wBAAwB;AAEzE,MAAI;AACF,UAAM,IAAI,YAAY,GAAG,GAAG,IAAI;AAChC,QAAI,OAAO,MAAM,YAAa,QAAO;AACrC,QAAI,OAAO,MAAM,YAAY,OAAO,MAAM,CAAC,EAAG,QAAO;AACrD,QAAI,iBAAkB,iBAAgB;AACtC,WAAO;AAAA,EACT,SAAS,OAAO;AACd,QAAI,CAAC,SAAS;AACZ,gBAAU;AACV,cAAQ,KAAK,+EAA+E,gBAAgB,KAAK,CAAC;AAAA,IACpH;AACA,WAAO;AAAA,EACT;AACF;","names":[]}