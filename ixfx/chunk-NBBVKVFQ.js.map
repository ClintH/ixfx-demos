{"version":3,"sources":["../src/KeyValue.ts"],"sourcesContent":["\nimport type { KeyValue } from './PrimitiveTypes.js';\nimport { defaultComparer } from './util/index.js';\nimport { minMaxAvg as arrayMinMaxAg } from './numbers/MinMaxAvg.js';\n\n// const byKey = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 0 ])\n// );\n\n// export const byValueString = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as string)\n// );\n\n// const byValueNumber = (reverse = false) => pipe(\n//   reverse ? reverseOrd(N.Ord) : N.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as number)\n// );\n\n// export const sortByKey = (reverse = false) => sort<KeyValue>(byKey(reverse));\n// export const sortByValueString = (reverse = false) => sort<KeyValue>(byValueString(reverse));\n// export const sortByValueNumber = (reverse = false) => sort<KeyValue>(byValueNumber(reverse));\n\n// eslint-disable-next-line functional/prefer-readonly-type,functional/prefer-immutable-types\nexport type KeyValueSorter = (data: Array<KeyValue>) => Array<KeyValue>;\n\nconst sorterByValueIndex = (index: number, reverse = false) => {\n  return (values: Array<KeyValue>) => {\n    const s = values.toSorted((a, b) => {\n      return defaultComparer(a[ index ], b[ index ]);\n    });\n    if (reverse) return s.reverse();\n    return s;\n  }\n}\n\nexport type SortSyles = `value` | `value-reverse` | `key` | `key-reverse`;\nexport const getSorter = (sortStyle: SortSyles): KeyValueSorter => {\n  switch (sortStyle) {\n    case `value`: {\n      return sorterByValueIndex(1, false);\n    }\n    case `value-reverse`: {\n      return sorterByValueIndex(1, true);\n    }\n    case `key`: {\n      return sorterByValueIndex(0, false);\n    }\n    case `key-reverse`: {\n      return sorterByValueIndex(0, true);\n    }\n    default: {\n      throw new Error(`Unknown sorting value '${ (sortStyle as string) }'. Expecting: value, value-reverse, key or key-reverse`);\n    }\n  }\n};\n\n\nexport const minMaxAvg = (entries: ReadonlyArray<KeyValue>, conversionFunction?: (v: KeyValue) => number) => {\n  const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n  const values = entries.map<number>(entry => converter(entry));\n  return arrayMinMaxAg(values);\n};"],"mappings":";;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,mBAAAA;AAAA;AA2BA,IAAM,qBAAqB,CAAC,OAAe,UAAU,UAAU;AAC7D,SAAO,CAAC,WAA4B;AAClC,UAAM,IAAI,OAAO,SAAS,CAAC,GAAG,MAAM;AAClC,aAAO,gBAAgB,EAAG,KAAM,GAAG,EAAG,KAAM,CAAC;AAAA,IAC/C,CAAC;AACD,QAAI,QAAS,QAAO,EAAE,QAAQ;AAC9B,WAAO;AAAA,EACT;AACF;AAGO,IAAM,YAAY,CAAC,cAAyC;AACjE,UAAQ,WAAW;AAAA,IACjB,KAAK,SAAS;AACZ,aAAO,mBAAmB,GAAG,KAAK;AAAA,IACpC;AAAA,IACA,KAAK,iBAAiB;AACpB,aAAO,mBAAmB,GAAG,IAAI;AAAA,IACnC;AAAA,IACA,KAAK,OAAO;AACV,aAAO,mBAAmB,GAAG,KAAK;AAAA,IACpC;AAAA,IACA,KAAK,eAAe;AAClB,aAAO,mBAAmB,GAAG,IAAI;AAAA,IACnC;AAAA,IACA,SAAS;AACP,YAAM,IAAI,MAAM,0BAA4B,SAAqB,wDAAwD;AAAA,IAC3H;AAAA,EACF;AACF;AAGO,IAAMC,aAAY,CAAC,SAAkC,uBAAiD;AAC3G,QAAM,YAAY,uBAAuB,CAAC,MAAgB,EAAG,CAAE;AAC/D,QAAM,SAAS,QAAQ,IAAY,WAAS,UAAU,KAAK,CAAC;AAC5D,SAAO,UAAc,MAAM;AAC7B;","names":["minMaxAvg","minMaxAvg"]}