{"version":3,"sources":["../src/numbers/Interpolate.ts"],"sourcesContent":["import type { Interval } from '../flow/IntervalType.js';\nimport { wrap } from './Wrap.js';\nimport { ofTotal } from '../flow/Timer.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { clamp } from '../numbers/Clamp.js';\nimport { get as getEasing, type EasingName } from '../modulation/easing/index.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * \n * Limit\n * What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. \n */\nexport type InterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  easing: EasingName,\n  transform: (v: number) => number\n}\n\n\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide](https://clinth.github.io/ixfx-docs/modulation/interpolate/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * Interpolation is often used for animation. In that case, `amount`\n * would start at 0 and you would keep interpolating up to `1`\n * @example\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { percentPingPong } from 'https://unpkg.com/ixfx/dist/modulation.js'\n *\n * // Go back and forth between 0 and 1 by 0.1\n * let pp = percentPingPong(0.1);\n * continuously(() => {\n *  // Get position in ping-pong\n *  const amt = pp.next().value;\n *  // interpolate between Math.PI and Math.PI*2\n *  const v = interpolate(amt, Math.PI, Math.PI*2);\n *  // do something with v...\n * }).start();\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * If two parameters are given, it instead returns a function which interpolates:\n * ```js\n * const i = interpolate(100, 200);\n * i(0.5); // 150\n * \n * // Compared to:\n * interpolate(0.5, 100, 200); // 150\n * ```\n * \n * This is useful if you want to reuse the interpolator with fixed `a` and `b` values.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  //let opts: Partial<InterpolateOptions> = {};\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    throwNumberTest(_a, ``, `a`);\n    throwNumberTest(_b, ``, `b`);\n    throwNumberTest(_amt, ``, `amount`);\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easingFn = getEasing(o.easing);\n      if (!easingFn) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easingFn;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    let amount = handleAmount(pos1);\n    readOpts(pos2);\n    throwNumberTest(amount, ``, `amount`);\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n"],"mappings":"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","names":[]}