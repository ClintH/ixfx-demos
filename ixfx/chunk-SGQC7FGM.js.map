{"version":3,"sources":["../src/util/ToString.ts","../src/util/IsEqual.ts"],"sourcesContent":["export type ToString<V> = (itemToMakeStringFor: V) => string;\n// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultToString = (object: any): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (object === null) return `null`;\n  if (typeof object === `boolean` || typeof object === `number`) {\n    return object.toString();\n  }\n\n  if (typeof object === `string`) return object;\n  if (typeof object === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  return JSON.stringify(object);\n};","import { toStringDefault } from \"./ToString.js\";\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: any) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  JSON.stringify(itemToMakeStringFor, (key: string, value: any) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = <T1 extends Record<string, any>, T2 extends Record<string, any>>(a: T1, b: T2, fieldComparer?: IsEqual<any>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Parameter 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Parameter 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueA = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueA === `object` && typeof valueB === `object`) {\n      if (!comparer(valueA, valueB)) {\n        return false;\n      }\n    } else {\n      if (valueA !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};"],"mappings":";AAGA,IAAM,iBAAiB,OAAO,UAAU;AACxC,IAAM,eAAe,CAAC,UACpB,eAAe,KAAK,KAAK;AACpB,IAAM,QAAQ,CAAC,UACpB,aAAa,KAAK,MAAM;AACnB,IAAM,QAAQ,CAAC,UACpB,aAAa,KAAK,MAAM;AAKnB,IAAM,kBAAkB,CAAI,wBACjC,OAAO,wBAAwB,WAC3B,sBACA,KAAK,UAAU,mBAAmB;AAGjC,IAAM,kBAAkB,CAAC,WAAwB;AAEtD,MAAI,WAAW,KAAM,QAAO;AAC5B,MAAI,OAAO,WAAW,aAAa,OAAO,WAAW,UAAU;AAC7D,WAAO,OAAO,SAAS;AAAA,EACzB;AAEA,MAAI,OAAO,WAAW,SAAU,QAAO;AACvC,MAAI,OAAO,WAAW,SAAU,OAAM,IAAI,UAAU,sCAAsC;AAC1F,SAAO,KAAK,UAAU,MAAM;AAC9B;;;ACpBO,IAAM,kBAAkB,CAAC,wBAA6B;AAC3D,MAAI,OAAO,wBAAwB,SAAU,QAAO;AACpD,QAAM,UAAU,oBAAI,IAAY;AAEhC,OAAK,UAAU,qBAAqB,CAAC,KAAa,WAAgB,QAAQ,IAAI,GAAG,GAAG,MAAM;AAC1F,SAAO,KAAK,UAAU,qBAAqB,CAAE,GAAG,OAAQ,EAAE,KAAK,CAAC;AAClE;AAWO,IAAM,iBAAiB,CAAI,GAAM,MAAkB,MAAM;AAoBzD,IAAM,sBAAsB,CAAI,GAAM,MAAkB;AAE7D,MAAI,MAAM,EAAG,QAAO;AACpB,SAAO,gBAAgB,CAAC,MAAM,gBAAgB,CAAC;AACjD;AA4BO,IAAM,sBAAsB,CAAiE,GAAO,GAAO,kBAA0C;AAC1J,MAAI,OAAO,MAAM,SAAU,OAAM,IAAI,MAAM,qCAAqC;AAChF,MAAI,OAAO,MAAM,SAAU,OAAM,IAAI,MAAM,qCAAqC;AAEhF,MAAI,OAAO,GAAG,GAAG,CAAC,EAAG,QAAO;AAC5B,QAAM,WAAW,iBAAiB;AAClC,aAAW,UAAU,OAAO,QAAQ,CAAC,GAAG;AACtC,UAAM,SAAS,EAAG,OAAQ,CAAE,CAAE;AAC9B,UAAM,SAAS,OAAQ,CAAE;AACzB,QAAI,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;AAC5D,UAAI,CAAC,SAAS,QAAQ,MAAM,GAAG;AAC7B,eAAO;AAAA,MACT;AAAA,IACF,OAAO;AACL,UAAI,WAAW,QAAQ;AACrB,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAgBO,IAAM,0BAA0B,CAAI,GAAM,MAAkB;AAEjE,MAAI,MAAM,EAAG,QAAO;AACpB,SAAO,gBAAgB,CAAC,MAAM,gBAAgB,CAAC;AACjD;","names":[]}