{"version":3,"sources":["../src/data/TrackerBase.ts","../src/data/TrackedValue.ts"],"sourcesContent":["import { type Timestamped, type TrackedValueOpts } from './TrackedValue.js';\n\n/**\n * Base tracker class\n */\nexport abstract class TrackerBase<V, SeenResultType> {\n  /**\n   * @ignore\n   */\n  seenCount: number;\n\n  /**\n   * @ignore\n   */\n  protected storeIntermediate: boolean;\n\n  /**\n   * @ignore\n   */\n  protected resetAfterSamples: number;\n\n  /**\n   * @ignore\n   */\n  protected sampleLimit: number;\n\n  public readonly id: string;\n\n  protected debug: boolean;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    this.id = opts.id ?? `tracker`;\n    this.debug = opts.debug ?? false;\n    this.sampleLimit = opts.sampleLimit ?? -1;\n    this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n\n    this.storeIntermediate =\n      opts.storeIntermediate ??\n      (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n    this.seenCount = 0;\n\n    if (this.debug) {\n      console.log(`TrackerBase: sampleLimit: ${ this.sampleLimit } resetAfter: ${ this.resetAfterSamples } store: ${ this.storeIntermediate }`);\n    }\n  }\n\n  /**\n   * Reset tracker\n   */\n  reset() {\n    this.seenCount = 0;\n    this.onReset();\n  }\n\n  /**\n   * Calculate results\n   *  \n   * @param p \n   * @returns \n   */\n  seen(...p: Array<V>): SeenResultType {\n    if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n      this.reset();\n    } else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n      this.seenCount = this.trimStore(this.sampleLimit);\n      this.onTrimmed();\n    }\n\n    this.seenCount += p.length;\n    const t = this.filterData(p);\n    return this.computeResults(t);\n  }\n\n  /**\n   * @ignore\n   * @param p\n   */\n  abstract filterData(p: Array<V>): Array<Timestamped>;\n\n  abstract get last(): V | undefined;\n\n  /**\n   * Returns the initial value, or undefined\n   */\n  abstract get initial(): V | undefined;\n\n  /**\n   * Returns the elapsed milliseconds since the initial value\n   */\n  abstract get elapsed(): number;\n\n  /**\n   * @ignore\n   */\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  abstract computeResults(_p: Array<Timestamped>): SeenResultType;\n\n  /**\n   * @ignore\n   */\n  abstract onReset(): void;\n\n  abstract onTrimmed(): void;\n  abstract trimStore(limit: number): number;\n}\n","import { type GetOrGenerate, getOrGenerate } from './maps/GetOrGenerate.js';\nimport { TrackerBase } from './TrackerBase.js';\n\nexport type Timestamped = {\n  readonly at: number\n}\nexport type TimestampedObject<V> = V & Timestamped;\n\n/**\n * Options\n */\nexport type TrackedValueOpts = {\n  readonly id?: string;\n\n  /**\n   * If true, intermediate points are stored. False by default\n   */\n  readonly storeIntermediate?: boolean;\n  /**\n   * If above zero, tracker will reset after this many samples\n   */\n  readonly resetAfterSamples?: number;\n\n  /**\n   * If above zero, there will be a limit to intermediate values kept.\n   *\n   * When the seen values is twice `sampleLimit`, the stored values will be trimmed down\n   * to `sampleLimit`. We only do this when the values are double the size so that\n   * the collections do not need to be trimmed repeatedly whilst we are at the limit.\n   *\n   * Automatically implies storeIntermediate\n   */\n  readonly sampleLimit?: number;\n\n  /**\n   * If true\n   */\n  readonly debug?: boolean\n};\n\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class TrackedPointMap extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap<V, T extends TrackerBase<V, TResult>, TResult> {\n  store: Map<string, T>;\n  gog: GetOrGenerate<string, T, V>;\n\n  constructor(creator: (key: string, start: V | undefined) => T) {\n    this.store = new Map();\n    this.gog = getOrGenerate<string, T, V>(this.store, creator);\n  }\n\n  /**\n   * Number of named values being tracked\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Returns _true_ if `id` is stored\n   * @param id\n   * @returns\n   */\n  has(id: string) {\n    return this.store.has(id);\n  }\n\n  /**\n   * For a given id, note that we have seen one or more values.\n   * @param id Id\n   * @param values Values(s)\n   * @returns Information about start to last value\n   */\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  //eslint-disable-next-line functional/prefer-immutable-types\n  public async seen(id: string, ...values: Array<V>): Promise<TResult> {\n    const trackedValue = await this.getTrackedValue(id, ...values);\n\n    // Pass it over to the TrackedValue\n    const result = trackedValue.seen(...values);\n\n    return result;\n  }\n\n  /**\n   * Creates or returns a TrackedValue instance for `id`.\n   * @param id\n   * @param values\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  protected async getTrackedValue(id: string, ...values: Array<V>) {\n    if (id === null) throw new Error(`id parameter cannot be null`);\n    if (id === undefined) throw new Error(`id parameter cannot be undefined`);\n\n    // Create or recall TrackedValue by id\n    const trackedValue = await this.gog(id, values[ 0 ]);\n    return trackedValue;\n  }\n\n  /**\n   * Remove a tracked value by id.\n   * Use {@link reset} to clear them all.\n   * @param id\n   */\n  delete(id: string) {\n    this.store.delete(id);\n  }\n\n  /**\n   * Remove all tracked values.\n   * Use {@link delete} to remove a single value by id.\n   */\n  reset() {\n    this.store = new Map();\n  }\n\n  /**\n   * Enumerate ids\n   */\n  *ids() {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Enumerate tracked values\n   */\n  *tracked() {\n    yield* this.store.values();\n  }\n\n  /**\n   * Iterates TrackedValues ordered with oldest first\n   * @returns\n   */\n  *trackedByAge() {\n    const tp = [ ...this.store.values() ];\n    tp.sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa > bb) return -1;\n      return 1;\n    });\n\n    for (const t of tp) {\n      yield t;\n    }\n  }\n\n  /**\n   * Iterates underlying values, ordered by age (oldest first)\n   * First the named values are sorted by their `elapsed` value, and then\n   * we return the last value for that group.\n   */\n  *valuesByAge() {\n    for (const tb of this.trackedByAge()) {\n      yield tb.last;\n    }\n  }\n\n  /**\n   * Enumerate last received values\n   *\n   * @example Calculate centroid of latest-received values\n   * ```js\n   * const pointers = pointTracker();\n   * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n   * ```\n   */\n  *last() {\n    for (const p of this.store.values()) {\n      yield p.last;\n    }\n  }\n\n  /**\n   * Enumerate starting values\n   */\n  *initialValues() {\n    for (const p of this.store.values()) {\n      yield p.initial;\n    }\n  }\n\n  /**\n   * Returns a tracked value by id, or undefined if not found\n   * @param id\n   * @returns\n   */\n  get(id: string): TrackerBase<V, TResult> | undefined {\n    return this.store.get(id);\n  }\n}\n"],"mappings":"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","names":[]}