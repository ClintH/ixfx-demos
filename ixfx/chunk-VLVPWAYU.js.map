{"version":3,"sources":["../src/data/Interpolate.ts","../src/random/FloatSource.ts"],"sourcesContent":["import type { Interval } from '../flow/IntervalType.js';\nimport { wrap } from './Wrap.js';\nimport { progress } from '../flow/Elapsed.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { clamp } from './Clamp.js';\nexport const piPi = Math.PI * 2;\n\nexport type InterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n}\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide](https://clinth.github.io/ixfx-docs/modulation/interpolate/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * Interpolation is often used for animation. In that case, `amount`\n * would start at 0 and you would keep interpolating up to `1`\n * @example\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { percentPingPong } from 'https://unpkg.com/ixfx/dist/modulation.js'\n *\n * // Go back and forth between 0 and 1 by 0.1\n * let pp = percentPingPong(0.1);\n * continuously(() => {\n *  // Get position in ping-pong\n *  const amt = pp.next().value;\n *  // interpolate between Math.PI and Math.PI*2\n *  const v = interpolate(amt, Math.PI, Math.PI*2);\n *  // do something with v...\n * }).start();\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * If two parameters are given, it instead returns a function which interpolates:\n * ```js\n * const i = interpolate(100, 200);\n * i(0.5); // 150\n * \n * // Compared to:\n * interpolate(0.5, 100, 200); // 150\n * ```\n * \n * This is useful if you want to reuse the interpolator with fixed `a` and `b` values.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Geometry.Points.interpolate}.\n * @param amount Interpolation amount, between 0 and 1 inclusive\n * @param a Start (ie when `amt` is 0)\n * @param b End (ie. when `amt` is 1)\n * @returns Interpolated value which will be between `a` and `b`.\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\nexport function interpolate(amountOrA: number, aOrB: number, bOrMissingOrOpts?: number | Partial<InterpolateOptions>, options?: Partial<InterpolateOptions>) {\n\n  const a = bOrMissingOrOpts === undefined ? amountOrA : aOrB;\n  const b = bOrMissingOrOpts === undefined || typeof bOrMissingOrOpts === `object` ? aOrB : bOrMissingOrOpts;\n  // eslint-disable-next-line unicorn/no-negated-condition, @typescript-eslint/prefer-nullish-coalescing\n  const opts = options !== undefined ? options : (typeof bOrMissingOrOpts === `number` ? {} : bOrMissingOrOpts);\n  const limits = opts?.limits ?? `clamp`;\n\n  throwNumberTest(a, ``, `a`);\n  throwNumberTest(b, ``, `b`);\n\n  const calculate = (amount: number) => {\n    if (limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    throwNumberTest(amount, ``, `amount`);\n    return (1 - amount) * a + amount * b;\n  }\n  if (bOrMissingOrOpts === undefined || typeof bOrMissingOrOpts === `object`) return calculate;\n  return calculate(amountOrA);\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration\n * @param a \n * @param b \n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1) => {\n  const durationProgression = progress(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b);\n    return value;\n  }\n}\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians\n * @param bRadians\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t));\n};\n\n","\nimport { type RandomOptions, type RandomSource, defaultRandom } from \"./Types.js\";\nimport { throwNumberTest } from '../util/GuardNumbers.js';\n/**\n * Returns a function that produces random float values.\n * Use {@link float} to produce a valued directly.\n *\n * Random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n *\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const r = floatSource();\n * r(); // Execute to produce random value\n *\n * // Random float between 0..100 (but not including 100)\n * const v = floatSource(100)();\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const r = floatSource({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const floatSource = (maxOrOptions: number | RandomOptions = 1): RandomSource => {\n  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n  //eslint-disable-next-line functional/no-let\n  let max = options.max;\n  //eslint-disable-next-line functional/no-let\n  let min = options.min ?? 0;\n  const source = options.source ?? defaultRandom;\n\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (!options.min && max < 0) {\n    min = max;\n    max = 0;\n  }\n  if (min > max) {\n    throw new Error(`Min is greater than max. Min: ${ min } max: ${ max }`);\n  }\n\n  return () => source() * (max - min) + min;\n};\n\n/**\n * Returns a random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n * Use {@link floatSource} to get a function that produces values. This is used internally.\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const v = float();\n * // Random float between 0..100 (but not including 100)\n * const v = float(100);\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const v = float({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const float = (maxOrOptions: number | RandomOptions = 1): number =>\n  floatSource(maxOrOptions)();"],"mappings":";;;;;;;;;;;;;;;;;AAKO,IAAM,OAAO,KAAK,KAAK;AAiEvB,SAAS,YAAY,WAAmB,MAAc,kBAAyD,SAAuC;AAE3J,QAAM,IAAI,qBAAqB,SAAY,YAAY;AACvD,QAAM,IAAI,qBAAqB,UAAa,OAAO,qBAAqB,WAAW,OAAO;AAE1F,QAAM,OAAO,YAAY,SAAY,UAAW,OAAO,qBAAqB,WAAW,CAAC,IAAI;AAC5F,QAAM,SAAS,MAAM,UAAU;AAE/B,kBAAgB,GAAG,IAAI,GAAG;AAC1B,kBAAgB,GAAG,IAAI,GAAG;AAE1B,QAAM,YAAY,CAAC,WAAmB;AACpC,QAAI,WAAW,SAAS;AACtB,eAAS,MAAM,MAAM;AAAA,IACvB,WAAW,WAAW,QAAQ;AAC5B,UAAI,SAAS,EAAG,UAAS,SAAS;AAAA,eACzB,SAAS,GAAG;AACnB,iBAAS,IAAK,SAAS;AAAA,MACzB;AAAA,IACF;AACA,oBAAgB,QAAQ,IAAI,QAAQ;AACpC,YAAQ,IAAI,UAAU,IAAI,SAAS;AAAA,EACrC;AACA,MAAI,qBAAqB,UAAa,OAAO,qBAAqB,SAAU,QAAO;AACnF,SAAO,UAAU,SAAS;AAC5B;AAqCO,IAAM,sBAAsB,CAAC,iBAAyB,IAAI,GAAG,IAAI,GAAG,uBAAuB,MAAM;AACtG,MAAI,SAAS;AACb,SAAO,CAAC,WAAoB,cAAuB;AACjD,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,UAAU,EAAG,QAAO;AACxB,UAAM,QAAQ,YAAY,QAAQ,GAAG,CAAC;AACtC,cAAU;AACV,WAAO;AAAA,EACT;AACF;AA6BO,IAAM,uBAAuB,CAAC,UAAoB,IAAI,GAAG,IAAI,MAAM;AACxE,QAAM,sBAAsB,SAAS,UAAU,EAAE,YAAY,KAAK,CAAC;AACnE,SAAO,CAAC,WAAoB,cAAuB;AACjD,UAAM,SAAS,oBAAoB;AACnC,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,cAAc,OAAW,KAAI;AACjC,QAAI,UAAU,EAAG,QAAO;AACxB,UAAM,QAAQ,YAAY,QAAQ,GAAG,CAAC;AACtC,WAAO;AAAA,EACT;AACF;AAcO,IAAM,mBAAmB,CAC9B,QACA,UACA,aACW;AACX,QAAM,IAAI,KAAK,WAAW,UAAU,GAAG,IAAI;AAC3C,SAAO,YAAY,QAAQ,UAAU,YAAY,IAAI,KAAK,KAAK,IAAI,OAAO,EAAE;AAC9E;;;AC9KO,IAAM,cAAc,CAAC,eAAuC,MAAoB;AACrF,QAAM,UAAU,OAAO,iBAAiB,WAAW,EAAE,KAAK,aAAa,IAAI;AAE3E,MAAI,MAAM,QAAQ;AAElB,MAAI,MAAM,QAAQ,OAAO;AACzB,QAAM,SAAS,QAAQ,UAAU;AAEjC,kBAAgB,KAAK,IAAI,KAAK;AAC9B,kBAAgB,KAAK,IAAI,KAAK;AAE9B,MAAI,CAAC,QAAQ,OAAO,MAAM,GAAG;AAC3B,UAAM;AACN,UAAM;AAAA,EACR;AACA,MAAI,MAAM,KAAK;AACb,UAAM,IAAI,MAAM,iCAAkC,GAAI,SAAU,GAAI,EAAE;AAAA,EACxE;AAEA,SAAO,MAAM,OAAO,KAAK,MAAM,OAAO;AACxC;AAsBO,IAAM,QAAQ,CAAC,eAAuC,MAC3D,YAAY,YAAY,EAAE;","names":[]}