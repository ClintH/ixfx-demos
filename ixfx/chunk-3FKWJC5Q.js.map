{"version":3,"sources":["../src/collections/Stack.ts","../src/collections/Lists.ts","../src/collections/SimpleMutableMapArray.ts","../src/Events.ts","../src/collections/Set.ts"],"sourcesContent":["// ✔ Unit tested!\r\n\r\nexport enum OverflowPolicy {\r\n  /**\r\n   * Removes items front of the queue (ie older items are discarded)\r\n   */\r\n  DiscardOlder,\r\n  /**\r\n   * Remove from rear of queue to make space for new items (ie newer items are discarded)\r\n   */\r\n  DiscardNewer,\r\n  /**\r\n   * Only adds new items that there are room for (ie. brand new items are discarded)\r\n   */\r\n  DiscardAdditions\r\n}\r\n\r\nexport type StackOpts = {\r\n  readonly debug?:boolean\r\n  readonly capacity?: number\r\n  readonly overflowPolicy?: OverflowPolicy\r\n}\r\n\r\nconst trimStack = <V>(opts: StackOpts, stack: ReadonlyArray<V>, toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  const potentialLength = stack.length + toAdd.length;\r\n  const policy = opts.overflowPolicy ?? OverflowPolicy.DiscardAdditions;\r\n  const capacity = opts.capacity ?? potentialLength;\r\n  const toRemove = potentialLength - capacity;\r\n  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${OverflowPolicy[policy]}`);\r\n\r\n  switch (policy) {\r\n  case OverflowPolicy.DiscardAdditions:\r\n    if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength-capacity} toAddLen: ${toAdd.length}`);\r\n    if (stack.length === opts.capacity) {\r\n      return stack; // Completely full\r\n    } else {\r\n      // Only add some from the new array\r\n      return [...stack, ...toAdd.slice(0, toAdd.length-toRemove)];\r\n    }\r\n  case OverflowPolicy.DiscardNewer:\r\n    if (toRemove >= stack.length) {\r\n      // New items will completely flush out old\r\n      return toAdd.slice(Math.max(0, toAdd.length-capacity), Math.min(toAdd.length, capacity)+1);\r\n    } else {\r\n      // Keep some of the old (from 0)\r\n      if (opts.debug) console.log(` from orig: ${stack.slice(0, toRemove-1)}`);\r\n      return [...stack.slice(0, toRemove-1), ...toAdd.slice(0, Math.min(toAdd.length, capacity-toRemove+1))];    \r\n    }\r\n  case OverflowPolicy.DiscardOlder:\r\n    // Oldest item in stack is position 0\r\n    return [...stack, ...toAdd].slice(toRemove);\r\n  default:\r\n    throw new Error(`Unknown overflow policy ${policy}`);\r\n  }\r\n};\r\n\r\n// Add to top (last index)\r\nconst push = <V>(opts: StackOpts, stack: ReadonlyArray<V>, ...toAdd: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\r\n  //const mutated = [...stack, ...toAdd];\r\n  const potentialLength = stack.length + toAdd.length;\r\n\r\n  const overSize = (opts.capacity && potentialLength > opts.capacity);\r\n  const toReturn  = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];\r\n  return toReturn;\r\n};\r\n\r\n// Remove from top (last index)\r\nconst pop = <V>(opts: StackOpts, stack: ReadonlyArray<V>): ReadonlyArray<V> => {\r\n  if (stack.length === 0) throw new Error(`Stack is empty`);\r\n  return stack.slice(0, stack.length - 1);\r\n};\r\n\r\n/**\r\n * Peek at the top of the stack (end of array)\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {V[]} stack\r\n * @returns {(V | undefined)}\r\n */\r\nconst peek = <V>(opts: StackOpts, stack: ReadonlyArray<V>): V | undefined => stack[stack.length - 1];\r\n\r\nconst isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => stack.length === 0;\r\n\r\nconst isFull = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean => {\r\n  if (opts.capacity) {\r\n    return stack.length >= opts.capacity;\r\n  }\r\n  return false;\r\n};\r\n\r\n// -------------------------\r\n// Immutable\r\n// -------------------------\r\n\r\n/**\r\n * Immutable stack\r\n * `Push` & `pop` both return a new instance, the original is never modified.\r\n * \r\n * Usage:\r\n * ```\r\n * push(item);  // Return a new stack with item(s) added\r\n * pop();       // Return a new stack with top-most item removed (ie. newest)\r\n * .peek;       // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length;     // How many items in stack\r\n * .data;       // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * let sanga = new Stack();\r\n * sanga = sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga = sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * const sangaAlt = sanga.push(`lettuce`, `cheese`); // sanga stays [`bread`, `tomato`], while sangaAlt is [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class Stack\r\n * @template V\r\n */\r\nexport class Stack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): Stack<V> {\r\n    return new Stack<V>(this.opts, push(this.opts, this.data, ...toAdd));\r\n  }\r\n\r\n  pop(): Stack<V> {\r\n    return new Stack<V>(this.opts, pop(this.opts, this.data));\r\n  }\r\n\r\n  /**\r\n   * Enumerates stack from bottom-to-top\r\n   *\r\n   * @param {(v:V) => void} fn\r\n   * @memberof Stack\r\n   */\r\n  forEach(fn:(v:V) => void): void {\r\n    this.data.forEach(fn);\r\n  }\r\n\r\n  forEachFromTop(fn:(v:V) => void): void {\r\n    [...this.data].reverse().forEach(fn);\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n/**\r\n * Returns an immutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} [opts={}]\r\n * @param {...V[]} startingItems\r\n * @returns {Stack<V>}\r\n */\r\nexport const stack = <V>(opts: StackOpts = {}, ...startingItems: ReadonlyArray<V>): Stack<V> => new Stack({...opts}, [...startingItems]);\r\n\r\n\r\n// -------------------------\r\n// Mutable\r\n// -------------------------\r\n\r\n\r\n/**\r\n * Mutable stack\r\n * \r\n * Usage:\r\n * ```\r\n * push(item); // Add one or more items to the top of the stack\r\n * pop(); // Removes and retiurns the item at the top of the stack (ie the newest thing)\r\n * .peek; // Return what is at the top of the stack or undefined if empty\r\n * .isEmpty/.isFull;\r\n * .length; // How many items in stack\r\n * .data; // Get the underlying array\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const sanga = new MutableStack();\r\n * sanga.push(`bread`, `tomato`, `cheese`);\r\n * sanga.peek;  // `cheese`\r\n * sanga.pop(); // removes `cheese`\r\n * sanga.peek;  // `tomato`\r\n * sanga.push(`lettuce`, `cheese`); // Stack is now [`bread`, `tomato`, `lettuce`, `cheese`]\r\n * ```\r\n *\r\n * Stack can also be created from the basis of an existing array. First index of array will be the bottom of the stack.\r\n * @class MutableStack\r\n * @template V\r\n */\r\nclass MutableStack<V> {\r\n  readonly opts: StackOpts;\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  data: ReadonlyArray<V>;\r\n\r\n  constructor(opts: StackOpts, data: ReadonlyArray<V>) {\r\n    this.opts = opts;\r\n    this.data = data;\r\n  }\r\n\r\n  push(...toAdd: ReadonlyArray<V>): number {\r\n    /* eslint-disable-next-line functional/immutable-data */\r\n    this.data = push(this.opts, this.data, ...toAdd);\r\n    return this.data.length;\r\n  }\r\n\r\n  pop(): V|undefined {\r\n    const v = peek(this.opts, this.data);\r\n    pop(this.opts, this.data);\r\n    return v;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return isEmpty(this.opts, this.data);\r\n  }\r\n\r\n  get isFull(): boolean {\r\n    return isFull(this.opts, this.data);\r\n  }\r\n\r\n  get peek(): V | undefined {\r\n    return peek(this.opts, this.data);\r\n  }\r\n\r\n  get length():number {\r\n    return this.data.length;\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a mutable stack\r\n *\r\n * @template V\r\n * @param {StackOpts} opts\r\n * @param {...V[]} startingItems\r\n * @returns\r\n */\r\nexport const stackMutable = <V>(opts: StackOpts, ...startingItems: ReadonlyArray<V>) =>  new MutableStack({...opts}, [...startingItems]);","import {stack, stackMutable,  OverflowPolicy as StackOverflowPolicy} from './Stack.js';\r\nimport {queue, queueMutable, OverflowPolicy as QueueOverflowPolicy} from './Queue.js';\r\nimport {IsEqual, isEqualDefault} from '../util.js';\r\n\r\nexport {stack, stackMutable, StackOverflowPolicy};\r\nexport {queue, queueMutable, QueueOverflowPolicy};\r\n\r\nexport const guardArray = <V>(array:ArrayLike<V>, paramName:string = `?`) => {\r\n  if (array === undefined) throw new Error(`Param '${paramName}' is undefined. Expected array.`);\r\n  if (array === null) throw new Error(`Param '${paramName}' is null. Expected array.`);\r\n  if (!Array.isArray(array)) throw new Error(`Param '${paramName}' not an array as expected`);\r\n};\r\n\r\nexport const randomIndex = <V>(array: ArrayLike<V>): number => Math.floor(Math.random() * array.length);\r\n\r\nexport const randomElement = <V>(array: ArrayLike<V>): V => {\r\n  guardArray(array, `array`);\r\n  return array[Math.floor(Math.random() * array.length)];\r\n};\r\n\r\n/**\r\n * Removes a random item from an array, returning both the item and the new array as a result.\r\n * Does not modify the original array unless `mutate` parameter is true\r\n *\r\n * @template V\r\n * @param {readonly} array Array to pluck item from\r\n * @param {*} V \r\n * @param {*} []\r\n * @return {*}  {({readonly value:V|undefined, readonly array:ReadonlyArray<V> })}\r\n */\r\n//eslint-disable-next-line functional/prefer-readonly-type\r\nexport const randomPluck = <V>(array:readonly V[], mutate = false):{readonly value:V|undefined, readonly array:Array<V> } => {\r\n  if (array === undefined) throw new Error(`array is undefined`);\r\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\r\n  if (array.length === 0) return {value: undefined, array: []};\r\n  const index = randomIndex(array);\r\n  if (mutate) {\r\n    return {\r\n      value: array[index],\r\n      //eslint-disable-next-line functional/immutable-data\r\n      array: array.splice(index, 1)\r\n    };\r\n  } else {\r\n    // Copy array, remove item from that\r\n    const t = [...array];\r\n    //eslint-disable-next-line functional/immutable-data\r\n    t.splice(index, 1);\r\n    return {\r\n      value: array[index],\r\n      array: t\r\n    };\r\n  }\r\n};\r\n\r\nexport const shuffle = (dataToShuffle:ReadonlyArray<unknown>): ReadonlyArray<unknown> => {\r\n  const array = [...dataToShuffle];\r\n  // eslint-disable-next-line functional/no-loop-statement, functional/no-let\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    [array[i], array[j]] = [array[j], array[i]];\r\n  }\r\n  return array;\r\n};\r\n\r\n/**\r\n * Returns an array with a value omitted.\r\n * Value checking is completed via the provided `comparer` function, or by default checking whether `a === b`.\r\n *\r\n * @template V\r\n * @param {ReadonlyArray<V>} data\r\n * @param {V} value\r\n * @param {IsEqual<V>} [comparer=isEqualDefault]\r\n * @return {*}  {ReadonlyArray<V>}\r\n */\r\nexport const without = <V>(data:ReadonlyArray<V>, value:V, comparer:IsEqual<V> = isEqualDefault):ReadonlyArray<V> => data.filter(v => !comparer(v, value));\r\n\r\n","/**\r\n * A simple mutable map of arrays, without events\r\n *\r\n * @export\r\n * @class SimpleMutableMapArray\r\n * @template V\r\n */\r\nexport class SimpleMutableMapArray<V> {\r\n  /* eslint-disable-next-line functional/prefer-readonly-type */\r\n  readonly #map: Map<string, ReadonlyArray<V>> = new Map();\r\n\r\n  add(key: string, ...values: ReadonlyArray<V>) {\r\n    const existing = this.#map.get(key);\r\n    if (existing === undefined) {\r\n      this.#map.set(key, values);\r\n    } else {\r\n      this.#map.set(key, [...existing, ...values]);\r\n    }\r\n  }\r\n\r\n  debugString(): string {\r\n    // eslint-disable-next-line functional/no-let\r\n    let r = ``;\r\n    const keys = Array.from(this.#map.keys());\r\n    keys.every(k => {\r\n      const v = this.#map.get(k);\r\n      if (v === undefined) return;\r\n      r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\r\n    });\r\n    return r;\r\n  }\r\n\r\n  get(key: string): ReadonlyArray<V> | undefined {\r\n    return this.#map.get(key);\r\n  }\r\n\r\n  delete(key: string, v: V): boolean {\r\n    const existing = this.#map.get(key);\r\n    if (existing === undefined) return false;\r\n    const without = existing.filter(i => i !== v);\r\n    this.#map.set(key, without);\r\n    return without.length < existing.length;\r\n  }\r\n\r\n  clear() {\r\n    this.#map.clear();\r\n  }\r\n}","import { SimpleMutableMapArray } from \"./collections/SimpleMutableMapArray.js\";\r\nexport type Listener<Events> = (ev: unknown, sender: SimpleEventEmitter<Events>) => void;\r\n\r\ntype FlowSource = {\r\n  name:string,\r\n  dispose():void,\r\n  input:FlowSink,\r\n};\r\n\r\ntype FlowHandler = (args?:any) => void;\r\n\r\ninterface FlowSink {\r\n [key:string]: FlowHandler;\r\n}\r\n\r\nexport type Debouncer = {\r\n  reset:()=>void\r\n  dispose:()=>void\r\n}\r\n\r\nconst sinkify = (handler:FlowHandler): FlowSink => ({ '*': handler });\r\n\r\nexport const debounceFactory = (sink:FlowSink, opts:{timeoutMs:number}): FlowSource => {\r\n  let timer:number|undefined;\r\n\r\n  const input = sinkify(() => {\r\n    //console.log(`debounce reset`);\r\n    if (timer) window.clearTimeout(timer);\r\n    timer = window.setTimeout(() => { sink[`*`](null); }, opts.timeoutMs);\r\n  });\r\n\r\n  const dispose = () => {\r\n    if (timer) window.clearTimeout(timer);\r\n    timer = undefined;\r\n  };\r\n\r\n  return { input, dispose, name:`debounce` };\r\n};\r\n\r\nexport const debounce = (triggered:()=>void, timeoutMs:number):Debouncer => {\r\n  const opts = { timeoutMs: timeoutMs};\r\n  \r\n  const sink:FlowSink = {\r\n    '*': () => {\r\n      triggered();\r\n    }\r\n  };\r\n  const source = debounceFactory(sink, opts);\r\n  const reset = () => {\r\n    source.input[`*`](null);\r\n  };\r\n  return {...source, reset};\r\n};\r\n\r\nexport class SimpleEventEmitter<Events> {\r\n  readonly #listeners = new SimpleMutableMapArray<Listener<Events>>();\r\n\r\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[K]) {\r\n    const listeners = this.#listeners.get(type as string);\r\n    if (listeners === undefined) return;\r\n    listeners.forEach(l => {\r\n      // eslint-disable-next-line functional/no-try-statement\r\n      try {\r\n        l(args, this);\r\n      } catch (err) {\r\n        console.debug(`Event listener error: `, err);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds event listener\r\n   *\r\n   * @template K\r\n   * @param {K} type\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  addEventListener<K extends keyof Events>(type: K, listener: (ev: Events[K], sender: SimpleEventEmitter<Events>) => void): void { // (this: any, ev: Events[K]) => any): void {\r\n    this.#listeners.add(type as string, listener as Listener<Events>);\r\n  }\r\n  //addEventListener<K extends keyof WindowEventMap>(type: K, listener: (this: Window, ev: WindowEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\r\n\r\n  /**\r\n   * Remove event listener\r\n   *\r\n   * @param {Listener<Events>} listener\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  removeEventListener<K extends keyof Events>(type: K, listener: Listener<Events>): void {\r\n    this.#listeners.delete(type as string, listener);\r\n  }\r\n\r\n  /**\r\n   * Clear all event listeners\r\n   *\r\n   * @memberof SimpleEventEmitter\r\n   */\r\n  clearEventListeners() {\r\n    this.#listeners.clear();\r\n  }\r\n}\r\n\r\n// type TestEventMap = {\r\n//   readonly change: TestEvent\r\n//   readonly other: TestEvent2;\r\n// }\r\n\r\n// interface TestEvent2 {\r\n//   readonly something: string;\r\n// }\r\n// interface TestEvent {\r\n//   readonly blah: boolean;\r\n// }\r\n\r\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\r\n//   constructor() {\r\n//     super();\r\n//     this.addEventListener(`change`, (e) => {\r\n//       e.blah;\r\n//     });\r\n//   }\r\n// }\r\n\r\n/*\r\nexport class Event {\r\n  public target: any;\r\n  public type: string;\r\n  constructor(type: string, target: any) {\r\n    this.target = target;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\nexport class ErrorEvent extends Event {\r\n  public message: string;\r\n  public error: Error;\r\n  constructor(error: Error, target: any) {\r\n    super('error', target);\r\n    this.message = error.message;\r\n    this.error = error;\r\n  }\r\n}\r\n\r\nexport class CloseEvent extends Event {\r\n  public code: number;\r\n  public reason: string;\r\n  public wasClean = true;\r\n  constructor(code = 1000, reason = '', target: any) {\r\n    super('close', target);\r\n    this.code = code;\r\n    this.reason = reason;\r\n  }\r\n}\r\nexport interface WebSocketEventMap {\r\n  close: CloseEvent;\r\n  error: ErrorEvent;\r\n  message: MessageEvent;\r\n  open: Event;\r\n}\r\n\r\nexport interface WebSocketEventListenerMap {\r\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\r\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\r\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\r\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\r\n}\r\n*/","// ✔ UNIT TESTED\r\n\r\nimport { ToString } from \"../util.js\";\r\nimport {SimpleEventEmitter} from \"../Events.js\";\r\n\r\ntype MutableValueSetEventMap<V> = {\r\n  readonly add: {readonly value: V, readonly updated: boolean}\r\n  readonly clear: boolean\r\n  readonly delete: V\r\n}\r\n\r\nexport const addUniqueByHash = <V>(set:ReadonlyMap<string, V>|undefined, hashFunc: ToString<V>, ...values:readonly V[]) => {\r\n  const s = set === undefined ? new Map() : new Map(set);\r\n  values.forEach(v => {\r\n    const vStr = hashFunc(v);\r\n    if (s.has(vStr)) return;\r\n    s.set(vStr, v);\r\n  });\r\n  return s;\r\n};\r\n\r\nexport const mutableStringSet = <V>(keyString: ToString<V> | undefined = undefined) => new MutableStringSetImpl(keyString);\r\n\r\nexport type MutableStringSet<V> = {\r\n  readonly add: (item:V) => void\r\n  readonly has: (item:V) => boolean\r\n}\r\n\r\n/**\r\n * A mutable set that stores unique items by their value, rather\r\n * than object reference.\r\n * \r\n * By default the JSON.stringify() representation is used to compare\r\n * objects. Alternatively, pass a function into the constructor\r\n *\r\n * It also fires `add`, `clear` and `delete` events.\r\n * \r\n * Usage\r\n * ```\r\n * .add(item);    // Add one or more items. Items with same key are overriden.\r\n * .has(item);    // Returns true if item *value* is present\r\n * .clear();      // Remove everything\r\n * .delete(item); // Delete item by value\r\n * .toArray();    // Returns values as an array\r\n * .values();     // Returns an iterator over values\r\n * ```\r\n * \r\n * Example\r\n * ```\r\n * const people = [\r\n *  {name: `Barry`, city: `London`}\r\n *  {name: `Sally`, city: `Bristol`}\r\n * ];\r\n * const set = mutableValueSet(person => {\r\n *  // Key person objects by name and city (assi)\r\n *  return `${person.name}-${person.city}`\r\n * });\r\n * set.add(...people);\r\n * \r\n * set.has({name:`Barry`, city:`Manchester`})); // False, key is different (Barry-Manchester)\r\n * set.has({name:`Barry`, city:`London`}));     // True, we have Barry-London as a key\r\n * set.has(people[1]);   // True, key of object is found (Sally-Bristol)\r\n * \r\n * set.addEventListener(`add`, newItem => {\r\n *  console.log(`New item added: ${newItem}`);\r\n * });\r\n * ```\r\n * \r\n * @export\r\n * @class MutableValueSet\r\n * @template V\r\n */\r\nclass MutableStringSetImpl<V> extends SimpleEventEmitter<MutableValueSetEventMap<V>> {\r\n  // ✔ UNIT TESTED\r\n  /* eslint-disable functional/prefer-readonly-type */\r\n  store = new Map<string, V>();\r\n  keyString: ToString<V>;\r\n\r\n  constructor(keyString: ToString<V> | undefined = undefined) {\r\n    super();\r\n    \r\n    if (keyString === undefined) {\r\n      keyString = (a) => {\r\n        if (typeof a === `string`) { \r\n          return a;\r\n        } else { \r\n          return JSON.stringify(a);\r\n        }\r\n      };\r\n    }\r\n    this.keyString = keyString;\r\n  }\r\n\r\n  add(...v: ReadonlyArray<V>) {\r\n    v.forEach(i => {\r\n      const isUpdated = this.has(i);\r\n      this.store.set(this.keyString(i), i);\r\n      super.fireEvent(`add`, { value: i, updated: isUpdated});\r\n    });\r\n  }\r\n\r\n  values() {\r\n    return this.store.values();\r\n  }\r\n\r\n  clear() {\r\n    this.store.clear();\r\n    super.fireEvent(`clear`, true);\r\n  }\r\n\r\n  delete(v: V): boolean {\r\n    const isDeleted = this.store.delete(this.keyString(v));\r\n    if (isDeleted) super.fireEvent(`delete`, v);\r\n    return isDeleted;\r\n  }\r\n\r\n  has(v: V): boolean {\r\n    return this.store.has(this.keyString(v));\r\n  }\r\n\r\n  toArray(): V[] {\r\n    return Array.from(this.store.values());\r\n  }\r\n}"],"mappings":"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","names":[]}