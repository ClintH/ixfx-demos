{"version":3,"sources":["../src/flow/Timer.ts"],"sourcesContent":["import { clamp } from '../numbers/Clamp.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport type { HasCompletion } from './Types.js';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * Implementations: {@link elapsedMillisecondsAbsolute}, {@link elapsedTicksAbsolute}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relative}\n */\nexport type CompletionTimer = Timer & {\n  /**\n   * Returns _true_ if this timer has completed.\n   */\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link msElapsedTimer}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n * \n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n *\n * See also {@link Elapsed.progress}.\n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute() });\n  return () => t.isDone;\n}\n\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * const timer = Timer.ofTotal(1000);\n * \n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Timer.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Timer.ofTotal({ mins: 4 });\n * ```\n * \n * See also {@link hasElapsed}.\n * \n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @returns\n */\nexport function ofTotal(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`Param 'duration' not valid`);\n  const timerOpts = {\n    ...opts,\n    timer: elapsedMillisecondsAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    if (!t) {\n      t = relative(totalMs, timerOpts);\n    }\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * const timer = Timer.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Timer.ofTotal(1000, { clampValue: true });\n * ```\n *\n * See also {@link hasElapsed}.\n * \n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @returns\n */\nexport function ofTotalTicks(totalTicks: number, opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const timerOpts = {\n    ...opts,\n    timer: elapsedTicksAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    if (!t) {\n      t = relative(totalTicks, timerOpts);\n    }\n    return t.elapsed;\n  }\n}\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `msElapsedTimer()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (\n  total: number,\n  options: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  const clampValue = options.clampValue ?? false;\n  const wrapValue = options.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  // Keep track of value to avoid over-advancing the tick counter\n  let lastValue = 0;\n  const computeElapsed = (value: number) => {\n    lastValue = value;\n    let v = value / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      //const tmp = computeElapsed();\n      //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n      return computeElapsed(lastValue) >= 1;\n    },\n    get elapsed() {\n      return computeElapsed(timer.elapsed);\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  options: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = (): Timer & { peek: number } => {\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Get current ticks without incrementing.\n     */\n    get peek() {\n      return start;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     * \n     * Use {@link peek} to get the current ticks without incrementing.\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n\n\n/**\n * Wraps `timer`, computing a value for based on its elapsed value.\n * `fn` creates this value.\n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n * \n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n * \n * @param fn \n * @param timer \n * @returns \n */\nexport const timerWithFunction = (\n  fn: ((v: number) => number),\n  timer: CompletionTimer\n): HasCompletion & CompletionTimer & { compute: () => number } => {\n  if (typeof fn !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${ typeof fn }`);\n  let startCount = 1;\n  return {\n    get elapsed() {\n      return timer.elapsed;\n    },\n    get isDone() {\n      return timer.isDone;\n    },\n    get runState() {\n      if (timer.isDone) return `idle`;\n      return `scheduled`;\n    },\n    /**\n     * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n     */\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCount;\n    },\n    compute: () => {\n      const elapsed = timer.elapsed;\n      return fn(elapsed);\n    },\n    reset: () => {\n      timer.reset();\n      startCount++;\n    },\n  };\n};"],"mappings":"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","names":[]}