{"version":3,"sources":["../src/iterables/IterableAsync.ts","../src/data/BasicProcessors.ts"],"sourcesContent":["import { intervalToMs, type Interval } from '../flow/IntervalType.js';\nimport { type IsEqual } from '../util/IsEqual.js';\nimport { sleep, type SleepOpts } from '../flow/Sleep.js';\nimport { isAsyncIterable, isIterable } from './Iterable.js';\nimport { toStringDefault } from '../util/ToString.js';\nimport type { ToArrayOptions } from './Types.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: Array<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in a number or AbortSignal as a second parameter.\n * ```js\n * repeat(generator, 5); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, ac.signal); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param gen \n * @param maximumRepeats \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    const result = await f(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it \n * @param delay \n */\nexport async function* withDelay<V>(it: Iterable<V>, delay: Interval) {\n  for (const v of it) {\n    await sleep(delay);\n    yield v;\n  }\n}\n\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout<V>(it: AsyncIterableIterator<V> | IterableIterator<V>, options: SleepOpts<any>) {\n  const ms = intervalToMs(options, 1000);\n\n  const value: IteratorResult<V> | undefined = await Promise.race([\n    (async () => {\n      await sleep({ millis: ms, signal: options.signal });\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      return undefined;\n    })(),\n    (async () => {\n      return await it.next();\n    })()\n  ]);\n  if (value === undefined) throw new Error(`Timeout`);\n  return value;\n}\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n * \n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Promise<Array<V>> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n\n  while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback \n */\nexport async function* fromFunctionAwaited<T>(callback: () => Promise<T> | T) {\n  while (true) {\n    const v = await callback();\n    yield v;\n  }\n}\n\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback \n */\nexport function* fromFunction<T>(callback: () => T) {\n  while (true) {\n    const v = callback();\n    yield v;\n  }\n}\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | Array<AsyncIterable<V>>\n) {\n  const buffer: Array<any> = [];\n  const itera: Array<AsyncIterable<V>> = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: (value: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","import type { Process } from \"./Process.js\";\nimport type { RankFunction, RankOptions } from \"./Types.js\";\n\nexport const max = (): Process<number | Array<number>, number> => {\n  let max = Number.MIN_SAFE_INTEGER;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      max = Math.max(subValue, max);\n    }\n    return max;\n  }\n  return compute;\n}\n\nexport const min = (): Process<number | Array<number>, number> => {\n  let min = Number.MAX_SAFE_INTEGER;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      min = Math.min(subValue, min);\n    }\n    return min;\n  }\n  return compute;\n}\n\nexport const sum = (): Process<number | Array<number>, number> => {\n  let t = 0;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      t += subValue;\n    }\n    return t;\n  }\n  return compute;\n}\n\nexport const average = (): Process<number | Array<number>, number> => {\n  let total = 0;\n  let tally = 0;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      tally++;\n      total += subValue;\n    }\n    return total / tally;\n  }\n  return compute;\n}\n\nexport const tally = (countArrayItems: boolean): Process<any, number> => {\n  let t = 0;\n  const compute = (value: number | Array<number>) => {\n    if (countArrayItems) {\n      if (Array.isArray(value)) t += value.length;\n      else t++;\n    } else {\n      t++;\n    }\n    return t;\n  }\n  return compute;\n}\n\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}) {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  let best: In | undefined;\n  return (value: In) => {\n    if (includeType && typeof value !== includeType) return;\n    if (best === undefined) {\n      best = value;\n      return best;\n    } else {\n      const result = r(value, best);\n      //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n      if (result == `a`) {\n        // New value is the current best\n        best = value;\n        return best;\n      } else if (result === `eq` && emitEqualRanked) {\n        // New value is same rank as previous, but we have flag on\n        return best;\n      } else if (emitRepeatHighest) {\n        // Emit current highest due to flag\n        return best;\n      }\n    }\n  }\n}\n\n\n"],"mappings":"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","names":["max","min","max","min","tally"]}