{"version":3,"sources":["../src/audio/index.ts","../src/audio/Analyser.ts","../src/audio/AudioVisualiser.ts","../src/temporal/Tracker.ts"],"sourcesContent":["export * as Analysers from './Analyser.js';\r\nexport * as Visualiser from './AudioVisualiser.js';","import {Arrays} from \"../collections/index.js\";\r\nimport AudioVisualiser from \"./AudioVisualiser.js\";\r\nimport {number as guardNumber, integer as guardInteger} from \"../Guards.js\";\r\nimport {isPowerOfTwo} from \"~/Util.js\";\r\n\r\n/**\r\n * Options for audio processing\r\n * \r\n * fftSize: Must be a power of 2, from 32 - 32768. Higher number means\r\n * more precision and higher CPU overhead\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\r\n * \r\n * smoothingTimeConstant: Range from 0-1, default is 0.8.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\r\n * \r\n * debug: If true, additonal console logging will happen\r\n */\r\nexport type Opts = Readonly<{\r\n  readonly showVis?:boolean\r\n  /**\r\n   * FFT size. Must be a power of 2, from 32 - 32768. Higher number means\r\n   * more precision and higher CPU overhead\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\r\n   */\r\n  readonly fftSize?:number\r\n  /**\r\n   * Range from 0-1, default is 0.8\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\r\n   */\r\n  readonly smoothingTimeConstant?:number\r\n  readonly debug?:boolean\r\n}>;\r\n\r\nexport type DataAnalyser = (node:AnalyserNode, analyser:Analyser) => void;\r\n\r\n/**\r\n * Basic audio analyser. Returns back waveform and FFT analysis. Use {@link peakLevel} if you want sound level, or {@link freq} if you just want FFT results.\r\n * \r\n * ```js\r\n * const onData = (freq, wave, analyser) => {\r\n *  // Demo: Get FFT results just for 100Hz-1KHz.\r\n *  const freqSlice = analyser.sliceByFrequency(100,1000,freq);\r\n * \r\n *  // Demo: Get FFT value for a particular frequency (1KHz)\r\n *  const amt = freq[analyser.getIndexForFrequency(1000)];\r\n * }\r\n * basic(onData, {fftSize: 512});\r\n * ```\r\n * \r\n * An `Analyser` instance is returned and can be controlled:\r\n * ```js\r\n * const analyser = basic(onData);\r\n * analyser.paused = true;\r\n * ```\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler. \r\n * \r\n * @param onData Handler for data\r\n * @param opts Options\r\n * @returns Analyser instance\r\n */\r\nexport const basic = (onData:(freq:Float32Array, wave:Float32Array, analyser:Analyser) => void, opts:Opts = {}):Analyser => new Analyser((node, analyser) => {\r\n  // Get frequency and amplitude data\r\n  const freq = new Float32Array(node.frequencyBinCount);\r\n  const wave = new Float32Array(node.fftSize);\r\n\r\n  // Load arrays with data\r\n  node.getFloatFrequencyData(freq);\r\n  node.getFloatTimeDomainData(wave);\r\n\r\n  // Send back\r\n  onData(freq, wave, analyser);\r\n}, opts);\r\n\r\n/**\r\n * Basic audio analyser. Returns FFT analysis. Use {@link peakLevel} if you want the sound level, or {@link basic} if you also want the waveform.\r\n * \r\n * ```js\r\n * const onData = (freq, analyser) => {\r\n *  // Demo: Print out each sound frequency (Hz) and amount of energy in that band\r\n *  for (let i=0;i<freq.length;i++) {\r\n *    const f = analyser.getFrequencyAtIndex(0);\r\n *    console.log(`${i}. frequency: ${f} amount: ${freq[i]}`);\r\n *  }\r\n * }\r\n * freq(onData, {fftSize:512});\r\n * ```\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler. \r\n * \r\n * @param onData \r\n * @param opts \r\n * @returns \r\n */\r\nexport const freq = (onData:(freq:Float32Array, analyser:Analyser)=>void, opts:Opts={}):Analyser => new Analyser((node, analyser) => {\r\n  const freq = new Float32Array(node.frequencyBinCount);\r\n  node.getFloatFrequencyData(freq);\r\n  onData(freq, analyser);\r\n}, opts);\r\n\r\n/**\r\n * Basic audio analyser which reports the peak sound level.\r\n * \r\n * ```js\r\n * peakLevel(level => {\r\n *  console.log(level);\r\n * });\r\n * ```\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler. \r\n * @param onData \r\n * @param opts \r\n * @returns \r\n */\r\nexport const peakLevel = (onData:(level:number, analyser:Analyser)=>void, opts:Opts={}):Analyser => new Analyser((node, analyser) => {\r\n  const wave = new Float32Array(node.fftSize);\r\n  node.getFloatTimeDomainData(wave);\r\n  onData(Arrays.maxFast(wave), analyser);\r\n}, opts);\r\n\r\n/**\r\n * Helper for doing audio analysis. It takes case of connecting the audio stream, running in a loop and pause capability.\r\n * \r\n * Provide a function which works with an [AnalyserNode](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode), and does something with the result.\r\n * ```js\r\n * const myAnalysis = (node, analyser) => {\r\n *  const freq = new Float32Array(node.frequencyBinCount);\r\n *  node.getFloatFrequencyData(freq);\r\n *  // Do something with frequency data...\r\n * }\r\n * const a = new Analyser(myAnalysis);\r\n * ```\r\n * \r\n * Two helper functions provide ready-to-use Analysers:\r\n * * {@link peakLevel} peak decibel reading\r\n * * {@link freq} FFT results\r\n * * {@link basic} FFT results and waveform\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\r\n *\r\n */\r\nexport class Analyser {\r\n  showVis:boolean;\r\n  fftSize:number;\r\n  smoothingTimeConstant:number;\r\n  #isPaused = false;\r\n  debug:boolean;\r\n  #initInProgress = false;\r\n\r\n  visualiser:AudioVisualiser|undefined;  \r\n  audioCtx:AudioContext|undefined;\r\n  analyserNode:AnalyserNode|undefined;\r\n\r\n  analyse:DataAnalyser;\r\n\r\n  constructor(analyse:DataAnalyser, opts:Opts = {}) {\r\n    this.showVis = opts.showVis ?? false;\r\n    this.fftSize = opts.fftSize ?? 1024;\r\n    this.debug = opts.debug ?? false;\r\n    this.smoothingTimeConstant = opts.smoothingTimeConstant ?? 0.8;\r\n\r\n    guardInteger(this.fftSize, `positive`, `opts.fftSize`);\r\n    guardNumber(this.smoothingTimeConstant, `percentage`, `opts.smoothingTimeConstant`);\r\n\r\n    if (!isPowerOfTwo(this.fftSize)) throw new Error(`fftSize must be a power of two from 32 to 32768 (${this.fftSize})`);\r\n    if(this.fftSize < 32) throw new Error(`fftSize must be at least 32`);\r\n    if (this.fftSize > 32768) throw new Error(`fftSize must be no greater than 32768`);\r\n\r\n    this.analyse = analyse;\r\n    this.paused = false;\r\n\r\n    this.init();\r\n\r\n    const visualiserEl = document.getElementById(`audio-visualiser`);\r\n    if (visualiserEl) {\r\n      const visualiser = new AudioVisualiser(visualiserEl, this);\r\n      visualiser.setExpanded(this.showVis);\r\n      this.visualiser = visualiser;\r\n    }\r\n  }\r\n\r\n  init() {\r\n    if (this.#initInProgress) {\r\n      if (this.debug) console.debug(`Init already in progress`);\r\n      return;\r\n    }\r\n    this.#initInProgress = true;\r\n\r\n    // Initalise microphone\r\n    navigator.mediaDevices.getUserMedia({audio: true})\r\n      .then(stream => {     \r\n        this.onMicSuccess(stream);\r\n      })\r\n      .catch(err => {\r\n        this.#initInProgress = false;\r\n        console.error(err);\r\n      });\r\n  }\r\n\r\n  get paused():boolean {\r\n    return this.#isPaused;\r\n  }\r\n\r\n  set paused(v:boolean) {\r\n    if (v === this.#isPaused) return;\r\n    this.#isPaused = v;\r\n    if (!v) {\r\n      if (this.debug) console.log(`Unpaused`);\r\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\r\n    } else {\r\n      if (this.debug) console.log(`Paused`);\r\n    }\r\n  }\r\n\r\n  private setup(audioCtx:AudioContext, stream:MediaStream) {\r\n    const analyser = audioCtx.createAnalyser();\r\n\r\n    // fftSize must be a power of 2. Higher values slower, more detailed\r\n    // Range is 32-32768\r\n    analyser.fftSize = this.fftSize;\r\n\r\n    // smoothingTimeConstant ranges from 0.0 to 1.0\r\n    // 0 = no averaging. Fast response, jittery\r\n    // 1 = maximum averaging. Slow response, smooth\r\n    analyser.smoothingTimeConstant = this.smoothingTimeConstant;\r\n\r\n    // Microphone -> analyser\r\n    const micSource = audioCtx.createMediaStreamSource(stream);\r\n    micSource.connect(analyser);\r\n    return analyser;\r\n  }\r\n\r\n  // Microphone successfully initalised, now have access to audio data\r\n  private onMicSuccess(stream:MediaStream) {\r\n    //eslint-disable-next-line functional/no-try-statement\r\n    try {\r\n      const audioCtx = new AudioContext();\r\n\r\n      audioCtx.addEventListener(`statechange`, () => {\r\n        if (this.debug) console.log(`Audio context state: ${audioCtx.state}`);\r\n      });\r\n\r\n      this.audioCtx = audioCtx;\r\n      this.analyserNode = this.setup(audioCtx, stream);\r\n\r\n      // Start loop\r\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\r\n    } catch (ex) {\r\n      this.#initInProgress = false;\r\n      console.error(ex);\r\n    }\r\n  }\r\n\r\n  private analyseLoop() {\r\n    if (this.paused) {\r\n      if (this.debug) console.log(`Paused`);\r\n      return;\r\n    }\r\n\r\n    const a = this.analyserNode;\r\n    if (a === undefined) {\r\n      console.warn(`Analyser undefined`);\r\n      return;\r\n    }\r\n\r\n    //eslint-disable-next-line functional/no-try-statement\r\n    try {\r\n      // Perform analysis\r\n      this.analyse(a, this);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n\r\n    // Run again\r\n    window.requestAnimationFrame(this.analyseLoop.bind(this));\r\n  }\r\n\r\n  // visualise(wave, freq) {\r\n  //   if (!this.visualiser) return;\r\n  //   this.visualiser.renderWave(wave, true);\r\n  //   this.visualiser.renderFreq(freq);\r\n  // }\r\n\r\n  /**\r\n   * Returns the maximum FFT value within the given frequency range\r\n   */\r\n  getFrequencyRangeMax(lowFreq:number, highFreq:number, freqData:readonly number[]):number {\r\n    const samples = this.sliceByFrequency(lowFreq, highFreq, freqData);\r\n    return Arrays.max(...samples);\r\n  }\r\n\r\n  /**\r\n   * Returns a sub-sampling of frequency analysis data that falls between\r\n   * `lowFreq` and `highFreq`.\r\n   * @param lowFreq Low frequency\r\n   * @param highFreq High frequency\r\n   * @param freqData Full-spectrum frequency data\r\n   * @returns Sub-sampling of analysis\r\n   */\r\n  sliceByFrequency(lowFreq:number, highFreq:number, freqData:readonly number[]) {\r\n    const lowIndex = this.getIndexForFrequency(lowFreq);\r\n    const highIndex = this.getIndexForFrequency(highFreq);\r\n\r\n    // Grab a 'slice' of the array between these indexes\r\n    const samples = freqData.slice(lowIndex, highIndex);\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * Returns the starting frequency for a given binned frequency index.\r\n   * @param index Array index\r\n   * @returns Sound frequency\r\n   */\r\n  getFrequencyAtIndex(index:number):number {\r\n    const a = this.analyserNode;\r\n    const ctx = this.audioCtx;\r\n    if (a === undefined) throw new Error(`Analyser not available`);\r\n    if (ctx === undefined) throw new Error(`Audio context not available`);\r\n\r\n    guardInteger(index, `positive`, `index`);\r\n    if (index > a.frequencyBinCount) throw new Error(`Index ${index} exceeds frequency bin count ${a.frequencyBinCount}`);\r\n\r\n    return index * ctx.sampleRate / (a.frequencyBinCount * 2);\r\n  }\r\n\r\n  /**\r\n   * Returns a binned array index for a given frequency\r\n   * @param freq Sound frequency\r\n   * @returns Array index into frequency bins\r\n   */\r\n  getIndexForFrequency(freq:number):number {\r\n    const a = this.analyserNode;\r\n    if (a === undefined) throw new Error(`Analyser not available`);\r\n\r\n    const nyquist = a.context.sampleRate / 2.0;\r\n    const index = Math.round(freq / nyquist * a.frequencyBinCount);\r\n    if (index < 0) return 0;\r\n    if (index >= a.frequencyBinCount) return a.frequencyBinCount - 1;\r\n    return index;\r\n  }\r\n}","/**\r\n * Visualiser component\r\n *\r\n * Usage: import visualiser.js. Instantiate on document load, and pass in the\r\n * parent element into the constructor.\r\n *\r\n * eg: const v = new Visualiser(document.getElementById('renderer'));\r\n *\r\n * Data must be passed to the component via renderFreq or renderWave.\r\n * \r\n * Draws on https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\r\n */\r\n\r\nimport {Arrays} from '~/collections/index.js';\r\nimport {Points} from '../geometry/index.js';\r\nimport {Tracker} from '../temporal/Tracker.js';\r\nimport {Analyser} from './Analyser.js';\r\n\r\n// TODO: This is an adaption of old code. Needs to be smartened up further\r\nexport default class Visualiser {\r\n  freqMaxRange = 200;\r\n  audio:Analyser;\r\n  parent:HTMLElement;\r\n \r\n  lastPointer:Points.Point = {x:0, y:0};\r\n  pointerDown = false;\r\n  pointerClicking = false;\r\n  pointerClickDelayMs = 100;\r\n  pointerDelaying = false;\r\n\r\n  waveTracker:Tracker;\r\n  freqTracker:Tracker;\r\n  el:HTMLElement;\r\n\r\n  constructor(parentElem:HTMLElement, audio:Analyser) {\r\n    this.audio = audio;\r\n    this.parent = parentElem;\r\n    this.waveTracker = new Tracker(`wave`);\r\n    this.freqTracker = new Tracker(`freq`);\r\n   \r\n    // Add HTML\r\n    parentElem.innerHTML = `\r\n    <section>\r\n      <button id=\"rendererComponentToggle\">ðŸ”¼</button>\r\n      <div>\r\n        <h1>Visualiser</h1>\r\n        <div style=\"display:flex; flex-wrap: wrap\">\r\n          <div class=\"visPanel\">\r\n            <h2>Frequency distribution</h2>\r\n            <br />\r\n            <canvas id=\"rendererComponentFreqData\" height=\"200\" width=\"400\"></canvas>\r\n          </div>\r\n          <div class=\"visPanel\">\r\n            <h2>Waveform</h2>\r\n            <button id=\"rendererComponentWaveReset\">Reset</button>\r\n            <div>\r\n              Press and hold on wave to measure\r\n            </div>\r\n            <br />\r\n            <canvas id=\"rendererComponentWaveData\" height=\"200\" width=\"400\"></canvas>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </section>\r\n    `;\r\n    this.el = parentElem.children[0] as HTMLElement;\r\n\r\n    document.getElementById(`rendererComponentToggle`)?.addEventListener(`click`, () => {\r\n      this.setExpanded(!this.isExpanded());\r\n    });\r\n    this.el.addEventListener(`pointermove`, (e) => this.onPointer(e));\r\n    //this.el.addEventListener(`touchbegin`, (e) => this.onPointer(e));\r\n    this.el.addEventListener(`pointerup`, () => { \r\n      this.pointerDelaying = false; \r\n      this.pointerDown = false;\r\n    });\r\n    this.el.addEventListener(`pointerdown`, () => {\r\n      this.pointerDelaying = true;\r\n      setTimeout(() => {\r\n        if (this.pointerDelaying) { this.pointerDelaying = false; this.pointerDown = true; }\r\n      }, this.pointerClickDelayMs);\r\n    });\r\n    this.el.addEventListener(`pointerleave`, () => { \r\n      this.pointerDelaying = false; \r\n      this.pointerDown = false; });\r\n\r\n    document.getElementById(`rendererComponentWaveReset`)?.addEventListener(`click`, () => {\r\n      this.clear();\r\n    });\r\n  }\r\n\r\n  renderFreq(freq:readonly number[]) {\r\n    if (!this.isExpanded()) return; // Don't render if collapsed\r\n    if (!freq) return; // Data is undefined/null\r\n\r\n    const canvas = document.getElementById(`rendererComponentFreqData`) as HTMLCanvasElement;\r\n    if (canvas === null) throw new Error(`Cannot find canvas element`);\r\n    const g = canvas.getContext(`2d`);\r\n    if (g === null) throw new Error(`Cannot create drawing context`);\r\n\r\n    const bins = freq.length;\r\n    const canvasWidth = canvas.clientWidth;\r\n    const canvasHeight = canvas.clientHeight;\r\n    g.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    const pointer = this.getPointerRelativeTo(canvas);\r\n    const width = (canvasWidth / bins);\r\n    const minMax = Arrays.minMaxAvg(freq);\r\n\r\n    //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let i = 0; i < bins; i++) {\r\n      if (!Number.isFinite(freq[i])) continue;\r\n\r\n      const value = freq[i] - minMax.min;\r\n      const valueRelative = value / this.freqMaxRange;\r\n      const height = Math.abs(canvasHeight * valueRelative);\r\n      const offset = canvasHeight - height;\r\n\r\n      const hue = i / bins * 360;\r\n      const left = i * width;\r\n      g.fillStyle = `hsl(` + hue + `, 100%, 50%)`;\r\n\r\n      // Show info about data under pointer\r\n      if (pointer.y > 0 && pointer.y <= canvasHeight && pointer.x >= left && pointer.x <= left + width) {\r\n        // Keep track of data\r\n        if (this.freqTracker.id !== i.toString()) {\r\n          this.freqTracker.reset(i.toString());\r\n        }\r\n        this.freqTracker.seen(freq[i]);\r\n\r\n        const freqMma = this.freqTracker.getMinMaxAvg();\r\n\r\n        // Display\r\n        g.fillStyle = `black`;\r\n        if (this.audio) { \r\n          g.fillText(`Frequency (${i}) at pointer: ${this.audio.getFrequencyAtIndex(i).toLocaleString(`en`)} - ${this.audio.getFrequencyAtIndex(i + 1).toLocaleString(`en`)}`, 2, 10); \r\n        }\r\n        g.fillText(`Raw value: ${freq[i].toFixed(2)}`, 2, 20);\r\n        g.fillText(`Min: ${freqMma.min.toFixed(2)}`, 2, 40);\r\n        g.fillText(`Max: ${freqMma.max.toFixed(2)}`, 60, 40);\r\n        g.fillText(`Avg: ${freqMma.avg.toFixed(2)}`, 120, 40);\r\n\r\n      }\r\n      g.fillRect(left, offset, width, height);\r\n    }\r\n  }\r\n\r\n  isExpanded() {\r\n    const contentsElem = this.el.querySelector(`div`);\r\n    if (contentsElem === null) throw new Error(`contents div not found`);\r\n    return (contentsElem.style.display === ``);\r\n  }\r\n\r\n  setExpanded(value:boolean) {\r\n    const contentsElem = this.el.querySelector(`div`);\r\n    const button = this.el.querySelector(`button`);\r\n\r\n    if (button === null) throw new Error(`Button element not found`);\r\n    if (contentsElem === null) throw new Error(`Contents element not found`);\r\n    if (value) {\r\n      contentsElem.style.display = ``;\r\n      button.innerText = `ðŸ”¼`;\r\n    } else {\r\n      contentsElem.style.display = `none`;\r\n      button.innerText = `ðŸ”½`;\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.clearCanvas(document.getElementById(`rendererComponentFreqData`) as HTMLCanvasElement);\r\n    this.clearCanvas(document.getElementById(`rendererComponentWaveData`) as HTMLCanvasElement);\r\n  }\r\n\r\n  // Clears a canvas to white\r\n  clearCanvas(canvas:HTMLCanvasElement|null) {\r\n    if (canvas === null) throw new Error(`Canvas is null`);\r\n    const g = canvas.getContext(`2d`);\r\n    if (g === null) throw new Error(`Cannot create drawing context`);\r\n    g.fillStyle = `white`;\r\n    g.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);\r\n  }\r\n\r\n  // Renders waveform data.\r\n  // Adapted from MDN's AnalyserNode.getFloatTimeDomainData() example\r\n  renderWave(wave:readonly number[], bipolar = true) {\r\n    if (!this.isExpanded()) return; // Don't render if collapsed\r\n    if (!wave) return; // Undefined or null data\r\n    const canvas = document.getElementById(`rendererComponentWaveData`) as HTMLCanvasElement;\r\n    if (canvas === null) throw new Error(`Cannot find wave canvas`);\r\n    \r\n    const g = canvas.getContext(`2d`);\r\n    if (g === null) throw new Error(`Cannot create drawing context for wave`);\r\n\r\n    const canvasWidth = canvas.clientWidth;\r\n    const canvasHeight = canvas.clientHeight;\r\n    const pointer = this.getPointerRelativeTo(canvas);\r\n    const infoAreaHeight = 20;\r\n    const infoAreaWidth = 60;\r\n    const bins = wave.length;\r\n    g.fillStyle = `white`;\r\n    g.fillRect(0, 0, infoAreaWidth, infoAreaHeight);\r\n\r\n    const width = canvasWidth / bins;\r\n\r\n    // Clears the screen with very light tint of white\r\n    // to fade out last waveform. Set this higher to remove effect\r\n    g.fillStyle = `rgba(255, 255, 255, 0.03)`;\r\n    g.fillRect(0, 20, canvasWidth, canvasHeight);\r\n\r\n    g.fillStyle = `red`;\r\n    if (bipolar) {\r\n      g.fillRect(0, canvasHeight / 2, canvasWidth, 1);\r\n    } else {\r\n      g.fillRect(0, canvasHeight - 1, canvasWidth, 1);\r\n    }\r\n\r\n    g.lineWidth = 1;\r\n    g.strokeStyle = `black`;\r\n    g.beginPath();\r\n\r\n    //eslint-disable-next-line functional/no-let\r\n    let x = 0;\r\n\r\n    //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let i = 0; i < bins; i++) {\r\n      const height = wave[i] * canvasHeight;\r\n      const y = bipolar ? (canvasHeight / 2) - height : canvasHeight - height;\r\n\r\n      if (i === 0) {\r\n        g.moveTo(x, y);\r\n      } else {\r\n        g.lineTo(x, y);\r\n      }\r\n      x += width;\r\n\r\n      if (this.pointerDown) this.waveTracker.seen(wave[i]);\r\n    }\r\n    g.lineTo(canvasWidth, bipolar ? canvasHeight / 2 : canvasHeight);//canvas.height / 2);\r\n    g.stroke();\r\n\r\n    // Draw\r\n    if (this.pointerDown) {\r\n      const waveMma = this.waveTracker.getMinMaxAvg();\r\n      g.fillStyle = `rgba(255,255,0,1)`;\r\n      g.fillRect(infoAreaWidth, 0, 150, 20);\r\n      g.fillStyle = `black`;\r\n      g.fillText(`Min: ` + waveMma.min.toFixed(2), 60, 10);\r\n      g.fillText(`Max: ` + waveMma.max.toFixed(2), 110, 10);\r\n      g.fillText(`Avg: ` + waveMma.avg.toFixed(2), 160, 10);\r\n    } else {\r\n      this.waveTracker.reset();\r\n    }\r\n\r\n    // Show info about data under pointer\r\n    if (pointer.y > 0 && pointer.y <= canvasHeight && pointer.x >= 0 && pointer.x <= canvasWidth) {\r\n      g.fillStyle = `black`;\r\n      g.fillText(`Level: ` + (1.0 - (pointer.y / canvasHeight)).toFixed(2), 2, 10);\r\n    }\r\n\r\n  }\r\n\r\n  // Yields pointer position relative to given element\r\n  getPointerRelativeTo(elem:HTMLElement) {\r\n    const rect = elem.getBoundingClientRect();\r\n    return {\r\n      x: this.lastPointer.x - rect.left - window.scrollX, //elem.offsetLeft + window.scrollX,\r\n      y: this.lastPointer.y - rect.top - window.scrollY//elem.offsetTop + window.scrollY\r\n    };\r\n  }\r\n\r\n  // Keeps track of last pointer position in page coordinate space\r\n  onPointer(evt:MouseEvent|PointerEvent) {\r\n    this.lastPointer = {\r\n      x: evt.pageX,\r\n      y: evt.pageY\r\n    };\r\n    evt.preventDefault();\r\n  }\r\n\r\n  // getMinMax(data, start = 0, end = data.length) {\r\n  //   if (end > data.length) throw new Error(`end is past size of array`);\r\n  //   if (start < 0) throw new Error(`start should be at least 0`);\r\n  //   if (end <= start) throw new Error(`end should be greater than start`);\r\n\r\n  //   let max = Number.MIN_SAFE_INTEGER;\r\n  //   let min = Number.MAX_SAFE_INTEGER;\r\n  //   for (let i = start; i < end; i++) {\r\n  //     max = Math.max(data[i], max);\r\n  //     min = Math.min(data[i], min);\r\n  //   }\r\n  //   if (!Number.isFinite(max)) max = 0;\r\n  //   if (!Number.isFinite(min)) min = 0;\r\n\r\n  //   return {max: max, min: min};\r\n  // }\r\n}","/**\r\n * Keeps track of the min, max and avg in a stream of values without actually storing them.\r\n * \r\n * Usage:\r\n * \r\n * ```js\r\n *  const t = tracker(); \r\n *  t.seen(10);\r\n * \r\n *  t.avg / t.min/ t.max / t.getMinMax()\r\n * ```\r\n * \r\n * Use `reset()` to clear everything, or `resetAvg()` to only reset averaging calculation\r\n * @class Tracker\r\n */\r\nexport class Tracker {\r\n  samples = 0;\r\n  total = 0;\r\n  min = 0;\r\n  max = 0;\r\n  id: string | undefined;\r\n\r\n  constructor(id: string | undefined = undefined) {\r\n    this.id = id;\r\n  }\r\n\r\n  get avg() { return this.total / this.samples; }\r\n\r\n  resetAvg(newId: string | null = null) {\r\n    if (newId !== null) this.id = newId;\r\n    this.total = 0;\r\n    this.samples = 0;\r\n  }\r\n\r\n  reset(newId: string | null = null) {\r\n    this.min = Number.MAX_SAFE_INTEGER;\r\n    this.max = Number.MIN_SAFE_INTEGER;\r\n    this.resetAvg(newId);\r\n  }\r\n\r\n  seen(sample: number) {\r\n    if (Number.isNaN(sample)) throw Error(`Cannot add NaN`);\r\n    this.samples++;\r\n    this.total += sample;\r\n    this.min = Math.min(sample, this.min);\r\n    this.max = Math.max(sample, this.max);\r\n  }\r\n\r\n  getMinMaxAvg() {\r\n    return {\r\n      min: this.min,\r\n      max: this.max,\r\n      avg: this.avg,\r\n    };\r\n  }\r\n}\r\n\r\nexport const tracker = (id?:string) => new Tracker(id);\r\n\r\n/**\r\n * A `Tracker` that tracks interval between calls to `mark()`\r\n *\r\n * @export\r\n * @class IntervalTracker\r\n * @extends {Tracker}\r\n */\r\nexport class IntervalTracker extends Tracker {\r\n  lastMark = 0;\r\n  perf;\r\n  constructor(id: string | undefined = undefined) {\r\n    super(id);\r\n    if (typeof performance === `undefined`) {\r\n      //eslint-disable-next-line functional/no-try-statement\r\n      try {\r\n        //eslint-disable-next-line @typescript-eslint/no-var-requires\r\n        const p = require(`perf_hooks`);\r\n        this.perf = p.performance.now;\r\n      } catch (err) {\r\n        // no-op\r\n      }\r\n    } else {\r\n      this.perf = window.performance.now;\r\n    }\r\n  }\r\n\r\n  mark() {\r\n    if (this.lastMark > 0) {\r\n      this.seen(this.perf() - this.lastMark);\r\n    }\r\n    this.lastMark = this.perf();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\r\n * records the interval between each call to `mark`.\r\n * \r\n * ```js\r\n * const t = intervalTracker();\r\n * \r\n * // Call `mark` to record an interval\r\n * t.mark();\r\n * ...\r\n * t.mark();\r\n * \r\n * // Get average time in milliseconds between calls to `mark`\r\n * t.avg;\r\n * \r\n * // Longest and shortest times are available too...\r\n * t.min; t.max\r\n * ```\r\n * @param id Optional id of instance\r\n * @returns New interval tracker\r\n */\r\nexport const intervalTracker = (id?:string) => new IntervalTracker(id);"],"mappings":"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","names":[]}