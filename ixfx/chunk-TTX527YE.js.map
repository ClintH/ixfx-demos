{"version":3,"sources":["../src/modulation/PingPong.ts","../src/modulation/Jitter.ts"],"sourcesContent":["import { throwNumberTest } from '../util/GuardNumbers.js';\n\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (\n  interval = 0.1,\n  lower?: number,\n  upper?: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) lower = 0;\n  if (upper === undefined) upper = 1;\n  if (start === undefined) start = lower;\n\n  throwNumberTest(interval, `bipolar`, `interval`);\n  throwNumberTest(upper, `bipolar`, `end`);\n  throwNumberTest(start, `bipolar`, `offset`);\n  throwNumberTest(lower, `bipolar`, `start`);\n  return pingPong(interval, lower, upper, start, rounding);\n};\n\n/**\n * Ping-pongs continually back and forth a `lower` and `upper` value (both inclusive) by a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (\n  interval: number,\n  lower: number,\n  upper: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\n  if (interval === undefined) {\n    throw new Error(`Parameter 'interval' is undefined`);\n  }\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\n\n  if (rounding === undefined && interval <= 1 && interval >= 0) {\n    rounding = 10 / interval;\n  } else if (rounding === undefined) rounding = 1234;\n\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\n\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\n  const distance = upper - lower;\n  if (Math.abs(interval) >= distance) {\n    throw new Error(`Interval should be between -${ distance } and ${ distance }`);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let incrementing = interval > 0;\n\n  // Scale up values by rounding factor\n  upper = Math.floor(upper * rounding);\n  lower = Math.floor(lower * rounding);\n  interval = Math.floor(Math.abs(interval * rounding));\n\n  if (interval === 0) {\n    throw new Error(`Interval is zero (rounding: ${ rounding })`);\n  }\n  start = start === undefined ? lower : Math.floor(start * rounding);\n  if (start > upper || start < lower) {\n    throw new Error(\n      `Start (${ start / rounding }) must be within lower (${ lower / rounding\n      }) and upper (${ upper / rounding })`\n    );\n  }\n\n  let v = start;\n  yield v / rounding;\n  let firstLoop = true;\n  while (true) {\n    v = v + (incrementing ? interval : -interval);\n    if (incrementing && v >= upper) {\n      incrementing = false;\n      v = upper;\n      if (v === upper && firstLoop) {\n        // Edge case where we start at upper bound and increment\n        v = lower;\n        incrementing = true;\n      }\n    } else if (!incrementing && v <= lower) {\n      incrementing = true;\n      v = lower;\n      if (v === lower && firstLoop) {\n        // Edge case where we start at lower bound and decrement\n        v = upper;\n        incrementing = false;\n      }\n    }\n    yield v / rounding;\n    firstLoop = false;\n  }\n};\n","import {\n  float as randomFloat\n} from '../random/index.js';\nimport { floatSource as randomFloatFunction } from '../random/FloatSource.js';\nimport { clamp } from '../data/Clamp.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { defaultRandom, type RandomSource } from '../random/Types.js';\n\nexport type JitterOpts = {\n  readonly relative?: number;\n  readonly absolute?: number;\n  readonly clamped?: boolean;\n  readonly source?: RandomSource;\n};\n\nexport type Jitterer = (value: number) => number;\n\n/**\n * Returns a {@link Jitterer} that works with absolute values,\n * ie. values outside of 0..1 range.\n * \n * Jitter amount is _absolute_, meaning a fixed value regardless of input value,\n * or _relative_, meaning it is scaled according to input value.\n * \n * ```js\n * // Jitter by -10 to +10 (absolute value: 10)\n * const j1 = jitterAbsolute({ absolute: 10 });\n * j1(100); // Produces range of 90...110\n * \n * // Jitter by -20 to +20 (relative value 20%)\n * const j2 = jitterAbsolute({ relative: 0.20 });\n * j2(100); // Produces a range of -80...120\n * ```\n * \n * The expected used case is calling `jitterAbsolute` to set up a jitterer\n * and then reusing it with different input values, as above with the `j1` and `j2`.\n * \n * However to use it 'one-off', just call the returned function immediately:\n * ```js\n * const v = jitterAbsolute({ absolute: 10 })(100); // v is in range of 90-110\n * ```\n * \n * When `clamped` is true, return value is clamped to 0...value.\n * That is, rather than the usual bipolar jittering, the jittering only goes below.\n * ```js\n * const j = jitterAbsolute({ absolute: 10, clamped: true })\n * j(100); // Produces range of 90-100\n * ```\n * @param options\n * @returns \n */\nexport const jitterAbsolute = (options: JitterOpts): Jitterer => {\n  const { relative, absolute } = options;\n  const clamped = options.clamped ?? false;\n  const source = options.source ?? defaultRandom;\n  if (absolute !== undefined) {\n    return (value: number) => {\n      const abs = (source() * absolute * 2) - absolute;\n      const valueNew = value + abs;\n      if (clamped) return clamp(valueNew, 0, value);\n      return valueNew;\n    }\n  }\n  if (relative !== undefined) {\n    return (value: number) => {\n      const rel = value * relative;\n      const abs = (source() * rel * 2) - rel;\n      const valueNew = value + abs;\n      if (clamped) return clamp(valueNew, 0, value);\n      return valueNew;\n    }\n  }\n  throw new Error(`Either absolute or relative fields expected`);\n}\n\n/**\n * Jitters `value` by the absolute `jitter` amount. Returns a function.\n *\n * All values should be on a 0..1 scale, and the return value is by default clamped to 0..1.\n * Pass `clamped:false` as an option to allow for arbitary ranges.\n *\n * `jitter` returns a function that calculates jitter. If you only need a one-off\n * jitter, you can immediately execute the returned function:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Compute 10% jitter of input 0.5\n * const value = jitter({ relative: 0.1 })(0.5);\n * ```\n *\n * However, if the returned jitter function is to be used again,\n * assign it to a variable:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * const myJitter = jitter({ absolute: 0.5 });\n *\n * // Jitter an input value 1.0\n * const value = myJitter(1);\n * ```\n *\n * A custom source for random numbers can be provided. Eg, use a weighted\n * random number generator:\n *\n * ```js\n * import { weighted } from 'https://unpkg.com/ixfx/dist/random.js';\n * jitter({ relative: 0.1, source: weighted });\n * ```\n *\n * Options\n * * clamped: If false, `value`s out of percentage range can be used and return value may be beyond percentage range. True by default\n * * random: Random source (default is Math.random)\n * @param options Options\n * @returns Function that performs jitter\n */\nexport const jitter = (options: JitterOpts = {}): Jitterer => {\n  const clamped = options.clamped ?? true;\n  let r = (_: number) => 0;\n  if (options.absolute !== undefined) {\n    throwNumberTest(\n      options.absolute,\n      clamped ? `percentage` : `bipolar`,\n      `opts.absolute`\n    );\n    const absRand = randomFloatFunction({\n      min: -options.absolute,\n      max: options.absolute,\n      source: options.source,\n    });\n    r = (v: number) => v + absRand();\n  } else if (options.relative === undefined) {\n    throw new TypeError(`Either absolute or relative jitter amount is required.`);\n  } else {\n    const rel = options.relative ?? 0.1;\n    throwNumberTest(\n      rel,\n      clamped ? `percentage` : `bipolar`,\n      `opts.relative`\n    );\n    r = (v: number) =>\n      v +\n      randomFloat({\n        min: -Math.abs(rel * v),\n        max: Math.abs(rel * v),\n        source: options.source,\n      });\n  }\n\n  const compute = (value: number) => {\n    throwNumberTest(value, clamped ? `percentage` : `bipolar`, `value`);\n    //eslint-disable-next-line functional/no-let\n    let v = r(value);\n    if (clamped) v = clamp(v);\n    return v;\n  };\n  return compute;\n};\n"],"mappings":"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","names":[]}