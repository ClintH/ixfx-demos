{"version":3,"sources":["../src/io/index.ts","../src/io/NordicBleDevice.ts","../src/io/Codec.ts","../src/io/StringReceiveBuffer.ts","../src/io/StringWriteBuffer.ts","../src/io/BleDevice.ts","../src/io/AudioAnalyser.ts","../src/io/AudioVisualiser.ts","../src/io/Espruino.ts","../src/io/EspruinoBleDevice.ts","../src/io/Serial.ts","../src/io/JsonDevice.ts","../src/io/EspruinoSerialDevice.ts","../src/io/Camera.ts","../src/io/VideoFile.ts","../src/visual/Video.ts","../src/io/FrameProcessor.ts","../src/io/ReconnectingWebSocket.ts"],"sourcesContent":["import { type StateChangeEvent } from '../flow/StateMachineWithEvents.js';\nimport { type Transitions } from '../flow/StateMachine.js';\n\n\n/**\n * Generic support for Bluetooth LE devices\n */\nexport * as Bluetooth from './NordicBleDevice.js';\n\nexport * as AudioAnalysers from './AudioAnalyser.js';\nexport * as AudioVisualisers from './AudioVisualiser.js';\n\nexport { StringReceiveBuffer } from './StringReceiveBuffer.js';\nexport {\n  StringWriteBuffer,\n  type Opts as StringWriteBufferOpts,\n} from './StringWriteBuffer.js';\nexport { Codec } from './Codec.js';\n\n/**\n * Espruino-based devices connected via Bluetooth LE\n *\n * See [demos](https://clinth.github.io/ixfx-demos/io/)\n *\n * Overview:\n * * {@link puck}: Connects a [Espruino BLE Device](../classes/Io.Espruino.EspruinoBleDevice.html).\n * * {@link Espruino.connectBle}: Connect to a generic Espruino via BLE\n */\nexport * as Espruino from './Espruino.js';\n\nexport * as Camera from './Camera.js';\n\nexport * as VideoFile from './VideoFile.js';\n\nexport { FrameProcessor } from './FrameProcessor.js';\nexport type { FrameProcessorOpts } from './FrameProcessor.js';\n\n/**\n * Microcontrollers such as Arduinos connected via USB serial\n *\n * Overview\n * * {@link Serial.Device}\n *\n */\nexport * as Serial from './Serial.js';\nexport * from './ReconnectingWebSocket.js';\n\nexport type IoDataEvent = {\n  readonly data: string;\n};\n\nexport type IoEvents<StateMachineTransitions extends Transitions> = {\n  readonly data: IoDataEvent;\n  readonly change: StateChangeEvent<StateMachineTransitions>;\n};\n\nexport const genericStateTransitionsInstance = Object.freeze({\n  ready: `connecting`,\n  connecting: [ `connected`, `closed` ],\n  connected: [ `closed` ],\n  closed: `connecting`,\n});\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport type GenericStateTransitions = Readonly<\n  typeof genericStateTransitionsInstance\n>;\n\nexport { type StateChangeEvent } from '../flow/StateMachineWithEvents.js';","import { BleDevice } from './BleDevice.js';\n\nexport const defaultOpts = {\n  chunkSize: 20,\n  service: `6e400001-b5a3-f393-e0a9-e50e24dcca9e`,\n  txGattCharacteristic: `6e400002-b5a3-f393-e0a9-e50e24dcca9e`,\n  rxGattCharacteristic: `6e400003-b5a3-f393-e0a9-e50e24dcca9e`,\n  name: `NordicDevice`,\n  connectAttempts: 5,\n  debug: false,\n};\n\nexport type Opts = {\n  readonly chunkSize?: number;\n  readonly name?: string;\n  readonly connectAttempts?: number;\n  readonly debug?: boolean;\n};\n\nexport class NordicBleDevice extends BleDevice {\n  constructor(device: BluetoothDevice, opts: Opts = {}) {\n    super(device, { ...defaultOpts, ...opts });\n  }\n}\n","/**\n * Handles utf-8 text encoding/decoding\n */\nexport class Codec {\n  enc = new TextEncoder();\n  dec = new TextDecoder(`utf-8`);\n\n  /**\n   * Convert string to Uint8Array buffer\n   * @param str\n   * @returns\n   */\n  toBuffer(str: string) {\n    return this.enc.encode(str);\n  }\n\n  /**\n   * Returns a string from a provided buffer\n   * @param buffer\n   * @returns\n   */\n  fromBuffer(buffer: ArrayBuffer) {\n    return this.dec.decode(buffer);\n  }\n}\n","/**\n * Receives text\n */\nexport class StringReceiveBuffer {\n  buffer: string = ``;\n  stream: WritableStream<string> | undefined;\n\n  constructor(\n    private onData: (data: string) => void,\n    public separator = `\\n`\n  ) {}\n\n  async close() {\n    const s = this.stream;\n    if (!s) return;\n    await s.abort();\n\n    await s.close();\n  }\n\n  clear() {\n    this.buffer = ``;\n  }\n\n  writable() {\n    if (this.stream === undefined) this.stream = this.createWritable();\n    return this.stream;\n  }\n\n  private createWritable() {\n    //eslint-disable-next-line @typescript-eslint/no-this-alias\n    const b = this;\n    return new WritableStream<string>({\n      write(chunk) {\n        b.add(chunk);\n      },\n      close() {\n        b.clear();\n      },\n    });\n  }\n\n  addImpl(str: string): string {\n    // Look for separator in new string\n    const pos = str.indexOf(this.separator);\n    if (pos < 0) {\n      // Not found, just add to buffer and return\n      this.buffer += str;\n      return ``;\n    }\n\n    // Found! Trigger callback for existing buffer and part of new string\n    const part = str.substring(0, pos);\n    try {\n      this.onData(this.buffer + part);\n      str = str.substring(part.length + this.separator.length);\n    } catch (ex) {\n      console.warn(ex);\n    }\n\n    this.buffer = ``;\n\n    return str;\n  }\n\n  add(str: string) {\n    while (str.length > 0) {\n      str = this.addImpl(str);\n    }\n  }\n}\n","import type { Interval } from '../flow/IntervalType.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport {\n  type Continuously,\n  continuously\n} from '../flow/index.js';\nimport { splitByLength } from '../Text.js';\n\nexport type Opts = {\n  readonly chunkSize?: number;\n  readonly interval?: Interval;\n};\n\n/**\n * Buffers a queue of strings.\n *\n * When text is queued via {@link add}, it is chopped up\n * into chunks and sent in serial to the `dataHandler` function.\n * Data is processed at a set rate, by default 10ms.\n *\n * ```js\n * const dataHandler = (data:string) => {\n *  // Do something with queued data.\n *  // eg. send to serial port\n * }\n *\n * // Create a buffer with a chunk size of 100 characters\n * const b = new StringWriteBuffer(dataHandler, { chunkSize: 100 });\n * b.add('some text'); // Write to buffer\n * // dataHandler will be called until queued data is empty\n * ```\n *\n * It's also possible to get the buffer as a WritableStream<string>:\n * ```js\n * const dataHandler = (data:string) => { ... }\n * const b = new StringWriteBuffer(dataHandler, 100);\n * const s = b.writable();\n * ```\n *\n * Other functions:\n * ```js\n * b.close(); // Close buffer\n * b.clear(); // Clear queued data, but don't close anything\n * ```\n */\nexport class StringWriteBuffer {\n  paused = false;\n  queue = new QueueMutable<string>();\n  writer: Continuously;\n  stream: WritableStream<string> | undefined;\n  closed = false;\n  chunkSize: number;\n\n  /**\n   * Constructor\n   * @param dataHandler Calback to 'send' data onwards\n   * @param opts Options\n   */\n  constructor(\n    private dataHandler: (data: string) => Promise<void>,\n    opts: Opts = {}\n  ) {\n    this.chunkSize = opts.chunkSize ?? -1;\n    this.writer = continuously(async () => {\n      await this.onWrite()\n    }, opts.interval ?? 10);\n  }\n\n  /**\n   * Close writer (async)\n   */\n  async close() {\n    if (this.closed) return;\n    const w = this.stream?.getWriter();\n    w?.releaseLock();\n    await w?.close();\n    this.closed = true;\n  }\n\n  /**\n   * Clear queued data.\n   *\n   * Throws an error if {@link close} has been called.\n   */\n  clear() {\n    if (this.closed) throw new Error(`Buffer closed`);\n    this.queue = new QueueMutable<string>();\n  }\n\n  /**\n   * Gets the buffer as a writable stream.\n   *\n   * Do not close stream directly, use .close on this class instead.\n   *\n   * Throws an error if .close() has been called.\n   * @returns Underlying stream\n   */\n  writable() {\n    if (this.closed) throw new Error(`Buffer closed`);\n    if (this.stream === undefined) this.stream = this.createWritable();\n    return this.stream;\n  }\n\n  private createWritable() {\n    // eslint-disable-next-line unicorn/no-this-assignment,@typescript-eslint/no-this-alias\n    const b = this;\n    return new WritableStream<string>({\n      write(chunk) {\n        b.add(chunk);\n      },\n      close() {\n        b.clear();\n      },\n    });\n  }\n\n  /**\n   * Run in a `continunously` loop to process queued data\n   * @returns _False_ if queue is empty and loop should stop. _True_ if it shoud continue.\n   */\n  async onWrite(): Promise<boolean> {\n    if (this.queue.isEmpty) {\n      //console.warn(`WriteBuffer.onWrite: queue empty`);\n      return false; // Stop continuously\n    }\n\n    if (this.paused) {\n      console.warn(`WriteBuffer.onWrite: paused...`);\n      return true; // Keep going tho\n    }\n\n    // Dequeue and send\n    const s = this.queue.dequeue();\n    if (s === undefined) return false;\n    await this.dataHandler(s);\n\n    return true;\n  }\n\n  /**\n   * Returns _true_ if {@link close} has been called.\n   */\n  get isClosed() {\n    return this.closed;\n  }\n\n  /**\n   * Adds some queued data to send.\n   * Longer strings are automatically chunked up according to the buffer's settings.\n   *\n   * Throws an error if {@link close} has been called.\n   * @param stringToQueue\n   */\n  add(stringToQueue: string) {\n    if (this.closed) throw new Error(`Buffer closed`);\n    // Add whole string or chunked string\n    if (this.chunkSize > 0) {\n      this.queue.enqueue(...splitByLength(stringToQueue, this.chunkSize));\n    } else {\n      this.queue.enqueue(stringToQueue);\n    }\n\n    // Run continuously loop if it's not already running\n    this.writer.start();\n  }\n}\n","/* eslint-disable @typescript-eslint/no-useless-template-literals */\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as StateMachine from '../flow/StateMachine.js';\n\nimport { indexOfCharCode, omitChars } from '../Text.js';\nimport { Codec } from './Codec.js';\nimport { StringReceiveBuffer } from './StringReceiveBuffer.js';\nimport { StringWriteBuffer } from './StringWriteBuffer.js';\nimport { retryFunction } from '../flow/Retry.js';\nimport {\n  genericStateTransitionsInstance,\n  type GenericStateTransitions,\n  type IoEvents,\n} from './index.js';\n\nexport type Opts = {\n  readonly service: string;\n  readonly rxGattCharacteristic: string;\n  readonly txGattCharacteristic: string;\n  readonly chunkSize: number;\n  readonly name: string;\n  readonly connectAttempts: number;\n  readonly debug: boolean;\n};\n\nconst reconnect = async () => {\n  console.log(`Connect?`);\n  if (!(`bluetooth` in navigator)) return false;\n  if (!(`getDevices` in navigator.bluetooth)) return false;\n\n  const devices = await navigator.bluetooth.getDevices();\n  console.log(devices);\n\n  for (const device of devices) {\n    console.log(device);\n    // Start a scan for each device before connecting to check that they're in\n    // range.\n    const abortController = new AbortController();\n    await device.watchAdvertisements({ signal: abortController.signal });\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    device.addEventListener(`advertisementreceived`, async (event) => {\n      console.log(event);\n      // Stop the scan to conserve power on mobile devices.\n      abortController.abort();\n\n      // At this point, we know that the device is in range, and we can attempt\n      // to connect to it.\n      await event.device.gatt?.connect();\n      console.log(`Connected!`);\n    });\n  }\n};\n\nexport class BleDevice extends SimpleEventEmitter<\n  IoEvents<GenericStateTransitions>\n> {\n  states: StateMachine.WithEvents<GenericStateTransitions>;\n  codec: Codec;\n  rx: BluetoothRemoteGATTCharacteristic | undefined;\n  tx: BluetoothRemoteGATTCharacteristic | undefined;\n  gatt: BluetoothRemoteGATTServer | undefined;\n  verboseLogging = false;\n\n  rxBuffer: StringReceiveBuffer;\n  txBuffer: StringWriteBuffer;\n\n  constructor(\n    private device: BluetoothDevice,\n    private config: Opts\n  ) {\n    super();\n    this.verboseLogging = config.debug;\n    this.txBuffer = new StringWriteBuffer(async (data) => {\n      await this.writeInternal(data);\n    }, config);\n\n    this.rxBuffer = new StringReceiveBuffer((line) => {\n      this.fireEvent(`data`, { data: line });\n    });\n\n    this.codec = new Codec();\n    this.states = new StateMachine.WithEvents<GenericStateTransitions>(\n      genericStateTransitionsInstance,\n      {\n        initial: `ready`,\n      }\n    );\n    this.states.addEventListener(`change`, (event) => {\n      this.fireEvent(`change`, event);\n      this.verbose(`${ event.priorState } -> ${ event.newState }`);\n\n      if (event.priorState === `connected`) {\n        // Clear out buffers\n        this.rxBuffer.clear();\n        this.txBuffer.clear();\n      }\n    });\n\n    device.addEventListener(`gattserverdisconnected`, () => {\n      if (this.isClosed) return;\n      this.verbose(`GATT server disconnected`);\n      this.states.state = `closed`;\n    });\n\n    this.verbose(`ctor ${ device.name } ${ device.id }`);\n  }\n\n  get isConnected(): boolean {\n    return this.states.state === `connected`;\n  }\n\n  get isClosed(): boolean {\n    return this.states.state === `closed`;\n  }\n\n  write(txt: string) {\n    if (this.states.state !== `connected`) {\n      throw new Error(`Cannot write while state is ${ this.states.state }`);\n    }\n    this.txBuffer.add(txt);\n  }\n\n  private async writeInternal(txt: string) {\n    this.verbose(`writeInternal ${ txt }`);\n    const tx = this.tx;\n    if (tx === undefined) {\n      throw new Error(`Unexpectedly without tx characteristic`);\n    }\n    try {\n      await tx.writeValue(this.codec.toBuffer(txt));\n    } catch (error: unknown) {\n      this.warn(error);\n    }\n  }\n\n  disconnect() {\n    if (this.states.state !== `connected`) return;\n    this.gatt?.disconnect();\n  }\n\n  async connect() {\n    const attempts = this.config.connectAttempts ?? 3;\n\n    this.states.state = `connecting`;\n\n    this.verbose(`connect`);\n    const gatt = this.device.gatt;\n    if (gatt === undefined) throw new Error(`Gatt not available on device`);\n\n    await retryFunction(\n      async () => {\n        this.verbose(`connect.retry`);\n        const server = await gatt.connect();\n        this.verbose(`Getting primary service`);\n        const service = await server.getPrimaryService(this.config.service);\n        this.verbose(`Getting characteristics`);\n        const rx = await service.getCharacteristic(\n          this.config.rxGattCharacteristic\n        );\n        const tx = await service.getCharacteristic(\n          this.config.txGattCharacteristic\n        );\n\n        rx.addEventListener(`characteristicvaluechanged`, (event) => { this.onRx(event); }\n        );\n        this.rx = rx;\n        this.tx = tx;\n        this.gatt = gatt;\n        this.states.state = `connected`;\n\n        await rx.startNotifications();\n        return true;\n      },\n      {\n        limitAttempts: attempts,\n        startAt: 200,\n      }\n    );\n  }\n\n  private onRx(event: Event) {\n    const rx = this.rx;\n    if (rx === undefined) return;\n\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const view = (event.target as any).value as DataView;\n    if (view === undefined) return;\n\n    //eslint-disable-next-line functional/no-let\n    let string_ = this.codec.fromBuffer(view.buffer);\n\n    // Check for flow control chars\n    const plzStop = indexOfCharCode(string_, 19);\n    const plzStart = indexOfCharCode(string_, 17);\n\n    // Remove if found\n    if (plzStart && plzStop < plzStart) {\n      this.verbose(`Tx plz start`);\n      string_ = omitChars(string_, plzStart, 1);\n      this.txBuffer.paused = false;\n    }\n    if (plzStop && plzStop > plzStart) {\n      this.verbose(`Tx plz stop`);\n      string_ = omitChars(string_, plzStop, 1);\n      this.txBuffer.paused = true;\n    }\n\n    this.rxBuffer.add(string_);\n  }\n\n  protected verbose(m: string) {\n    if (this.verboseLogging) console.info(`${ this.config.name }`, m);\n  }\n\n  protected log(m: string) {\n    console.log(`${ this.config.name }`, m);\n  }\n\n  protected warn(m: unknown) {\n    console.warn(`${ this.config.name }`, m);\n  }\n}\n","import { Arrays } from '../collections/index.js';\nimport AudioVisualiser from './AudioVisualiser.js';\nimport { throwNumberTest, throwIntegerTest } from '../Guards.js';\nimport { isPowerOfTwo } from '../Util.js';\n\n/**\n * Options for audio processing\n *\n * fftSize: Must be a power of 2, from 32 - 32768. Higher number means\n * more precision and higher CPU overhead\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\n *\n * smoothingTimeConstant: Range from 0-1, default is 0.8.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\n *\n * debug: If true, additonal console logging will happen\n */\nexport type Opts = {\n  readonly showVis?: boolean;\n  /**\n   * FFT size. Must be a power of 2, from 32 - 32768. Higher number means\n   * more precision and higher CPU overhead\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\n   */\n  readonly fftSize?: number;\n  /**\n   * Range from 0-1, default is 0.8\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\n   */\n  readonly smoothingTimeConstant?: number;\n  readonly debug?: boolean;\n};\n\nexport type DataAnalyser = (\n  node: AnalyserNode,\n  analyser: AudioAnalyser\n) => void;\n\n/**\n * Basic audio analyser. Returns back waveform and FFT analysis. Use {@link peakLevel} if you want sound level, or {@link freq} if you just want FFT results.\n *\n * ```js\n * const onData = (freq, wave, analyser) => {\n *  // Demo: Get FFT results just for 100Hz-1KHz.\n *  const freqSlice = analyser.sliceByFrequency(100,1000,freq);\n *\n *  // Demo: Get FFT value for a particular frequency (1KHz)\n *  const amt = freq[analyser.getIndexForFrequency(1000)];\n * }\n * basic(onData, {fftSize: 512});\n * ```\n *\n * An `Analyser` instance is returned and can be controlled:\n * ```js\n * const analyser = basic(onData);\n * analyser.paused = true;\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n * @param onData Handler for data\n * @param opts Options\n * @returns Analyser instance\n */\nexport const basic = (\n  onData: (\n    freq: Float32Array,\n    wave: Float32Array,\n    analyser: AudioAnalyser\n  ) => void,\n  opts: Opts = {}\n): AudioAnalyser =>\n  new AudioAnalyser((node, analyser) => {\n    // Get frequency and amplitude data\n    const freq = new Float32Array(node.frequencyBinCount);\n    const wave = new Float32Array(node.fftSize);\n\n    // Load arrays with data\n    node.getFloatFrequencyData(freq);\n    node.getFloatTimeDomainData(wave);\n\n    // Send back\n    onData(freq, wave, analyser);\n  }, opts);\n\n/**\n * Basic audio analyser. Returns FFT analysis. Use {@link peakLevel} if you want the sound level, or {@link basic} if you also want the waveform.\n *\n * ```js\n * const onData = (freq, analyser) => {\n *  // Demo: Print out each sound frequency (Hz) and amount of energy in that band\n *  for (let i=0;i<freq.length;i++) {\n *    const f = analyser.getFrequencyAtIndex(0);\n *    console.log(`${i}. frequency: ${f} amount: ${freq[i]}`);\n *  }\n * }\n * freq(onData, {fftSize:512});\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n * @param onData\n * @param opts\n * @returns\n */\nexport const freq = (\n  onData: (freq: Float32Array, analyser: AudioAnalyser) => void,\n  opts: Opts = {}\n): AudioAnalyser =>\n  new AudioAnalyser((node, analyser) => {\n    const freq = new Float32Array(node.frequencyBinCount);\n    node.getFloatFrequencyData(freq);\n    onData(freq, analyser);\n  }, opts);\n\n/**\n * Basic audio analyser which reports the peak sound level.\n *\n * ```js\n * peakLevel(level => {\n *  console.log(level);\n * });\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n * @param onData\n * @param opts\n * @returns\n */\nexport const peakLevel = (\n  onData: (level: number, analyser: AudioAnalyser) => void,\n  opts: Opts = {}\n): AudioAnalyser =>\n  new AudioAnalyser((node, analyser) => {\n    const wave = new Float32Array(node.fftSize);\n    node.getFloatTimeDomainData(wave);\n    onData(Arrays.maxFast(wave), analyser);\n  }, opts);\n\n/**\n * Helper for doing audio analysis. It takes case of connecting the audio stream, running in a loop and pause capability.\n *\n * Provide a function which works with an [AnalyserNode](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode), and does something with the result.\n * ```js\n * const myAnalysis = (node, analyser) => {\n *  const freq = new Float32Array(node.frequencyBinCount);\n *  node.getFloatFrequencyData(freq);\n *  // Do something with frequency data...\n * }\n * const a = new Analyser(myAnalysis);\n * ```\n *\n * Two helper functions provide ready-to-use Analysers:\n * * {@link peakLevel} peak decibel reading\n * * {@link freq} FFT results\n * * {@link basic} FFT results and waveform\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n */\nexport class AudioAnalyser {\n  showVis: boolean;\n  fftSize: number;\n  smoothingTimeConstant: number;\n  #isPaused = false;\n  debug: boolean;\n  #initInProgress = false;\n\n  visualiser: AudioVisualiser | undefined;\n  audioCtx: AudioContext | undefined;\n  analyserNode: AnalyserNode | undefined;\n\n  analyse: DataAnalyser;\n\n  constructor(analyse: DataAnalyser, opts: Opts = {}) {\n    this.showVis = opts.showVis ?? false;\n    this.fftSize = opts.fftSize ?? 1024;\n    this.debug = opts.debug ?? false;\n    this.smoothingTimeConstant = opts.smoothingTimeConstant ?? 0.8;\n\n    throwIntegerTest(this.fftSize, `positive`, `opts.fftSize`);\n    throwNumberTest(\n      this.smoothingTimeConstant,\n      `percentage`,\n      `opts.smoothingTimeConstant`\n    );\n\n    if (!isPowerOfTwo(this.fftSize)) {\n      throw new Error(\n        `fftSize must be a power of two from 32 to 32768 (${ this.fftSize })`\n      );\n    }\n    if (this.fftSize < 32) throw new Error(`fftSize must be at least 32`);\n    if (this.fftSize > 32768) { throw new Error(`fftSize must be no greater than 32768`); }\n\n    this.analyse = analyse;\n    this.paused = false;\n\n    this.init();\n\n    const visualiserEl = document.getElementById(`audio-visualiser`);\n    if (visualiserEl) {\n      const visualiser = new AudioVisualiser(visualiserEl, this);\n      visualiser.setExpanded(this.showVis);\n      this.visualiser = visualiser;\n    }\n  }\n\n  init() {\n    if (this.#initInProgress) {\n      if (this.debug) console.debug(`Init already in progress`);\n      return;\n    }\n    this.#initInProgress = true;\n\n    // Initalise microphone\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then((stream) => {\n        this.onMicSuccess(stream);\n      })\n      .catch((err) => {\n        this.#initInProgress = false;\n        console.error(err);\n      });\n  }\n\n  get paused(): boolean {\n    return this.#isPaused;\n  }\n\n  set paused(v: boolean) {\n    if (v === this.#isPaused) return;\n    this.#isPaused = v;\n    if (!v) {\n      if (this.debug) console.log(`Unpaused`);\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\n    } else {\n      if (this.debug) console.log(`Paused`);\n    }\n  }\n\n  private setup(audioCtx: AudioContext, stream: MediaStream) {\n    const analyser = audioCtx.createAnalyser();\n\n    // fftSize must be a power of 2. Higher values slower, more detailed\n    // Range is 32-32768\n    analyser.fftSize = this.fftSize;\n\n    // smoothingTimeConstant ranges from 0.0 to 1.0\n    // 0 = no averaging. Fast response, jittery\n    // 1 = maximum averaging. Slow response, smooth\n    analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n\n    // Microphone -> analyser\n    const micSource = audioCtx.createMediaStreamSource(stream);\n    micSource.connect(analyser);\n    return analyser;\n  }\n\n  // Microphone successfully initalised, now have access to audio data\n  private onMicSuccess(stream: MediaStream) {\n    try {\n      const audioCtx = new AudioContext();\n\n      audioCtx.addEventListener(`statechange`, () => {\n        if (this.debug) console.log(`Audio context state: ${ audioCtx.state }`);\n      });\n\n      this.audioCtx = audioCtx;\n      this.analyserNode = this.setup(audioCtx, stream);\n\n      // Start loop\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\n    } catch (ex) {\n      this.#initInProgress = false;\n      console.error(ex);\n    }\n  }\n\n  private analyseLoop() {\n    if (this.paused) {\n      if (this.debug) console.log(`Paused`);\n      return;\n    }\n\n    const a = this.analyserNode;\n    if (a === undefined) {\n      console.warn(`Analyser undefined`);\n      return;\n    }\n\n    try {\n      // Perform analysis\n      this.analyse(a, this);\n    } catch (e) {\n      console.error(e);\n    }\n\n    // Run again\n    window.requestAnimationFrame(this.analyseLoop.bind(this));\n  }\n\n  // visualise(wave, freq) {\n  //   if (!this.visualiser) return;\n  //   this.visualiser.renderWave(wave, true);\n  //   this.visualiser.renderFreq(freq);\n  // }\n\n  /**\n   * Returns the maximum FFT value within the given frequency range\n   */\n  getFrequencyRangeMax(\n    lowFreq: number,\n    highFreq: number,\n    freqData: readonly number[]\n  ): number {\n    const samples = this.sliceByFrequency(lowFreq, highFreq, freqData);\n    return Arrays.max(samples);\n  }\n\n  /**\n   * Returns a sub-sampling of frequency analysis data that falls between\n   * `lowFreq` and `highFreq`.\n   * @param lowFreq Low frequency\n   * @param highFreq High frequency\n   * @param freqData Full-spectrum frequency data\n   * @returns Sub-sampling of analysis\n   */\n  sliceByFrequency(\n    lowFreq: number,\n    highFreq: number,\n    freqData: readonly number[]\n  ) {\n    const lowIndex = this.getIndexForFrequency(lowFreq);\n    const highIndex = this.getIndexForFrequency(highFreq);\n\n    // Grab a 'slice' of the array between these indexes\n    const samples = freqData.slice(lowIndex, highIndex);\n    return samples;\n  }\n\n  /**\n   * Returns the starting frequency for a given binned frequency index.\n   * @param index Array index\n   * @returns Sound frequency\n   */\n  getFrequencyAtIndex(index: number): number {\n    const a = this.analyserNode;\n    const ctx = this.audioCtx;\n    if (a === undefined) throw new Error(`Analyser not available`);\n    if (ctx === undefined) throw new Error(`Audio context not available`);\n\n    throwIntegerTest(index, `positive`, `index`);\n    if (index > a.frequencyBinCount) {\n      throw new Error(\n        `Index ${ index } exceeds frequency bin count ${ a.frequencyBinCount }`\n      );\n    }\n\n    return (index * ctx.sampleRate) / (a.frequencyBinCount * 2);\n  }\n\n  /**\n   * Returns a binned array index for a given frequency\n   * @param freq Sound frequency\n   * @returns Array index into frequency bins\n   */\n  getIndexForFrequency(freq: number): number {\n    const a = this.analyserNode;\n    if (a === undefined) throw new Error(`Analyser not available`);\n\n    const nyquist = a.context.sampleRate / 2.0;\n    const index = Math.round((freq / nyquist) * a.frequencyBinCount);\n    if (index < 0) return 0;\n    if (index >= a.frequencyBinCount) return a.frequencyBinCount - 1;\n    return index;\n  }\n}\n","/**\n * Visualiser component\n *\n * Usage: import visualiser.js. Instantiate on document load, and pass in the\n * parent element into the constructor.\n *\n * eg: const v = new Visualiser(document.getElementById('renderer'));\n *\n * Data must be passed to the component via renderFreq or renderWave.\n *\n * Draws on https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\n */\n\nimport { Arrays } from '../collections/index.js';\nimport { numberTracker } from '../data/NumberTracker.js';\nimport { AudioAnalyser } from './AudioAnalyser.js';\nimport type { Point } from '../geometry/point/index.js';\n\n// TODO: This is an adaption of old code. Needs to be smartened up further\nexport default class AudioVisualiser {\n  freqMaxRange = 200;\n  audio: AudioAnalyser;\n  parent: HTMLElement;\n\n  lastPointer: Point = { x: 0, y: 0 };\n  pointerDown = false;\n  pointerClicking = false;\n  pointerClickDelayMs = 100;\n  pointerDelaying = false;\n\n  waveTracker;\n  freqTracker;\n  el: HTMLElement;\n\n  constructor(parentElem: HTMLElement, audio: AudioAnalyser) {\n    this.audio = audio;\n    this.parent = parentElem;\n    this.waveTracker = numberTracker();\n    this.freqTracker = numberTracker();\n\n    // Add HTML\n    parentElem.innerHTML = `\n    <section>\n      <button id=\"rendererComponentToggle\">🔼</button>\n      <div>\n        <h1>Visualiser</h1>\n        <div style=\"display:flex; flex-wrap: wrap\">\n          <div class=\"visPanel\">\n            <h2>Frequency distribution</h2>\n            <br />\n            <canvas id=\"rendererComponentFreqData\" height=\"200\" width=\"400\"></canvas>\n          </div>\n          <div class=\"visPanel\">\n            <h2>Waveform</h2>\n            <button id=\"rendererComponentWaveReset\">Reset</button>\n            <div>\n              Press and hold on wave to measure\n            </div>\n            <br />\n            <canvas id=\"rendererComponentWaveData\" height=\"200\" width=\"400\"></canvas>\n          </div>\n        </div>\n      </div>\n    </section>\n    `;\n    this.el = parentElem.children[ 0 ] as HTMLElement;\n\n    document\n      .getElementById(`rendererComponentToggle`)\n      ?.addEventListener(`click`, () => {\n        this.setExpanded(!this.isExpanded());\n      });\n    this.el.addEventListener(`pointermove`, (e) => this.onPointer(e));\n    //this.el.addEventListener(`touchbegin`, (e) => this.onPointer(e));\n    this.el.addEventListener(`pointerup`, () => {\n      this.pointerDelaying = false;\n      this.pointerDown = false;\n    });\n    this.el.addEventListener(`pointerdown`, () => {\n      this.pointerDelaying = true;\n      setTimeout(() => {\n        if (this.pointerDelaying) {\n          this.pointerDelaying = false;\n          this.pointerDown = true;\n        }\n      }, this.pointerClickDelayMs);\n    });\n    this.el.addEventListener(`pointerleave`, () => {\n      this.pointerDelaying = false;\n      this.pointerDown = false;\n    });\n\n    document\n      .getElementById(`rendererComponentWaveReset`)\n      ?.addEventListener(`click`, () => {\n        this.clear();\n      });\n  }\n\n  renderFreq(freq: readonly number[]) {\n    if (!this.isExpanded()) return; // Don't render if collapsed\n    if (!freq) return; // Data is undefined/null\n\n    const canvas = document.getElementById(\n      `rendererComponentFreqData`\n    ) as HTMLCanvasElement;\n    if (canvas === null) throw new Error(`Cannot find canvas element`);\n    const g = canvas.getContext(`2d`);\n    if (g === null) throw new Error(`Cannot create drawing context`);\n\n    const bins = freq.length;\n    const canvasWidth = canvas.clientWidth;\n    const canvasHeight = canvas.clientHeight;\n    g.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    const pointer = this.getPointerRelativeTo(canvas);\n    const width = canvasWidth / bins;\n    const minMax = Arrays.minMaxAvg(freq);\n\n    //eslint-disable-next-line functional/no-let\n    for (let i = 0; i < bins; i++) {\n      if (!Number.isFinite(freq[ i ])) continue;\n\n      const value = freq[ i ] - minMax.min;\n      const valueRelative = value / this.freqMaxRange;\n      const height = Math.abs(canvasHeight * valueRelative);\n      const offset = canvasHeight - height;\n\n      const hue = (i / bins) * 360;\n      const left = i * width;\n      g.fillStyle = `hsl(` + hue + `, 100%, 50%)`;\n\n      // Show info about data under pointer\n      if (\n        pointer.y > 0 &&\n        pointer.y <= canvasHeight &&\n        pointer.x >= left &&\n        pointer.x <= left + width\n      ) {\n        // Keep track of data\n        if (this.freqTracker.id !== i.toString()) {\n          this.freqTracker = numberTracker({ id: i.toString() });\n        }\n        this.freqTracker.seen(freq[ i ]);\n\n        const freqMma = this.freqTracker.getMinMaxAvg();\n\n        // Display\n        g.fillStyle = `black`;\n        if (this.audio) {\n          g.fillText(\n            `Frequency (${ i }) at pointer: ${ this.audio\n              .getFrequencyAtIndex(i)\n              .toLocaleString(`en`) } - ${ this.audio\n                .getFrequencyAtIndex(i + 1)\n                .toLocaleString(`en`) }`,\n            2,\n            10\n          );\n        }\n        g.fillText(`Raw value: ${ freq[ i ].toFixed(2) }`, 2, 20);\n        g.fillText(`Min: ${ freqMma.min.toFixed(2) }`, 2, 40);\n        g.fillText(`Max: ${ freqMma.max.toFixed(2) }`, 60, 40);\n        g.fillText(`Avg: ${ freqMma.avg.toFixed(2) }`, 120, 40);\n      }\n      g.fillRect(left, offset, width, height);\n    }\n  }\n\n  isExpanded() {\n    const contentsElem = this.el.querySelector(`div`);\n    if (contentsElem === null) throw new Error(`contents div not found`);\n    return contentsElem.style.display === ``;\n  }\n\n  setExpanded(value: boolean) {\n    const contentsElem = this.el.querySelector(`div`);\n    const button = this.el.querySelector(`button`);\n\n    if (button === null) throw new Error(`Button element not found`);\n    if (contentsElem === null) throw new Error(`Contents element not found`);\n    if (value) {\n      contentsElem.style.display = ``;\n      button.innerText = `🔼`;\n    } else {\n      contentsElem.style.display = `none`;\n      button.innerText = `🔽`;\n    }\n  }\n\n  clear() {\n    this.clearCanvas(\n      document.getElementById(`rendererComponentFreqData`) as HTMLCanvasElement\n    );\n    this.clearCanvas(\n      document.getElementById(`rendererComponentWaveData`) as HTMLCanvasElement\n    );\n  }\n\n  // Clears a canvas to white\n  clearCanvas(canvas: HTMLCanvasElement | null) {\n    if (canvas === null) throw new Error(`Canvas is null`);\n    const g = canvas.getContext(`2d`);\n    if (g === null) throw new Error(`Cannot create drawing context`);\n    g.fillStyle = `white`;\n    g.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n  }\n\n  // Renders waveform data.\n  // Adapted from MDN's AnalyserNode.getFloatTimeDomainData() example\n  renderWave(wave: readonly number[], bipolar = true) {\n    if (!this.isExpanded()) return; // Don't render if collapsed\n    if (!wave) return; // Undefined or null data\n    const canvas = document.getElementById(\n      `rendererComponentWaveData`\n    ) as HTMLCanvasElement;\n    if (canvas === null) throw new Error(`Cannot find wave canvas`);\n\n    const g = canvas.getContext(`2d`);\n    if (g === null) throw new Error(`Cannot create drawing context for wave`);\n\n    const canvasWidth = canvas.clientWidth;\n    const canvasHeight = canvas.clientHeight;\n    const pointer = this.getPointerRelativeTo(canvas);\n    const infoAreaHeight = 20;\n    const infoAreaWidth = 60;\n    const bins = wave.length;\n    g.fillStyle = `white`;\n    g.fillRect(0, 0, infoAreaWidth, infoAreaHeight);\n\n    const width = canvasWidth / bins;\n\n    // Clears the screen with very light tint of white\n    // to fade out last waveform. Set this higher to remove effect\n    g.fillStyle = `rgba(255, 255, 255, 0.03)`;\n    g.fillRect(0, 20, canvasWidth, canvasHeight);\n\n    g.fillStyle = `red`;\n    if (bipolar) {\n      g.fillRect(0, canvasHeight / 2, canvasWidth, 1);\n    } else {\n      g.fillRect(0, canvasHeight - 1, canvasWidth, 1);\n    }\n\n    g.lineWidth = 1;\n    g.strokeStyle = `black`;\n    g.beginPath();\n\n    //eslint-disable-next-line functional/no-let\n    let x = 0;\n\n    //eslint-disable-next-line functional/no-let\n    for (let i = 0; i < bins; i++) {\n      const height = wave[ i ] * canvasHeight;\n      const y = bipolar ? canvasHeight / 2 - height : canvasHeight - height;\n\n      if (i === 0) {\n        g.moveTo(x, y);\n      } else {\n        g.lineTo(x, y);\n      }\n      x += width;\n\n      if (this.pointerDown) this.waveTracker.seen(wave[ i ]);\n    }\n    g.lineTo(canvasWidth, bipolar ? canvasHeight / 2 : canvasHeight); //canvas.height / 2);\n    g.stroke();\n\n    // Draw\n    if (this.pointerDown) {\n      const waveMma = this.waveTracker.getMinMaxAvg();\n      g.fillStyle = `rgba(255,255,0,1)`;\n      g.fillRect(infoAreaWidth, 0, 150, 20);\n      g.fillStyle = `black`;\n      g.fillText(`Min: ` + waveMma.min.toFixed(2), 60, 10);\n      g.fillText(`Max: ` + waveMma.max.toFixed(2), 110, 10);\n      g.fillText(`Avg: ` + waveMma.avg.toFixed(2), 160, 10);\n    } else {\n      this.waveTracker.reset();\n    }\n\n    // Show info about data under pointer\n    if (\n      pointer.y > 0 &&\n      pointer.y <= canvasHeight &&\n      pointer.x >= 0 &&\n      pointer.x <= canvasWidth\n    ) {\n      g.fillStyle = `black`;\n      g.fillText(\n        `Level: ` + (1.0 - pointer.y / canvasHeight).toFixed(2),\n        2,\n        10\n      );\n    }\n  }\n\n  // Yields pointer position relative to given element\n  getPointerRelativeTo(elem: HTMLElement) {\n    const rect = elem.getBoundingClientRect();\n    return {\n      x: this.lastPointer.x - rect.left - window.scrollX, //elem.offsetLeft + window.scrollX,\n      y: this.lastPointer.y - rect.top - window.scrollY, //elem.offsetTop + window.scrollY\n    };\n  }\n\n  // Keeps track of last pointer position in page coordinate space\n  onPointer(evt: MouseEvent | PointerEvent) {\n    this.lastPointer = {\n      x: evt.pageX,\n      y: evt.pageY,\n    };\n    evt.preventDefault();\n  }\n\n  // getMinMax(data, start = 0, end = data.length) {\n  //   if (end > data.length) throw new Error(`end is past size of array`);\n  //   if (start < 0) throw new Error(`start should be at least 0`);\n  //   if (end <= start) throw new Error(`end should be greater than start`);\n\n  //   let max = Number.MIN_SAFE_INTEGER;\n  //   let min = Number.MAX_SAFE_INTEGER;\n  //   for (let i = start; i < end; i++) {\n  //     max = Math.max(data[i], max);\n  //     min = Math.min(data[i], min);\n  //   }\n  //   if (!Number.isFinite(max)) max = 0;\n  //   if (!Number.isFinite(min)) min = 0;\n\n  //   return {max: max, min: min};\n  // }\n}\n","import { EspruinoBleDevice } from './EspruinoBleDevice.js';\nimport { defaultOpts as NordicDefaults } from './NordicBleDevice.js';\nimport { type StateChangeEvent } from '../flow/StateMachineWithEvents.js';\nimport { type ISimpleEventEmitter } from '../ISimpleEventEmitter.js';\nimport { string as randomString } from '../random/String.js';\nimport { waitFor } from '../flow/WaitFor.js';\nimport {\n  EspruinoSerialDevice,\n\n} from './EspruinoSerialDevice.js';\nimport type {\n  GenericStateTransitions,\n  IoDataEvent,\n  IoEvents,\n} from './index.js';\n\nexport type EspruinoStates =\n  | `ready`\n  | `connecting`\n  | `connected`\n  | `closed`\n  | `closing`\n  ;\n\n/**\n * Options for device\n */\nexport type Options = {\n  /**\n   * Default milliseconds to wait before giving up on a well-formed reply. 5 seconds is the default.\n   */\n  readonly evalTimeoutMs?: number;\n  /**\n   * Name of device. Only used for printing log mesages to the console\n   */\n  readonly name?: string;\n\n  /**\n   * If true, additional logging information is printed\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Options for code evaluation\n */\nexport type EvalOpts = {\n  /**\n   * Milliseconds to wait before giving up on well-formed reply. 5 seconds is the default.\n   */\n  readonly timeoutMs?: number;\n  /**\n   * If true (default), it assumes that anything received from the board\n   * is a response to the eval\n   */\n  readonly assumeExclusive?: boolean;\n\n  /**\n   * If true, executed code is traced\n   */\n  readonly debug?: boolean;\n};\n\nexport type EspruinoBleOpts = {\n  /**\n   * If the name is specified, this value is used\n   * for filtering Bluetooth devices\n   */\n  readonly name?: string;\n  /**\n   * If true, additional logging messages are\n   * displayed on the console\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, these filtering options are used instead\n   */\n  readonly filters?: ReadonlyArray<BluetoothLEScanFilter>;\n};\n\n/**\n * Instantiates a Puck.js. See {@link EspruinoBleDevice} for more info.\n * [Online demos](https://clinth.github.io/ixfx-demos/io/)\n *\n * If `opts.name` is specified, this will the the Bluetooth device sought.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.puck({ name:`Puck.js a123` });\n * ```\n *\n * If no name is specified, a list of all devices starting with `Puck.js` are shown.\n *\n * To get more control over filtering, pass in `opts.filter`. `opts.name` is not used as a filter in this scenario.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const filters = [\n *  { namePrefix: `Puck.js` },\n *  { namePrefix: `Pixl.js` },\n *  {services: [NordicDefaults.service] }\n * ]\n * const e = await Espruino.puck({ filters });\n * ```\n *\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const puck = async (opts: EspruinoBleOpts = {}) => {\n  const name = opts.name ?? `Puck`;\n  const debug = opts.debug ?? false;\n\n  const device = await navigator.bluetooth.requestDevice({\n    filters: getFilters(opts),\n    optionalServices: [ NordicDefaults.service ],\n  });\n\n  console.log(device.name);\n  const d = new EspruinoBleDevice(device, { name, debug });\n  await d.connect();\n  return d;\n};\n\n/**\n * Create a serial-connected Espruino device.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruio.serial();\n * e.connect();\n * ```\n *\n * Options:\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.serial({ debug: true, evalTimeoutMs: 1000, name: `My Pico` });\n * e.connect();\n * ```\n *\n * Listen for events:\n * ```js\n * e.addEventListener(`change`, evt => {\n *  console.log(`State change ${evt.priorState} -> ${evt.newState}`);\n *  if (evt.newState === `connected`) {\n *    // Do something when connected...\n *  }\n * });\n * ```\n *\n * Reading incoming data:\n * ```\n * // Parse incoming data as JSON\n * s.addEventListener(`data`, evt => {\n *  try {\n *    const o = JSON.parse(evt.data);\n *    // If we get this far, JSON is legit\n *  } catch (ex) {\n *  }\n * });\n * ```\n *\n * Writing to the microcontroller\n * ```\n * s.write(JSON.stringify({msg:\"hello\"}));\n * ```\n * @param opts\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const serial = async (\n  opts: {\n    readonly name?: string;\n    readonly debug?: boolean;\n    readonly evalTimeoutMs?: number;\n  } = {}\n) => {\n  const d = new EspruinoSerialDevice(opts);\n  await d.connect();\n  return d;\n};\n\n/**\n * Returns a list of BLE scan filters, given the\n * connect options.\n * @param opts\n * @returns\n */\nconst getFilters = (opts: EspruinoBleOpts) => {\n  //eslint-disable-next-line functional/no-let\n  const filters: Array<BluetoothLEScanFilter> = [];\n\n  if (opts.filters) {\n    //eslint-disable-next-line functional/immutable-data\n    filters.push(...opts.filters);\n  } else if (opts.name) {\n    // Name filter\n    //eslint-disable-next-line functional/immutable-data\n    filters.push({ name: opts.name });\n    console.info(`Filtering Bluetooth devices by name '${ opts.name }'`);\n  } else {\n    // Default filter\n    //eslint-disable-next-line functional/immutable-data\n    filters.push({ namePrefix: `Puck.js` });\n  }\n  // {namePrefix: 'Pixl.js'},\n  // {namePrefix: 'MDBT42Q'},\n  // {namePrefix: 'RuuviTag'},\n  // {namePrefix: 'iTracker'},\n  // {namePrefix: 'Thingy'},\n  // {namePrefix: 'Espruino'},\n  //{services: [NordicDefaults.service]}\n\n  return filters;\n};\n/**\n * Connects to a generic Espruino BLE device. See  {@link EspruinoBleDevice} for more info.\n * Use {@link puck} if you're connecting to a Puck.js\n *\n * If `opts.name` is specified, only this BLE device will be shown.\n * ```js\n * const e = await connectBle({ name: `Puck.js a123` });\n * ```\n *\n * `opts.filters` overrides and sets arbitary filters.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const filters = [\n *  { namePrefix: `Puck.js` },\n *  { namePrefix: `Pixl.js` },\n *  {services: [NordicDefaults.service] }\n * ]\n * const e = await Espruino.connectBle({ filters });\n * ```\n *\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const connectBle = async (opts: EspruinoBleOpts = {}) => {\n  const device = await navigator.bluetooth.requestDevice({\n    filters: getFilters(opts),\n    optionalServices: [ NordicDefaults.service ],\n  });\n  const d = new EspruinoBleDevice(device, { name: `Espruino`, ...opts });\n  await d.connect();\n  return d;\n};\n\nexport type Events = IoEvents<GenericStateTransitions>;\n/**\n * EspruinoDevice\n *\n * This base interface is implemented by {@link EspruinoBleDevice} and {@link EspruinoSerialDevice}.\n */\nexport type EspruinoDevice = {\n  /**\n   * Sends some code to be executed on the Espruino. The result\n   * is packaged into JSON and sent back to your code. An exception is\n   * thrown if code can't be executed for some reason.\n   *\n   * ```js\n   * const sum = await e.eval(`2+2`);\n   * ```\n   *\n   * It will wait for a period of time for a well-formed response from the\n   * Espruino. This might not happen if there is a connection problem\n   * or a syntax error in the code being evaled. In cases like the latter,\n   * it will take up to `timeoutMs` (default 5 seconds) before we give up\n   * waiting for a correct response and throw an error.\n   *\n   * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n   * or too slowly. A default timeout can be given when creating the class.\n   *\n   * Options:\n   *  timeoutMs: Timeout for execution. 5 seconds by default\n   *  assumeExclusive If true, eval assumes all replies from controller are in response to eval. True by default\n   *  debug: If true, execution is traced via `warn` callback\n   * @param code Code to run on the Espruino.\n   * @param opts Options\n   * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n   */\n  eval(\n    code: string,\n    opts?: EvalOpts,\n    warn?: (message: string) => void\n  ): Promise<string>;\n\n  /**\n   * Write some code for immediate execution. This is a lower-level\n   * alternative to {@link writeScript}. Be sure to include a new line character '\\n' at the end.\n   * @param m Code\n   */\n  write(m: string): void;\n\n  /**\n   * Writes a script to Espruino.\n   *\n   * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n   * and then the provided `code` followed by a new line.\n   *\n   * Use {@link eval} instead to execute remote code and get the result back.\n   *\n   * ```js\n   * // Eg from https://www.espruino.com/Web+Bluetooth\n   * espruino.writeScript(`\n   *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n   *  NRF.on('disconnect',()=>reset());\n   * `);\n   * ```\n   *\n   * @param code Code to send. A new line is added automatically.\n   */\n  writeScript(code: string): void;\n\n  /**\n   * Disconnect\n   */\n  disconnect(): void;\n\n  /**\n   * Gets the current evaluation (millis)\n   */\n  get evalTimeoutMs(): number;\n\n  get isConnected(): boolean;\n} & ISimpleEventEmitter<Events>\n\n/**\n * Evaluates some code on an Espruino device.\n *\n * Options:\n * * timeoutMs: how many millis to wait before assuming code failed. If not specified, `device.evalTimeoutMs` is used as a default.\n * * assumeExlusive: assume device is not producing any other output than for our evaluation\n *\n * A random string is created to pair eval requests and responses. `code` will be run on the device, with the result\n * wrapped in JSON, and in turn wrapped in a object that is sent back.\n *\n * The actual code that gets sent to the device is then:\n * `\\x10${evalReplyPrefix}(JSON.stringify({reply:\"${id}\", result:JSON.stringify(${code})}))\\n`\n *\n * For example, it might end up being:\n * `\\x10Bluetooth.println(JSON.stringify({reply: \"a35gP\", result: \"{ 'x': '10' }\" }))\\n`\n *\n * @param code Code to evaluation\n * @param opts Options for evaluation\n * @param device Device to execute on\n * @param evalReplyPrefix How to send code back (eg `Bluetooth.println`, `console.log`)\n * @param debug If true, the full evaled code is printed locally to the console\n * @param warn Callback to display warnings\n * @returns\n */\nexport const deviceEval = async (\n  code: string,\n  opts: EvalOpts = {},\n  device: EspruinoDevice,\n  evalReplyPrefix: string,\n  debug: boolean,\n  warn: (m: string) => void\n): Promise<string> => {\n  const timeoutMs = opts.timeoutMs ?? device.evalTimeoutMs;\n  const assumeExclusive = opts.assumeExclusive ?? true;\n\n  if (typeof code !== `string`) {\n    throw new TypeError(`code parameter should be a string`);\n  }\n\n  return new Promise((resolve, reject) => {\n    // Generate a random id so reply can be matched up with this request\n    const id = randomString(5);\n\n    const onData = (d: IoDataEvent) => {\n      try {\n        //eslint-disable-next-line functional/no-let\n        let cleaned = d.data;\n\n        // Prefixed with angled bracket sometimes?\n        if (cleaned.startsWith(`>{`) && cleaned.endsWith(`}`)) {\n          cleaned = cleaned.slice(1);\n        }\n\n        // Parse reply, expecting JSON.\n        const dd = JSON.parse(cleaned);\n\n        // Check for reply field, and that it matches\n        if (`reply` in dd) {\n          if (dd.reply === id) {\n            done(); // Stop waiting for result\n            if (`result` in dd) {\n              resolve(dd.result);\n            }\n          } else {\n            warn(`Expected reply ${ id }, got ${ dd.reply }`);\n          }\n        } else {\n          warn(`Expected packet, missing 'reply' field. Got: ${ d.data }`);\n        }\n      } catch (error: unknown) {\n        // If there was a syntax error, response won't be JSON\n        if (assumeExclusive) {\n          // Fail with unexpected reply as the message\n          done(d.data);\n        } else {\n          // Unexpected reply, but we cannot be sure if it's in response to eval or\n          // some other code running on board. So just warn and eventually timeout\n          warn(error as string);\n        }\n      }\n    };\n\n    const onStateChange = (event: StateChangeEvent<GenericStateTransitions>) => {\n      if (event.newState !== `connected`) {\n        done(`State changed to '${ event.newState }', aborting`);\n      }\n    };\n\n    device.addEventListener(`data`, onData);\n    device.addEventListener(`change`, onStateChange);\n\n    // Init waitFor\n    const done = waitFor(\n      timeoutMs,\n      (reason: string) => {\n        reject(reason);\n      },\n      () => {\n        // If we got a response or there was a timeout, remove event listeners\n        device.removeEventListener(`data`, onData);\n        device.removeEventListener(`change`, onStateChange);\n      }\n    );\n\n    const source = `\\u0010${ evalReplyPrefix }(JSON.stringify({reply:\"${ id }\", result:JSON.stringify(${ code })}))\\n`;\n    if (debug) warn(source);\n    device.write(source);\n  });\n};\n\nexport { type EspruinoSerialDeviceOpts, EspruinoSerialDevice } from './EspruinoSerialDevice.js';\nexport { EspruinoBleDevice } from './EspruinoBleDevice.js';","import { type EvalOpts, type Options, deviceEval } from './Espruino.js';\nimport { NordicBleDevice } from './NordicBleDevice.js';\n\n/**\n * An Espruino BLE-connection\n *\n * See [online demos](https://clinth.github.io/ixfx-demos/io/)\n *\n * Use the `puck` function to initialise and connect to a Puck.js.\n * It must be called in a UI event handler for browser security reasons.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.puck();\n * ```\n *\n * To connect to a particular device:\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.puck({name:`Puck.js a123`});\n * ```\n *\n * Listen for events:\n * ```js\n * // Received something\n * e.addEventListener(`data`, d => console.log(d.data));\n * // Monitor connection state\n * e.addEventListener(`change`, c => console.log(`${d.priorState} -> ${d.newState}`));\n * ```\n *\n * Write to the device (note the \\n for a new line at the end of the string). This will\n * execute the code on the Espruino.\n *\n * ```js\n * e.write(`digitalPulse(LED1,1,[10,500,10,500,10]);\\n`);\n * ```\n *\n * Run some code and return result:\n * ```js\n * const result = await e.eval(`2+2\\n`);\n * ```\n */\nexport class EspruinoBleDevice extends NordicBleDevice {\n  evalTimeoutMs: number;\n  evalReplyBluetooth = true;\n\n  /**\n   * Creates instance. You probably would rather use {@link puck} to create.\n   * @param device\n   * @param opts\n   */\n  constructor(device: BluetoothDevice, opts: Options = {}) {\n    super(device, opts);\n    this.evalTimeoutMs = opts.evalTimeoutMs ?? 5 * 1000;\n  }\n\n  /**\n   * Writes a script to Espruino.\n   *\n   * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n   * and then the provided `code` followed by a new line.\n   *\n   * Use {@link eval} instead to execute remote code and get the result back.\n   *\n   * ```js\n   * // Eg from https://www.espruino.com/Web+Bluetooth\n   * writeScript(`\n   *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n   *  NRF.on('disconnect',()=>reset());\n   * `);\n   * ```\n   *\n   * @param code Code to send. A new line is added automatically.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async writeScript(code: string) {\n    this.write(`\\u0003\\u0010reset();\\n`);\n    this.write(`\\u0010${ code }\\n`);\n  }\n\n  /**\n   * Sends some code to be executed on the Espruino. The result\n   * is packaged into JSON and sent back to your code. An exception is\n   * thrown if code can't be executed for some reason.\n   *\n   * ```js\n   * const sum = await e.eval(`2+2`);\n   * ```\n   *\n   * It will wait for a period of time for a well-formed response from the\n   * Espruino. This might not happen if there is a connection problem\n   * or a syntax error in the code being evaled. In cases like the latter,\n   * it will take up to `timeoutMs` (default 5 seconds) before we give up\n   * waiting for a correct response and throw an error.\n   *\n   * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n   * or too slowly. A default timeout can be given when creating the class.\n   *\n   * Options:\n   *  timeoutMs: Timeout for execution. 5 seconds by default\n   *  assumeExclusive If true, eval assumes all replies from controller are in response to eval. True by default\n   *  debug: If true, execution is traced via `warn` callback\n   * @param code Code to run on the Espruino.\n   * @param opts Options\n   * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n   */\n  async eval(\n    code: string,\n    opts: EvalOpts = {},\n    warn?: (message: string) => void\n  ): Promise<string> {\n    const debug = opts.debug ?? false;\n    const warnCallback = warn ?? ((m) => { this.warn(m); });\n    return deviceEval(code, opts, this, `Bluetooth.println`, debug, warnCallback);\n  }\n  /*\n    const timeoutMs = opts.timeoutMs ?? this.evalTimeoutMs;\n    const assumeExclusive = opts.assumeExclusive ?? true;\n\n    if (typeof code !== `string`) throw new Error(`code parameter should be a string`);\n      \n    return new Promise((resolve, reject) => {\n      // Generate a random id so reply can be matched up with this request\n      const id = randomString(5);\n\n      const onData = (d:DataEvent) => {\n        try {\n          // Parse reply, expecting JSON.\n          const dd = JSON.parse(d.data);\n\n          // Check for reply field, and that it matches\n          if (`reply` in dd) {\n            if (dd.reply === id) {\n              done(); // Stop waiting for result\n              if (`result` in dd) {\n                resolve(dd.result);\n              }\n            } else {\n              this.warn(`Expected reply ${id}, got ${dd.reply}`);\n            }\n          }\n        } catch (ex:unknown) {\n          // If there was a syntax error, response won't be JSON\n          if (assumeExclusive) {\n            // Fail with unexpected reply as the message\n            done(d.data);\n          } else {\n            // Unexpected reply, but we cannot be sure if it's in response to eval or\n            // some other code running on board. So just warn and eventually timeout\n            this.warn(ex);\n          }\n        }\n      };\n\n      const onStateChange = (e:StateChangeEvent) => {\n        if (e.newState !== `connected`) done(`State changed to '${e.newState}', aborting`);\n      };\n\n      this.addEventListener(`data`, onData);\n      this.addEventListener(`change`, onStateChange);\n\n      // Init waitFor\n      const done = waitFor(timeoutMs, (reason:string) => {\n        reject(reason);\n      }, () => {\n        // If we got a response or there was a timeout, remove event listeners\n        this.removeEventListener(`data`, onData);\n        this.removeEventListener(`change`, onStateChange);\n      });\n\n      this.write(`\\x10Bluetooth.println(JSON.stringify({reply:\"${id}\", result:JSON.stringify(${code})}))\\n`);\n    });\n  */\n}\n","import {\n  type JsonDeviceOpts,\n  JsonDevice,\n} from './JsonDevice.js';\n\nexport type SerialOpts = JsonDeviceOpts & {\n  readonly filters?: ReadonlyArray<SerialPortFilter>;\n  readonly baudRate?: number;\n  /**\n   * End-of-line string sequence. \\r\\n by default.\n   */\n  readonly eol?: string;\n};\n\n/**\n * Serial device. Assumes data is sent with new line characters (\\r\\n) between messages.\n *\n * ```\n * const s = new Device();\n * s.addEventListener(`change`, evt => {\n *  console.log(`State change ${evt.priorState} -> ${evt.newState}`);\n *  if (evt.newState === `connected`) {\n *    // Do something when connected...\n *  }\n * });\n *\n * // In a UI event handler...\n * s.connect();\n * ```\n *\n * Reading incoming data:\n * ```\n * // Parse incoming data as JSON\n * s.addEventListener(`data`, evt => {\n *  try {\n *    const o = JSON.parse(evt.data);\n *    // If we get this far, JSON is legit\n *  } catch (ex) {\n *  }\n * });\n * ```\n *\n * Writing to the microcontroller\n * ```\n * s.write(JSON.stringify({msg:\"hello\"}));\n * ```\n */\nexport class Device extends JsonDevice {\n  port: SerialPort | undefined;\n  tx: WritableStreamDefaultWriter<string> | undefined;\n  abort: AbortController;\n  baudRate: number;\n\n  constructor(private config: SerialOpts = {}) {\n    super(config);\n\n    this.abort = new AbortController();\n\n    const eol = config.eol ?? `\\r\\n`;\n\n    this.baudRate = config.baudRate ?? 9600;\n    if (config.name === undefined) this.name = `Serial.Device`;\n\n    // Serial.println on microcontroller == \\r\\n\n    this.rxBuffer.separator = eol;\n  }\n\n  /**\n   * Writes text collected in buffer\n   * @param txt\n   */\n  protected async writeInternal(txt: string) {\n    if (this.tx === undefined) throw new Error(`tx not ready`);\n    try {\n      this.tx.write(txt);\n    } catch (error: unknown) {\n      this.warn(error);\n    }\n  }\n\n  onClosed(): void {\n    this.tx?.releaseLock();\n\n    this.abort.abort(`closing port`);\n    // try {\n    //   this.port?.close();\n    // } catch (ex) {\n    //   this.warn(ex);\n    // }\n    this.states.state = `closed`;\n  }\n\n  onPreConnect(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async onConnectAttempt(): Promise<void> {\n    //eslint-disable-next-line functional/no-let\n    let reqOpts: SerialPortRequestOptions = {};\n    const openOpts: SerialOptions = {\n      baudRate: this.baudRate,\n    };\n\n    if (this.config.filters) reqOpts = { filters: [ ...this.config.filters ] };\n    this.port = await navigator.serial.requestPort(reqOpts);\n\n    this.port.addEventListener(`disconnect`, (_) => {\n      this.close();\n    });\n\n    await this.port.open(openOpts);\n\n    const txW = this.port.writable;\n    const txText = new TextEncoderStream();\n    if (txW !== null) {\n      txText.readable\n        .pipeTo(txW, { signal: this.abort.signal })\n        .catch((error) => {\n          console.log(`Serial.onConnectAttempt txText pipe:`);\n          console.log(error);\n        });\n      this.tx = txText.writable.getWriter();\n    }\n\n    const rxR = this.port.readable;\n    const rxText = new TextDecoderStream();\n    if (rxR !== null) {\n      rxR\n        .pipeTo(rxText.writable, { signal: this.abort.signal })\n        .catch((error) => {\n          console.log(`Serial.onConnectAttempt rxR pipe:`);\n          console.log(error);\n        });\n      rxText.readable\n        .pipeTo(this.rxBuffer.writable(), { signal: this.abort.signal })\n        .catch((error) => {\n          console.log(`Serial.onConnectAttempt rxText pipe:`);\n          console.log(error);\n          try {\n            this.port?.close();\n          } catch (error) {\n            console.log(error);\n          }\n        });\n    }\n  }\n}\n\nexport { type JsonDeviceEvents, type JsonDataEvent, type JsonDeviceOpts } from './JsonDevice.js';","/* eslint-disable @typescript-eslint/no-useless-template-literals */\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as StateMachine from '../flow/StateMachine.js';\nimport { type StateChangeEvent } from '../flow/StateMachineWithEvents.js';\nimport { indexOfCharCode, omitChars } from '../Text.js';\nimport { Codec } from './Codec.js';\nimport { StringReceiveBuffer } from './StringReceiveBuffer.js';\nimport { StringWriteBuffer } from './StringWriteBuffer.js';\nimport { retryFunction } from '../flow/Retry.js';\nimport {\n  genericStateTransitionsInstance,\n  type GenericStateTransitions,\n} from './index.js';\n\n/**\n * Options for JsonDevice\n */\nexport type JsonDeviceOpts = {\n  /**\n   * How much data to transfer at a time\n   */\n  readonly chunkSize?: number;\n  /**\n   * Name of device. This is only used for assisting the console.log output\n   */\n  readonly name?: string;\n  /**\n   * Number of times to automatically try to reconnect\n   */\n  readonly connectAttempts?: number;\n  /**\n   * If true, additional logging will be done\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Data received event\n */\nexport type JsonDataEvent = {\n  /**\n   * Data received\n   */\n  readonly data: string;\n};\n\n/**\n * Events emitted by JsonDevice\n */\nexport type JsonDeviceEvents = {\n  /**\n   * Data received\n   */\n  readonly data: JsonDataEvent;\n  /**\n   * State changed\n   */\n  readonly change: StateChangeEvent<GenericStateTransitions>;\n};\n\nexport abstract class JsonDevice extends SimpleEventEmitter<JsonDeviceEvents> {\n  states: StateMachine.WithEvents<GenericStateTransitions>;\n  codec: Codec;\n\n  verboseLogging = false;\n  name: string;\n  connectAttempts: number;\n  chunkSize: number;\n\n  rxBuffer: StringReceiveBuffer;\n  txBuffer: StringWriteBuffer;\n\n  constructor(config: JsonDeviceOpts = {}) {\n    super();\n\n    // Init\n    this.verboseLogging = config.debug ?? false;\n    this.chunkSize = config.chunkSize ?? 1024;\n    this.connectAttempts = config.connectAttempts ?? 3;\n    this.name = config.name ?? `JsonDevice`;\n\n    // Transmit buffer\n    this.txBuffer = new StringWriteBuffer(async (data) => {\n      // When we have data to actually write to device\n      // eslint-disable-next-line @typescript-eslint/await-thenable, @typescript-eslint/no-confusing-void-expression\n      await this.writeInternal(data);\n    }, config);\n\n    // Receive buffer\n    this.rxBuffer = new StringReceiveBuffer((line) => {\n      this.fireEvent(`data`, { data: line });\n    });\n\n    this.codec = new Codec();\n    this.states = new StateMachine.WithEvents(genericStateTransitionsInstance, {\n      initial: `ready`,\n    });\n\n    this.states.addEventListener(`change`, (event) => {\n      this.fireEvent(`change`, event);\n      this.verbose(`${ event.priorState } -> ${ event.newState }`);\n      if (event.priorState === `connected`) {\n        // Clear out buffers\n        this.rxBuffer.clear();\n        this.txBuffer.clear();\n      }\n    });\n  }\n\n  get isConnected(): boolean {\n    return this.states.state === `connected`;\n  }\n\n  get isClosed(): boolean {\n    return this.states.state === `closed`;\n  }\n\n  write(txt: string) {\n    if (this.states.state !== `connected`) {\n      throw new Error(`Cannot write while state is ${ this.states.state }`);\n    }\n    this.txBuffer.add(txt);\n  }\n\n  /**\n   * Writes text to output device\n   * @param txt\n   */\n  protected abstract writeInternal(txt: string): void;\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async close() {\n    if (this.states.state !== `connected`) return;\n\n    // console.log(`rxBuffer closing`);\n    // try {\n    //   await this.rxBuffer.close();\n    // } catch (e) {\n    //   console.warn(e);\n    // }\n\n    // console.log(`txBuffer closing`);\n    // try {\n    //   await this.txBuffer.close();\n    // } catch (e) {\n    //   console.warn(e);\n    // }\n\n    // console.log(`calling onClose`);\n\n    this.onClosed();\n  }\n\n  /**\n   * Must change state\n   */\n  abstract onClosed(): void;\n\n  abstract onPreConnect(): Promise<void>;\n\n  async connect() {\n    const attempts = this.connectAttempts;\n\n    this.states.state = `connecting`;\n    await this.onPreConnect();\n\n    await retryFunction(\n      async () => {\n        await this.onConnectAttempt();\n        this.states.state = `connected`;\n        return true;\n      },\n      {\n        limitAttempts: attempts,\n        startAt: 200,\n      }\n    );\n  }\n\n  /**\n   * Should throw if did not succeed.\n   */\n  protected abstract onConnectAttempt(): Promise<void>;\n\n  private onRx(event: Event) {\n    //const rx = this.rx;\n    //if (rx === undefined) return;\n\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const view = (event.target as any).value as DataView;\n    if (view === undefined) return;\n\n    //eslint-disable-next-line functional/no-let\n    let string_ = this.codec.fromBuffer(view.buffer);\n\n    // Check for flow control chars\n    const plzStop = indexOfCharCode(string_, 19);\n    const plzStart = indexOfCharCode(string_, 17);\n\n    // Remove if found\n    if (plzStart && plzStop < plzStart) {\n      this.verbose(`Tx plz start`);\n      string_ = omitChars(string_, plzStart, 1);\n      this.txBuffer.paused = false;\n    }\n    if (plzStop && plzStop > plzStart) {\n      this.verbose(`Tx plz stop`);\n      string_ = omitChars(string_, plzStop, 1);\n      this.txBuffer.paused = true;\n    }\n\n    this.rxBuffer.add(string_);\n  }\n\n  protected verbose(m: string) {\n    if (this.verboseLogging) console.info(`${ this.name }`, m);\n  }\n\n  protected log(m: string) {\n    console.log(`${ this.name }`, m);\n  }\n\n  protected warn(m: unknown) {\n    console.warn(`${ this.name }`, m);\n  }\n}\n","import { deviceEval, type EvalOpts } from './Espruino.js';\nimport { Device as SerialDevice, type SerialOpts } from './Serial.js';\n\nexport type EspruinoSerialDeviceOpts = SerialOpts & {\n  readonly evalTimeoutMs?: number;\n};\n\nexport class EspruinoSerialDevice extends SerialDevice {\n  evalTimeoutMs: number;\n  evalReplyBluetooth = false;\n\n  constructor(opts?: EspruinoSerialDeviceOpts) {\n    super(opts);\n\n    if (opts === undefined) opts = {};\n    this.evalTimeoutMs = opts.evalTimeoutMs ?? 5 * 1000;\n  }\n\n  async disconnect() {\n    return super.close();\n  }\n\n  /**\n   * Writes a script to Espruino.\n   *\n   * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n   * and then the provided `code` followed by a new line.\n   *\n   * Use {@link eval} instead to execute remote code and get the result back.\n   *\n   * ```js\n   * // Eg from https://www.espruino.com/Web+Bluetooth\n   * writeScript(`\n   *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n   *  NRF.on('disconnect',()=>reset());\n   * `);\n   * ```\n   *\n   * @param code Code to send. A new line is added automatically.\n   */\n  async writeScript(code: string) {\n    this.write(`\\x03\\x10reset();\\n`);\n    this.write(`\\x10${code}\\n`);\n  }\n\n  /**\n   * Sends some code to be executed on the Espruino. The result\n   * is packaged into JSON and sent back to your code. An exception is\n   * thrown if code can't be executed for some reason.\n   *\n   * ```js\n   * const sum = await e.eval(`2+2`);\n   * ```\n   *\n   * It will wait for a period of time for a well-formed response from the\n   * Espruino. This might not happen if there is a connection problem\n   * or a syntax error in the code being evaled. In cases like the latter,\n   * it will take up to `timeoutMs` (default 5 seconds) before we give up\n   * waiting for a correct response and throw an error.\n   *\n   * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n   * or too slowly. A default timeout can be given when creating the class.\n   *\n   * Options:\n   *  timeoutMs: Timeout for execution. 5 seconds by default\n   *  assumeExclusive: If true, eval assumes all replies from controller are in response to eval. True by default\n   *  debug: If true, execution is traced via `warn` callback\n   * @param code Code to run on the Espruino.\n   * @param opts Options\n   * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n   */\n  async eval(\n    code: string,\n    opts: EvalOpts = {},\n    warn?: (msg: string) => void\n  ): Promise<string> {\n    const debug = opts.debug ?? false;\n    const warnCb = warn ?? ((m) => this.warn(m));\n\n    return deviceEval(code, opts, this, `USB.println`, debug, warnCb);\n  }\n}\n","import type { Rect } from '../geometry/rect/index.js';\nimport { waitFor } from '../flow/WaitFor.js';\nimport { getErrorMessage } from '../debug/GetErrorMessage.js';\n\nconst startTimeoutMs = 10_000;\n\n/**\n * Print available media devices to console\n * @param filterKind Defaults `videoinput`\n */\nexport const dumpDevices = async (filterKind = `videoinput`) => {\n  const devices = await navigator.mediaDevices.enumerateDevices();\n\n  for (const d of devices) {\n    if (d.kind !== filterKind) continue;\n    console.log(d.label);\n    console.log(` Kind: ${ d.kind }`);\n    console.log(` Device id: ${ d.deviceId }`);\n  }\n};\n\n/**\n * Constraints when requesting a camera source\n */\nexport type Constraints = {\n  /**\n   * Camera facing: user is front-facing, environment is a rear camera\n   */\n  readonly facingMode?: `user` | `environment`;\n  /**\n   * Maximum resolution\n   */\n  readonly max?: Rect;\n  /**\n   * Minimum resolution\n   */\n  readonly min?: Rect;\n  /**\n   * Ideal resolution\n   */\n  readonly ideal?: Rect;\n  /**\n   * If specified, will try to use this media device id\n   */\n  readonly deviceId?: string;\n\n  /**\n   * Number of milliseconds to wait on `getUserMedia` before giving up.\n   * Defaults to 30seconds\n   */\n  readonly startTimeoutMs?: number;\n};\n\n/**\n * Result from starting a camera\n */\n//eslint-disable-next-line functional/no-mixed-types\nexport type StartResult = {\n  /**\n   * Call dispose to stop the camera feed and remove any created resources,\n   * such as a VIDEO element\n   */\n  readonly dispose: () => void;\n  /**\n   * Video element camera is connected to\n   */\n  readonly videoEl: HTMLVideoElement;\n};\n\n/**\n * Attempts to start a video-only stream from a camera into a hidden\n * VIDEO element for frame capture. The VIDEO element is created automatically.\n *\n *\n * ```js\n * import {Camera} from 'https://unpkg.com/ixfx/dist/visual.js'\n * try\n *  const { videoEl, dispose } = await Camera.start();\n *  for await (const frame of frames(videoEl)) {\n *   // Do something with pixels...\n *  }\n * } catch (ex) {\n *  console.error(`Video could not be started`);\n * }\n * ```\n *\n * Be sure to call the dispose() function to stop the video stream and remov\n * the created VIDEO element.\n *\n * _Constraints_ can be specified to select a camera and resolution:\n * ```js\n * import {Camera} from 'https://unpkg.com/ixfx/dist/visual.js'\n * try\n *  const { videoEl, dispose } = await Camera.start({\n *    facingMode: `environment`,\n *    max: { width: 640, height: 480 }\n *  });\n *  for await (const frame of frames(videoEl)) {\n *   // Do something with pixels...\n *  }\n * } catch (ex) {\n *  console.error(`Video could not be started`);\n * }\n * ```\n * @param constraints\n * @returns Returns `{ videoEl, dispose }`, where `videoEl` is the created VIDEO element, and `dispose` is a function for removing the element and stopping the video.\n */\nexport const start = async (\n  constraints: Constraints = {}\n): Promise<StartResult> => {\n  const videoEl = document.createElement(`VIDEO`) as HTMLVideoElement;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.style.display = `none`;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.playsInline = true;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.muted = true;\n\n  videoEl.classList.add(`ixfx-camera`);\n\n  document.body.append(videoEl);\n\n  //eslint-disable-next-line functional/no-let\n  let stopVideo = () => {\n    /* no-op */\n  };\n\n  const dispose = () => {\n    try {\n      // Stop source\n      stopVideo();\n    } catch {\n      /* no-op */\n    }\n\n    // Remove the element we created\n    videoEl.remove();\n  };\n\n  try {\n    // Attempt to start video\n    const r = await startWithVideoEl(videoEl, constraints);\n    stopVideo = r.dispose;\n    return { videoEl, dispose };\n  } catch (error) {\n    // If it didn't work, delete the created element\n    console.error(error);\n    dispose();\n    throw error;\n  }\n};\n\n/**\n * Attempts to start a video-only stream from a camera into the designated VIDEO element.\n * @param videoEl\n * @param constraints\n * @returns Result contains videoEl and dispose function\n */\nconst startWithVideoEl = async (\n  videoEl: HTMLVideoElement,\n  constraints: Constraints = {}\n): Promise<StartResult> => {\n  if (videoEl === undefined) throw new Error(`videoEl undefined`);\n  if (videoEl === null) throw new Error(`videoEl null`);\n\n  const maxResolution = constraints.max;\n  const minResolution = constraints.min;\n  const idealResolution = constraints.ideal;\n\n  // Setup constraints\n  const c = {\n    audio: false,\n    video: {\n      width: {},\n      height: {},\n    },\n  };\n\n  // Just in case some intuitive values are passed in...\n  if ((constraints as any).facingMode === `front`) {\n    constraints = { ...constraints, facingMode: `user` };\n  }\n  if ((constraints as any).facingMode === `back`) {\n    constraints = { ...constraints, facingMode: `environment` };\n  }\n\n  if (constraints.facingMode) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (c.video as any).facingMode = constraints.facingMode;\n  }\n\n  if (constraints.deviceId) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (c.video as any).deviceId = constraints.deviceId;\n  }\n\n  if (idealResolution) {\n    //eslint-disable-next-line functional/immutable-data\n    c.video.width = {\n      ...c.video.width,\n      ideal: idealResolution.width,\n    };\n    //eslint-disable-next-line functional/immutable-data\n    c.video.height = {\n      ...c.video.height,\n      ideal: idealResolution.height,\n    };\n  }\n\n  if (maxResolution) {\n    //eslint-disable-next-line functional/immutable-data\n    c.video.width = {\n      ...c.video.width,\n      max: maxResolution.width,\n    };\n    //eslint-disable-next-line functional/immutable-data\n    c.video.height = {\n      ...c.video.height,\n      max: maxResolution.height,\n    };\n  }\n\n  if (minResolution) {\n    //eslint-disable-next-line functional/immutable-data\n    c.video.width = {\n      ...c.video.width,\n      min: minResolution.width,\n    };\n    //eslint-disable-next-line functional/immutable-data\n    c.video.height = {\n      ...c.video.height,\n      min: minResolution.height,\n    };\n  }\n\n  // Request stream\n  const done = waitFor(\n    constraints.startTimeoutMs ?? startTimeoutMs,\n    (reason) => {\n      throw new Error(`Camera getUserMedia failed: ${ reason }`);\n    }\n  );\n\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(c);\n\n    // Clean-up function\n    const dispose = () => {\n      videoEl.pause();\n      const t = stream.getTracks();\n      for (const track of t) track.stop();\n    };\n\n    // Assign to VIDEO element\n    //eslint-disable-next-line functional/immutable-data\n    videoEl.srcObject = stream;\n    done();\n\n    const returnValue = { videoEl, dispose };\n    const p = new Promise<StartResult>((resolve, reject) => {\n      videoEl.addEventListener(`loadedmetadata`, () => {\n        videoEl\n          .play()\n          .then(() => {\n            resolve(returnValue);\n          })\n          .catch((error) => {\n            reject(error);\n          });\n      });\n    });\n    return p;\n  } catch (error) {\n    done(getErrorMessage(error));\n    throw error;\n  }\n};\n","/**\n * Result from starting a camera\n */\n//eslint-disable-next-line functional/no-mixed-types\nexport type StartResult = {\n  /**\n   * Call dispose to stop the camera feed and remove any created resources,\n   * such as a VIDEO element\n   */\n  readonly dispose: () => void;\n  /**\n   * Video element camera is connected to\n   */\n  readonly videoEl: HTMLVideoElement;\n};\n\n/**\n * Starts video file playback, creating a VIDEO element automatically.\n * @param file File\n * @returns StartResult\n */\nexport const start = async (file: File): Promise<StartResult> => {\n  const videoEl = document.createElement(`VIDEO`) as HTMLVideoElement;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.style.display = `none`;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.playsInline = true;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.muted = true;\n\n  videoEl.classList.add(`ixfx-video`);\n\n  document.body.appendChild(videoEl);\n\n  //eslint-disable-next-line functional/no-let\n  let stopVideo = () => {\n    /* no-op */\n  };\n\n  const dispose = () => {\n    try {\n      // Stop source\n      stopVideo();\n    } catch {\n      /* no-op */\n    }\n\n    // Remove the element we created\n    videoEl.remove();\n  };\n\n  try {\n    // Attempt to start video\n    const r = await startWithVideoEl(videoEl, file);\n    stopVideo = r.dispose;\n    return { videoEl, dispose };\n  } catch (ex) {\n    // If it didn't work, delete the created element\n    console.error(ex);\n    dispose();\n    throw ex;\n  }\n};\n\n/**\n * Starts playback of a video file in the provided VIDEO element.\n * @param videoEl\n * @param file\n * @returns\n */\nconst startWithVideoEl = async (\n  videoEl: HTMLVideoElement,\n  file: File\n): Promise<StartResult> => {\n  if (videoEl === undefined) throw new Error(`videoEl undefined`);\n  if (videoEl === null) throw new Error(`videoEl null`);\n\n  const url = URL.createObjectURL(file);\n\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.src = url;\n  //eslint-disable-next-line functional/immutable-data\n  videoEl.loop = true;\n\n  // Clean-up function\n  const dispose = () => {\n    videoEl.pause();\n  };\n\n  const ret = { videoEl, dispose };\n  const p = new Promise<StartResult>((resolve, reject) => {\n    videoEl.addEventListener(`loadedmetadata`, () => {\n      videoEl\n        .play()\n        .then(() => {\n          resolve(ret);\n        })\n        .catch((ex) => {\n          reject(ex);\n        });\n    });\n  });\n  return p;\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion,functional/immutable-data */\nimport { continuously, delayLoop } from '../flow/index.js';\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type Capturer = {\n  start(): void;\n  cancel(): void;\n  readonly canvasEl: HTMLCanvasElement;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type ManualCapturer = {\n  capture(): ImageData;\n  readonly canvasEl: HTMLCanvasElement;\n  dispose(): void;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type CaptureOpts = {\n  readonly maxIntervalMs?: number;\n  readonly showCanvas?: boolean;\n  readonly workerScript?: string;\n  readonly onFrame?: (pixels: ImageData) => void;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type ManualCaptureOpts = {\n  /**\n   * If true, the intermediate canvas is shown\n   * The intermediate canvas is where captures from the source are put in order\n   * to get the ImageData\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * If specified, this is the canvas captured to\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Options for frames generator\n */\nexport type FramesOpts = {\n  /**\n   * Max frame rate (millis per frame), or 0 for animation speed\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * False by default, created canvas will be hidden\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If provided, this canvas will be used as the buffer rather than creating one.\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\n//eslint-disable-next-line func-style\nexport async function* frames(\n  sourceVideoEl: HTMLVideoElement,\n  opts: FramesOpts = {}\n): AsyncIterable<ImageData> {\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  \n  const showCanvas = opts.showCanvas ?? false;\n  //eslint-disable-next-line functional/no-let\n  let canvasEl = opts.canvasEl;\n  //eslint-disable-next-line functional/no-let\n  let w, h;\n  w = h = 0;\n\n  // Create & setup canvas\n  if (canvasEl === undefined) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-frames`);\n    if (!showCanvas) {\n      canvasEl.style.display = `none`;\n    }\n    document.body.appendChild(canvasEl);\n  }\n\n  // Update size of canvas based on video\n  const updateSize = () => {\n    if (canvasEl === undefined) return;\n    w = sourceVideoEl.videoWidth;\n    h = sourceVideoEl.videoHeight;\n    canvasEl.width = w;\n    canvasEl.height = h;\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let c: CanvasRenderingContext2D | null = null;\n\n  const looper = delayLoop(maxIntervalMs);\n  for await (const _ of looper) {\n    // If we don't yet have the size of video, get it\n    if (w === 0 || h === 0) updateSize();\n\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n    if (w === 0 || h === 0) continue;\n\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    // Get pixels\n    const pixels = c.getImageData(0, 0, w, h);\n    yield pixels;\n  }\n}\n\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: CaptureOpts = {}\n): Capturer => {\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  const showCanvas = opts.showCanvas ?? false;\n  const onFrame = opts.onFrame;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n  canvasEl.classList.add(`ixfx-capture`);\n\n  if (!showCanvas) {\n    canvasEl.style.display = `none`;\n  }\n  canvasEl.width = w;\n  canvasEl.height = h;\n  //eslint-disable-next-line functional/no-let\n  let c: CanvasRenderingContext2D | null = null;\n  //eslint-disable-next-line functional/no-let\n  let worker: Worker | undefined;\n  if (opts.workerScript) {\n    worker = new Worker(opts.workerScript);\n  }\n\n  // Should we get image data?\n  const getPixels = worker || onFrame;\n  if (!getPixels && !showCanvas) {\n    console.warn(\n      `Video will be captured to hidden element without any processing. Is this what you want?`\n    );\n  }\n\n  const loop = continuously(() => {\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n    //eslint-disable-next-line functional/no-let\n    let pixels: ImageData | undefined;\n\n    if (getPixels) {\n      // ImageData necessary\n      pixels = c.getImageData(0, 0, w, h);\n    }\n\n    if (worker) {\n      // Send to worker\n      worker.postMessage(\n        {\n          pixels: pixels!.data.buffer,\n          width: w,\n          height: h,\n          channels: 4,\n        },\n        [pixels!.data.buffer]\n      );\n    }\n    if (onFrame) {\n      // Send to callback\n      try {\n        onFrame(pixels!);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, maxIntervalMs);\n\n  return {\n    start: () => loop.start(),\n    cancel: () => loop.cancel(),\n    canvasEl,\n  };\n};\n\nexport const manualCapture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: ManualCaptureOpts = {}\n): ManualCapturer => {\n  const showCanvas = opts.showCanvas ?? false;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas if necessary\n  const definedCanvasEl = opts.canvasEl !== undefined;\n  //eslint-disable-next-line functional/no-let\n  let canvasEl = opts.canvasEl;\n  if (!canvasEl) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-capture`);\n    document.body.append(canvasEl);\n    if (!showCanvas) canvasEl.style.display = `none`;\n  }\n\n  canvasEl.width = w;\n  canvasEl.height = h;\n\n  const capture = (): ImageData => {\n    //eslint-disable-next-line functional/no-let\n    let c: CanvasRenderingContext2D | undefined | null;\n\n    // Draw current frame from video element to canvas\n    if (!c) c = canvasEl?.getContext(`2d`, { willReadFrequently: true });\n    if (!c) throw new Error(`Could not create graphics context`);\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    //eslint-disable-next-line functional/no-let\n    const pixels = c.getImageData(0, 0, w, h);\n\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (pixels as any).currentTime = sourceVideoEl.currentTime;\n\n    if (opts.postCaptureDraw) opts.postCaptureDraw(c, w, h);\n    return pixels;\n  };\n\n  const dispose = (): void => {\n    if (definedCanvasEl) return; // we didn't create it\n    try {\n      canvasEl?.remove();\n    } catch (_) {\n      // no-op\n    }\n  };\n\n  const c: ManualCapturer = {\n    canvasEl,\n    capture,\n    dispose,\n  };\n  return c;\n};\n","export type Sources = `` | `camera` | `video`;\nimport * as Camera from './Camera.js';\nimport * as VideoFile from './VideoFile.js';\nimport * as Video from '../visual/Video.js';\n\ntype State = `ready` | `initialised` | `disposed`;\n\n/**\n * Frame procesor options\n */\n//eslint-disable-next-line functional/no-mixed-types\nexport type FrameProcessorOpts = {\n  /**\n   * If true, capture canvas will be shown\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If true, raw source will be shown\n   */\n  readonly showPreview?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * Default constraints to use for the camera source\n   */\n  readonly cameraConstraints?: Camera.Constraints;\n\n  /**\n   * If specified, this canvas will be used for capturing frames to\n   */\n  readonly captureCanvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Frame Processor\n * Simplifies grabbing frames from a source\n */\nexport class FrameProcessor {\n  private _source: Sources;\n  private _state: State;\n  private _teardownNeeded = false;\n\n  private _cameraConstraints: Camera.Constraints | undefined;\n  private _cameraStartResult: Camera.StartResult | undefined;\n  private _videoSourceCapture: Video.ManualCapturer | undefined;\n\n  private _videoFile: File | undefined;\n  private _videoStartResult: VideoFile.StartResult | undefined;\n\n  private _showCanvas: boolean;\n  private _showPreview: boolean;\n  private _postCaptureDraw;\n  private _timer: number;\n  private _captureCanvasEl?: HTMLCanvasElement;\n\n  /**\n   * Create a new frame processor\n   * @param opts\n   */\n  constructor(opts: FrameProcessorOpts = {}) {\n    this._state = `ready`;\n    this._source = ``;\n    this._timer = performance.now();\n    this._showCanvas = opts.showCanvas ?? false;\n    this._showPreview = opts.showPreview ?? false;\n    this._cameraConstraints = opts.cameraConstraints ?? undefined;\n    this._captureCanvasEl = opts.captureCanvasEl ?? undefined;\n    this._postCaptureDraw = opts.postCaptureDraw;\n  }\n\n  /**\n   * Hides or shows the raw source in the DOM\n   * @param enabled Preview enabled\n   */\n  showPreview(enabled: boolean) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    //eslint-disable-next-line functional/no-let\n    let el: HTMLElement | undefined;\n\n    switch (this._source) {\n      case `camera`: {\n        el = this._cameraStartResult?.videoEl;\n        if (el !== undefined) el.style.display = enabled ? `block` : `none`;\n        break;\n      }\n    }\n\n    this._showPreview = enabled;\n  }\n\n  /**\n   * Shows or hides the Canvas we're capturing to\n   * @param enabled\n   */\n  showCanvas(enabled: boolean) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    //eslint-disable-next-line functional/no-let\n    let el: HTMLElement | undefined;\n\n    if (this._source === `camera` || this._source === `video`) {\n      el = this._videoSourceCapture?.canvasEl;\n      if (el !== undefined) el.style.display = enabled ? `block` : `none`;\n    } else throw new Error(`Source not implemented: ${ this._source }`);\n\n    this._showCanvas = enabled;\n  }\n\n  /**\n   * Returns the current capturer instance\n   * @returns\n   */\n  getCapturer(): Video.ManualCapturer | undefined {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    if (this._source === `camera` || this._source === `video`) {\n      return this._videoSourceCapture;\n    }\n    throw new Error(`Source kind not supported ${ this._source }`);\n  }\n\n  /**\n   * Grab frames from a video camera source and initialises\n   * frame processor.\n   *\n   * If `constraints` are not specified, it will use the ones\n   * provided when creating the class, or defaults.\n   *\n   * @param constraints Override of constraints when requesting camera access\n   */\n  async useCamera(constraints?: Camera.Constraints) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n\n    this._source = `camera`;\n    if (this._teardownNeeded) this.teardown();\n    if (constraints) this._cameraConstraints;\n\n    await this.init();\n  }\n\n  async useVideo(file: File) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    this._source = `video`;\n    if (this._teardownNeeded) this.teardown();\n    this._videoFile = file;\n    await this.init();\n  }\n\n  /**\n   * Initialises camera\n   */\n  private async initCamera() {\n    const r = await Camera.start(this._cameraConstraints);\n    if (r === undefined) throw new Error(`Could not start camera`);\n    this._cameraStartResult = r;\n    this.postInit(r);\n  }\n\n  private async initVideo() {\n    if (!this._videoFile) throw new Error(`Video file not defined`);\n    const r = await VideoFile.start(this._videoFile);\n    this._videoStartResult = r;\n\n    this.postInit(r);\n  }\n\n  private async postInit(r: Camera.StartResult | VideoFile.StartResult) {\n    if (this._showPreview) r.videoEl.style.display = `block`;\n\n    // Set up manual capturer\n    this._videoSourceCapture = Video.manualCapture(r.videoEl, {\n      postCaptureDraw: this._postCaptureDraw,\n      showCanvas: this._showCanvas,\n      canvasEl: this._captureCanvasEl,\n    });\n\n    this._teardownNeeded = true;\n    this._cameraStartResult = r;\n  }\n\n  /**\n   * Closes down connections and removes created elements.\n   * Once disposed, the frame processor cannot be used\n   * @returns\n   */\n  dispose() {\n    if (this._state === `disposed`) return;\n    this.teardown();\n    this._state = `disposed`;\n  }\n\n  private async init() {\n    this._timer = performance.now();\n    switch (this._source) {\n      case `camera`: {\n        await this.initCamera();\n        break;\n      }\n      case `video`: {\n        await this.initVideo();\n        break;\n      }\n    }\n    this._state = `initialised`;\n  }\n\n  private teardown() {\n    if (!this._teardownNeeded) return;\n    if (this._source === `camera` || this._source === `video`) {\n      this._videoSourceCapture?.dispose();\n    }\n    switch (this._source) {\n      case `camera`: {\n        this._cameraStartResult?.dispose();\n        break;\n      }\n      case `video`: {\n        this._videoStartResult?.dispose();\n        break;\n      }\n    }\n    this._teardownNeeded = false;\n  }\n\n  /**\n   * Get the last frame\n   * @returns\n   */\n  getFrame(): ImageData | undefined {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n\n    switch (this._source) {\n      case `camera`: {\n        return this.getFrameCamera();\n      }\n      case `video`: {\n        return this.getFrameCamera();\n      }\n      default: {\n        throw new Error(`source type unhandled ${ this._source }`);\n      }\n    }\n  }\n\n  /**\n   * Get the timestamp of the processor (elapsed time since starting)\n   * @returns\n   */\n  getTimestamp(): number {\n    return performance.now() - this._timer;\n  }\n\n  private getFrameCamera(): ImageData | undefined {\n    return this._videoSourceCapture?.capture();\n  }\n}\n","import { retryTask } from \"../flow/Retry.js\"\nimport { intervalToMs, type Interval } from \"../flow/IntervalType.js\"\nimport { eventRace } from \"../Events.js\"\nimport { StateMachine } from \"../flow/index.js\"\n\n\nexport type ReconnectingWebsocket = {\n  /**\n   * Sends data\n   * @param data \n   * @returns \n   */\n  send: (data: string | ArrayBufferLike | ArrayBufferView | Blob) => void\n  /**\n   * Closes websocket, disabling reconnection\n   * @returns\n   */\n  close: () => void\n\n  /**\n   * Opens websocket if it's not already connected or connecting\n   * @returns \n   */\n  open: () => Promise<boolean>\n\n  /**\n   * Returns _true_ if it seems the websocket is connected\n   * @returns \n   */\n  isConnected: () => boolean\n}\n\nexport type ReconnectingWebsocketStates = `connecting` | `open` | `closed`;\n\nexport type ReconnectingOptions = {\n  startDelay: Interval\n  maxDelay: Interval\n  limitAttempts: number\n  /**\n   * How often to check the state of the\n   * underlying websocket.\n   * \n   * Default: 5s\n   */\n  checkStateMs: Interval\n  /**\n   * Callback when message is received\n   * @param message \n   * @returns \n   */\n  onMessage: (message: any) => void\n  onConnected: () => void\n  onDisconnected: () => void\n  onError: (error: any) => void\n}\n\nexport const reconnectingWebsocket = (url: string | URL, opts: Partial<ReconnectingOptions> = {}): ReconnectingWebsocket => {\n  const startDelayMs = intervalToMs(opts.startDelay, 2000);\n  const maxDelayMs = intervalToMs(opts.maxDelay, startDelayMs * 10);\n  const checkStateMs = intervalToMs(opts.checkStateMs, 5000)\n  if (startDelayMs > maxDelayMs) throw new Error(`startDelay should be less than maxDelay`);\n  if (checkStateMs < 0) throw new Error(`Param 'checkState' should be above zero`);\n  let reconnect = true;\n  let currentState = StateMachine.init({\n    closed: `connecting`,\n    open: `closed`,\n    connecting: [ `closed`, `open` ]\n  });//`closed`;\n\n  let ws: WebSocket | undefined;\n  const onError = (event_: any) => {\n    if (opts.onError) {\n      opts.onError(event_);\n    } else {\n      console.log(`rw on error`, event_);\n      console.error(` error: ${ event_.error }`);\n      console.error(` type: ${ event_.type }`);\n      console.error(` error msg: ${ event_.message }`);\n    }\n  }\n\n  const onMessage = (message: MessageEvent) => {\n    if (opts.onMessage) opts.onMessage(message.data);\n  }\n\n  const connect = async () => {\n    if (currentState.value === `connecting`) throw new Error(`Cannot connect twice`);\n    currentState = StateMachine.to(currentState, `connecting`);\n    if (ws !== undefined) {\n      ws.removeEventListener(`error`, onError);\n      if (opts.onMessage) {\n        ws.removeEventListener(`message`, onMessage);\n      }\n      ws = undefined;\n    }\n\n    // Keep trying to connect\n    const retry = await retryTask({\n      async probe(attempts: number) {\n        const wss = new WebSocket(url);\n        const r = await eventRace(wss, [ `open`, `error` ], { timeout: 1000 });\n        return r.type === `open` ? { success: true, value: wss } : { success: false, value: undefined };\n      },\n    }, { predelayMs: startDelayMs, limitAttempts: opts.limitAttempts });\n\n    // Final result\n    ws = retry.value;\n    let result = false;\n    if (retry.success && ws) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      ws.addEventListener(`error`, onError);\n      if (opts.onMessage) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        ws.addEventListener(`message`, onMessage);\n      }\n      result = true;\n      currentState = StateMachine.to(currentState, `open`);\n      if (opts.onConnected) opts.onConnected();\n    } else {\n      currentState = StateMachine.to(currentState, `closed`);\n    }\n    return result;\n  }\n\n  const send = (data: string | ArrayBufferLike | ArrayBufferView | Blob) => {\n    if (ws) {\n      if (ws.readyState === ws.OPEN) {\n        ws.send(data)\n      } else {\n        onDisconnected();\n      }\n    } else {\n      throw new Error(`Not connected`);\n    }\n  }\n\n  const onDisconnected = () => {\n    if (currentState.value === `closed`) return;\n    if (currentState.value === `open`) {\n      currentState = StateMachine.to(currentState, `closed`);\n      if (opts.onDisconnected) opts.onDisconnected();\n    }\n    if (reconnect && currentState.value !== `connecting`) {\n      console.log(`Scheduling connect`);\n      setTimeout(() => {\n        void connect();\n      }, 100)\n    }\n  }\n  const isConnected = () => {\n    if (!ws) return false;\n    return ws.readyState === ws.OPEN;\n  }\n\n  const close = () => {\n    reconnect = false;\n    currentState = StateMachine.to(currentState, `closed`);\n    ws?.close();\n    if (opts.onDisconnected) opts.onDisconnected();\n  }\n\n  const open = () => {\n    reconnect = true;\n    if (currentState.value === `open`) return Promise.resolve(true);\n    if (currentState.value === `connecting`) return Promise.resolve(false);\n    return connect();\n  }\n\n  void connect();\n\n  setInterval(() => {\n    if (!ws) return;\n    switch (ws.readyState) {\n      case ws.CLOSED: {\n        if (currentState.value === `open`) {\n          onDisconnected();\n        }\n        break;\n      }\n    }\n  }, checkStateMs);\n  return { send, isConnected, close, open }\n}"],"mappings":"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","names":["AudioAnalyser","freq","AudioAnalyser","freq","error","start","startWithVideoEl","capture","c","start"]}