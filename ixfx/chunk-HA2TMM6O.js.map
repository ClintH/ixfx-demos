{"version":3,"sources":["../src/iterables/chain/index.ts","../src/iterables/chain/Dom.ts","../src/iterables/chain/Util.ts","../src/iterables/chain/Links.ts","../src/iterables/chain/AddToArray.ts","../src/iterables/chain/AsArray.ts","../src/iterables/chain/AsCallback.ts","../src/iterables/chain/AsPromise.ts","../src/iterables/chain/AsValue.ts","../src/iterables/chain/Run.ts","../src/iterables/chain/Prepare.ts","../src/iterables/chain/from/index.ts","../src/iterables/chain/from/Array.ts","../src/iterables/chain/from/Event.ts","../src/iterables/chain/from/Function.ts","../src/iterables/chain/from/Iterable.ts","../src/iterables/chain/from/Ticks.ts","../src/iterables/chain/Lazy.ts","../src/iterables/chain/MergeFlat.ts","../src/iterables/chain/CombineLatestToArray.ts","../src/iterables/chain/CombineLatestToObject.ts","../src/iterables/chain/Single.ts","../src/iterables/chain/Sync.ts"],"sourcesContent":["export * as Dom from './Dom.js';\nexport * as Links from './Links.js';\nexport * from './Types.js';\n\nexport * from './AddToArray.js';\nexport * from './AsArray.js';\nexport * from './AsCallback.js';\nexport * from './AsPromise.js';\nexport * from './AsValue.js';\nexport * from './Prepare.js';\nexport * as From from './from/index.js';\nexport * from './Lazy.js';\nexport * from './MergeFlat.js';\nexport * from './CombineLatestToArray.js';\nexport * from './CombineLatestToObject.js';\nexport * from './Run.js';\nexport * from './Single.js';\nexport * from './Sync.js';\nexport * from './from/Ticks.js'\nexport * from './Util.js';\n\n\n","//import { query as DomQuery } from \"../../dom/Query.js\";\n\nimport type { GenOrData, Link } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { resolveEl } from \"../../dom/ResolveEl.js\";\nimport { toStringDefault } from \"../../util/index.js\";\n\nexport type QueryOptions = {\n  baseElement: HTMLElement;\n}\n\nexport type CreateOptions<In> = {\n  /**\n   * Parent element to create elements in. Defaults to `document.body`.\n   */\n  parentEl: string | HTMLElement\n  /**\n   * When set, provide a custom function to return a unique key for a value.\n   * This is used for matching values with elements when using immutable data.\n   * \n   * By default uses the\n   * JSON.stringify() representation.\n   * \n   * To match elements with values by reference, set `byReference` instead.\n   * \n   * @param value \n   * @returns \n   */\n  key: (value: In) => string\n  /**\n   * Default: _false_. When _true_, associate created elements\n   * to values by reference rather than value. This can be useful with mutable values.\n   * \n   * Use this _or_ the `key` option.\n   */\n  byReference: boolean\n  /**\n   * What kind of HTML element to make, defaults to DIV\n   */\n  tagName: string\n  /**\n   * Called whenever an element is created but not yet added to parent element\n   * @param element \n   * @returns \n   */\n  beforeInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element is inserted to the parent element\n   */\n  afterInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element has been removed\n   * @param element \n   * @returns \n   */\n  beforeRemove: (element: HTMLElement) => void\n}\n\nconst createMap = <T, TValue>(key?: (value: T) => string) => {\n  const keyFunction = key ?? ((value: T) => value);\n\n  const map = new Map<ReturnType<typeof keyFunction>, TValue>();\n  return {\n    has(key: T) {\n      return map.has(keyFunction(key));\n    },\n    get(key: T) {\n      return map.get(keyFunction(key));\n    },\n    set(key: T, value: TValue) {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      //console.log(`Chains.Dom.createMap: key: ${ keyFunction(key) } value: ${ value }`);\n      map.set(keyFunction(key), value);\n    },\n    entries() {\n      return map.entries();\n    },\n    delete(key: T | string) {\n      map.delete(key);\n    }\n  }\n\n}\n\nexport type ElementWithValue<T> = {\n  el: HTMLElement\n  value: T\n}\n\n/**\n * Creates a HTML element per value. By default compares\n * values by `JSON.stringify`. Set `byReference:true` to\n * compare values based on reference. Or provide a toString\n * function via `key`.\n * \n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n * \n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n * ```\n */\nexport function perValue<In>(options: Partial<CreateOptions<In>> = {}): Link<In, ElementWithValue<In>> {\n  const byReference = options.byReference;\n  const tagName = options.tagName ?? `div`;\n  if (byReference && options.key) throw new Error(`byReference and key options are mutually exclusive`);\n  const keyFunction = byReference ? undefined : options.key ?? toStringDefault;\n  const map = createMap<In, HTMLElement>(keyFunction);\n  const parentElementOrQuery = options.parentEl ?? document.body;\n  const parentEl = resolveEl(parentElementOrQuery);\n\n  const usedElements = new Set<HTMLElement>();\n\n  async function* perValue(input: GenOrData<In>): AsyncGenerator<ElementWithValue<In>> {\n    for await (const value of resolveToGen(input)) {\n      let el = map.get(value);\n      if (!el) {\n        el = document.createElement(tagName);\n        map.set(value, el);\n        if (options.beforeInsert) options.beforeInsert(el);\n        parentEl.append(el);\n        if (options.afterInsert) options.afterInsert(el);\n      }\n      usedElements.add(el);\n      yield { el, value };\n    }\n\n    // Remove unused elements\n    for (const [ id, el ] of map.entries()) {\n      if (usedElements.has(el)) continue;\n      if (options.beforeRemove) options.beforeRemove(el);\n      el.remove();\n      map.delete(id);\n    }\n  }\n  perValue._name = `dom.perValue`;\n  return perValue;\n}\n\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options \n * @returns \n */\nexport function query(options: Partial<QueryOptions> = {}): Link<string, HTMLElement> {\n  const baseElement = options.baseElement ?? document;\n\n  async function* query(input: GenOrData<string>): AsyncGenerator<HTMLElement> {\n    const gen = resolveToGen(input);\n    for await (const value of gen) {\n      for (const element of baseElement.querySelectorAll(value)) {\n        yield element as HTMLElement;\n      }\n    }\n  }\n  query._name = `dom.query`;\n  return query;\n}\n\n","import * as Async from \"../IterableAsync.js\";\nimport type { GenOrData, GenFactoryNoInput, Gen } from \"./Types.js\";\nimport { isAsyncIterable } from \"../Iterable.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\n\nexport function isGenFactoryNoInput<Out>(c: any): c is GenFactoryNoInput<Out> {\n  if (!(`_type` in c)) return false;\n  if (c._type === `GenFactoryNoInput`) return true;\n  return false;\n}\n\n/**\n * Wrap the primitive value as generator\n * @param value \n */\nfunction* primitiveToGenerator(value: number | boolean | string) {\n  yield value;\n}\n\n/**\n * Wrap the primitive value as an async generator\n * @param value \n */\nasync function* primitiveToAsyncGenerator(value: number | boolean | string) {\n  yield value;\n  await sleep(1);\n}\n\n/**\n * Resolve the array, data or function to a Generator\n * @param input \n * @returns \n */\nexport function resolveToGen<V>(input: GenOrData<V> | GenFactoryNoInput<V>): Gen<V> {\n  if (Array.isArray(input)) {\n    const a = input.values();\n    (a as any)._name = `arrayInput`;\n    return a;\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToGenerator(input) as Gen<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  }\n  return input;\n}\n\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input \n * @returns \n */\nexport function resolveToAsyncGen<V>(input: GenOrData<V> | GenFactoryNoInput<V> | undefined): AsyncGenerator<V> | undefined {\n  if (input === undefined) return;\n  if (Array.isArray(input)) {\n    return Async.fromArray(input);\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToAsyncGenerator(input) as AsyncGenerator<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  } else if (isAsyncIterable(input)) {\n    return input;\n  }\n  return Async.fromIterable(input);\n}\n","import { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport type { Link, GenOrData, DelayOptions } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { Elapsed } from \"../../flow/index.js\";\nimport { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport * as BasicProcessors from '../../data/BasicProcessors.js';\nimport type { RankArrayOptions, RankFunction, RankOptions } from \"../../data/Types.js\";\n\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (v: In) => Out): Link<In, Out> {\n  async function* transform(input: GenOrData<In>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield transformer(value);\n    }\n  }\n  transform._name = `transform`;\n  return transform;\n}\n\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit \n * @returns \n */\nexport function take<In>(limit: number): Link<In, In> {\n  async function* take(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let yielded = 0;\n    for await (const value of input) {\n      if (++yielded > limit) break;\n      yield value;\n    }\n  }\n  take._name = `take`;\n  return take;\n}\n\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `reducer` function.\n * \n * ```js\n * // Create a chain that flattens values\n * const reduce = Chains.reduce(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(reduce, [ 1, 2, 3]); // 3\n * ```\n * @param reducer Function to reduce array of values to a single value\n * @returns \n */\nexport function reduce<In, Out>(reducer: (v: Array<In>) => Out): Link<Array<In>, Out> {\n  async function* reduce(input: GenOrData<Array<In>>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield reducer(value);\n    }\n  }\n  reduce._name = `reduce`;\n  return reduce;\n}\n\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed \n * @returns \n */\nexport function duration<In>(elapsed: Interval): Link<In, In> {\n  const durationMs = intervalToMs(elapsed, 0);\n\n  async function* duration(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    const elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() > durationMs) break;\n      yield value;\n    }\n  }\n  duration._name = `duration`;\n  return duration;\n}\n\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options \n * @returns \n */\nexport function delay<In>(options: DelayOptions): Link<In, In> {\n  const before = intervalToMs(options.before, 0);\n  const after = intervalToMs(options.after, 0);\n\n  async function* delay(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (before > 0) {\n        await sleep(before);\n      }\n      yield value;\n      if (after > 0) {\n        await sleep(after);\n      }\n    }\n  }\n  delay._name = `delay`;\n  return delay;\n}\n\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n * \n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.run(\n *  // Produce values every 10ms for 350ms\n *  Chains.From.timestamp({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.Links.debounce(100)\n * );\n * ```\n * @param rate \n * @returns \n */\nexport function debounce<In>(rate: Interval): Link<In, In> {\n  const rateMs = intervalToMs(rate, 0);\n\n  async function* debounce(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() < rateMs) continue;\n      yield value;\n      elapsed = Elapsed.since();\n    }\n  }\n  debounce._name = `debounce`;\n  return debounce;\n}\n\n\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * ```js\n * const ch = Chains.run(\n *  Chains.From.timestamp({ interval: 100 }),\n *  Chains.Links.tally()\n * );\n * \n * for await (const v of ch) {\n *   // Produces: 1, 2, 3 ... every 100ms\n * }\n * ```\n * This is different than {@link sum} which adds up numeric values.\n * By default it adds up individual array items\n * @returns \n */\nexport function tally<In>(countArrayItems = true): Link<In, number> {\n  async function* tally(input: GenOrData<In>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.tally(countArrayItems);\n    for await (const v of input) {\n      yield p(v);\n    }\n  }\n  tally._name = `tally`;\n  return tally;\n}\n\n/**\n * Returns the smallest value from the input.\n * Can work with numbers or number[] as input.\n * Non-numeric data is filtered out.\n * @returns \n */\nexport function min(): Link<number | Array<number>, number> {\n  async function* min(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.min();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  min._name = `min`;\n  return min;\n}\n\n/**\n * Returns the largest value from the input.\n * - Non-numeric data is filtered out.\n * - Looks inside of numeric arrays.\n * @returns \n */\nexport function max(): Link<number | Array<number>, number> {\n  async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.max();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  max._name = `max`;\n  return max;\n}\n// export function max(): Link<number | Array<number>, number> {\n//   async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n//     input = resolveToGen(input);\n//     let max = Number.MIN_SAFE_INTEGER;\n//     for await (const value of input) {\n//       const valueArray = Array.isArray(value) ? value : [ value ];\n//       for (const subValue of valueArray) {\n//         if (typeof subValue !== `number`) break;\n//         max = Math.max(subValue, max);\n//         yield max;\n//       }\n//     }\n//   }\n//   max._name = `max`;\n//   return max;\n// }\n\n\n\n/**\n * Emits the currently ranked 'highest' value from a stream. Only\n * values exceeding the current highest are emitted.\n * \n * eg, if we are ranking on numerical value, an input stream of:\n * ```\n * 4, 1, 6, 10, 2, 4\n * ```\n * \n * Results in the output stream of:\n * ```\n * 4, 6, 10\n * ```\n * \n * @example \n * ```js\n * // Rank based on a field\n * Chains.Links.rank((a,b) => {\n *  if (a.size > b.size) return `a`; // Signals the first param is highest\n *  if (a.size < b.size) return `b`; // Signals the second param is highest\n *  return `eq`;\n * });\n * ```\n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}): Link<In, In> {\n  async function* rank(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    //let best: In | undefined;\n    const p = BasicProcessors.rank(r, options);\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  rank._name = `rank`;\n  return rank;\n}\n\n/**\n * Emits the highest-ranked value from amongst an array of values.\n * \n * By default, it tracks the highest-ranked _between_ arrays.\n * \n * For example:\n * ```js\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Outputs:\n * [ 6 ]\n * ```\n * \n * This behaviour can be modified with an option to only compare _within_ arrays.\n * ```\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Output:\n * [ 6, 3 ]\n * ```\n * \n * Uses the `rank` option to determine which is more highly ranked.\n * ```js\n * Chains.Links.rankArray(\n *  (a, b) => {\n *    if (a > b) return `a`; // a is higher\n *    else if (b > a) return `b`; // b is higher\n *    return `eq`; // same\n *  }\n * )\n * ```\n * @param options \n * @returns \n */\nexport function rankArray<In>(r: RankFunction<In>, options: Partial<RankArrayOptions> = {}): Link<Array<In>, In> {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  const withinArrays = options.withinArrays ?? false;\n\n  async function* rankArray(input: GenOrData<Array<In>>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let best: In | undefined;\n    for await (const value of input) {\n      let emit = false;\n      if (withinArrays) best = undefined; // Reset\n      for (const subValue of value) {\n        if (includeType && typeof subValue !== includeType) continue;\n        if (best === undefined) {\n          best = subValue;\n          emit = true;\n        } else {\n          const result = r(subValue, best);\n          if (result == `a`) {\n            // New value is the current best\n            best = subValue;\n            emit = true;\n          } else if (result === `eq` && emitEqualRanked) {\n            // New value is same rank as previous, but we have flag on\n            emit = true;\n          } else if (emitRepeatHighest) {\n            // Emit current highest due to flag\n            emit = true;\n          }\n        }\n      }\n\n      if (emit && best) yield best;\n    }\n  }\n  rankArray._name = `rankArray`;\n  return rankArray;\n}\n\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function average(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.average();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function sum(): Link<number, number> {\n  async function* total(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.sum();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  total._name = `total`;\n  return total;\n}\n\n/**\n * Chunks an input stream into `size` chunks.\n * \n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n * \n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size \n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns \n */\nexport function chunk<In>(size: number, returnRemainders = true): Link<In, Array<In>> {\n  throwIntegerTest(size, `aboveZero`, `size`);\n  async function* chunk(input: GenOrData<In>): AsyncGenerator<Array<In>> {\n    input = resolveToGen(input);\n    let buffer: Array<In> = [];\n    for await (const value of input) {\n      buffer.push(value);\n      if (buffer.length >= size) {\n        yield buffer;\n        buffer = []\n      }\n    }\n    if (returnRemainders && buffer.length > 0) yield buffer;\n  }\n  chunk._name = `chunk`;\n  return chunk;\n}\n\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n * \n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate \n * @returns \n */\nexport function filter<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* filter(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  filter._name = `filter`;\n  return filter;\n}\n\n\n\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n * \n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate \n * @returns \n */\nexport function drop<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* drop(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (!predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  drop._name = `drop`;\n  return drop;\n}\n","import type { GenFactoryNoInput } from \"./Types.js\";\n\n/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n * \n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap \n * @param array \n */\nexport async function addToArray<Out>(array: Array<Out>, valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    array.push(value);\n  }\n}","import type { GenFactoryNoInput } from \"./Types.js\"\n\nimport { toArray as AsyncToArray } from \"../IterableAsync.js\";\nimport type { ToArrayOptions } from \"../Types.js\";\n\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n * \n * If the chain is infinite, be sure to specify limits:\n * ```js\n * // Stop after we have five items\n * const values = await asArray(chain, { limit: 5 });\n * // Stop after 5 seconds has elapsed\n * const values = await asArray(chain, { elapsed: 5000 });\n * ```\n * @param valueToWrap \n * @returns \n */\nexport async function asArray<Out>(valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>, options: Partial<ToArrayOptions> = {}): Promise<Array<Out>> {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  return AsyncToArray(outputType, options);\n}","import type { GenFactoryNoInput, GenOrData } from \"./Types.js\";\n\n/**\n * Calls `callback` whenever the chain/generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap \n * @param callback \n */\nexport async function asCallback<V>(valueToWrap: GenOrData<V> | GenFactoryNoInput<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}","import type { GenFactoryNoInput } from \"./Types.js\";\n\n/**\n * Treats the chain/generator as a promise\n * \n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n * \n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap \n * @returns \n */\nexport function asPromise<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>) {\n  let lastValue: V | undefined;\n\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  async function asPromise(): Promise<V | undefined> {\n    const v = await outputType.next();\n    if (v.done) return;\n    lastValue = v.value;\n    return lastValue;\n  }\n  return asPromise;\n}","import type { GenFactoryNoInput } from \"./Types.js\";\n\n/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n * \n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n * \n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n * \n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns \n */\nexport function asValue<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>, initialValue?: V) {\n  let lastValue: V | undefined = initialValue;\n  let awaiting = false;\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  function asValue(): V | undefined {\n    if (!awaiting) {\n      awaiting = true;\n      outputType.next().then(v => {\n        lastValue = v.value;\n        awaiting = false;\n      }).catch((error: unknown) => {\n        awaiting = false;\n        throw error;\n      });\n    }\n    return lastValue;\n  }\n  return asValue;\n}","import type { LinksWithSource, Gen, GenOrData, GenFactoryNoInput, Link } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\n\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * \n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n * \n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param functions \n * @returns \n */\nexport async function* runN<In, Out>(...functions: LinksWithSource<In, Out>): AsyncGenerator<Out> {\n  let input: Gen<In> | undefined;\n  for (const fnOrData of functions) {\n    input = typeof fnOrData === `function` ? fnOrData(input ?? []) : resolveToGen(fnOrData);\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v as Out;\n  }\n}\n\nexport function run<T1>(gen: GenOrData<T1> | GenFactoryNoInput<T1>): AsyncGenerator<T1>;\nexport function run<T1, T2>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>): AsyncGenerator<T2>;\nexport function run<T1, T2, T3>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>): AsyncGenerator<T3>;\nexport function run<T1, T2, T3, T4>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>): AsyncGenerator<T4>;\nexport function run<T1, T2, T3, T4, T5>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>): AsyncGenerator<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>): AsyncGenerator<T6>;\nexport function run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>, l5: Link<T6, T7>): AsyncGenerator<T7>;\n\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * \n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n * \n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param gen \n * @param l0 \n * @param l1 \n * @param l2 \n * @param l3 \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0?: Link<T1, T2>, l1?: Link<T2, T3>, l2?: Link<T3, T4>, l3?: Link<T4, T5>, l4?: Link<T5, T6>, l5?: Link<T6, T7>): AsyncGenerator<T1> {\n  let input: Gen<any> | undefined;\n  // eslint-disable-next-line prefer-rest-params\n  const functions = arguments;\n  for (const fnOrData of functions) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (typeof fnOrData === `function`) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v;\n  }\n}\n","import { runN } from \"./Run.js\";\nimport type { GenFactoryNoInput, GenOrData, Links } from \"./Types.js\";\nimport * as Chains from \"./index.js\";\n\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => Number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\nexport function prepare<In, Out>(...functions: Links<In, Out>) {\n  const r = (source: GenOrData<In> | GenFactoryNoInput<In>) => {\n    return runN<In, Out>(source, ...functions);\n  }\n  return r;\n}\n\n// const chain = combine(\n//   Chains.Links.transform(v => Number.parseInt(v)),\n//   Chains.Links.filter(v => v % 2 === 0)\n// );\n// const read = chain(Chains.From.array([ 1, 2, 3 ], 100));\n","export * from './Array.js';\nexport * from './Event.js';\nexport * from './Function.js';\nexport * from './Iterable.js';\nexport * from './Ticks.js';","import type { Interval } from \"../../../flow/IntervalType.js\";\nimport { sleep } from \"../../../flow/Sleep.js\";\nimport type { GenFactoryNoInput } from \"../Types.js\";\n\n/**\n * Creates a chain from an array, reading values at a given interval\n * @param it \n * @param delay \n * @returns \n */\nexport function array<Out>(it: Array<Out>, delay: Interval = 5): GenFactoryNoInput<Out> {\n  async function* fromArray(): AsyncGenerator<Out> {\n    for (const v of it) {\n      await sleep(delay);\n      yield v;\n    }\n  }\n  fromArray._name = `fromArray`;\n  /* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion */\n  fromArray._type = `GenFactoryNoInput` as const;\n  return fromArray;\n}\n\n","import { promiseFromEvent } from \"../../../flow/PromiseFromEvent.js\";\nimport type { GenFactoryNoInput } from \"../Types.js\";\n\n/**\n * Create an iterable from an event\n * @param target Event source (eg HTML element)\n * @param name Name of event (eg. 'pointermove')\n * @returns \n */\nexport function event<Out>(target: EventTarget, name: string): GenFactoryNoInput<Out> {\n  async function* event(): AsyncGenerator<Out> {\n    while (true) {\n      yield await promiseFromEvent(target, name) as Out;\n    }\n  }\n  event._name = `event`;\n  /* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion */\n  event._type = `GenFactoryNoInput` as const;\n  return event;\n}\n\n\n//https://stackoverflow.com/questions/51045136/how-can-i-use-a-event-emitter-as-an-async-generator","import type { GenFactoryNoInput } from \"../Types.js\";\n\n/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n * \n * ```js\n * const callback = () => Math.random();\n * \n * const f = Chains.From.func(callback);\n * for await (const v of f) {\n *  // v is a new random number\n * }\n * ```\n * \n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.From.func(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback \n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function func<Out>(callback: () => Promise<Out> | Out): GenFactoryNoInput<Out> {\n  async function* fromFunction(): AsyncGenerator<Out> {\n    while (true) {\n      const v = await callback();\n      if (v === undefined) break;\n      yield v;\n    }\n  }\n\n  fromFunction._name = `fromFunction`;\n  /* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion */\n  fromFunction._type = `GenFactoryNoInput` as const;\n  return fromFunction;\n}\n","import type { GenFactoryNoInput } from \"../Types.js\";\n\n/**\n * Creates a chain from an interable\n * @param it \n * @returns \n */\nexport function iterable<Out>(it: Iterable<Out> | AsyncIterable<Out>): GenFactoryNoInput<Out> {\n  async function* fromIterable(): AsyncGenerator<Out> {\n    for await (const v of it) {\n      yield v;\n    }\n  }\n  fromIterable._name = `fromIterable`;\n  /* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion */\n  fromIterable._type = `GenFactoryNoInput` as const;\n  return fromIterable;\n}","import { intervalToMs } from \"../../../flow/IntervalType.js\";\nimport { sleep } from \"../../../flow/Sleep.js\";\nimport { Elapsed } from \"../../../flow/index.js\";\nimport type { GenFactoryNoInput, TickOptions } from \"../Types.js\";\n\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever. \n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n * \n * ```js\n * const c = Chains.From.timestamp({ interval: 1000 });\n * ```\n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options \n * @returns \n */\nexport function timestamp(options: TickOptions): GenFactoryNoInput<number> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const asClockTime = options.asClockTime ?? false;\n  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n  let looped = 0;\n  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n\n  async function* ts(): AsyncGenerator<number> {\n    const elapsed = Elapsed.since();\n    while (looped < loops && elapsed() < durationTime) {\n      yield asClockTime ? Date.now() : elapsed();\n\n      // Adjust sleep period so timing errors don't accumulate\n      const expectedTimeDiff = (looped * intervalMs) - elapsed();\n      await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n      looped++;\n    }\n  }\n  ts._name = `timestamp`;\n  /* eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion */\n  ts._type = `GenFactoryNoInput` as const;\n  return ts;\n}","import type { Interval } from \"../../flow/IntervalType.js\";\nimport * as Async from \"../IterableAsync.js\";\nimport { func as fromFunction } from \"./from/Function.js\";\nimport type { GenOrData, LazyChain, DelayOptions, Link } from \"./Types.js\";\nimport { isGenFactoryNoInput, resolveToAsyncGen } from \"./Util.js\";\nimport * as L from './Links.js';\nimport type { RankFunction, RankArrayOptions, RankOptions } from \"../../data/Types.js\";\n\nconst getLinkName = (c: Link<any, any>): string => {\n  //return c._name;\n  return c._name ?? c.name;\n}\n\nexport function lazy<In, Out>(): LazyChain<In, Out> {\n  const chained: Array<Link<any, any>> = [];\n  let dataToUse: GenOrData<In> | undefined;\n\n  const asGenerator = <V>(data?: GenOrData<In>) => {\n    if (data === undefined) data = dataToUse;\n    let d = resolveToAsyncGen(data);\n    for (const c of chained) {\n      if (d === undefined) {\n        if (isGenFactoryNoInput<In>(c)) {\n          d = c();\n        } else {\n          throw new Error(`Function '${ getLinkName(c) }' requires input. Provide it to the function, or call 'input' earlier.`)\n        }\n      } else {\n        d = c(d);\n      }\n    }\n    return d as AsyncGenerator<V>\n  }\n\n  const w: LazyChain<In, Out> = {\n    rankArray: (r: RankFunction<In>, options: Partial<RankArrayOptions>): LazyChain<In, Out> => {\n      chained.push(L.rankArray(r, options));\n      return w;\n    },\n    rank: (r: RankFunction<In>, options: Partial<RankOptions>): LazyChain<In, Out> => {\n      chained.push(L.rank(r, options));\n      return w;\n    },\n    transform: (transformer: (v: any) => any) => {\n      chained.push(L.transform(transformer));\n      return w;\n    },\n    reduce: (reducer: (values: Array<any>) => any) => {\n      // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-reduce\n      chained.push(L.reduce(reducer));\n      return w;\n    },\n    drop: (predicate: (v: In) => boolean) => {\n      chained.push(L.drop(predicate));\n      return w;\n    },\n    delay: (options: DelayOptions) => {\n      chained.push(L.delay(options));\n      return w;\n    },\n    duration: (elapsed: Interval) => {\n      chained.push(L.duration(elapsed));\n      return w;\n    },\n    debounce: (rate: Interval) => {\n      chained.push(L.debounce(rate));\n      return w;\n    },\n    fromFunction: (callback: () => any) => {\n      chained.push(fromFunction(callback));\n      return w;\n    },\n    take: (limit: number) => {\n      chained.push(L.take(limit));\n      return w;\n    },\n    chunk: (size: number, returnRemainders = true) => {\n      chained.push(L.chunk(size, returnRemainders))\n      return w;\n    },\n    filter: (predicate: (input: any) => boolean) => {\n      chained.push(L.filter(v => predicate(v)));\n      return w;\n    },\n    min: (): LazyChain<any, number> => {\n      chained.push(L.min());\n      return w as unknown as LazyChain<any, number>;\n    },\n    max: (): LazyChain<any, number> => {\n      chained.push(L.max());\n      return w as unknown as LazyChain<any, number>;\n    },\n    average: (): LazyChain<any, number> => {\n      chained.push(L.average());\n      return w as unknown as LazyChain<any, number>;\n    },\n    sum: (): LazyChain<any, number> => {\n      chained.push(L.sum());\n      return w as unknown as LazyChain<any, number>;\n    },\n    tally: (countArrayItems: boolean): LazyChain<any, number> => {\n      chained.push(L.tally(countArrayItems));\n      return w as unknown as LazyChain<any, number>;\n    },\n    input(data: GenOrData<In>) {\n      dataToUse = data;\n      return w\n    },\n    asGenerator,\n    asAsync(data?: GenOrData<In>) {\n      let d = data ?? dataToUse;\n      for (const c of chained) {\n        if (d === undefined && isGenFactoryNoInput<In>(c)) {\n          d = c();\n        } else if (d === undefined) {\n          throw new Error(`Function '${ getLinkName(c) }' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n        } else {\n          d = c(d);\n        }\n      }\n      return w;\n    },\n    asArray: async (data?: GenOrData<In>): Promise<Array<Out>> => {\n      const g = asGenerator<Out>(data);\n      return await Async.toArray<Out>(g);\n    },\n    firstOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      const v = await g.next();\n      return v.value as Out;\n    },\n    lastOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      let lastValue: Out | undefined;\n      for await (const v of g) {\n        lastValue = v as Out;\n      }\n      return lastValue;\n    },\n  }\n  return w as unknown as LazyChain<In, Out>;\n}","import type { GenFactoryNoInput, GenOrData } from \"./Types.js\";\nimport { Queues } from \"../../collections/index.js\";\nimport { sleep } from \"../..//flow/Sleep.js\";\nimport { resolveToAsyncGen } from \"./Util.js\";\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n * \n * Alternatively:\n * - {@link combineLatestToArray}/{@link combineLatestToObject} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link syncToArray}/{@link syncToObject} which releases a set of results when all inputs have emitted a value\n * @param sources \n */\nexport async function* mergeFlat<Out>(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Out> {\n  const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n  const buffer = Queues.mutable<Out>();\n  let completed = 0;\n\n  const schedule = async (source: AsyncGenerator<any> | undefined) => {\n    if (source === undefined) {\n      completed++;\n      return;\n    }\n\n    const x = await source.next();\n    if (x.done) {\n      completed++;\n    } else {\n      buffer.enqueue(x.value as Out);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(() => schedule(source), 1);\n    }\n  }\n\n  for (const source of sourcesInput) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(() => schedule(source), 1);\n  }\n\n  const loopSpeed = 10;\n  let loopFactor = 1;\n  while (completed < sourcesInput.length) {\n    const d = buffer.dequeue();\n    if (d === undefined) {\n      // Grow loop factor up to 10\n      loopFactor = Math.min(loopFactor + 1, 10);\n    } else {\n      yield d;\n      // Reset loop factor\n      loopFactor = 1;\n    }\n    await sleep(loopSpeed * loopFactor);\n  }\n}","import type { GenOrData, GenFactoryNoInput, CombineLatestOptions, Gen } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { isEqual as ArrayIsEqual } from \"../../data/arrays/Equality.js\";\n\n/**\n * Monitors sources, storing as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. The default is\n * 'break', meaning the whole combined stream stops.\n * \n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToArray(sources: Array<GenOrData<any> | GenFactoryNoInput<any>>, options: Partial<CombineLatestOptions> = {}): AsyncGenerator<Array<any>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const afterEmit = options.afterEmit ?? `last`;\n  type InputState = {\n    waiting: Promise<any> | undefined,\n    index: number\n    gen: Gen<any>\n    done: boolean\n    lastValue: any\n  }\n  const inputs = sources.map<InputState>((source, index) => ({ waiting: undefined, index, gen: resolveToGen(source), done: false, lastValue: undefined }));\n\n  const isDone = () => !inputs.some(v => !v.done);\n  const isWaiting = () => inputs.some(v => v.waiting !== undefined);\n  const allEmpty = (d: Array<any>) => !d.some(v => v !== undefined);\n\n  let lastEmitted: Array<any> = [];\n  //let count = 0;\n  while (true) {\n    const promises = [];\n    for (const input of inputs) {\n      //console.log(`  ${ input.index } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n      if (input.done) continue;\n      if (input.waiting !== undefined) {\n        promises.push(input.waiting);\n        continue;\n      }\n      const p = Promise.resolve((async () => {\n        if (input.done) return input;\n        const v = await input.gen.next();\n        input.waiting = undefined;\n        if (v.done) {\n          input.done = true;\n          if (finalValue === `undefined`) input.lastValue = undefined;\n        } else {\n          //console.log(`   ${ input.index } value: ${ v.value }`);\n          input.lastValue = v.value;\n        }\n        return input;\n      })());\n      input.waiting = p;\n      promises.push(p);\n    }\n    const won = await Promise.race(promises);\n\n    if (won.done && onSourceDone === `break`) break;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    const d = inputs.map(v => v.lastValue);\n    if (d.length === 0) {\n      return;\n    }\n\n    const dataEmpty = allEmpty(d);\n\n    if (dataEmpty && !isWaiting()) {\n      return;\n    }\n\n    if (!ArrayIsEqual(lastEmitted, d) && !dataEmpty) {\n      lastEmitted = d;\n      yield d;\n    }\n    if (afterEmit === `undefined`) {\n      for (const input of inputs) {\n        if (input.waiting !== undefined) continue;\n        input.lastValue = undefined;\n      }\n    }\n    if (isDone()) {\n      break;\n    }\n  }\n}\n","import type { GenOrData, GenFactoryNoInput, CombineLatestOptions, Gen, GenValueTypeObject } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport * as MapFns from \"../../data/maps/MapFns.js\"\nimport { isEqualValueIgnoreOrder } from \"../../util/IsEqual.js\";\n\n/**\n * Monitors sources, storing as they happen to an object.\n * Whenever a new value is emitted, the object is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToObject<const T extends Record<string, GenOrData<any> | GenFactoryNoInput<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}): AsyncGenerator<GenValueTypeObject<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const afterEmit = options.afterEmit ?? `last`;\n  type InputState = {\n    waiting: Promise<any> | undefined\n    gen: Gen<any>\n    done: boolean\n    lastValue: any\n    key: string\n  }\n\n  const states = new Map<string, InputState>();\n  for (const [ key, value ] of Object.entries(sources)) {\n    states.set(key, {\n      gen: resolveToGen(value),\n      done: false,\n      lastValue: undefined,\n      waiting: undefined,\n      key\n    })\n  }\n\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const isDone = () => !MapFns.some(states, v => !v.done);\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const isWaiting = () => MapFns.some(states, v => v.waiting !== undefined);\n  const allEmpty = (d: object) => {\n    for (const v of Object.values(d)) {\n      if (v !== undefined) return false;\n    }\n    return true;\n  }\n\n  const getData = (): GenValueTypeObject<T> => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      (r as any)[ key ] = state.lastValue;\n    }\n    return r as GenValueTypeObject<T>;\n  }\n  let lastEmitted: GenValueTypeObject<T> | undefined;\n\n  while (true) {\n    const promises = [];\n    for (const input of states.values()) {\n      //console.log(`  ${ input.key } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n      if (input.done) continue;\n      if (input.waiting !== undefined) {\n        promises.push(input.waiting);\n        continue;\n      }\n      const p = Promise.resolve((async () => {\n        if (input.done) return input;\n        const v = await input.gen.next();\n        input.waiting = undefined;\n        if (v.done) {\n          input.done = true;\n          if (finalValue === `undefined`) input.lastValue = undefined;\n        } else {\n          //console.log(`   ${ input.key } value: ${ v.value }`);\n          input.lastValue = v.value;\n        }\n        return input;\n      })());\n      input.waiting = p;\n      promises.push(p);\n    }\n    const won = await Promise.race(promises);\n\n    if (won.done && onSourceDone === `break`) break;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    const d = getData();\n    //console.log(`d`, d);\n    // if (isEqualValueIgnoreOrder(d, {} as any)) {\n    //   console.log(`keys is empty`);\n    //   return;\n    // }\n\n    const dataEmpty = allEmpty(d);\n    if (dataEmpty && !isWaiting()) {\n      //console.log(`dataEmpty and not waiting`);\n      return;\n    }\n\n    if (!isEqualValueIgnoreOrder(lastEmitted, d) && !dataEmpty) {\n      //console.log(` -- emitting!`);\n      lastEmitted = d;\n      yield d;\n    }\n    if (afterEmit === `undefined`) {\n      for (const input of states.values()) {\n        if (input.waiting !== undefined) continue;\n        input.lastValue = undefined;\n      }\n    }\n    if (isDone()) {\n      break;\n    }\n  }\n}\n","import type { Link } from \"./Types.js\";\n\n/**\n * Input a single value to the chain, return a single result\n * \n * \n * ```js\n * // Create chain link\n * const f = Chains.Links.flatten<string, string>(data => data.join(`-`));\n * // Input a single value (an array)\n * const r1 = await Chains.single(f, [ `a`, `b`, `c` ]);\n * // r1 = `a-b-c`\n * ```\n * @param f \n * @param input \n * @returns \n */\nexport async function single<In, Out>(f: Link<In, Out>, input: In): Promise<Out | undefined> {\n  const iterator = await f([ input ]).next();\n  return iterator.value as Out | undefined;\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport type { SleepOpts } from \"../../flow/Sleep.js\";\nimport * as Async from \"../IterableAsync.js\";\nimport type { GenOrData, GenFactoryNoInput, SyncOptions } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\n\n// export function syncToObject<const T extends Record<string, GenOrData<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): AsyncGenerator<GenValueTypeObject<T>> {\n//   const keys = Object.keys(reactiveSources)\n//   const values = Object.values(reactiveSources);\n\n//   const s = syncToArray(values, options);\n//   const st = transform(s, (streamValues) => {\n//     return zipKeyValue(keys, streamValues);\n//   });\n//   return st as AsyncGenerator<GenValueTypeObject<T>>;\n// }\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and \n * source C is still producing values, synchronisation is not possible \n * because A & B stopped producing values. Thus the stream will terminate\n * after `maximumWait` (2 seconds). Newer values from C are lost.\n */\nexport async function* syncToArray(sources: Array<GenOrData<any> | GenFactoryNoInput<any>>, options: Partial<SyncOptions> = {}): AsyncGenerator<Array<any>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  //const ac = new AbortController();\n  const maximumWaitMs = intervalToMs(options.maximumWait, 2000);\n  const finalValue = options.finalValue ?? `undefined`;\n  const inputs = sources.map(source => ({ seq: 0, lastValue: undefined, gen: resolveToGen(source), done: false }));\n  const nextWithTimeoutOpts: SleepOpts<any> = {\n    millis: maximumWaitMs\n  };\n  let seq = 0;\n  const isAllDone = () => !inputs.some(v => !v.done);\n  let go = true;\n  while (go) {\n    seq++;\n    for (const input of inputs) {\n      if (input.done) {\n        input.seq = seq;\n        continue;\n      }\n      // Read source, with a timeout\n      const v = await Async.nextWithTimeout(input.gen, nextWithTimeoutOpts);\n\n      // Input has finished\n      if (v.done) {\n        input.done = true;\n        input.seq = seq;\n        if (finalValue === `undefined`) {\n          input.lastValue = undefined;\n        }\n        if (onSourceDone === `break`) {\n          return;\n        }\n      } else {\n        // Stash away value\n        input.lastValue = v.value;\n        input.seq = seq;\n      }\n    }\n    if (go) {\n      // Return the set of data\n      const d = inputs.filter(v => v.seq === seq).map(v => v.lastValue);\n      if (d.length === 0) return;\n      if (!d.some(v => v !== undefined)) return;\n      yield d;\n    }\n    if (isAllDone()) go = false;\n  }\n  // let somethingProduced = true;\n\n  // while (somethingProduced) {\n  //   let data = [];\n  //   for (let index = 0; index < sourcesInput.length; index++) {\n  //     // eslint-disable-next-line unicorn/no-null\n  //     data[ index ] = null;\n  //   }\n\n  //   somethingProduced = false;\n  //   // Request the next value from each source\n  //   for (const [ index, source ] of sourcesInput.entries()) {\n  //     const v = await source.next();\n  //     if (!v.done) {\n  //       data[ index ] = v.value;\n  //       somethingProduced = true;\n  //     }\n  //   }\n  //   if (somethingProduced) {\n  //     // Send data\n  //     yield data;\n  //     data = [];\n  //   }\n  // }\n}"],"mappings":"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","names":["key","perValue","query","average","max","min","rank","sum","tally","transform","take","reduce","duration","elapsed","delay","debounce","tally","min","max","rank","rankArray","average","sum","chunk","filter","drop","array","asPromise","asValue","delay","fromArray","event","fromIterable","rank","min","max","average","sum","tally"]}