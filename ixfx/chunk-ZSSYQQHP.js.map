{"version":3,"sources":["../src/Events.ts","../src/collections/map/MapMultiFns.ts","../src/collections/map/MapOfSimpleBase.ts","../src/collections/map/MapOfSimpleMutable.ts"],"sourcesContent":["\nimport type { ISimpleEventEmitter, Listener } from './ISimpleEventEmitter.js';\nimport { ofSimpleMutable } from './collections/map/MapOfSimpleMutable.js';\n\nexport class SimpleEventEmitter<Events> implements ISimpleEventEmitter<Events> {\n  readonly #listeners = ofSimpleMutable<Listener<Events>>();\n\n  /**\n   * Fire event\n   * @private\n   * @param type Type of event\n   * @param args Arguments for event\n   * @returns\n   */\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[ K ]) {\n    const listeners = this.#listeners.get(type as string);\n    //console.log(`Firing ${type as string}`);\n    for (const l of listeners) {\n      l(args, this);\n    }\n  }\n\n  /**\n   * Adds event listener\n   *\n   * @template K\n   * @param {K} type\n   * @param {Listener<Events>} listener\n   * @memberof SimpleEventEmitter\n   */\n  addEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ): void {\n    // (this: any, ev: Events[K]) => any): void {\n    this.#listeners.addKeyedValues(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Remove event listener\n   *\n   * @param {Listener<Events>} listener\n   * @memberof SimpleEventEmitter\n   */\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ) {\n    // listener: Listener<Events>): void {\n    this.#listeners.deleteKeyValue(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Clear all event listeners\n   * @private\n   * @memberof SimpleEventEmitter\n   */\n  clearEventListeners() {\n    this.#listeners.clear();\n  }\n}\n\n// type TestEventMap = {\n//   readonly change: TestEvent\n//   readonly other: TestEvent2;\n// }\n\n// interface TestEvent2 {\n//   readonly something: string;\n// }\n// interface TestEvent {\n//   readonly blah: boolean;\n// }\n\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\n//   constructor() {\n//     super();\n//     this.addEventListener(`change`, (e) => {\n//       e.blah;\n//     });\n//   }\n// }\n\n/*\nexport class Event {\n  public target: any;\n  public type: string;\n  constructor(type: string, target: any) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  constructor(error: Error, target: any) {\n    super('error', target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  constructor(code = 1000, reason = '', target: any) {\n    super('close', target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nexport interface WebSocketEventListenerMap {\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\n}\n*/\n\nexport { type ISimpleEventEmitter, type Listener } from './ISimpleEventEmitter.js';","// âœ” UNIT TESTED\n\nimport { type IsEqual, isEqualDefault } from '../../IsEqual.js';\nimport type { IMapOf } from './IMapOf.js';\nimport type { IWithEntries } from './IMappish.js';\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByIterablePredicate(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByIterableValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByIterablePredicate = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (predicate(subValue, e[ 0 ])) return e;\n    }\n  }\n};\n\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = <V>(map: IMapOf<V>): number => {\n  //eslint-disable-next-line functional/no-let\n  let largest: readonly [ string, number ] = [ '', 0 ];\n  for (const e of map.keysAndCounts()) {\n    if (e[ 1 ] > largest[ 1 ]) {\n      largest = e;\n    }\n  }\n  return largest[ 1 ];\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByIterableValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByIterablePredicate} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByIterableValue = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (isEqual(subValue, value)) return e;\n    }\n  }\n};\n","import { type IsEqual, isEqualDefault } from '../../IsEqual.js';\nimport {\n  defaultKeyer,\n  type ToString,\n} from '../../Util.js';\nimport { firstEntryByIterableValue } from './MapMultiFns.js';\n\nexport class MapOfSimpleBase<V> {\n  protected map: Map<string, ReadonlyArray<V>>;\n  protected readonly groupBy;\n  protected valueEq;\n\n  /**\n   * Constructor\n   * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n   * @param valueEq Compare values. By default uses JS logic for equality\n   */\n  constructor(\n    groupBy: ToString<V> = defaultKeyer,\n    valueEq: IsEqual<V> = isEqualDefault<V>,\n    initial: [ string, readonly V[] ][] = []\n  ) {\n    this.groupBy = groupBy;\n    this.valueEq = valueEq;\n    this.map = new Map(initial);\n  }\n  /**\n   * Iterate over all entries\n   */\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const key of this.map.keys()) {\n      for (const value of this.map.get(key)!) {\n        yield [ key, value ];\n      }\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: V[] ]> {\n    for (const [ k, v ] of this.map.entries()) {\n      yield [ k, [ ...v ] ];\n    }\n  }\n\n  firstKeyByValue(value: V, eq: IsEqual<V> = isEqualDefault) {\n    const e = firstEntryByIterableValue(this, value, eq);\n    if (e) return e[ 0 ];\n  }\n\n  /**\n   * Get all values under `key`\n   * @param key\n   * @returns\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.map.get(key);\n    if (!m) return;\n    yield* m.values();\n  }\n\n  /**\n   * Iterate over all keys\n   */\n  *keys(): IterableIterator<string> {\n    yield* this.map.keys();\n  }\n\n  /**\n   * Iterate over all values (regardless of key)\n   */\n  *valuesFlat(): IterableIterator<V> {\n    for (const entries of this.map) {\n      yield* entries[ 1 ];\n    }\n  }\n\n  /**\n   * Iterate over keys and length of values stored under keys\n   */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const entries of this.map) {\n      yield [ entries[ 0 ], entries[ 1 ].length ];\n    }\n  }\n\n  /**\n   * Returns _true_ if `key` exists\n   * @param key\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Returns _true_ if `value` exists under `key`.\n   * @param key Key\n   * @param value Value to seek under `key`\n   * @returns _True_ if `value` exists under `key`.\n   */\n  hasKeyValue(key: string, value: V): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    for (const v of values) {\n      if (this.valueEq(v, value)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Debug dump of contents\n   * @returns\n   */\n  debugString(): string {\n    // eslint-disable-next-line functional/no-let\n    let r = ``;\n    const keys = Array.from(this.map.keys());\n    keys.every((k) => {\n      const v = this.map.get(k);\n      if (v === undefined) return;\n      r += k + ` (${ v.length }) = ${ JSON.stringify(v) }\\r\\n`;\n    });\n    return r;\n  }\n\n  /**\n   * _True_ if empty\n   */\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  /**\n   * Return number of values stored under `key`.\n   * Returns 0 if `key` is not found.\n   * @param key\n   * @returns\n   */\n  count(key: string): number {\n    const values = this.map.get(key);\n    if (!values) return 0;\n    return values.length;\n  }\n}\n","import { type IsEqual, isEqualDefault } from '../../IsEqual.js';\nimport {\n  type ToString,\n  defaultKeyer\n} from '../../Util.js';\nimport type { IMapOfMutable } from './IMapOfMutable.js';\nimport { MapOfSimpleBase } from './MapOfSimpleBase.js';\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @template V Type of items\n */\nexport class MapOfSimpleMutable<V>\n  extends MapOfSimpleBase<V>\n  implements IMapOfMutable<V>\n{\n  addKeyedValues(key: string, ...values: ReadonlyArray<V>) {\n    const existing = this.map.get(key);\n    if (existing === undefined) {\n      this.map.set(key, values);\n    } else {\n      this.map.set(key, [ ...existing, ...values ]);\n    }\n  }\n\n  /**\n   * Adds a value, automatically extracting a key via the\n   * `groupBy` function assigned in the constructor options.\n   * @param values Adds several values\n   */\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) {\n      const key = this.groupBy(v);\n      this.addKeyedValues(key, v);\n    }\n  }\n\n  /**\n   * Delete `value` under a particular `key`\n   * @param key\n   * @param value\n   * @returns _True_ if `value` was found under `key`\n   */\n  deleteKeyValue(key: string, value: V): boolean {\n    const existing = this.map.get(key);\n    if (existing === undefined) return false;\n    const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n    this.map.set(key, without);\n    return without.length < existing.length;\n  }\n\n  /**\n   * Deletes `value` regardless of key.\n   *\n   * Uses the constructor-defined equality function.\n   * @param value Value to delete\n   * @returns\n   */\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let del = false;\n    const entries = [ ...this.map.entries() ];\n    for (const keyEntries of entries) {\n      for (const values of keyEntries[ 1 ]) {\n        if (this.valueEq(values, value)) {\n          del = true;\n          this.deleteKeyValue(keyEntries[ 0 ], value);\n        }\n      }\n    }\n    return del;\n  }\n\n  /**\n   * Deletes all values under `key`,\n   * @param key\n   * @returns _True_ if `key` was found and values stored\n   */\n  delete(key: string): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    if (values.length === 0) return false;\n    this.map.delete(key);\n    return true;\n  }\n\n  /**\n   * Clear contents\n   */\n  clear() {\n    this.map.clear();\n  }\n}\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @template V Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = <V>(\n  groupBy: ToString<V> = defaultKeyer,\n  valueEq: IsEqual<V> = isEqualDefault<V>\n): IMapOfMutable<V> => new MapOfSimpleMutable<V>(groupBy, valueEq);\n"],"mappings":"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","names":[]}