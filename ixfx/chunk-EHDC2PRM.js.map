{"version":3,"sources":["../src/data/Compare.ts"],"sourcesContent":["import { mapKeys } from '../util/MapKeys.js';\nimport { isEqualDefault, type IsEqual } from '../util/IsEqual.js';\nimport { compareValuesShallow as IterableCompareValues } from '../iterables/CompareValues.js';\nexport type ChangeKind = `mutate` | `add` | `del`\nexport type ChangeRecord<TKey extends string | number | symbol> = [ kind: ChangeKind, path: TKey, value: any ];\n\n/**\n * Result of {@link compareData}\n */\nexport type CompareChangeSet<TKey extends string | number> = {\n  /**\n   * _True_ if there are any changes\n   */\n  hasChanged: boolean\n  /**\n   * Results for child objects\n   */\n  children: Record<TKey, CompareChangeSet<any>>\n  /**\n   * Values that have changed\n   */\n  changed: Record<TKey, any>\n  /**\n   * Fields that have been added\n   */\n  added: Record<TKey, any>\n  /**\n   * Fields that have been removed\n   */\n  removed: Array<TKey>\n  isArray: boolean\n  /**\n   * Summary of changes\n   */\n  summary: Array<ChangeRecord<TKey>>\n}\n\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const compareKeys = (a: object, b: object) => {\n  const c = IterableCompareValues(Object.keys(a), Object.keys(b));\n  return c;\n}\n\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n * \n * ```js\n * const a = { msg: `hi`, v: 10 };\n * \n * changedDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n * \n * Under the hood, we use {@link compareData}(a, b, true). If B has additional or removed fields,\n * this is considered an error.\n * \n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a \n * @param b \n */\nexport const changedDataFields = (a: object, b: object) => {\n  const r = compareData(a, b, true);\n  if (Object.entries(r.added).length > 0) throw new Error(`Shape of data has changed`);\n  if (Object.entries(r.removed).length > 0) throw new Error(`Shape of data has changed`);\n\n  const output = compareResultToObject(r, b);\n  return output;\n}\n\nconst compareResultToObject = (r: CompareChangeSet<any>, b: object): Record<string, any> | Array<any> => {\n  const output = {}\n\n  if (r.isArray) {\n    return b;\n  }\n\n  for (const entry of Object.entries(r.changed)) {\n    (output as any)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n  for (const entry of Object.entries(r.added)) {\n    (output as any)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n\n  for (const childEntry of Object.entries(r.children)) {\n    if (childEntry[ 1 ].hasChanged) {\n      (output as any)[ childEntry[ 0 ] ] = compareResultToObject(childEntry[ 1 ], (b as any)[ childEntry[ 0 ] ]);\n    }\n  }\n  return output;\n}\n\nexport const compareArrays = <TValue>(a: Array<TValue>, b: Array<TValue>, eq: IsEqual<TValue> = isEqualDefault<TValue>): CompareChangeSet<number> => {\n  if (!Array.isArray(a)) throw new Error(`Param 'a' is not an array`);\n  if (!Array.isArray(b)) throw new Error(`Param 'b' is not an array`);\n  const c = compareData(a, b, false, eq);\n  if (!c.isArray) throw new Error(`Change set does not have arrays as parameters`);\n\n  const convert = (key: string) => {\n    if (key.startsWith(`_`)) {\n      return Number.parseInt(key.slice(1));\n    } else throw new Error(`Unexpected key '${ key }'`);\n  }\n  const cc: CompareChangeSet<number> = {\n    ...c,\n    added: mapKeys(c.added, convert),\n    changed: mapKeys(c.changed, convert),\n    removed: c.removed.map(v => convert(v)),\n    summary: c.summary.map(value => {\n      return [ value[ 0 ], convert(value[ 1 ]), value[ 2 ] ];\n    })\n  }\n  return cc;\n}\n\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the \n * values are primitive values or other simple objects. It also works with arrays.\n * \n * Uses === equality semantics by default.\n * @param a \n * @param b \n */\nexport const compareData = (a: object, b: object, assumeSameShape = false, eq: IsEqual<any> = isEqualDefault): CompareChangeSet<string> => {\n  const entriesA = Object.entries(a);\n  const entriesB = Object.entries(b);\n\n  const scannedKeys = new Set<string>();\n  const changed = {}\n  const added = {}\n  const children = {}\n  const removed: Array<string> = [];\n  const isArray = Array.isArray(a);\n\n  const summary = new Array<ChangeRecord<string>>();\n  let hasChanged = false;\n\n  // Look for existing entries of A that are modified\n  for (const entry of entriesA) {\n    const outputKey = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n    const aValue = entry[ 1 ];\n    const bValue = (b as any)[ entry[ 0 ] ];\n    scannedKeys.add(entry[ 0 ]);\n\n    if (bValue === undefined) {\n      // B does not have a key from A\n      hasChanged = true;\n      if (assumeSameShape && !isArray) {\n        // If we're assuming it's the same shape, then _undefined_ is actually the value\n        (changed as any)[ outputKey ] = bValue;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      } else {\n        // Key removed\n        removed.push(outputKey);\n        summary.push([ `del`, outputKey, aValue ]);\n      }\n      continue;\n    }\n\n    if (typeof aValue === `object`) {\n      const r = compareData(aValue, bValue, assumeSameShape, eq);\n      if (r.hasChanged) hasChanged = true;\n      (children as any)[ outputKey ] = r;\n      const childSummary = r.summary.map(sum => { return [ sum[ 0 ], outputKey + `.` + sum[ 1 ], sum[ 2 ] ] }) as Array<ChangeRecord<string>>;\n      summary.push(...childSummary);\n    } else {\n      if (!eq(aValue, bValue)) {\n        (changed as any)[ outputKey ] = bValue;\n        hasChanged = true;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      }\n    }\n  }\n\n  // Look for entries in B that weren't in A\n  if (!assumeSameShape || isArray) {\n    for (const entry of entriesB) {\n      const key = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n\n      if (scannedKeys.has(entry[ 0 ])) continue;\n      (added as any)[ key ] = entry[ 1 ];\n      hasChanged = true;\n      summary.push([ `add`, key, entry[ 1 ] ])\n    }\n  }\n  return {\n    changed, added, removed, children, hasChanged, isArray, summary\n  }\n}"],"mappings":"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","names":[]}