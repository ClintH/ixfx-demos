{"version":3,"sources":["../src/Generators.ts"],"sourcesContent":["import { throwIntegerTest, throwNumberTest } from './Guards.js';\nexport { pingPong, pingPongPercent } from './modulation/PingPong.js';\nexport * as Async from './IterableAsync.js';\nexport * as Sync from './IterableSync.js';\n\nexport { interval } from './flow/Interval.js';\nexport { delayLoop, type DelayOpts } from './flow/Delay.js';\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using\n * {@link Flow.repeat}.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/generators.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport const count = function* (amount: number, offset = 0) {\n  // Unit tested.\n  throwIntegerTest(amount, ``, `amount`);\n  throwIntegerTest(offset, ``, `offset`);\n\n  if (amount === 0) return;\n\n  let index = 0;\n  do {\n    yield (amount < 0 ? -index + offset : index + offset);\n  } while (index++ < Math.abs(amount) - 1);\n};\n\n/**\n * Returns a number range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};\n\nexport { integerUniqueGen as randomUniqueInteger } from './random/index.js';"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuBO,IAAM,kBAAkB,WAC7BA,WACA,QAAQ,GACR,KACA,YAAY,OACZ;AACA,MAAIA,aAAY;AAAG,UAAM,IAAI,MAAM,uCAAuC;AAC1E,MAAI,QAAQ;AAAW,UAAM,OAAO;AACpC,MAAI,IAAI;AACR,KAAG;AACD,WAAO,IAAI,KAAK;AACd,YAAM;AACN,WAAKA;AAAA,IACP;AAAA,EACF,SAAS;AACX;AA6BO,IAAM,eAAe,WAC1BA,WACA,QAAQ,GACR,KACA,YAAY,OACZ,UACA;AACA,kBAAgBA,WAAU,SAAS;AAEnC,QAAM,mBAAmBA,YAAW;AACpC,MAAI,QAAQ,QAAW;AAAA,EAEvB,OAAO;AACL,QAAI,oBAAoB,QAAQ,KAAK;AACnC,YAAM,IAAI;AAAA,QACR,eAAgBA,SAAS,uBAAwB,KAAM,OAAQ,GAAI;AAAA,MACrE;AAAA,IACF;AACA,QAAI,CAAC,oBAAoB,QAAQ,KAAK;AACpC,YAAM,IAAI;AAAA,QACR,eAAgBA,SAAS,uBAAwB,KAAM,OAAQ,GAAI;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAEA,aAAW,YAAY;AACvB,MAAI,QAAQ;AAAW,UAAM,OAAO;AAAA;AAC/B,WAAO;AACZ,EAAAA,YAAWA,YAAW;AAEtB,KAAG;AACD,QAAI,IAAI,QAAQ;AAChB,WAAQ,CAAC,oBAAoB,KAAK,OAAS,oBAAoB,KAAK,KAAM;AACxE,YAAM,IAAI;AACV,WAAKA;AAAA,IACP;AAAA,EACF,SAAS;AACX;AAoCO,IAAM,QAAQ,WAAW,QAAgB,SAAS,GAAG;AAE1D,mBAAiB,QAAQ,IAAI,QAAQ;AACrC,mBAAiB,QAAQ,IAAI,QAAQ;AAErC,MAAI,WAAW;AAAG;AAElB,MAAI,QAAQ;AACZ,KAAG;AACD,UAAO,SAAS,IAAI,CAAC,QAAQ,SAAS,QAAQ;AAAA,EAChD,SAAS,UAAU,KAAK,IAAI,MAAM,IAAI;AACxC;AAsBO,IAAM,iBAAiB,SAC5BA,YAAW,MACX,YAAY,OACZ,QAAQ,GACR,MAAM,GACN;AACA,kBAAgBA,WAAU,cAAc,UAAU;AAClD,kBAAgB,OAAO,cAAc,OAAO;AAC5C,kBAAgB,KAAK,cAAc,KAAK;AACxC,SAAO,aAAaA,WAAU,OAAO,KAAK,SAAS;AACrD;","names":["interval"]}