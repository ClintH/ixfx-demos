{"version":3,"sources":["../src/numbers/index.ts","../src/numbers/ApplyToValues.ts","../src/numbers/Guard.ts","../src/numbers/Filter.ts","../src/numbers/Generate.ts","../src/numbers/IsApproximately.ts","../src/numbers/RelativeDifference.ts"],"sourcesContent":["/**\n * * {@link average}, {@link max}, {@link min}, {@link total}: Calculate average/max/min/total\n * * {@link averageWeighted}: Calculate average, but applies a weighting function, eg to favour items at beginning of array\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * {@link maxIndex}, {@link minIndex}: Return index of largest/smallest value\n * * {@link dotProduct}: Returns the dot-product between two arrays\n * * {@link weight}: Applies a weighting function to all values based on their index\n * * See also {@link Numbers} module for working with numbers in general.\n * @module\n */\n\nimport { numberTracker } from '../data/NumberTracker.js';\nimport { type TrackedValueOpts as TrackedValueOptions } from '../data/TrackedValue.js';\nexport * from './ApplyToValues.js';\nexport * from './AverageWeighted.js'\nexport * from './Count.js';\nexport * from './Filter.js';\nexport * from './Generate.js';\nexport * from './Guard.js';\nexport * from './IsApproximately.js';\nexport * from './LinearSpace.js';\nexport * from './MinMaxAvg.js';\nexport * from './NumericArrays.js';\nexport * from './Quantise.js';\nexport * from './RelativeDifference.js';\nexport * from './Round.js';\nexport type * from './Types.js';\nexport * from '../modulation/PingPong.js';\nexport * from '../modulation/Jitter.js';\nexport { integer as randomInteger, integerUniqueGen as randomUniqueInteger } from '../random/Integer.js';\n\n/**\n * Alias for [Data.numberTracker](https://clinth.github.io/ixfx/classes/Data.numberTracker-1.html)\n */\nexport const tracker = (options?: TrackedValueOptions) => numberTracker(options);","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n * \n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object \n * @param apply \n * @returns \n */\nexport const applyToValues = <T extends Record<string, any>>(object: T, apply: (v: number) => number): T => {\n  const o: T = { ...object };\n  for (const [ key, value ] of Object.entries(object)) {\n    if (typeof value === `number`) {\n      // Run number through function\n      //eslint-disable-next-line functional/immutable-data\n      (o as any)[ key ] = apply(value);\n    } else {\n      // Copy value\n      //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n      (o as any)[ key ] = value;\n    }\n  }\n  return o;\n}","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber: unknown) => {\n  if (typeof possibleNumber !== `number`) return false;\n  if (Number.isNaN(possibleNumber)) return false;\n  return true;\n};","import { isValid } from './Guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filter(data)) {\n *  // 5\n * }\n * ```\n * @param it\n */\n//eslint-disable-next-line func-style\nexport function* filter(it: Iterable<unknown>) {\n  for (const v of it) {\n    if (isValid(v)) yield v;\n  }\n}\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\n\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n\n\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { round } from \"./Round.js\";\n\nexport function isApproximately(\n  baseValue: number,\n  rangePercent: number\n): (v: number) => boolean;\n\nexport function isApproximately(\n  baseValue: number,\n  rangePercent: number,\n  v: number\n): boolean;\n\n/**\n * Returns a function that yields _true_ if a value is within\n * a percentage range of a base value.\n *\n * ```js\n * // Allow 10% above or below\n * const closeTo100 = isApproximately(100, 0.1); // returns a function\n * closeTo100(100); // true\n * closeTo100(101); // true;\n * closeTo100(90); // true;\n * closeTo100(80); // false;\n * ```\n *\n * `isApproximately` returns a function, but if a third value is provided,\n * it returns true/false, testing the value:\n * ```js\n * isApproximately(100, 0.1, 101); // True\n * ```\n * If the tested value is not a number, _false_ is returned\n * (because it is not, in fact approximately `baseValue`).\n *\n * For baseValues between -2 and 2, the calculated difference is rounded down\n * to 5 decimal places to avoid weird JS floating point math.\n * @param baseValue\n * @param rangePercent\n * @returns\n */\nexport function isApproximately(\n  baseValue: number,\n  rangePercent: number,\n  v?: number\n) {\n  throwNumberTest(rangePercent, `percentage`, `rangePercent`);\n  throwNumberTest(baseValue, ``, `baseValue`);\n\n  const diff = baseValue * rangePercent;\n  const test = (v: number): boolean => {\n    try {\n      throwNumberTest(v, ``, `v`);\n\n      //eslint-disable-next-line functional/no-let\n      let diffV = Math.abs(v - baseValue);\n      if (Math.abs(baseValue) <= 2) {\n        diffV = round(5, diffV);\n      }\n      return diffV <= diff;\n    } catch {\n      return false;\n    }\n  };\n\n  return v === undefined ? test : test(v);\n}\n","/**\n * Returns the relative difference from the `initial` value\n * ```js\n * const rel = relativeDifference(100);\n * rel(100); // 1\n * rel(150); // 1.5\n * rel(50);  // 0.5\n * ```\n *\n * The code for this is simple:\n * ```js\n * const relativeDifference = (initial) => (v) => v/initial\n * ```\n * @param {number} initial\n * @returns\n */\nexport const relativeDifference = (initial: number) => (v: number) =>\n  v / initial;"],"mappings":"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","names":["v"]}