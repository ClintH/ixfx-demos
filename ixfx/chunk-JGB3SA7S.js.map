{"version":3,"sources":["../src/collections/set/index.ts","../src/collections/set/SetMutable.ts","../src/collections/set/SetImmutable.ts","../src/collections/set/MassiveSet.ts"],"sourcesContent":["\n\nexport { mutable } from './SetMutable.js';\nexport { immutable } from './SetImmutable.js';\nexport { type ISetMutable } from './ISetMutable.js';\nexport { type ISetImmutable } from './ISetImmutable.js';\nexport * from './MassiveSet.js';\nexport type * from './Types.js';","// ✔ UNIT TESTED\nimport type { ToString } from '../../util/index.js';\nimport { defaultKeyer } from '../../DefaultKeyer.js';\nimport { SimpleEventEmitter } from '../../Events.js';\nimport { type ISetMutable } from './ISetMutable.js';\nimport { type ValueSetEventMap } from './Types.js';\n\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = <V>(\n  keyString?: ToString<V> | undefined\n): ISetMutable<V> => new SetStringMutable(keyString);\n\n/**\n * Mutable string set\n */\nexport class SetStringMutable<V>\n  extends SimpleEventEmitter<ValueSetEventMap<V>>\n  implements ISetMutable<V> {\n  // ✔ UNIT TESTED\n  /* eslint-disable functional/prefer-readonly-type */\n  store = new Map<string, V>();\n  keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n   */\n  constructor(keyString: ToString<V> | undefined) {\n    super();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  /**\n   * Number of items stored in set\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Adds one or more items to set. `add` event is fired for each item\n   * @param values items to add\n   */\n  add(...values: Array<V>): boolean {\n    //eslint-disable-next-line functional/no-let\n    let somethingAdded = false;\n    for (const value of values) {\n      const isUpdated = this.has(value);\n      this.store.set(this.keyString(value), value);\n      super.fireEvent(`add`, { value: value, updated: isUpdated });\n      if (!isUpdated) somethingAdded = true;\n    }\n    return somethingAdded;\n  }\n\n  /**\n   * Returns values from set as an iterable\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  values() {\n    return this.store.values();\n  }\n\n  /**\n   * Clear items from set\n   */\n  clear() {\n    this.store.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  /**\n   * Delete value from set.\n   * @param v Value to delete\n   * @returns _True_ if item was found and removed\n   */\n  delete(v: V): boolean {\n    const isDeleted = this.store.delete(this.keyString(v));\n    if (isDeleted) super.fireEvent(`delete`, v);\n    return isDeleted;\n  }\n\n  /**\n   * Returns _true_ if item exists in set\n   * @param v\n   * @returns\n   */\n  has(v: V): boolean {\n    return this.store.has(this.keyString(v));\n  }\n\n  /**\n   * Returns array copy of set\n   * @returns Array copy of set\n   */\n  toArray(): Array<V> {\n    return [ ...this.store.values() ];\n  }\n}\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type ToString, toStringDefault } from '../../util/index.js';\nimport { type ISetImmutable } from './ISetImmutable.js';\n\nexport class SetStringImmutable<V> implements ISetImmutable<V> {\n  private store: Map<string, V>;\n  private keyString;\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(keyString?: ToString<V>, map?: Map<string, V>) {\n    this.store = map ?? new Map<string, V>();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  get size(): number {\n    return this.store.size;\n  }\n\n  add(...values: ReadonlyArray<V>): ISetImmutable<V> {\n    const s = new Map<string, V>(this.store);\n    for (const v of values) {\n      const key = this.keyString(v);\n      s.set(key, v);\n    }\n    return new SetStringImmutable<V>(this.keyString, s);\n  }\n\n  delete(v: V): ISetImmutable<V> {\n    const s = new Map<string, V>(this.store);\n    const key = this.keyString(v);\n    if (s.delete(key)) return new SetStringImmutable(this.keyString, s);\n    return this;\n  }\n\n  has(v: V): boolean {\n    const key = this.keyString(v);\n    return this.store.has(key);\n  }\n\n  toArray(): Array<V> {\n    return [ ...this.store.values() ];\n  }\n\n  *values() {\n    yield* this.store.values();\n  }\n}\n\n/**\n * Immutable set that uses a `keyString` function to determine uniqueness\n *\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`.\n * @returns\n */\nexport const immutable = <V>(\n  keyString: ToString<V> = toStringDefault\n): ISetImmutable<V> => new SetStringImmutable(keyString);\n","/**\n * MassiveSet supports semantics similar to Set, but without the\n * limitation on how much data is stored.\n * \n * It only supports strings, and stores data in a hierarchy.\n * \n * ```js\n * const set = new MassiveSet(); // maxDepth=1 default\n * set.add(`test`);\n * set.add(`bloorp`);\n * ```\n * \n * In the above example, it will create a subtree for the first letter\n * of each key, putting the value underneath it. So we'd get a sub\n * MassiveSet for every key starting with 't' and every one starting with 'b'.\n * \n * If `maxDepth` was 2, we'd get the same two top-level nodes, but then\n * another sub-node based on the _second_ character of the value.\n * \n * It's not a very smart data-structure since it does no self-balancing\n * or tuning.\n */\nexport class MassiveSet {\n  #depth\n  #maxDepth;\n  children = new Map<string, MassiveSet>();\n  values: Array<string> = [];\n\n  constructor(maxDepth = 1, depth = 0) {\n    this.#depth = depth;\n    this.#maxDepth = maxDepth;\n  }\n\n  /**\n   * Returns the number of values stored in just this level of the set\n   * @returns \n   */\n  sizeLocal() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the number of branches at this node\n   * Use {@link sizeChildrenDeep} to count all branches recursively\n   * @returns \n   */\n  sizeChildren() {\n    return [ ...this.children.values() ].length;\n  }\n\n  sizeChildrenDeep() {\n    let t = this.sizeChildren();\n    for (const c of this.children.values()) {\n      t += c.sizeChildrenDeep();\n    }\n    return t;\n  }\n\n  /**\n   * Returns the total number of values stored in the set\n   */\n  size() {\n    let x = this.values.length;\n    for (const set of this.children.values()) {\n      x += set.size();\n    }\n    return x;\n  }\n\n  add(value: string) {\n    if (typeof value !== `string`) throw new Error(`Param 'value' must be a string. Got: ${ typeof value }`);\n\n    if (value.length === 0) throw new Error(`Param 'value' is empty`);\n\n    const destination = this.#getChild(value, true);\n    if (destination === this) {\n      if (!this.hasLocal(value)) {\n        this.values.push(value);\n      }\n      return;\n    }\n\n    if (!destination) throw new Error(`Could not create child set for: ${ value }`);\n    destination.add(value);\n  }\n\n  remove(value: string): boolean {\n    if (typeof value !== `string`) throw new Error(`Param 'value' must be a string. Got: ${ typeof value }`);\n    if (value.length === 0) throw new Error(`Param 'value' is empty`);\n\n    const destination = this.#getChild(value, false);\n    if (destination === undefined) return false;\n    if (destination === this) {\n      if (this.hasLocal(value)) {\n        this.values = this.values.filter(v => v !== value);\n        return true;\n      }\n      return false; // Not found\n    }\n    return destination.remove(value);\n  }\n\n  debugDump() {\n    const r = this.#dumpToArray();\n    for (const rr of r) {\n      console.log(rr);\n    }\n  }\n\n  #dumpToArray(depth = 0) {\n    const r: Array<string> = [];\n    r.push(`Depth: ${ this.#depth } Max: ${ this.#maxDepth }`);\n    for (const [ key, value ] of this.children.entries()) {\n      const dumped = value.#dumpToArray(depth + 1);\n      r.push(` key: ${ key }`);\n      for (const d of dumped) {\n        r.push(` `.repeat(depth + 1) + d);\n      }\n    }\n\n    r.push(`Values: (${ this.values.length })`);\n    for (const v of this.values) {\n      r.push(` ${ v }`);\n    }\n    return r.map(line => ` `.repeat(depth) + line);\n  }\n\n  #getChild(value: string, create: boolean) {\n    if (value === undefined) throw new Error(`Param 'value' undefined`);\n    if (this.#depth === this.#maxDepth) return this;\n    if (value.length <= this.#depth) return this;\n    const k = value[ this.#depth ];\n    if (k === undefined) throw new Error(`Logic error. Depth: ${ this.#depth } Len: ${ value.length }`);\n    let child = this.children.get(k);\n    if (child === undefined && create) {\n      child = new MassiveSet(this.#maxDepth, this.#depth + 1);\n      this.children.set(k, child);\n    }\n    return child;\n  }\n\n  /**\n   * Returns _true_ if `value` stored on this node\n   * @param value \n   * @returns \n   */\n  hasLocal(value: string) {\n    for (const v of this.values) {\n      if (v === value) return true;\n    }\n    return false;\n  }\n\n  has(value: string): boolean {\n    if (typeof value !== `string`) return false;\n\n    const destination = this.#getChild(value, false);\n    if (destination === undefined) return false;\n    if (destination === this) return this.hasLocal(value);\n    return destination.has(value);\n  }\n}"],"mappings":";;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACYO,IAAM,UAAU,CACrB,cACmB,IAAI,iBAAiB,SAAS;AAK5C,IAAM,mBAAN,cACG,mBACkB;AAAA;AAAA;AAAA,EAG1B,QAAQ,oBAAI,IAAe;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,WAAoC;AAC9C,UAAM;AACN,SAAK,YAAY,aAAa;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAO;AACT,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,QAA2B;AAEhC,QAAI,iBAAiB;AACrB,eAAW,SAAS,QAAQ;AAC1B,YAAM,YAAY,KAAK,IAAI,KAAK;AAChC,WAAK,MAAM,IAAI,KAAK,UAAU,KAAK,GAAG,KAAK;AAC3C,YAAM,UAAU,OAAO,EAAE,OAAc,SAAS,UAAU,CAAC;AAC3D,UAAI,CAAC,UAAW,kBAAiB;AAAA,IACnC;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACP,WAAO,KAAK,MAAM,OAAO;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,MAAM,MAAM;AACjB,UAAM,UAAU,SAAS,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,GAAe;AACpB,UAAM,YAAY,KAAK,MAAM,OAAO,KAAK,UAAU,CAAC,CAAC;AACrD,QAAI,UAAW,OAAM,UAAU,UAAU,CAAC;AAC1C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,GAAe;AACjB,WAAO,KAAK,MAAM,IAAI,KAAK,UAAU,CAAC,CAAC;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAoB;AAClB,WAAO,CAAE,GAAG,KAAK,MAAM,OAAO,CAAE;AAAA,EAClC;AACF;;;ACnGO,IAAM,qBAAN,MAAM,oBAAkD;AAAA,EACrD;AAAA,EACA;AAAA;AAAA,EAGR,YAAY,WAAyB,KAAsB;AACzD,SAAK,QAAQ,OAAO,oBAAI,IAAe;AACvC,SAAK,YAAY,aAAa;AAAA,EAChC;AAAA,EAEA,IAAI,OAAe;AACjB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA,EAEA,OAAO,QAA4C;AACjD,UAAM,IAAI,IAAI,IAAe,KAAK,KAAK;AACvC,eAAW,KAAK,QAAQ;AACtB,YAAM,MAAM,KAAK,UAAU,CAAC;AAC5B,QAAE,IAAI,KAAK,CAAC;AAAA,IACd;AACA,WAAO,IAAI,oBAAsB,KAAK,WAAW,CAAC;AAAA,EACpD;AAAA,EAEA,OAAO,GAAwB;AAC7B,UAAM,IAAI,IAAI,IAAe,KAAK,KAAK;AACvC,UAAM,MAAM,KAAK,UAAU,CAAC;AAC5B,QAAI,EAAE,OAAO,GAAG,EAAG,QAAO,IAAI,oBAAmB,KAAK,WAAW,CAAC;AAClE,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,GAAe;AACjB,UAAM,MAAM,KAAK,UAAU,CAAC;AAC5B,WAAO,KAAK,MAAM,IAAI,GAAG;AAAA,EAC3B;AAAA,EAEA,UAAoB;AAClB,WAAO,CAAE,GAAG,KAAK,MAAM,OAAO,CAAE;AAAA,EAClC;AAAA,EAEA,CAAC,SAAS;AACR,WAAO,KAAK,MAAM,OAAO;AAAA,EAC3B;AACF;AAQO,IAAM,YAAY,CACvB,YAAyB,oBACJ,IAAI,mBAAmB,SAAS;;;AClChD,IAAM,aAAN,MAAM,YAAW;AAAA,EACtB;AAAA,EACA;AAAA,EACA,WAAW,oBAAI,IAAwB;AAAA,EACvC,SAAwB,CAAC;AAAA,EAEzB,YAAY,WAAW,GAAG,QAAQ,GAAG;AACnC,SAAK,SAAS;AACd,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY;AACV,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAe;AACb,WAAO,CAAE,GAAG,KAAK,SAAS,OAAO,CAAE,EAAE;AAAA,EACvC;AAAA,EAEA,mBAAmB;AACjB,QAAI,IAAI,KAAK,aAAa;AAC1B,eAAW,KAAK,KAAK,SAAS,OAAO,GAAG;AACtC,WAAK,EAAE,iBAAiB;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO;AACL,QAAI,IAAI,KAAK,OAAO;AACpB,eAAW,OAAO,KAAK,SAAS,OAAO,GAAG;AACxC,WAAK,IAAI,KAAK;AAAA,IAChB;AACA,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,OAAe;AACjB,QAAI,OAAO,UAAU,SAAU,OAAM,IAAI,MAAM,wCAAyC,OAAO,KAAM,EAAE;AAEvG,QAAI,MAAM,WAAW,EAAG,OAAM,IAAI,MAAM,wBAAwB;AAEhE,UAAM,cAAc,KAAK,UAAU,OAAO,IAAI;AAC9C,QAAI,gBAAgB,MAAM;AACxB,UAAI,CAAC,KAAK,SAAS,KAAK,GAAG;AACzB,aAAK,OAAO,KAAK,KAAK;AAAA,MACxB;AACA;AAAA,IACF;AAEA,QAAI,CAAC,YAAa,OAAM,IAAI,MAAM,mCAAoC,KAAM,EAAE;AAC9E,gBAAY,IAAI,KAAK;AAAA,EACvB;AAAA,EAEA,OAAO,OAAwB;AAC7B,QAAI,OAAO,UAAU,SAAU,OAAM,IAAI,MAAM,wCAAyC,OAAO,KAAM,EAAE;AACvG,QAAI,MAAM,WAAW,EAAG,OAAM,IAAI,MAAM,wBAAwB;AAEhE,UAAM,cAAc,KAAK,UAAU,OAAO,KAAK;AAC/C,QAAI,gBAAgB,OAAW,QAAO;AACtC,QAAI,gBAAgB,MAAM;AACxB,UAAI,KAAK,SAAS,KAAK,GAAG;AACxB,aAAK,SAAS,KAAK,OAAO,OAAO,OAAK,MAAM,KAAK;AACjD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AACA,WAAO,YAAY,OAAO,KAAK;AAAA,EACjC;AAAA,EAEA,YAAY;AACV,UAAM,IAAI,KAAK,aAAa;AAC5B,eAAW,MAAM,GAAG;AAClB,cAAQ,IAAI,EAAE;AAAA,IAChB;AAAA,EACF;AAAA,EAEA,aAAa,QAAQ,GAAG;AACtB,UAAM,IAAmB,CAAC;AAC1B,MAAE,KAAK,UAAW,KAAK,MAAO,SAAU,KAAK,SAAU,EAAE;AACzD,eAAW,CAAE,KAAK,KAAM,KAAK,KAAK,SAAS,QAAQ,GAAG;AACpD,YAAM,SAAS,MAAM,aAAa,QAAQ,CAAC;AAC3C,QAAE,KAAK,SAAU,GAAI,EAAE;AACvB,iBAAW,KAAK,QAAQ;AACtB,UAAE,KAAK,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC;AAAA,MAClC;AAAA,IACF;AAEA,MAAE,KAAK,YAAa,KAAK,OAAO,MAAO,GAAG;AAC1C,eAAW,KAAK,KAAK,QAAQ;AAC3B,QAAE,KAAK,IAAK,CAAE,EAAE;AAAA,IAClB;AACA,WAAO,EAAE,IAAI,UAAQ,IAAI,OAAO,KAAK,IAAI,IAAI;AAAA,EAC/C;AAAA,EAEA,UAAU,OAAe,QAAiB;AACxC,QAAI,UAAU,OAAW,OAAM,IAAI,MAAM,yBAAyB;AAClE,QAAI,KAAK,WAAW,KAAK,UAAW,QAAO;AAC3C,QAAI,MAAM,UAAU,KAAK,OAAQ,QAAO;AACxC,UAAM,IAAI,MAAO,KAAK,MAAO;AAC7B,QAAI,MAAM,OAAW,OAAM,IAAI,MAAM,uBAAwB,KAAK,MAAO,SAAU,MAAM,MAAO,EAAE;AAClG,QAAI,QAAQ,KAAK,SAAS,IAAI,CAAC;AAC/B,QAAI,UAAU,UAAa,QAAQ;AACjC,cAAQ,IAAI,YAAW,KAAK,WAAW,KAAK,SAAS,CAAC;AACtD,WAAK,SAAS,IAAI,GAAG,KAAK;AAAA,IAC5B;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,OAAe;AACtB,eAAW,KAAK,KAAK,QAAQ;AAC3B,UAAI,MAAM,MAAO,QAAO;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,OAAwB;AAC1B,QAAI,OAAO,UAAU,SAAU,QAAO;AAEtC,UAAM,cAAc,KAAK,UAAU,OAAO,KAAK;AAC/C,QAAI,gBAAgB,OAAW,QAAO;AACtC,QAAI,gBAAgB,KAAM,QAAO,KAAK,SAAS,KAAK;AACpD,WAAO,YAAY,IAAI,KAAK;AAAA,EAC9B;AACF;","names":[]}