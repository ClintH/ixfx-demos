{"version":3,"sources":["../src/iterables/sync/AdditionalValues.ts","../src/data/arrays/Unique.ts"],"sourcesContent":["import { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\n\n/**\n * Yield additional values from `values` which are not in `source`.\n *\n * Assuming that `source` is a set of unique values, this function\n * yields items from `values` which are not present in `source`.\n *\n * Duplicate items in `values` are ignored - only the first is yielded.\n *\n * If `eq` function is not provided, values are compared using the\n * default === semantics (via {@link isEqualDefault})\n *\n * ```js\n * const existing = [ 1, 2, 3 ];\n * const newValues = [ 3, 4, 5];\n * const v = [...additionalValues(existing, newValues)];\n * // [ 1, 2, 3, 4, 5]\n * ```\n *\n * ```js\n * const existing = [ 1, 2, 3 ];\n * const newValues = [ 3, 4, 5 ];\n * for (const v of additionalValues(existing, newValues)) {\n *  // 4, 5\n * }\n * To combine one or more iterables, keeping only unique items, use {@link unique}\n * @param source\n * @param values\n */\nexport function* additionalValues<V>(\n  source: Iterable<V>,\n  values: Iterable<V>,\n  eq: IsEqual<V> = isEqualDefault\n): Iterable<V> {\n  const sourceArray = Array.isArray(source) ? source : [ ...source ];\n  const yielded: Array<V> = [];\n  for (const v of values) {\n    const found = sourceArray.find((index) => eq(index, v));\n    if (!found) {\n      const alreadyYielded = yielded.find((ii) => eq(ii, v));\n      if (!alreadyYielded) {\n        //eslint-disable-next-line functional/immutable-data\n        yielded.push(v);\n        yield v;\n      }\n    }\n  }\n}\n","import { isEqualDefault } from \"../../util/IsEqual.js\";\nimport { additionalValues } from \"../../iterables/sync/AdditionalValues.js\";\n\n/**\n * Combines the values of one or more arrays, removing duplicates\n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | Array<Array<V>>\n    | Array<V>\n    | ReadonlyArray<V>\n    | ReadonlyArray<ReadonlyArray<V>>,\n  comparer = isEqualDefault<V>\n): ReadonlyArray<V> => {\n  const t: Array<V> = [];\n  for (const a of arrays) {\n    if (Array.isArray(a)) {\n      for (const v of additionalValues<V>(t, a, comparer)) {\n        t.push(v);\n      }\n    } else {\n      return [ ...additionalValues<V>([], arrays as Array<V>, comparer) ];\n    }\n  }\n  return t;\n};\n\n"],"mappings":";;;;;AA8BO,UAAU,iBACf,QACA,QACA,KAAiB,gBACJ;AACb,QAAM,cAAc,MAAM,QAAQ,MAAM,IAAI,SAAS,CAAE,GAAG,MAAO;AACjE,QAAM,UAAoB,CAAC;AAC3B,aAAW,KAAK,QAAQ;AACtB,UAAM,QAAQ,YAAY,KAAK,CAAC,UAAU,GAAG,OAAO,CAAC,CAAC;AACtD,QAAI,CAAC,OAAO;AACV,YAAM,iBAAiB,QAAQ,KAAK,CAAC,OAAO,GAAG,IAAI,CAAC,CAAC;AACrD,UAAI,CAAC,gBAAgB;AAEnB,gBAAQ,KAAK,CAAC;AACd,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACF;;;ACtBO,IAAM,SAAS,CACpB,QAKA,WAAW,mBACU;AACrB,QAAM,IAAc,CAAC;AACrB,aAAW,KAAK,QAAQ;AACtB,QAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,iBAAW,KAAK,iBAAoB,GAAG,GAAG,QAAQ,GAAG;AACnD,UAAE,KAAK,CAAC;AAAA,MACV;AAAA,IACF,OAAO;AACL,aAAO,CAAE,GAAG,iBAAoB,CAAC,GAAG,QAAoB,QAAQ,CAAE;AAAA,IACpE;AAAA,EACF;AACA,SAAO;AACT;","names":[]}