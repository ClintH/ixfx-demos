{"version":3,"sources":["../src/collections/Map/index.ts","../src/collections/Map/ExpiringMap.ts","../src/collections/Map/MapMutable.ts","../src/collections/Map/MapOfMultiImpl.ts","../src/collections/Map/MapOfSetMutable.ts","../src/collections/CircularArray.ts","../src/collections/Map/MapOfCircularMutable.ts","../src/collections/Map/MapOfArrayMutable.ts"],"sourcesContent":["export { create as expiringMap } from './ExpiringMap.js';\nexport type {\n  ExpiringMapEvent,\n  ExpiringMapEvents,\n  Opts as ExpiringMapOpts,\n} from './ExpiringMap.js';\n\nexport type { IMapOf } from './IMapOf.js';\nexport { immutable, type IMapImmutable } from './Map.js';\nexport { mutable, type IMapMutable } from './MapMutable.js';\nexport { ofSetMutable } from './MapOfSetMutable.js';\nexport { ofCircularMutable } from './MapOfCircularMutable.js';\nexport type { MapCircularOpts } from './MapOfCircularMutable.js';\nexport type { IMapOfMutable } from './IMapOfMutable.js';\nexport type { MapArrayOpts } from './MapOfArrayMutable.js';\nexport { NumberMap } from './NumberMap.js';\nexport * from './MapMulti.js';\n\nexport type { IDictionary as IMappish, IWithEntries } from '../../data/maps/IMappish.js';\n","import { SimpleEventEmitter } from '../../Events.js';\nimport { sortByValueProperty } from '../../data/maps/MapFns.js';\nimport { intervalToMs, type Interval } from '../../flow/IntervalType.js';\nimport { throwIntegerTest } from '../../util/GuardNumbers.js';\n\n/**\n * Expiring map options\n */\nexport type Opts = {\n  /**\n   * Capacity limit\n   */\n  readonly capacity?: number;\n  /**\n   * Policy for evicting items if capacity is reached\n   */\n  readonly evictPolicy?: `none` | `oldestGet` | `oldestSet`;\n  /**\n   * Automatic deletion policy.\n   * none: no automatic deletion (default)\n   * get/set: interval based on last get/set\n   * either: if either interval has elapsed\n   */\n  readonly autoDeletePolicy?: `none` | `get` | `set` | `either`;\n  /**\n   * Automatic deletion interval\n   */\n  readonly autoDeleteElapsedMs?: number;\n};\n\ntype Item<V> = {\n  readonly value: V;\n  readonly lastSet: number;\n  readonly lastGet: number;\n};\n\n/**\n * Event from the ExpiringMap\n */\nexport type ExpiringMapEvent<K, V> = {\n  readonly key: K;\n  readonly value: V;\n};\n\nexport type ExpiringMapEvents<K, V> = {\n  /**\n   * Fires when an item is removed due to eviction\n   * or automatic expiry\n   */\n  readonly expired: ExpiringMapEvent<K, V>;\n  /**\n   * Fires when a item with a new key is added\n   */\n  readonly newKey: ExpiringMapEvent<K, V>;\n\n  /**\n   * Fires when an item is manually removed,\n   * removed due to eviction or automatic expiry\n   */\n  readonly removed: ExpiringMapEvent<K, V>;\n};\n\n/**\n * Create a ExpiringMap instance\n * @param options Options when creating map\n * @returns\n */\nexport const create = <K, V>(options: Opts = {}): ExpiringMap<K, V> =>\n  new ExpiringMap(options);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using {@link touch}.\n *\n *\n * Events:\n * * 'expired': when an item is automatically removed.\n * * 'removed': when an item is manually or automatically removed.\n * * 'newKey': when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example\n * Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example\n * Automatically delete the oldest item if we reach a capacity limit\n * ```js\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n * @typeParam K - Type of keys\n * @typeParam V - Type of values\n */\nexport class ExpiringMap<K, V> extends SimpleEventEmitter<\n  ExpiringMapEvents<K, V>\n> {\n  private capacity: number;\n  private store: Map<K, Item<V>>;\n  //private keyCount: number;\n  private evictPolicy;\n\n  private autoDeleteElapsedMs: number;\n  private autoDeletePolicy;\n\n  constructor(opts: Opts = {}) {\n    super();\n    this.capacity = opts.capacity ?? -1;\n\n    throwIntegerTest(this.capacity, `nonZero`, `capacity`);\n    this.store = new Map();\n    //this.keyCount = 0;\n\n    if (opts.evictPolicy && this.capacity <= 0) {\n      throw new Error(`evictPolicy is set, but no capacity limit is set`);\n    }\n    this.evictPolicy = opts.evictPolicy ?? `none`;\n    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n\n    if (this.autoDeleteElapsedMs > 0) {\n      setInterval(\n        () => { this.#maintain(); },\n        Math.max(1000, this.autoDeleteElapsedMs * 2)\n      );\n    }\n  }\n\n  /**\n   * Returns the number of keys being stored.\n   */\n  get keyLength() {\n    return this.store.size;// keyCount;\n  }\n\n  *entries(): IterableIterator<[ k: K, v: V ]> {\n    for (const entry of this.store.entries()) {\n      yield [ entry[ 0 ], entry[ 1 ].value ];\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const v of this.store.values()) {\n      yield v.value;\n    }\n  }\n\n  *keys(): IterableIterator<K> {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was set. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedSet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (!v) return v;\n    return Date.now() - v.lastSet;\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was accessed. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedGet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (!v) return v;\n    return Date.now() - v.lastGet;\n  }\n\n  /**\n   * Returns true if `key` is stored.\n   * Does not affect the key's last access time.\n   * @param key\n   * @returns\n   */\n  has(key: K): boolean {\n    return this.store.has(key);\n  }\n\n  /**\n   * Gets an item from the map by key, returning\n   * undefined if not present\n   * @param key Key\n   * @returns Value, or undefined\n   */\n  get(key: K): V | undefined {\n    const v = this.store.get(key);\n    if (v) {\n      return v.value;\n    }\n  }\n\n  /**\n   * Deletes the value under `key`, if present.\n   *\n   * Returns _true_ if something was removed.\n   * @param key\n   * @returns\n   */\n  delete(key: K): boolean {\n    const value = this.store.get(key);\n    if (!value) return false;\n    const d = this.store.delete(key);\n    //this.keyCount = this.keyCount - 1;\n    this.fireEvent(`removed`, {\n      key,\n      value: value.value,\n    });\n    return d;\n  }\n\n  /**\n   * Clears the contents of the map.\n   * Note: does not fire `removed` event\n   */\n  clear() {\n    this.store.clear();\n  }\n\n  /**\n   * Updates the lastSet/lastGet time for a value\n   * under `k`.\n   *\n   * Returns false if key was not found\n   * @param key\n   * @returns\n   */\n  touch(key: K): boolean {\n    const v = this.store.get(key);\n    if (!v) return false;\n    this.store.set(key, {\n      ...v,\n      lastSet: Date.now(),\n      lastGet: Date.now(),\n    });\n    return true;\n  }\n\n  private findEvicteeKey(): K | undefined {\n    if (this.evictPolicy === `none`) return;\n    //eslint-disable-next-line functional/no-let\n    let sortBy = ``;\n    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;\n    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    else throw new Error(`Unknown eviction policy ${ this.evictPolicy }`);\n    const sorted = sortByValueProperty(this.store, sortBy);\n    return sorted[ 0 ][ 0 ];\n  }\n\n  #maintain() {\n    if (this.autoDeletePolicy === `none`) return;\n    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n  }\n\n  /**\n   * Deletes all values where elapsed time has past\n   * for get/set or either.\n   * ```js\n   * // Delete all keys (and associated values) not accessed for a minute\n   * em.deleteWithElapsed({mins:1}, `get`);\n   * // Delete things that were set 1s ago\n   * em.deleteWithElapsed(1000, `set`);\n   * ```\n   * \n   * @param interval Interval\n   * @param property Basis for deletion 'get','set' or 'either'\n   * @returns Items removed\n   */\n  deleteWithElapsed(\n    interval: Interval,\n    property: `get` | `set` | `either`\n  ): Array<[ k: K, v: V ]> {\n    const entries = [ ...this.store.entries() ];\n    const prune: Array<[ k: K, v: V ]> = [];\n    const intervalMs = intervalToMs(interval, 1000);\n    const now = Date.now();\n    for (const entry of entries) {\n      const elapsedGet = now - entry[ 1 ].lastGet;\n      const elapsedSet = now - entry[ 1 ].lastSet;\n      const elapsed =\n        property === `get`\n          ? elapsedGet\n          : (property === `set`\n            ? elapsedSet\n            : Math.max(elapsedGet, elapsedSet));\n      if (elapsed >= intervalMs) {\n        prune.push([ entry[ 0 ], entry[ 1 ].value ]);\n      }\n    }\n\n    for (const entry of prune) {\n      this.store.delete(entry[ 0 ]);\n      //this.keyCount = this.keyCount - 1;\n      const eventArguments = {\n        key: entry[ 0 ],\n        value: entry[ 1 ],\n      };\n      this.fireEvent(`expired`, eventArguments);\n      this.fireEvent(`removed`, eventArguments);\n    }\n    return prune;\n  }\n\n  /**\n   * Sets the `key` to be `value`.\n   *\n   * If the key already exists, it is updated.\n   *\n   * If the map is full, according to its capacity,\n   * another value is selected for removal.\n   * @param key\n   * @param value\n   * @returns\n   */\n  set(key: K, value: V) {\n    const existing = this.store.get(key);\n\n    if (existing) {\n      // Update set time\n      this.store.set(key, {\n        ...existing,\n        lastSet: performance.now(),\n      });\n      return;\n    }\n\n    // New key\n    if (this.keyLength === this.capacity && this.capacity > 0) {\n      // Evict first\n      const key = this.findEvicteeKey();\n      if (!key) {\n        throw new Error(`ExpiringMap full (capacity: ${ this.capacity })`);\n      }\n      const existing = this.store.get(key);\n      this.store.delete(key);\n      //this.keyCount = this.keyCount - 1;\n      if (existing) {\n        const eventArguments = { key, value: existing.value };\n        this.fireEvent(`expired`, eventArguments);\n        this.fireEvent(`removed`, eventArguments);\n      }\n    }\n\n    //this.keyCount++;\n    this.store.set(key, {\n      lastGet: 0,\n      lastSet: Date.now(),\n      value: value,\n    });\n\n    this.fireEvent(`newKey`, { key, value });\n  }\n}\n","import { type EitherKey } from '../Types.js';\nimport type { IMapBase } from './IMapBase.js';\nimport { add, del, set, has } from './MapImmutableFns.js';\n\n/**\n * A mutable map.\n *\n * It is a wrapper around the in-built Map type, but adds roughly the same API as {@link IMapImmutable}.\n *\n * @typeParam K - Type of map keys. Typically `string`\n * @typeParam V - Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapMutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items to map\n   *\n   * Can add items in the form of [key,value] or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): void;\n  /**\n   * Sets a value to a specified key\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): void;\n  /**\n   * Deletes an item by key\n   * @param key\n   */\n  delete(key: K): void;\n  /**\n   * Clears map\n   */\n  clear(): void;\n}\n\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = <K, V>(...data: EitherKey<K, V>): IMapMutable<K, V> => {\n  // eslint-disable-next-line functional/no-let\n  let m = add(new Map<K, V>(), ...data);\n  return {\n    add: (...data: EitherKey<K, V>) => {\n      m = add(m, ...data);\n    },\n    delete: (key: K) => {\n      m = del(m, key);\n    },\n    clear: () => {\n      m = add(new Map<K, V>());\n    },\n    set: (key: K, value: V): void => {\n      m = set(m, key, value);\n    },\n    get: (key: K): V | undefined => m.get(key),\n    entries: () => m.entries(),\n    values: () => m.values(),\n    isEmpty: () => m.size === 0,\n    has: (key: K) => has(m, key),\n  };\n};\n","import {\n  type IsEqual,\n  isEqualDefault\n} from '../../util/IsEqual.js';\nimport type {\n  MapArrayEvents,\n  IMapOfMutableExtended,\n} from './IMapOfMutableExtended.js';\nimport type { MapMultiOpts, MultiValue } from './MapMulti.js';\nimport { SimpleEventEmitter } from '../../Events.js';\nimport type { IMapOf } from './IMapOf.js';\nimport { toStringDefault, type ToString } from '../../util/index.js';\n\n/**\n * @internal\n */\nexport class MapOfMutableImpl<V, M>\n  extends SimpleEventEmitter<MapArrayEvents<V>>\n  implements IMapOfMutableExtended<V, M> {\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #map = new Map<string, M>();\n  readonly groupBy: ToString<V>;\n  readonly type: MultiValue<V, M>;\n\n  constructor(type: MultiValue<V, M>, opts: MapMultiOpts<V> = {}) {\n    super();\n    this.type = type;\n    this.groupBy = opts.groupBy ?? toStringDefault;\n  }\n\n  /**\n   * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n   */\n  get typeName() {\n    return this.type.name;\n  }\n\n  /**\n   * Returns the number of keys\n   */\n  get lengthKeys(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns the length of the longest child list\n   */\n  get lengthMax() {\n    //eslint-disable-next-line functional/no-let\n    let m = 0;\n    for (const v of this.#map.values()) {\n      m = Math.max(m, this.type.count(v));\n    }\n    return m;\n  }\n\n  debugString(): string {\n    const keys = [ ...this.#map.keys() ];\n    // eslint-disable-next-line functional/no-let\n    let r = `Keys: ${ keys.join(`, `) }\\r\\n`;\n    for (const k of keys) {\n      const v = this.#map.get(k);\n      if (v === undefined) {\n        r += ` - ${ k } (undefined)\\r\\n`\n      } else {\n        const asArray = this.type.toArray(v);\n        if (asArray !== undefined) {\n          r += ` - ${ k } (${ this.type.count(v) }) = ${ JSON.stringify(\n            asArray\n          ) }\\r\\n`;\n        }\n      }\n    };\n    return r;\n  }\n\n  get isEmpty(): boolean {\n    return this.#map.size === 0;\n  }\n\n  clear() {\n    this.#map.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  addKeyedValues(key: string, ...values: Array<V>) {\n    const set = this.#map.get(key);\n    if (set === undefined) {\n      this.#map.set(key, this.type.add(undefined, values));\n      super.fireEvent(`addedKey`, { key: key });\n      super.fireEvent(`addedValues`, { values: values });\n    } else {\n      // eslint-disable-next-line functional/immutable-data\n      this.#map.set(key, this.type.add(set, values));\n      super.fireEvent(`addedValues`, { values: values });\n    }\n  }\n  //eslint-disable-next-line functional/prefer-immutable-types\n  set(key: string, values: Array<V>) {\n    this.addKeyedValues(key, ...values);\n    return this;\n  }\n\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) this.addKeyedValues(this.groupBy(v), v);\n  }\n\n  hasKeyValue(key: string, value: V, eq: IsEqual<V>): boolean {\n    const m = this.#map.get(key);\n    if (m === undefined) return false;\n    return this.type.has(m, value, eq);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.#map.has(key);\n  }\n\n  deleteKeyValue(key: string, value: V): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    return this.deleteKeyValueFromMap(a, key, value);\n  }\n\n  private deleteKeyValueFromMap(map: M, key: string, value: V): boolean {\n    const preCount = this.type.count(map);\n    const filtered = this.type.without(map, value);\n    const postCount = filtered.length;\n    this.#map.set(key, this.type.add(undefined, filtered));\n    return preCount > postCount;\n  }\n\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let something = false;\n    [ ...this.#map.keys() ].filter((key) => {\n      const a = this.#map.get(key);\n      if (!a) throw new Error(`Bug: map could not be accessed`);\n      if (this.deleteKeyValueFromMap(a, key, value)) {\n        something = true; // note that something was deleted\n\n        // If key is empty, delete it\n        if (this.count(key) === 0) this.delete(key);\n      }\n    });\n    return something;\n  }\n\n  delete(key: string): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    this.#map.delete(key);\n    this.fireEvent(`deleteKey`, { key: key });\n    return true;\n  }\n\n  firstKeyByValue(\n    value: V,\n    eq: IsEqual<V> = isEqualDefault\n  ): string | undefined {\n    const keys = [ ...this.#map.keys() ];\n    const found = keys.find((key) => {\n      const a = this.#map.get(key);\n      if (a === undefined) throw new Error(`Bug: map could not be accessed`);\n      const r = this.type.has(a, value, eq);\n      return r;\n    });\n    return found;\n  }\n\n  count(key: string): number {\n    const entry = this.#map.get(key);\n    if (entry === undefined) return 0;\n    return this.type.count(entry);\n  }\n\n  /**\n   * Iterates over values stored under `key`\n   * An empty array is returned if there are no values\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  /**\n   * Iterate over the values stored under `key`.\n   * If key does not exist, iteration is essentially a no-op\n   * @param key\n   * @returns\n   */\n  *valuesFor(key: string) {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  getSource(key: string): M | undefined {\n    return this.#map.get(key);\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keys(): IterableIterator<string> {\n    yield* this.#map.keys();\n    //return Array.from(this.#map.keys());\n  }\n\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const entry of this.#map.entries()) {\n      for (const v of this.type.iterable(entry[ 1 ])) {\n        yield [ entry[ 0 ], v ];\n      }\n    }\n  }\n\n  *valuesFlat(): IterableIterator<V> {\n    for (const entry of this.#map.entries()) {\n      yield* this.type.iterable(entry[ 1 ]);\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: Array<V> ]> {\n    for (const [ k, v ] of this.#map.entries()) {\n      const temporary = [ ...this.type.iterable(v) ];\n      yield [ k, temporary ];\n    }\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const key of this.keys()) {\n      yield [ key, this.count(key) ];\n    }\n  }\n\n  merge(other: IMapOf<V>) {\n    for (const key of other.keys()) {\n      const data = other.get(key);\n      this.addKeyedValues(key, ...data);\n    }\n  }\n\n  get size() {\n    return this.#map.size;\n  }\n\n\n  get [ Symbol.toStringTag ]() {\n    return this.#map[ Symbol.toStringTag ];\n  }\n}\n","import { toStringDefault } from '../../util/index.js';\nimport { without } from '../../data/arrays/Filter.js';\nimport type { MapSetOpts, MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\nimport {\n  hasAnyValue as mapHasAnyValue,\n  toArray as mapToArray,\n  find as mapFind,\n  filter as mapFilter,\n  addKeepingExisting,\n} from '../../data/maps/MapFns.js';\nimport type { IMapOfMutableExtended } from './IMapOfMutableExtended.js';\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is a {@link Util.ToString} function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = mapOfSetMutable();\n * map.add(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = mapOfSetMutable(hash);\n * map.add(`hello`, {age:40, name: `Mary`});\n * map.add(`hello`, {age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param options\n * @returns\n */\nexport const ofSetMutable = <V>(\n  options?: MapSetOpts<V>\n): IMapOfMutableExtended<V, ReadonlyMap<string, V>> => {\n  const hash = options?.hash ?? toStringDefault;\n  const comparer = (a: V, b: V) => hash(a) === hash(b);\n\n  const t: MultiValue<V, ReadonlyMap<string, V>> = {\n    get name() {\n      return `set`;\n    },\n    iterable: (source) => source.values(),\n    add: (dest, values) => addKeepingExisting(dest, hash, ...values),\n    count: (source) => source.size,\n    find: (source, predicate) => mapFind(source, predicate),\n    filter: (source, predicate) => mapFilter(source, predicate),\n    toArray: (source) => mapToArray(source),\n    has: (source, value) => mapHasAnyValue(source, value, comparer),\n    without: (source, value) => without(mapToArray(source), value, comparer),\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyMap<string, V>>(t, options);\n  return m;\n};\n","import { throwIntegerTest } from \"../util/GuardNumbers.js\";\n\n/**\n * The circular array is immutable. It keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n * @example\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`); // Because it's immutable, capture the return result of `add`\n * a.isFull;  // True if circular array is full\n * a.pointer; // The current position in array it will write to\n * ```\n * @class CircularArray\n */\n\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ICircularArray<V> extends Array<V> {\n  /**\n   * Returns true if the array has filled to capacity and is now\n   * recycling array indexes.\n   */\n  get isFull(): boolean;\n\n  /**\n   * Returns a new Circular with item added\n   *\n   * Items are added at `pointer` position, which automatically cycles through available array indexes.\n   *\n   * @param value Thing to add\n   * @returns Circular with item added\n   */\n  add(value: V): ICircularArray<V>;\n\n  get length(): number;\n\n  /**\n   * Returns the current add position of array.\n   */\n  get pointer(): number;\n}\n\nclass CircularArray<V> extends Array {\n  // ✔ Class is unit tested!\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  #capacity: number;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  #pointer: number;\n\n  constructor(capacity = 0) {\n    super();\n    // Allowed to create with capacity zero\n    throwIntegerTest(capacity, `positive`, `capacity`);\n\n    // Can't throw because .filter won't use ctor proprly\n    this.#capacity = capacity;\n    this.#pointer = 0;\n  }\n\n  /**\n   * Add to array\n   * @param value Thing to add\n   * @returns \n   */\n  add(value: V): CircularArray<V> {\n    const ca = CircularArray.from(this) as CircularArray<V>;\n    /* eslint-disable-next-line functional/immutable-data */\n    ca[ this.#pointer ] = value;\n    /* eslint-disable-next-line functional/immutable-data */\n    ca.#capacity = this.#capacity;\n    if (this.#capacity > 0) {\n      /* eslint-disable-next-line functional/immutable-data */\n      ca.#pointer =\n        this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n    } else {\n      /* eslint-disable-next-line functional/immutable-data */\n      ca.#pointer = this.#pointer + 1;\n    }\n    return ca;\n  }\n\n  get pointer(): number {\n    return this.#pointer;\n  }\n\n  get isFull(): boolean {\n    if (this.#capacity === 0) return false;\n    return this.length === this.#capacity;\n  }\n}\n\n/**\n * Returns a new circular array. Immutable. A circular array only keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = circularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport const circularArray = <V>(capacity: number): ICircularArray<V> =>\n  new CircularArray<V>(capacity);\n","import { isEqualDefault } from '../../util/IsEqual.js';\nimport { type ICircularArray, circularArray } from '../CircularArray.js';\nimport type { MapMultiOpts, MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\nimport type { IMapOfMutableExtended } from './IMapOfMutableExtended.js';\n\nexport type MapCircularOpts<V> = MapMultiOpts<V> & {\n  readonly capacity: number;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param options\n * @returns\n */\nexport const ofCircularMutable = <V>(\n  options: MapCircularOpts<V>\n): IMapOfMutableExtended<V, ICircularArray<V>> => {\n  const comparer = isEqualDefault;\n\n  const t: MultiValue<V, ICircularArray<V>> = {\n    get name() {\n      return `circular`;\n    },\n    add: (destination, values) => {\n      if (destination === undefined) destination = circularArray<V>(options.capacity);\n      for (const v of values) {\n        //values.forEach(v => dest = dest?.add(v));\n        destination = destination.add(v);\n      }\n      return destination;\n    },\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(predicate),\n    filter: (source, predicate) => source.filter(predicate),\n    toArray: (source) => source,\n    iterable: (source) => source.values(),\n    has: (source, value) =>\n      source.find((v) => comparer(v, value)) !== undefined,\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n  };\n  return new MapOfMutableImpl<V, ICircularArray<V>>(t, options);\n};\n","import type { ToString } from '../../util/index.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport { type IMapOfMutableExtended } from './IMapOfMutableExtended.js';\nimport { type MapMultiOpts, type MultiValue } from './MapMulti.js';\nimport { MapOfMutableImpl } from './MapOfMultiImpl.js';\n\n/**\n * Map of array options\n */\nexport type MapArrayOpts<V> = MapMultiOpts<V> & {\n  /**\n   * Comparer to use\n   */\n  readonly comparer?: IsEqual<V>;\n  /**\n   * Key function\n   */\n  readonly convertToString?: ToString<V>;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: {@link Util.ToString}\n *\n * A custom {@link Util.ToString} function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param options Optiosn for mutable array\n * @typeParam V - Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = <V>(\n  options: MapArrayOpts<V> = {}\n): IMapOfMutableExtended<V, ReadonlyArray<V>> => {\n  // const toStringFunction = opts.toString === undefined ?  \n  // const comparer =\n  //   opts.comparer === undefined\n  //     ? (opts.toString === undefined\n  //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n  //       : isEqualDefault)\n  //     : opts.comparer;\n  // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n  //   const r = opts.convertToString(a) === opts.convertToString(b)\n  //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n  //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n  //   return r;\n  // };\n\n  const convertToString = options.convertToString;\n  const toStringFunction: IsEqual<V> = typeof convertToString === `undefined` ? isEqualDefault : (a: V, b: V) => convertToString(a) === convertToString(b)\n\n  const comparer = options.comparer ?? toStringFunction;\n\n  const t: MultiValue<V, ReadonlyArray<V>> = {\n    get name() {\n      return `array`;\n    },\n    add: (destination, values) => {\n      if (destination === undefined) return [ ...values ];\n      return [ ...destination, ...values ];\n    },\n    iterable: (source) => source.values(),\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(f => predicate(f)),\n    filter: (source, predicate) => source.filter(f => predicate(f)),\n    toArray: (source) => source,\n    has: (source, value) => source.some((v) => comparer(v, value)),\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n    //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyArray<V>>(t, options);\n  return m;\n};\n"],"mappings":"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","names":["key","existing","data","set"]}