{"version":3,"sources":["../src/Compare.ts"],"sourcesContent":["\nexport type ChangeKind = `mutate` | `add` | `del`\nexport type ChangeRecord = [ kind: ChangeKind, path: string, value: any ];\n\n/**\n * Result of {@link compareData}\n */\nexport type CompareChangeSet = {\n  /**\n   * _True_ if there are any changes\n   */\n  hasChanged: boolean\n  /**\n   * Results for child objects\n   */\n  children: Record<string, CompareChangeSet>\n  /**\n   * Values that have changed\n   */\n  changed: Record<string, any>\n  /**\n   * Fields that have been added\n   */\n  added: Record<string, any>\n  /**\n   * Fields that have been removed\n   */\n  removed: Array<string>\n  isArray: boolean\n  summary: Array<ChangeRecord>\n}\n\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n * \n * ```js\n * const a = { msg: `hi`, v: 10 };\n * \n * changedDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n * \n * Under the hood, we use `{@link compareData}(a, b, true)`. If B has additional or removed fields,\n * this is considered an error.\n * \n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a \n * @param b \n */\nexport const changedDataFields = (a: object, b: object) => {\n  const r = compareData(a, b, true);\n  if (Object.entries(r.added).length > 0) throw new Error(`Shape of data has changed`);\n  if (Object.entries(r.removed).length > 0) throw new Error(`Shape of data has changed`);\n\n  const output = compareResultToObject(r, b);\n  return output;\n}\n\nconst compareResultToObject = (r: CompareChangeSet, b: object): Record<string, any> | Array<any> => {\n  const output = {}\n\n  if (r.isArray) {\n    return b;\n  }\n\n  for (const entry of Object.entries(r.changed)) {\n    (output as any)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n  for (const entry of Object.entries(r.added)) {\n    (output as any)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n\n  for (const childEntry of Object.entries(r.children)) {\n    if (childEntry[ 1 ].hasChanged) {\n      (output as any)[ childEntry[ 0 ] ] = compareResultToObject(childEntry[ 1 ], (b as any)[ childEntry[ 0 ] ]);\n    }\n  }\n  return output;\n}\n\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the values are primitive values or other simple objects.\n * \n * @param a \n * @param b \n */\nexport const compareData = (a: object, b: object, assumeSameShape = false): CompareChangeSet => {\n  const entriesA = Object.entries(a);\n  const entriesB = Object.entries(b);\n\n  const scannedKeys = new Set<string>();\n  const changed = {}\n  const added = {}\n  const children = {}\n  const removed: Array<string> = [];\n  const isArray = Array.isArray(a);\n\n  const summary = new Array<ChangeRecord>();\n  let hasChanged = false;\n\n  // Look for existing entries of A that are modified\n  for (const entry of entriesA) {\n    const outputKey = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n    const aValue = entry[ 1 ];\n    const bValue = (b as any)[ entry[ 0 ] ];\n    scannedKeys.add(entry[ 0 ]);\n\n    if (bValue === undefined) {\n      // B does not have a key from A\n      hasChanged = true;\n      if (assumeSameShape && !isArray) {\n        // If we're assuming it's the same shape, then _undefined_ is actually the value\n        (changed as any)[ outputKey ] = bValue;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      } else {\n        // Key removed\n        removed.push(outputKey);\n        summary.push([ `del`, outputKey, aValue ]);\n      }\n      continue;\n    }\n\n    if (typeof aValue === `object`) {\n      const r = compareData(aValue, bValue, assumeSameShape);\n      if (r.hasChanged) hasChanged = true;\n      (children as any)[ outputKey ] = r;\n      const childSummary = r.summary.map(sum => { return [ sum[ 0 ], outputKey + `.` + sum[ 1 ], sum[ 2 ] ] }) as Array<ChangeRecord>;\n      summary.push(...childSummary);\n    } else {\n      if (aValue !== bValue) {\n        (changed as any)[ outputKey ] = bValue;\n        hasChanged = true;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      }\n    }\n  }\n\n  // Look for entries in B that weren't in A\n  if (!assumeSameShape || isArray) {\n    for (const entry of entriesB) {\n      const key = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n\n      if (scannedKeys.has(entry[ 0 ])) continue;\n      (added as any)[ key ] = entry[ 1 ];\n      hasChanged = true;\n      summary.push([ `add`, key, entry[ 1 ] ])\n    }\n  }\n  return {\n    changed, added, removed, children, hasChanged, isArray, summary\n  }\n}"],"mappings":"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","names":[]}