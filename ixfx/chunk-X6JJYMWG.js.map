{"version":3,"sources":["../src/Text.ts","../src/Guards.ts","../src/random/Types.ts","../src/random/String.ts"],"sourcesContent":["import { integerTest, throwFromResult } from './Guards.js';\nexport { string as random } from './random/String.js';\n\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n * \n * If `source` is under `maxLength` the original is returned.\n * @param source \n * @param maxLength Maximum length. Defaults to 20\n * @returns \n */\nexport const abbreviate = (source: string, maxLength = 15) => {\n  // ✔️ Unit tested\n  throwFromResult(integerTest(maxLength, `aboveZero`, `maxLength`));\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n\n  if (source.length > maxLength && source.length > 3) {\n    if (maxLength > 15) {\n      const chunk = Math.round((maxLength - 2) / 2);\n      return source.slice(0, chunk) + `...` + source.slice(-chunk);\n    }\n    return source.slice(0, maxLength) + `...`;\n  }\n  return source;\n}\n\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns \n */\nexport const toStringAbbreviate = (source: any, maxLength = 20) => {\n  if (source === undefined) return `(undefined)`;\n  if (source === null) return `(null)`;\n  return abbreviate(JSON.stringify(source), maxLength);\n}\n\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): string | undefined => {\n  // ✔ Unit tested\n\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return;\n\n  return source.slice(startPos + 1, endPos);\n};\n\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): [ source: string, between: string | undefined ] => {\n  // ✔ Unit tested\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);\n  if (end !== undefined && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return [ source, undefined ];\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return [ source, undefined ];\n\n  const between = source.slice(startPos + 1, endPos);\n  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n  return [ sourceResult, between ];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (\n  source: string,\n  code: number,\n  start = 0,\n  end = source.length - 1\n): number => {\n  //eslint-disable-next-line functional/no-let\n  for (let index = start; index <= end; index++) {\n    if (source.codePointAt(index) === code) return index;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (\n  source: string,\n  removeStart: number,\n  removeLength: number\n) =>\n  source.slice(0, removeStart) +\n  source.slice(removeStart + removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (\n  source: string | null,\n  length: number\n): ReadonlyArray<string> => {\n  throwFromResult(integerTest(length, `aboveZero`, `length`));\n  if (source === null) throw new Error(`source parameter null`);\n  if (typeof source !== `string`) {\n    throw new TypeError(`source parameter not a string`);\n  }\n\n  // ✔ Unit tested\n  const chunks = Math.ceil(source.length / length);\n  const returnValue: Array<string> = [];\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n\n  //eslint-disable-next-line functional/no-let\n  for (let c = 0; c < chunks; c++) {\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push(source.slice(start, start + length));\n    start += length;\n  }\n  return returnValue;\n};\n\n/**\n * Returns the `source` string up until (and excluding) `match`. If match is not\n * found, all of `source` is returned.\n *\n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * @param source\n * @param match\n * @param startPos If provided, gives the starting offset. Default 0\n */\nexport const untilMatch = (\n  source: string,\n  match: string,\n  options: MatchOptions = {}\n): string => {\n  //  ✔️ Unit tested\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0) return source;\n  return source.slice(startPos ?? 0, m);\n};\n\nexport type MatchOptions = {\n  readonly startPos?: number;\n  readonly fromEnd?: boolean;\n}\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param startPos\n * @returns\n */\nexport const afterMatch = (\n  source: string,\n  match: string,\n  options: MatchOptions = {}\n): string => {\n  if (source === undefined) throw new Error(`source is undefined`);\n\n  //  ✔️ Unit tested\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0) return source;\n  return source.slice(Math.max(0, m + match.length));\n};\n\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (\n  source: string,\n  ...wrappers: ReadonlyArray<string>\n): string => {\n  //eslint-disable-next-line functional/no-let\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.slice(w.length, source.length - w.length * 2 + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string;\n  /**\n   * Start position, with respect to source text\n   */\n  readonly start: number;\n  /**\n   * End position, with respect to source text\n   */\n  readonly end: number;\n  /**\n   * Index of range. First range is 0\n   */\n  readonly index: number;\n}\n\nexport type LineSpan = {\n  readonly start: number;\n  readonly end: number;\n  readonly length: number;\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (\n  ranges: ReadonlyArray<Range>,\n  start: number,\n  end: number\n): LineSpan => {\n  //eslint-disable-next-line functional/no-let\n  let s = -1;\n  //eslint-disable-next-line functional/no-let\n  let endPos = -1;\n  //eslint-disable-next-line functional/no-let\n  for (const [ index, r ] of ranges.entries()) {\n    s = index;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = s; index < ranges.length; index++) {\n    const r = ranges[ index ];\n    endPos = index;\n    if (end === r.end) {\n      endPos = index + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return { length: endPos - s, start: s, end: endPos };\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (\n  source: string,\n  split: string\n): ReadonlyArray<Range> => {\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n  //eslint-disable-next-line functional/no-let\n  let text = ``;\n  const ranges: Array<Range> = [];\n  //eslint-disable-next-line functional/no-let\n  let index = 0;\n  //eslint-disable-next-line functional/no-let,unicorn/prevent-abbreviations\n  for (let i = 0; i < source.length; i++) {\n    if (source.indexOf(split, i) === i) {\n      //eslint-disable-next-line functional/no-let\n      const end = i;\n      //eslint-disable-next-line functional/immutable-data\n      ranges.push({\n        text,\n        start,\n        end,\n        index,\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(i);\n    }\n  }\n  if (start < source.length) {\n    //eslint-disable-next-line functional/immutable-data\n    ranges.push({ text, start, index, end: source.length });\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (\n  source: string,\n  ...chars: ReadonlyArray<string>\n): number => {\n  //eslint-disable-next-line functional/no-let\n  let counted = 0;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < source.length; index++) {\n    if (chars.includes(source.charAt(index))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (\n  source: string,\n  start: string,\n  end: string = start\n): boolean => source.startsWith(start) && source.endsWith(end);\n\n//eslint-disable-next-line no-useless-escape\nexport const htmlEntities = (source: string): string =>\n  source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${ index.codePointAt(0) };`);\n","export type NumberGuardRange =\n  /**\n   * No range checking\n   */\n  | ``\n  /**\n   * Can be any number, except zero\n   */\n  | `nonZero`\n  | `positive`\n  | `negative`\n  /**\n   * Must be above zero\n   */\n  | `aboveZero`\n  | `belowZero`\n  | `percentage`\n  | `bipolar`;\n\ntype GuardResultOk = Readonly<readonly [ true: boolean ]>;\ntype GuardResultFail = Readonly<readonly [ false: boolean, reason: string ]>;\ntype GuardResult = GuardResultFail | GuardResultOk;\n\n/**\n * Throws an error if `t` is not a number or within specified range.\n * Use an empty string for no special range constraints.\n * Alternatives: {@link integer} for additional integer check, {@link percent} for percentage-range.\n *\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param paramName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns\n */\nexport const numberTest = (\n  value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`,\n): GuardResult => {\n  if (value === null) return [ false, `Parameter ${ parameterName } is null` ];\n  if (typeof value === `undefined`) {\n    return [ false, `Parameter ${ parameterName } is undefined` ];\n  }\n  if (Number.isNaN(value)) {\n    return [ false, `Parameter '${ parameterName }' is NaN` ];\n  }\n  if (typeof value !== `number`) {\n    return [ false, `Parameter '${ parameterName }' is not a number (${ JSON.stringify(value) })` ];\n  }\n  switch (range) {\n    case `positive`: {\n      if (value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be at least zero (${ value })` ];\n      }\n      break;\n    } case `negative`: {\n      if (value > 0) {\n        return [ false, `Parameter '${ parameterName }' must be zero or lower (${ value })` ];\n      }\n      break;\n    }\n    case `aboveZero`: {\n      if (value <= 0) {\n        return [ false, `Parameter '${ parameterName }' must be above zero (${ value })` ]\n\n      }\n      break;\n    }\n    case `belowZero`: {\n      if (value >= 0) {\n        return [ false, `Parameter '${ parameterName }' must be below zero (${ value })` ];\n      }\n      break;\n    }\n    case `percentage`: {\n      if (value > 1 || value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be in percentage range (0 to 1). (${ value })` ]\n      }\n      break;\n    }\n    case `nonZero`: {\n      if (value === 0) {\n        return [ false, `Parameter '${ parameterName }' must non-zero. (${ value })` ];\n      }\n      break;\n    }\n    case `bipolar`: {\n      if (value > 1 || value < -1) {\n        return [ false, `Parameter '${ parameterName }' must be in bipolar percentage range (-1 to 1). (${ value })` ];\n      }\n      break;\n    }\n  }\n  return [ true ];\n};\n\nexport const throwNumberTest = (value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(numberTest(value, range, parameterName));\n}\n/**\n * Test a number, returning _true_ if it passes, _false_ if not.\n * Compared to {@link number} which by default throws an exception.\n * @param value\n * @param range\n * @returns\n */\n// export const numberTry = (\n//   value?: number,\n//   range: NumberGuardRange = ``\n// ): boolean => {\n//   return number(value, range, ``, false);\n// };\n\n/**\n * Throws if `value` is _undefined_ or _null_.\n * @param value\n * @param paramName\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const nullUndef = (value: any, parameterName = `?`): GuardResult => {\n  if (typeof value === `undefined`) {\n    return [ false, `${ parameterName } param is undefined` ];\n  }\n  if (value === null) return [ false, `${ parameterName } param is null` ];\n  return [ true ];\n};\n\nexport const throwFromResult = (test: GuardResultFail | GuardResultOk) => {\n  if (test[ 0 ]) return false;\n  else throw new Error(test[ 1 ]);\n}\n\n/**\n * Returns test of `value` being in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n *\n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param paramName Param name for customising exception message\n * @returns\n */\nexport const percentTest = (value: number, parameterName = `?`): GuardResult =>\n  numberTest(value, `percentage`, parameterName);\n\nexport const throwPercentTest = (value: number, parameterName = `?`) => {\n  throwFromResult(percentTest(value, parameterName));\n}\n/**\n * Checks if `value` an integer and meets additional criteria.\n * See {@link number} for guard details, or use that if integer checking is not required.\n *\n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param paramName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integerTest = (\n  value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`\n): GuardResult => {\n  // ✔️ Unit tested\n  const r = numberTest(value, range, parameterName);\n  if (!r[ 0 ]) return r;\n  if (!Number.isInteger(value)) {\n    return [ false, `Parameter ${ parameterName } is not an integer` ];\n  }\n  return [ true ];\n};\n\nexport const throwIntegerTest = (value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(integerTest(value, range, parameterName));\n}\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n *\n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n *\n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n *\n * @param value\n * @param range\n * @param defaultValue\n * @returns\n */\nexport const integerParse = (\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  range: NumberGuardRange = ``,\n  defaultValue: number = Number.NaN\n): number => {\n  // ✔️ Unit tested\n  if (value === undefined) return defaultValue;\n  if (value === null) return defaultValue;\n  try {\n    const parsed = Number.parseInt(value);\n    const r = integerTest(parsed, range, `parsed`);\n    return r[ 0 ] ? parsed : defaultValue;\n  } catch {\n    return defaultValue;\n  }\n  return Number.parseInt(value);\n};\n\n/**\n * Returns true if parameter is an array of strings\n * @param value\n * @returns\n */\nexport const isStringArray = (value: unknown): boolean => {\n  if (!Array.isArray(value)) return false;\n  return !value.some((v) => typeof v !== `string`);\n};\n\n/**\n * Throws an error if parameter is not an array\n * @param value\n * @param paramName\n */\nexport const arrayTest = (value: unknown, parameterName = `?`): GuardResult => {\n  if (!Array.isArray(value)) {\n    return [ false, `Parameter '${ parameterName }' is expected to be an array'` ];\n  }\n  return [ true ];\n};\n\nexport const throwArrayTest = (value: unknown, parameterName = `?`) => {\n  throwFromResult(arrayTest(value, parameterName));\n}\n\n/** Throws an error if parameter is not defined */\nexport const defined = <T>(argument: T | undefined): argument is T =>\n  argument !== undefined;\n","/**\n * A random source.\n *\n * Predefined sources: {@link defaultRandom}, {@link gaussianSource}, {@link weightedSource}\n */\nexport type RandomSource = () => number;\n\n\nexport type StringOptions = Readonly<{\n  length: number;\n  source?: RandomSource;\n}>\n\n/**\n * Default random number generator: `Math.random`.\n */\nexport const defaultRandom = Math.random;\n\nexport type RandomOptions = Readonly<{\n  max: number;\n  min?: number;\n  source?: RandomSource;\n}>","import { defaultRandom, type StringOptions } from \"./Types.js\";\n\n/**\n * Returns a string of random letters and numbers of a given `length`.\n *\n * ```js\n * string();  // Random string of length 5\n * string(4); // eg. `4afd`\n * ```\n * @param length Length of random string\n * @returns Random string\n */\nexport const string = (lengthOrOptions: number | StringOptions = 5) => {\n  const options =\n    typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;\n  const calculate = options.source ?? defaultRandom;\n  return calculate()\n    .toString(36)\n    .slice(2, length + 2);\n};"],"mappings":"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","names":["between","length"]}