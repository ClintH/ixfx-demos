{"version":3,"sources":["../src/data/maps/MapFns.ts"],"sourcesContent":["import { isEqualDefault, type IsEqual } from '../../util/IsEqual.js';\nimport {\n  toStringDefault,\n  defaultComparer,\n  type ToString,\n} from '../../util/index.js';\nimport type { IWithEntries } from '../../data/maps/IMappish.js';\n\n// âœ” UNIT TESTED!\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (\n  data: ReadonlyMap<number, any>,\n  target: number\n): number => {\n  target = Math.round(target);\n  if (data.has(target)) {\n    return target;\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let offset = 1;\n    while (offset < 1000) {\n      if (data.has(target - offset)) return target - offset;\n      else if (data.has(target + offset)) return target + offset;\n      offset++;\n    }\n    throw new Error(`Could not find target ${ target }`);\n  }\n};\n\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = getFromKeys(data, keys);\n * ```\n * @param data \n * @param keys \n * @returns \n */\nexport const getFromKeys = <T>(data: ReadonlyMap<string, T>, keys: Iterable<string>): T | undefined => {\n  for (const key of keys) {\n    if (data.has(key)) return data.get(key);\n  }\n}\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  if (!map.has(key)) return false;\n  const values = [ ...map.values() ];\n  return values.some((v) => comparer(v, value));\n};\n\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\"\n *\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * Maps.deleteByValue(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer\n */\nexport const deleteByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n) => {\n  for (const entry of Object.entries(map)) {\n    if (comparer(entry[ 1 ], value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      (map as any).delete(entry[ 0 ]);\n    }\n  }\n};\n\n\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByPredicate = <K, V>(\n  map: IWithEntries<K, V>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (predicate(entry[ 1 ], entry[ 0 ])) return entry;\n  }\n};\n\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = <K, V>(\n  map: IWithEntries<K, V>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (isEqual(entry[ 1 ], value)) return entry;\n  }\n};\n\n\n\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link Util.ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n *\n * @example\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\";\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * Maps.addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\nexport const addKeepingExisting = <V>(\n  set: ReadonlyMap<string, V> | undefined,\n  hasher: ToString<V>,\n  ...values: ReadonlyArray<V>\n) => {\n  const s = set === undefined ? new Map() : new Map(set);\n  for (const v of values) {\n    const hashResult = hasher(v);\n    if (s.has(hashResult)) continue;\n    s.set(hashResult, v);\n  }\n  return s;\n};\n\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  comparer?: (a: V, b: V) => number\n) => {\n  const f = comparer ?? defaultComparer;\n  return [ ...map.entries() ].sort((a, b) => f(a[ 1 ], b[ 1 ]));\n};\n\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * cosnt m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = Maps.sortByValue(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = <K, V, Z>(\n  map: ReadonlyMap<K, V>,\n  property: string,\n  compareFunction?: (a: Z, b: Z) => number\n) => {\n  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n  return [ ...map.entries() ].sort((aE, bE) => {\n    const a = aE[ 1 ];\n    const b = bE[ 1 ];\n    // @ts-expect-error\n    return cfn(a[ property ], b[ property ]);\n  });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  const entries = [ ...map.entries() ];\n  return entries.some((kv) => comparer(kv[ 1 ], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\n//eslint-disable-next-line func-style\nexport function* filter<V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = <V>(map: ReadonlyMap<string, V>): ReadonlyArray<V> =>\n  [ ...map.values() ];\n\n\n/**\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` }\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = Maps.fromIterable(data, v => v.fruit);\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param allowOverwrites When set to _true_, items with same id will silently overwrite each other, with last write wins. _false_ by default.\n * @returns\n */\nexport const fromIterable = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>,\n  allowOverwrites = false\n): ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const id = keyFunction(d);\n    if (m.has(id) && !allowOverwrites) {\n      throw new Error(\n        `id ${ id } is already used and new data will overwrite it. `\n      );\n    }\n    m.set(id, d);\n  }\n  return m;\n};\n\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = Maps.fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObject}.\n * @param data\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const fromObject = <V>(data: any): ReadonlyMap<string, V> => {\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\n  const map = new Map<string, V>();\n  if (Array.isArray(data)) {\n    for (const d of data) addObject<V>(map, d);\n  } else {\n    addObject<V>(map, data);\n  }\n  return map;\n};\n\n/**\n * Adds an object to an existing map. It assumes a structure where\n * each top-level property is a key:\n *\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * Maps.addObject(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const addObject = <V>(map: Map<string, V>, data: any) => {\n  const entries = Object.entries(data);\n  for (const [ key, value ] of entries) {\n    map.set(key, value as V);\n  }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const find = <V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n): V | undefined => [ ...map.values() ].find(v => predicate(v));\n\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link find} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map \n * @param predicate \n * @returns \n */\nexport const some = <V>(map: ReadonlyMap<string, V>, predicate: (v: V) => boolean): boolean => [ ...map.values() ].some(v => predicate(v));\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const mapToObjectTransform = <T, K>(\n  m: ReadonlyMap<string, T>,\n  valueTransform: (value: T) => K\n): Readonly<Record<string, K>> =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, unicorn/no-array-reduce\n  [ ...m ].reduce((object: any, [ key, value ]) => {\n    const t = valueTransform(value);\n    /* eslint-disable-next-line functional/immutable-data */\n    object[ key ] = t;\n    return object;\n  }, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = <V>(\n  keys: ReadonlyArray<string>,\n  values: ArrayLike<V | undefined>\n) => {\n  if (keys.length !== values.length) {\n    throw new Error(`Keys and values arrays should be same length`);\n  }\n  return Object.fromEntries(keys.map((k, index) => [ k, values[ index ] ]));\n};\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = <K, V, R>(\n  source: ReadonlyMap<K, V>,\n  transformer: (value: V, key: K) => R\n) => new Map(Array.from(source, (v) => [ v[ 0 ], transformer(v[ 1 ], v[ 0 ]) ]));\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport const toObject = <T>(\n  m: ReadonlyMap<string, T>\n): Readonly<Record<string, T>> =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  [ ...m ].reduce((object: any, [ key, value ]) => {\n    /* eslint-disable-next-line functional/immutable-data */\n    object[ key ] = value;\n    return object;\n  }, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = <K, V, R>(\n  m: ReadonlyMap<K, V>,\n  transformer: (key: K, item: V) => R\n): ReadonlyArray<R> => [ ...m.entries() ].map((x) => transformer(x[ 0 ], x[ 1 ]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Arrays.mergeByKey Arrays.mergeByKey} if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = <K, V>(\n  reconcile: MergeReconcile<V>,\n  ...maps: ReadonlyArray<ReadonlyMap<K, V>>\n): ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [ mk, mv ] of m) {\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return result;\n};\n"],"mappings":"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","names":[]}