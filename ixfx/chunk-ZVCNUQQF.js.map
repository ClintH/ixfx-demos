{"version":3,"sources":["../src/numbers/index.ts","../src/numbers/Generate.ts","../src/numbers/Ranges.ts","../src/numbers/IsApproximately.ts","../src/numbers/Guard.ts"],"sourcesContent":["export * from './Count.js';\nexport * from './Generate.js';\nexport * from './Ranges.js';\nexport * from './Round.js';\nexport * from './IsApproximately.js';\nexport * from './LinearSpace.js';\nexport * from './Guard.js';\nexport * from './Quantise.js';\n\nexport * from '../modulation/PingPong.js';\nexport * from '../modulation/Jitter.js';\nexport { integer as randomUniqueInteger } from '../random/index.js';\n\nimport { numberTracker } from '../data/NumberTracker.js';\nimport { type TrackedValueOpts as TrackedValueOptions } from '../data/TrackedValue.js';\nimport { isValid } from './Guard.js';\n\n\n\n/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n * \n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param obj \n * @param apply \n * @returns \n */\nexport const applyToValues = <T extends Record<string, any>>(object: T, apply: (v: number) => number): T => {\n  const o: T = { ...object };\n  for (const [ key, value ] of Object.entries(object)) {\n    if (typeof value === `number`) {\n      // Run number through function\n      //eslint-disable-next-line functional/immutable-data\n      (o as any)[ key ] = apply(value);\n    } else {\n      // Copy value\n      //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n      (o as any)[ key ] = value;\n    }\n  }\n  return o;\n}\n\n\n/**\n * Alias for [Data.numberTracker](https://clinth.github.io/ixfx/classes/Data.numberTracker-1.html)\n */\nexport const tracker = (options?: TrackedValueOptions) => numberTracker(options);\n\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filter(data)) {\n *  // 5\n * }\n * ```\n * @param it\n */\n//eslint-disable-next-line func-style\nexport function* filter(it: Iterable<unknown>) {\n  for (const v of it) {\n    if (isValid(v)) yield v;\n  }\n}\n","import { throwNumberTest } from \"../Guards.js\";\n\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n\n\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};","import * as NumericArrays from '../collections/arrays/NumericArrays.js';\n\nexport function average(...values: Array<number>): number {\n  return NumericArrays.average(values);\n}\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.min(10, 20, 0); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (...data: ReadonlyArray<number>): number =>\n  NumericArrays.min(data);\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.max(10, 20, 0); // Yields 20\n * ```\n * @param data\n * @returns Maximum number\n */\nexport const max = (...data: ReadonlyArray<number>): number =>\n  NumericArrays.max(data);\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.total(10, 20, 0); // Yields 30\n * ```\n * @param data\n * @returns Total\n */\nexport const total = (...data: ReadonlyArray<number>): number =>\n  NumericArrays.total(data);\n\n","import { numberTest, throwFromResult } from \"../Guards.js\";\nimport { round } from \"./Round.js\";\n\nexport function isApproximately(\n  baseValue: number,\n  rangePercent: number\n): (v: number) => boolean;\n\nexport function isApproximately(\n  baseValue: number,\n  rangePercent: number,\n  v: number\n): boolean;\n\n/**\n * Returns a function that yields _true_ if a value is within\n * a percentage range of a base value.\n *\n * ```js\n * // Allow 10% above or below\n * const closeTo100 = isApproximately(100, 0.1); // returns a function\n * closeTo100(100); // true\n * closeTo100(101); // true;\n * closeTo100(90); // true;\n * closeTo100(80); // false;\n * ```\n *\n * `isApproximately` returns a function, but if a third value is provided,\n * it returns true/false, testing the value:\n * ```js\n * isApproximately(100, 0.1, 101); // True\n * ```\n * If the tested value is not a number, _false_ is returned\n * (because it is not, in fact approximately `baseValue`).\n *\n * For baseValues between -2 and 2, the calculated difference is rounded down\n * to 5 decimal places to avoid weird JS floating point math.\n * @param baseValue\n * @param rangePercent\n * @returns\n */\nexport function isApproximately(\n  baseValue: number,\n  rangePercent: number,\n  v?: number\n) {\n  throwFromResult(numberTest(rangePercent, `percentage`, `rangePercent`));\n  throwFromResult(numberTest(baseValue, ``, `baseValue`));\n\n  const diff = baseValue * rangePercent;\n  const test = (v: number): boolean => {\n    try {\n      throwFromResult(numberTest(v, ``, `v`));\n\n      //eslint-disable-next-line functional/no-let\n      let diffV = Math.abs(v - baseValue);\n      if (Math.abs(baseValue) <= 2) {\n        diffV = round(5, diffV);\n      }\n      return diffV <= diff;\n    } catch {\n      return false;\n    }\n  };\n\n  return v === undefined ? test : test(v);\n}\n","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber: unknown) => {\n  if (typeof possibleNumber !== `number`) return false;\n  if (Number.isNaN(possibleNumber)) return false;\n  return true;\n};"],"mappings":"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","names":["average","max","min","total","average","min","max","total","v"]}