{"version":3,"sources":["../src/modulation/index.ts","../src/modulation/envelope/index.ts","../src/modulation/envelope/Types.ts","../src/modulation/envelope/AdsrBase.ts","../src/modulation/envelope/Adsr.ts","../src/modulation/source/index.ts","../src/modulation/source/Ticks.ts","../src/modulation/source/Time.ts","../src/modulation/source/PerSecond.ts","../src/modulation/CubicBezier.ts","../src/modulation/Drift.ts","../src/modulation/Forces.ts","../src/modulation/Jitter.ts","../src/modulation/Mix.ts","../src/modulation/Noop.ts","../src/modulation/Oscillator.ts","../src/modulation/PingPong.ts","../src/modulation/Spring.ts","../src/modulation/Waveforms.ts","../src/modulation/WeightedAverage.ts"],"sourcesContent":["/**\n * Easings module\n *\n * [See the guide](https://clinth.github.io/ixfx-docs/modulation/easing/)\n *\n * Overview:\n * * {@link Easings.create}: Create an easing with provided settings\n * * {@link Easings.time}: Ease by time\n * * {@link Easings.ticks}: Ease by tick\n * * {@link Easings.get}: Get an easing function by name\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import { Easings } from '../../ixfx/dist/modulation.js';\n * Easings.time(...);\n *\n * // Import from web\n * import { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * Easings.time(...);\n * ```\n */\nexport * as Easings from './easing/index.js';\nexport * as Envelopes from './envelope/index.js';\nexport * as Sources from './source/index.js';\n\nexport * from './CubicBezier.js'\nexport * from './Drift.js';\n\n/**\n * Forces module can help to compute basic physical forces like gravity, friction, springs etc.\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import { Forces } from '../../ixfx/dist/modulation.js';\n * Forces.attractionForce(...);\n *\n * // Import from web\n * import { Forces } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * Forces.attractionForce(...);\n * ```\n *\n */\nexport * as Forces from './Forces.js';\nexport * from './Gaussian.js';\nexport * from './Jitter.js';\nexport * from './Mix.js';\nexport * from './ModulatorTimed.js';\nexport * from './Noop.js';\n/**\n * Oscillators module has waveshapes for producing values with a specified frequency.\n *\n * Overview\n * * {@link saw}: 'Sawtooth' wave\n * * {@link sine}: Sine wave\n * * {@link sineBipolar}: Sine wave with range of -1 to 1\n * * {@link square}: Square wave\n * * {@link triangle}: Triangle wave\n *\n * @example On-demand sampling\n * ```js\n * // Saw wave with frequency of 0.10hZ\n * const osc = Oscillators.saw(0.1);\n *\n * // Whever we need to sample from the oscillator...\n * const v = osc.next().value;\n * ```\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import { Oscillators } from '../../ixfx/dist/modulation.js';\n * Oscillators.saw(...);\n *\n * // Import from web\n * import { Oscillators } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * Oscillators.saw(...);\n * ```\n *\n */\nexport * as Oscillators from './Oscillator.js';\nexport * from './PingPong.js';\nexport * from './Spring.js';\nexport type * from './Types.js';\n//import * as Easings from './easing/index.js';\n//import * as Envelopes from './envelope/index.js';\n//import * as Forces from './Forces.js';\nexport * from './Waveforms.js';\nexport * from './WeightedAverage.js';\n","import type { AsyncPromiseOrGenerator } from 'src/flow/Types.js';\nimport { Adsr } from './Adsr.js';\nimport type { EnvelopeOpts } from './Types.js';\nimport { resolveWithFallback, resolveWithFallbackSync } from '../../data/Resolve.js';\n\nexport * from './Types.js';\nexport * from './Adsr.js';\nexport * from './AdsrBase.js';\n\n/**\n * Returns a function that iterates over an envelope\n * ```js\n * const e = Envelopes.adsr();\n * \n * e(); // Yields current value\n * ```\n * \n * Starts the envelope the first time the return function is called.\n * When the envelope finishes, it continues to return the `releaseLevel` of the envelope.\n * \n * Options can be provided to set the shape of the envelope as usual, eg:\n * ```js\n * const e = Envelopes.adsr({\n *  attackDuration: 1000,\n *  releaseDuration: 500\n * });\n * ```\n * @param opts \n * @returns \n */\nexport const adsr = (opts: EnvelopeOpts = {}) => {\n  const envelope = new Adsr(opts);\n  const finalValue = envelope.releaseLevel;\n  const iterator = envelope[ Symbol.iterator ]();\n  return () => resolveWithFallbackSync(iterator, { overrideWithLast: true, value: finalValue });\n}\n\n/**\n * Creates and runs an envelope, sampling its values at `sampleRateMs`.\n * Note that if the envelope loops, iterator never returns.\n *\n * @example Init\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * import { IterableAsync } from  'https://unpkg.com/ixfx/dist/util.js';\n *\n * const opts = {\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * ```\n *\n * ```js\n * //  Add data to array\n * // Sample an envelope every 20ms into an array\n * const data = await IterableAsync.toArray(Envelopes.adsrIterable(opts, 20));\n * ```\n *\n * ```js\n * // Iterate with `for await`\n * // Work with values as sampled\n * for await (const v of Envelopes.adsrIterable(opts, 5)) {\n *  // Work with envelope value `v`...\n * }\n * ```\n * @param opts Envelope options\n * @returns\n */\n// export async function* adsrIterable(\n//   opts: AdsrIterableOpts\n// ): AsyncGenerator<number> {\n//   const envelope = adsr(opts.env);\n//   const sampleRateMs = opts.sampleRateMs ?? 100;\n//   envelope.trigger();\n\n//   for await (const v of interval<number>(\n//     () => {\n//       if (envelope.isDone) return;\n//       return envelope.value;\n//     },\n//     {\n//       fixed: sampleRateMs,\n//       signal: opts.signal,\n//     }\n//   )) {\n//     yield v;\n//   }\n// }\n","export type EnvelopeOpts = AdsrOpts & AdsrTimingOpts;\n/**\n * Options for the ADSR envelope.\n */\nexport type AdsrOpts = Partial<{\n  /**\n   * Attack bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly attackBend: number;\n  /**\n   * Decay bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly decayBend: number;\n  /**\n   * Release bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly releaseBend: number;\n\n  /**\n   * Peak level (maximum of attack stage)\n   */\n  readonly peakLevel: number;\n\n  /**\n   * Starting level (usually 0)\n   */\n  readonly initialLevel: number;\n  /**\n   * Sustain level. Only valid if trigger and hold happens\n   */\n  readonly sustainLevel: number;\n  /**\n   * Release level, when envelope is done (usually 0)\n   */\n  readonly releaseLevel: number;\n\n  /**\n   * When _false_, envelope starts from it's current level when being triggered.\n   * _True_ by default.\n   */\n  readonly retrigger: boolean;\n}>;\n\nexport type AdsrTimingOpts = Partial<{\n  /**\n   * If true, envelope indefinately returns to attack stage after release\n   *\n   * @type {boolean}\n   */\n  readonly shouldLoop: boolean;\n\n  /**\n   * Duration for attack stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly attackDuration: number;\n  /**\n   * Duration for decay stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly decayDuration: number;\n  /**\n   * Duration for release stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly releaseDuration: number;\n}>;\n\nexport type AdsrIterableOpts = {\n  readonly signal?: AbortSignal;\n  readonly sampleRateMs?: number;\n  readonly env: EnvelopeOpts;\n};\n\n/**\n * State change event\n */\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface StateChangeEvent {\n  readonly newState: string;\n  readonly priorState: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface CompleteEvent {\n  /* no-op */\n}\n\nexport type AdsrEvents = {\n  readonly change: StateChangeEvent;\n  readonly complete: CompleteEvent;\n};\n\nexport const adsrStateTransitions = Object.freeze({\n  attack: [ `decay`, `release` ],\n  decay: [ `sustain`, `release` ],\n  sustain: [ `release` ],\n  release: [ `complete` ],\n  complete: null,\n});\nexport type AdsrStateTransitions = Readonly<typeof adsrStateTransitions>;\n\n","import { SimpleEventEmitter } from '../../Events.js';\nimport { elapsedMillisecondsAbsolute, type Timer, type TimerSource } from '../../flow/Timer.js';\nimport { adsrStateTransitions, type AdsrEvents, type AdsrStateTransitions, type AdsrTimingOpts } from './Types.js';\nimport { StateMachineWithEvents } from '../../flow/StateMachineWithEvents.js';\n\nexport const defaultAdsrTimingOpts = Object.freeze({\n  attackDuration: 600,\n  decayDuration: 200,\n  releaseDuration: 800,\n  shouldLoop: false\n})\n/**\n * Base class for an ADSR envelope.\n * \n * It outputs values on a scale of 0..1 corresponding to each phase.\n */\nexport class AdsrBase extends SimpleEventEmitter<AdsrEvents> {\n  readonly #sm: StateMachineWithEvents<AdsrStateTransitions>;\n  readonly #timeSource: TimerSource;\n\n  #timer: Timer | undefined;\n  #holding: boolean;\n  #holdingInitial: boolean;\n  #disposed = false;\n  #triggered = false;\n  protected attackDuration: number;\n  protected decayDuration: number;\n  protected releaseDuration: number;\n  protected decayDurationTotal: number;\n\n  /**\n   * If _true_ envelope will loop\n   */\n  shouldLoop: boolean;\n\n  constructor(opts: AdsrTimingOpts = {}) {\n    super();\n\n    this.attackDuration = opts.attackDuration ?? defaultAdsrTimingOpts.attackDuration;\n    this.decayDuration = opts.decayDuration ?? defaultAdsrTimingOpts.decayDuration;\n    this.releaseDuration = opts.releaseDuration ?? defaultAdsrTimingOpts.releaseDuration;\n    this.shouldLoop = opts.shouldLoop ?? defaultAdsrTimingOpts.shouldLoop;\n\n    this.#sm = new StateMachineWithEvents<AdsrStateTransitions>(\n      adsrStateTransitions,\n      { initial: `attack` }\n    );\n\n    this.#sm.addEventListener(`change`, (event) => {\n      // Reset timer on release\n      if (event.newState === `release` && this.#holdingInitial) {\n        this.#timer?.reset();\n      }\n      super.fireEvent(`change`, event);\n    });\n    this.#sm.addEventListener(`stop`, (event) => {\n      super.fireEvent(`complete`, event);\n    });\n\n    this.#timeSource = () => elapsedMillisecondsAbsolute();\n    this.#holding = this.#holdingInitial = false;\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\n  }\n\n  dispose() {\n    if (this.#disposed) return;\n    this.#sm.dispose();\n  }\n\n  get isDisposed() {\n    return this.#disposed;\n  }\n  protected switchStateIfNeeded(): boolean {\n    if (this.#timer === undefined) return false;\n    let elapsed = this.#timer.elapsed;\n    const wasHeld = this.#holdingInitial && !this.#holding;\n\n    // Change through states for as long as needed\n    let hasChanged = false;\n    do {\n      hasChanged = false;\n      switch (this.#sm.state) {\n        case `attack`: {\n          if (elapsed > this.attackDuration || wasHeld) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `decay`: {\n          if (elapsed > this.decayDurationTotal || wasHeld) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `sustain`: {\n          if (!this.#holding || wasHeld) {\n            elapsed = 0;\n            this.#sm.next();\n            this.#timer.reset();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `release`: {\n          if (elapsed > this.releaseDuration) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `complete`: {\n          if (this.shouldLoop) {\n            this.trigger(this.#holdingInitial);\n          }\n        }\n      }\n    } while (hasChanged);\n    return hasChanged;\n  }\n\n  /**\n   * Computes a stage progress from 0-1\n   * @param allowStateChange\n   * @returns\n   */\n  protected computeRaw(\n    allowStateChange = true\n  ): [ stage: string | undefined, amount: number, prevStage: string ] {\n    if (this.#timer === undefined) {\n      return [ undefined, 0, this.#sm.state ];\n    }\n    // Change state if necessary based on elapsed time\n    if (allowStateChange) this.switchStateIfNeeded();\n\n    const previousStage = this.#sm.state;\n    const elapsed = this.#timer.elapsed;\n\n    let relative = 0;\n    const state = this.#sm.state;\n    switch (state) {\n      case `attack`: {\n        relative = elapsed / this.attackDuration;\n        break;\n      }\n      case `decay`: {\n        relative = (elapsed - this.attackDuration) / this.decayDuration;\n        break;\n      }\n      case `sustain`: {\n        relative = 1;\n        break;\n      }\n      case `release`: {\n        relative = Math.min(elapsed / this.releaseDuration, 1);\n        break;\n      }\n      case `complete`: {\n        return [ undefined, 1, previousStage ];\n      }\n      default: {\n        throw new Error(`State machine in unknown state: ${ state }`);\n      }\n    }\n    return [ state, relative, previousStage ];\n  }\n\n  /**\n   * Returns _true_ if envelope has finished\n   */\n  get isDone(): boolean {\n    return this.#sm.isDone;\n  }\n\n  protected onTrigger(): void {\n    /* no op */\n  }\n\n  /**\n   * Triggers envelope.\n   *\n   * If event is already trigged,\n   * it will be _retriggered_. If`opts.retriggered` is false (default)\n   * envelope starts again at `opts.initialValue`. Otherwise it starts at\n   * the current value.\n   *\n   * @param hold If _true_ envelope will hold at sustain stage\n   */\n  trigger(hold = false) {\n    this.onTrigger();\n    this.#triggered = true;\n    this.#sm.reset();\n    this.#timer = this.#timeSource();\n    this.#holding = hold;\n    this.#holdingInitial = hold;\n  }\n\n  get hasTriggered() {\n    return this.#triggered;\n  }\n\n  compute(): void {\n    /* no-op */\n  }\n\n  /**\n   * Release if 'trigger(true)' was previouslly called.\n   * Has no effect if not triggered or held.\n   * @returns \n   */\n  release() {\n    if (this.isDone || !this.#holdingInitial) return; // Was never holding or done\n\n    // Setting holding flag to false, computeRaw will change state\n    this.#holding = false;\n    this.compute();\n  }\n}","import type { Path } from '../../geometry/path/index.js';\nimport * as Bezier from '../../geometry/bezier/index.js';\nimport { scale } from '../../numbers/Scale.js';\nimport { AdsrBase } from './AdsrBase.js';\nimport type { EnvelopeOpts } from './Types.js';\n\nexport const defaultAdsrOpts = Object.freeze({\n  attackBend: -1,\n  decayBend: -0.3,\n  releaseBend: -0.3,\n  peakLevel: 1,\n  initialLevel: 0,\n  sustainLevel: 0.6,\n  releaseLevel: 0,\n  retrigger: false\n})\n\nexport class AdsrIterator implements Iterator<number> {\n\n  constructor(private adsr: Adsr) {\n\n  }\n\n  next(...args: [] | [ undefined ]): IteratorResult<number, any> {\n    if (!this.adsr.hasTriggered) {\n      this.adsr.trigger();\n    }\n\n    const c = this.adsr.compute();\n    return {\n      value: c[ 1 ],\n      done: c[ 0 ] === undefined\n    }\n  }\n\n  get [ Symbol.toStringTag ]() {\n    return `Generator`;\n  }\n}\n/**\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\n * usually in response to an intial trigger.\n *\n * [See the ixfx Guide on Envelopes](https://clinth.github.io/ixfx-docs/modulation/envelope/).\n *\n * @example Setup\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * const env = new Envelopes.Adsr({\n *  attackDuration: 1000,\n *  decayDuration: 200,\n *  sustainDuration: 100\n * });\n * ```\n *\n * [Options for envelope](https://clinth.github.io/ixfx/types/Modulation.Envelopes.AdsrOpts.html) are as follows:\n *\n * ```js\n * initialLevel?: number\n * attackBend: number\n * attackDuration: number\n * decayBend: number\n * decayDuration:number\n * sustainLevel: number\n * releaseBend: number\n * releaseDuration: number\n * releaseLevel?: number\n * peakLevel: number\n * retrigger?: boolean\n * shouldLoop: boolean\n * ```\n *\n * If `retrigger` is false, re-triggers will continue at current level\n * rather than resetting to `initialLevel`.\n *\n * If `shouldLoop` is true, envelope loops until `release()` is called.\n *\n * @example Using\n * ```js\n * env.trigger(); // Start envelope\n * ...\n * // Get current value of envelope\n * const [state, scaled, raw] = env.compute();\n * ```\n *\n * * `state` is a string, one of the following: 'attack', 'decay', 'sustain', 'release', 'complete'\n * * `scaled` is a value scaled according to the stage's _levels_\n * * `raw` is the progress from 0 to 1 within a stage. ie. 0.5 means we're halfway through a stage.\n *\n * Instead of `compute()`, most usage of the envelope is just fetching the `value` property, which returns the same scaled value of `compute()`:\n *\n * ```js\n * const value = env.value; // Get scaled number\n * ```\n *\n * @example Hold & release\n * ```js\n * env.trigger(true);   // Pass in true to hold\n * ...envelope will stop at sustain stage...\n * env.release();      // Release into decay\n * ```\n *\n * Check if it's done:\n *\n * ```js\n * env.isDone; // True if envelope is completed\n * ```\n *\n * Envelope has events to track activity: 'change' and 'complete':\n *\n * ```\n * env.addEventListener(`change`, ev => {\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\n * })\n * ```\n * \n * It's also possible to iterate over the values of the envelope:\n * ```js\n * const env = new Envelopes.Adsr();\n * for await (const v of env) {\n *  // v is the numeric value\n *  await Flow.sleep(100); // Want to pause a little to give envelope time to run\n * }\n * // Envelope has finished\n * ```\n */\nexport class Adsr extends AdsrBase implements Iterable<number> {\n  readonly attackPath: Path;\n  readonly decayPath: Path;\n  readonly releasePath: Path;\n\n  readonly initialLevel;\n  readonly peakLevel;\n  readonly releaseLevel;\n  readonly sustainLevel;\n\n  readonly attackBend;\n  readonly decayBend;\n  readonly releaseBend;\n\n  protected initialLevelOverride: number | undefined;\n  readonly retrigger: boolean;\n  private releasedAt: number | undefined;\n\n  constructor(opts: EnvelopeOpts = {}) {\n    super(opts);\n\n    this.retrigger = opts.retrigger ?? defaultAdsrOpts.retrigger;\n\n    this.initialLevel = opts.initialLevel ?? defaultAdsrOpts.initialLevel;\n    this.peakLevel = opts.peakLevel ?? defaultAdsrOpts.peakLevel;\n    this.releaseLevel = opts.releaseLevel ?? defaultAdsrOpts.releaseLevel;\n    this.sustainLevel = opts.sustainLevel ?? defaultAdsrOpts.sustainLevel;\n\n    this.attackBend = opts.attackBend ?? defaultAdsrOpts.attackBend;\n    this.releaseBend = opts.releaseBend ?? defaultAdsrOpts.releaseBend;\n    this.decayBend = opts.decayBend ?? defaultAdsrOpts.decayBend;\n\n    const max = 1;\n    this.attackPath = Bezier.toPath(\n      Bezier.quadraticSimple(\n        { x: 0, y: this.initialLevel },\n        { x: max, y: this.peakLevel },\n        -this.attackBend\n      )\n    );\n    this.decayPath = Bezier.toPath(\n      Bezier.quadraticSimple(\n        { x: 0, y: this.peakLevel },\n        { x: max, y: this.sustainLevel },\n        -this.decayBend\n      )\n    );\n    this.releasePath = Bezier.toPath(\n      Bezier.quadraticSimple(\n        { x: 0, y: this.sustainLevel },\n        { x: max, y: this.releaseLevel },\n        -this.releaseBend\n      )\n    );\n  }\n\n  protected onTrigger() {\n    this.initialLevelOverride = undefined;\n    if (!this.retrigger) {\n      const [ _stage, scaled, _raw ] = this.compute();\n      if (!Number.isNaN(scaled) && scaled > 0) {\n        this.initialLevelOverride = scaled;\n      }\n    }\n  }\n\n  [ Symbol.iterator ](): Iterator<number> {\n    return new AdsrIterator(this);\n  }\n\n  /**\n   * Returns the scaled value\n   * Same as .compute()[1]\n   */\n  get value(): number {\n    return this.compute(true)[ 1 ];\n  }\n\n  /**\n   * Compute value of envelope at this point in time.\n   *\n   * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\n   * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\n   */\n  compute(\n    allowStateChange = true\n  ): [ stage: string | undefined, scaled: number, raw: number ] {\n    const [ stage, amt ] = super.computeRaw(allowStateChange);\n    if (stage === undefined) return [ undefined, Number.NaN, Number.NaN ];\n    let v;\n    switch (stage) {\n      case `attack`: {\n        v = this.attackPath.interpolate(amt).y;\n        if (this.initialLevelOverride !== undefined) {\n          v = scale(v, 0, 1, this.initialLevelOverride, 1);\n        }\n        this.releasedAt = v;\n        break;\n      }\n      case `decay`: {\n        v = this.decayPath.interpolate(amt).y;\n        this.releasedAt = v;\n        break;\n      }\n      case `sustain`: {\n        v = this.sustainLevel;\n        this.releasedAt = v;\n        break;\n      }\n      case `release`: {\n        v = this.releasePath.interpolate(amt).y;\n        // Bound release level to the amp level that we released at.\n        // ie. when release happens before a stage completes\n        if (this.releasedAt !== undefined) {\n          v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\n        }\n        break;\n      }\n      case `complete`: {\n        v = this.releaseLevel;\n        this.releasedAt = undefined;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown state: ${ stage }`);\n      }\n    }\n    return [ stage, v, amt ];\n  }\n}","export * from './Ticks.js'\nexport * from './Time.js';\nexport * from './PerSecond.js';","import { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport type { ModSettable, ModSettableFeedback, ModSettableOptions } from \"../Types.js\";\n\nexport type TicksModSettableOptions = ModSettableOptions & {\n  exclusiveStart: boolean\n  exclusiveEnd: boolean\n}\n/**\n * Returns a function which cycles between 0..1 (inclusive of 0 and 1).\n * `totalTicks` is how many ticks it takes to get to 1. Since we want an inclusive 0 & 1,\n * the total ticks is actually +1.\n *\n * Ie. if totalTicks = 10, we get: 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\n * \n * Use 'exclusiveStart' or 'exclusiveEnd' to shift range. Eg 'exclusiveStart' will begin at 0.1 and\n * include 1.0, while 'exclusiveEnd' will start at 0 and run up to and including 0.9.\n * \n * Other examples:\n * * totalTicks: 20, value goes up by 0.05\n * * totalTicks: 1, value goes up by 1\n * @param totalTicks Positive, integer value. How many ticks to complete a cycle\n * @param options\n * @returns \n */\nexport function ticks(totalTicks: number, options: Partial<TicksModSettableOptions> = {}): ModSettable {\n  throwIntegerTest(totalTicks, `aboveZero`, `totalTicks`);\n  const exclusiveStart = options.exclusiveStart ?? false;\n  const exclusiveEnd = options.exclusiveEnd ?? false;\n  const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n\n  const startPoint = exclusiveStart ? 1 : 0;\n  const endPoint = exclusiveEnd ? totalTicks - 1 : totalTicks;\n\n  let cycleCount = 0;\n  let v = options.startAt ?? startPoint;\n  if (options.startAtRelative) {\n    let totalTicksForReal = totalTicks;\n    if (exclusiveStart) totalTicksForReal--;\n    if (exclusiveEnd) totalTicksForReal--;\n    v = Math.round(options.startAtRelative * totalTicksForReal);\n  }\n\n  return (feedback?: Partial<ModSettableFeedback>) => {\n    if (feedback) {\n      if (feedback.resetAt !== undefined) {\n        v = feedback.resetAt;\n      }\n      if (feedback.resetAtRelative !== undefined) {\n        v = Math.floor(feedback.resetAtRelative * totalTicks);\n      }\n    }\n    if (cycleCount >= cycleLimit) return 1;\n\n    let current = v / totalTicks;\n    v++;\n    if (v > endPoint) {\n      cycleCount++;\n      v = startPoint;\n    }\n    return current;\n  }\n}\n","import { type Interval, intervalToMs } from \"../../flow/IntervalType.js\";\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { ModSettableOptions, ModSettable, ModSettableFeedback } from \"../Types.js\";\n\n/**\n * Returns an elapsed number of milliseconds up to `interval`.\n * If `oneShot` is _false_ (default), it will loop, resetting to 0 when `interval` is reached.\n * If `oneShot` is _true_, once `interval` is reached, this value will be returned.\n * \n * The starting 'position' is `performance.now()`. If `startAt` option is provided, this will be used instead.\n * It probably should be an offset of `performance.now()`, eg: `{ startAt: performance.now() - 500 }` to shift\n * the cycle by 500ms.\n * \n * When using `startAtRelative`, the starting position will be set backward by the relative amount. A value\n * of 0.5, for example, will set the timer back 50% of the interval, meaning the cycle will start half way through.\n * @param interval \n * @param options \n * @returns \n */\nexport function elapsed(interval: Interval, options: Partial<ModSettableOptions> = {}): ModSettable {\n  const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = 1;\n  let start = options.startAt ?? performance.now();\n  let cycleCount = 0;\n  const intervalMs = intervalToMs(interval, 1000);\n  if (options.startAtRelative) {\n    throwNumberTest(options.startAtRelative, `percentage`, `startAtRelative`);\n    start = performance.now() - (intervalMs * options.startAtRelative);\n  }\n  //let stopAt = cycleLimit > 0 ? (intervalMs + start) : Number.MAX_SAFE_INTEGER;\n  return (feedback?: Partial<ModSettableFeedback>) => {\n    if (feedback) {\n      if (feedback.resetAt !== undefined) {\n        start = feedback.resetAt;\n        if (start === 0) start = performance.now();\n      }\n      if (feedback.resetAtRelative !== undefined) {\n        throwNumberTest(feedback.resetAtRelative, `percentage`, `resetAtRelative`);\n        start = performance.now() - (intervalMs * feedback.resetAtRelative);\n      }\n    }\n    if (cycleCount >= cycleLimit) return limitValue;\n    const now = performance.now();\n    const elapsedCycle = now - start;\n    if (elapsedCycle >= intervalMs) {\n      cycleCount += Math.floor(elapsedCycle / intervalMs);\n      start = now;\n      if (cycleCount >= cycleLimit) return limitValue;\n    }\n    return (elapsedCycle % intervalMs) / intervalMs;\n  }\n\n  // } else {\n  //   return () => ((performance.now() - start) % intervalMs) / intervalMs;\n  // }\n}\n\n/**\n * Counts beats based on a BPM\n * @param bpm \n * @param options \n * @returns \n */\nexport function bpm(bpm: number, options: Partial<ModSettableOptions>): ModSettable {\n  const interval = (60 * 1000) / bpm; // milliseconds between beats.\n  return elapsed(interval, options);\n}\n\n/**\n * Counts based on hertz (oscillations per second)\n * @param hz \n * @param options \n * @returns \n */\nexport function hertz(hz: number, options: Partial<ModSettableOptions>): ModSettable {\n  const interval = 1000 / hz;\n  return elapsed(interval, options);\n}\n\n","import type { ModSource } from \"../Types.js\";\n\n/**\n * Returns a proportion of `amount` depending on elapsed time.\n * The idea being that cumulatively, `amount` is yielded every second.\n * \n * ```js\n * // Calculate a proportion of 0.1 every second\n * const x = perSecond(0.1);\n * x();\n * ```\n * \n * The faster `x()` is called, the smaller the chunks of `amount` are returned.\n * Values accumulate. For example, `x()` isn't called for two seconds, 2*amount is returned.\n * \n * @example Usage\n * ```js\n * const settings = {\n *  ageMod: perSecond(0.1);\n* };\n * \n * let state = {\n *  age: 1\n * };\n * \n * // Update\n * setInterval(() => {\n *  let { age } = state;\n *  // Add 0.1 per second, regardless of \n *  // loop speed\n *  age += settings.ageMod(); \n *  state = {\n *    ...state,\n *    age: clamp(age)\n *  }\n * });\n * ```\n * \n * Options:\n * * max: if specified, the max return value\n * * min: if specified, the min return value\n * @param amount\n * @returns \n */\nexport const perSecond = (amount: number, options: Partial<{ max: number, min: number }> = {}): ModSource => {\n  const perMilli = amount / 1000;\n  const min = options.min ?? Number.MIN_SAFE_INTEGER;\n  const max = options.max ?? Number.MAX_SAFE_INTEGER;\n  let called = performance.now();\n\n  return () => {\n    const now = performance.now();\n    const elapsed = now - called;\n    called = now;\n    const x = perMilli * elapsed;\n    if (x > max) return max;\n    if (x < min) return min;\n    return x;\n  }\n}\n\n/**\n * As {@link perSecond}, but per minute.\n * @param amount \n * @param options \n * @returns \n */\nexport const perMinute = (amount: number, options: Partial<{ max: number, min: number }> = {}): ModSource => {\n  return perSecond(amount / 60, options);\n}","import type { Modulate } from \"./Types.js\";\n\n/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @returns Value\n */\nexport const cubicBezierShape =\n  (b: number, d: number): Modulate =>\n    (t: number) => {\n      const s = 1 - t;\n      const s2 = s * s;\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n    };\n","export type Drifter = {\n  update(v: number): number;\n  reset(): void;\n};\n\n/**\n * WIP\n * Returns a {@link Drifter} that moves a value over time.\n *\n * It keeps track of how much time has elapsed, accumulating `driftAmtPerMs`.\n * The accumulated drift is wrapped on a 0..1 scale.\n * ```js\n * // Set up the drifer\n * const d = drif(0.001);\n *\n * d.update(1.0);\n * // Returns 1.0 + accumulated drift\n * ```\n * @param driftAmtPerMs\n * @returns\n */\nexport const drift = (driftAmtPerMs: number): Drifter => {\n  //eslint-disable-next-line functional/no-let\n  let lastChange = performance.now();\n\n  const update = (v: number = 1) => {\n    const elapsed = performance.now() - lastChange;\n\n    const amt = (driftAmtPerMs * elapsed) % 1;\n    lastChange = performance.now();\n    const calc = (v + amt) % 1;\n    return calc;\n  };\n\n  const reset = () => {\n    lastChange = performance.now();\n  };\n  return { update, reset };\n};\n","/**\n * Acknowledgements: much of the work here is an adapation from Daniel Shiffman's excellent _The Nature of Code_ website.\n */\nimport { Points, Polar } from '../geometry/index.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport { clamp } from '../numbers/Clamp.js';\nimport { interpolateAngle } from '../numbers/Interpolate.js';\nimport { getEdgeX, getEdgeY, type Rect } from '../geometry/rect/index.js';\nimport { divide as PointDivide } from '../geometry/point/Divider.js';\n\n/**\n * Logic for applying mass\n */\nexport type MassApplication = `dampen` | `multiply` | `ignored`;\n\n/**\n * Basic properties of a thing that can be\n * affected by forces\n */\nexport type ForceAffected = {\n  /**\n   * Position. Probably best to use relative coordinates\n   */\n  readonly position?: Point;\n  /**\n   * Velocity vector.\n   * Probably don't want to assign this yourself, but rather have it computed based on acceleration and applied forces\n   */\n  readonly velocity?: Point;\n  /**\n   * Acceleration vector. Most applied forces will alter the acceleration, culminating in a new velocity being set and the\n   * acceleraton value zeroed\n   */\n  readonly acceleration?: Point;\n  /**\n   * Mass. The unit is undefined, again best to think of this being on a 0..1 scale. Mass is particularly important\n   * for the attraction/repulsion force, but other forces can incorporate mass too.\n   */\n  readonly mass?: number;\n\n  readonly angularAcceleration?: number;\n\n  readonly angularVelocity?: number;\n\n  readonly angle?: number;\n};\n\n/**\n * A function that updates values of a thing.\n *\n * These can be created using the xxxForce functions, eg {@link attractionForce}, {@link accelerationForce}, {@link magnitudeForce}, {@link velocityForce}\n */\nexport type ForceFn = (t: ForceAffected) => ForceAffected;\n\n/**\n * A vector to apply to acceleration or a force function\n */\nexport type ForceKind = Point | ForceFn | null;\n\n/**\n * Throws an error if `t` is not of the `ForceAffected` shape.\n * @param t\n * @param name\n */\nexport const guard = (t: ForceAffected, name = `t`) => {\n  if (t === undefined) {\n    throw new Error(`Parameter ${ name } is undefined. Expected ForceAffected`);\n  }\n  if (t === null) {\n    throw new Error(`Parameter ${ name } is null. Expected ForceAffected`);\n  }\n  if (typeof t !== `object`) {\n    throw new TypeError(\n      `Parameter ${ name } is type ${ typeof t }. Expected object of shape ForceAffected`\n    );\n  }\n};\n\n/**\n * `constrainBounce` yields a function that affects `t`'s position and velocity such that it\n * bounces within bounds.\n *\n * ```js\n * // Setup bounce with area constraints\n * // Reduce velocity by 10% with each impact\n * const b = constrainBounce({ width:200, height:500 }, 0.9);\n *\n * // Thing\n * const t = {\n *  position: { x: 50,  y: 50 },\n *  velocity: { x: 0.3, y: 0.01 }\n * };\n *\n * // `b` returns an altereted version of `t`, with the\n * // bounce logic applied.\n * const bounced = b(t);\n * ```\n *\n * `dampen` parameter allows velocity to be dampened with each bounce. A value\n * of 0.9 for example reduces velocity by 10%. A value of 1.1 will increase velocity by\n * 10% with each bounce.\n * @param bounds Constraints of area\n * @param dampen How much to dampen velocity by. Defaults to 1 meaning there is no damping.\n * @returns A function that can perform bounce logic\n */\nexport const constrainBounce = (\n  bounds?: Rect,\n  dampen = 1\n) => {\n  if (!bounds) bounds = { width: 1, height: 1 }\n  const minX = getEdgeX(bounds, `left`);\n  const maxX = getEdgeX(bounds, `right`);\n  const minY = getEdgeY(bounds, `top`);\n  const maxY = getEdgeY(bounds, `bottom`);\n\n  return (t: ForceAffected): ForceAffected => {\n    const position = computePositionFromVelocity(\n      t.position ?? Points.Empty,\n      t.velocity ?? Points.Empty\n    );\n\n    let velocity = t.velocity ?? Points.Empty;\n    let { x, y } = position;\n\n    if (x > maxX) {\n      x = maxX;\n      velocity = Points.invert(Points.multiply(velocity, dampen), `x`);\n    } else if (x < minX) {\n      x = minX;\n      velocity = Points.invert(Points.multiply(velocity, dampen), `x`);\n    }\n\n    if (y > maxY) {\n      y = maxY;\n      velocity = Points.multiply(Points.invert(velocity, `y`), dampen);\n    } else if (position.y < minY) {\n      y = minY;\n      velocity = Points.invert(Points.multiply(velocity, dampen), `y`);\n    }\n\n    return Object.freeze({\n      ...t,\n      position: { x, y },\n      velocity,\n    });\n  };\n};\n\n/**\n * For a given set of attractors, returns a function that a sets acceleration of attractee.\n * Keep note though that this bakes-in the values of the attractor, it won't reflect changes to their state. For dynamic\n * attractors, it might be easier to use `computeAttractionForce`.\n *\n * @example Force\n * ```js\n * const f = Forces.attractionForce(sun, gravity);\n * earth = Forces.apply(earth, f);\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n * @param attractors\n * @param gravity\n * @param distanceRange\n * @returns\n */\nexport const attractionForce =\n  (\n    attractors: ReadonlyArray<ForceAffected>,\n    gravity: number,\n    distanceRange: { readonly min?: number; readonly max?: number } = {}\n  ) =>\n    (attractee: ForceAffected): ForceAffected => {\n      let accel = attractee.acceleration ?? Points.Empty;\n      for (const a of attractors) {\n        if (a === attractee) continue;\n\n        const f = computeAttractionForce(a, attractee, gravity, distanceRange);\n        accel = Points.sum(accel, f);\n      }\n      return {\n        ...attractee,\n        acceleration: accel,\n      };\n    };\n\n/**\n * Computes the attraction force between two things.\n * Value for `gravity` will depend on what range is used for `mass`. It's probably a good idea\n * to keep mass to mean something relative - ie 1 is 'full' mass, and adjust the `gravity`\n * value until it behaves as you like. Keeping mass in 0..1 range makes it easier to apply to\n * visual properties later.\n *\n * @example Attractee and attractor, gravity 0.005\n * ```js\n * const attractor = { position: { x:0.5, y:0.5 }, mass: 1 };\n * const attractee = { position: Points.random(), mass: 0.01 };\n * attractee = Forces.apply(attractee, Forces.computeAttractionForce(attractor, attractee, 0.005));\n * ```\n *\n * @example Many attractees for one attractor, gravity 0.005\n * ```js\n * attractor =  { position: { x:0.5, y:0.5 }, mass: 1 };\n * attractees = attractees.map(a => Forces.apply(a, Forces.computeAttractionForce(attractor, a, 0.005)));\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n *\n * `attractor` thing attracting (eg, earth)\n * `attractee` thing being attracted (eg. satellite)\n *\n *\n * `gravity` will have to be tweaked to taste.\n * `distanceRange` clamps the computed distance. This affects how tightly the particles will orbit and can also determine speed. By default it is 0.001-0.7\n * @param attractor Attractor (eg earth)\n * @param attractee Attractee (eg satellite)\n * @param gravity Gravity constant\n * @param distanceRange Min/max that distance is clamped to.\n * @returns\n */\nexport const computeAttractionForce = (\n  attractor: ForceAffected,\n  attractee: ForceAffected,\n  gravity: number,\n  distanceRange: { readonly min?: number; readonly max?: number } = {}\n): Point => {\n  if (attractor.position === undefined) {\n    throw new Error(`attractor.position not set`);\n  }\n  if (attractee.position === undefined) {\n    throw new Error(`attractee.position not set`);\n  }\n\n  const distributionRangeMin = distanceRange.min ?? 0.01;\n  const distributionRangeMax = distanceRange.max ?? 0.7;\n\n  // Vector between objects\n  const f = Points.normalise(\n    Points.subtract(attractor.position, attractee.position)\n  );\n\n  // Distance\n  const d = clamp(Points.distance(f), distributionRangeMin, distributionRangeMax);\n\n  // Multiply vector by gravity, scaled by mass of things and distance\n  return Points.multiply(\n    f,\n    (gravity * (attractor.mass ?? 1) * (attractee.mass ?? 1)) / (d * d)\n  );\n};\n\nexport type TargetOpts = {\n  /**\n   * Acceleration scaling. Defaults to 0.001\n   */\n  readonly diminishBy?: number;\n  /**\n   * If distance is less than this range, don't move.\n   * If undefined (default), will try to get an exact position\n   */\n  readonly range?: Point;\n};\n/**\n * A force that moves a thing toward `targetPos`.\n *\n * ```js\n * const t = Forces.apply(t, Forces.targetForce(targetPos));\n * ```\n * @param targetPos\n * @param opts\n * @returns\n */\nexport const targetForce = (targetPos: Point, opts: TargetOpts = {}) => {\n  const fn = (t: ForceAffected): ForceAffected => {\n    const accel = computeAccelerationToTarget(\n      targetPos,\n      t.position ?? { x: 0.5, y: 0.5 },\n      opts\n    );\n    return {\n      ...t,\n      acceleration: Points.sum(t.acceleration ?? Points.Empty, accel),\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns `pt` with x and y set to `setpoint` if either's absolute value is below `v`\n * @param pt\n * @param v\n * @returns\n */\n// const roundTo = (pt: Point, v: number, setpoint: number): Point => {\n//   const x = Math.abs(pt.x);\n//   const y = Math.abs(pt.y);\n\n//   if (x < v && y < v) return { x: setpoint, y: setpoint };\n//   if (x < v) return { x: setpoint, y: pt.y };\n//   if (y < v) return { x: pt.x, y: setpoint };\n//   return pt;\n// };\n\n/**\n * Apply a series of force functions or forces to `t`. Null/undefined entries are skipped silently.\n * It also updates the velocity and position of the returned version of `t`.\n *\n * ```js\n * // Wind adds acceleration. Force is dampened by mass\n * const wind = Forces.accelerationForce({ x: 0.00001, y: 0 }, `dampen`);\n *\n * // Gravity adds acceleration. Force is magnified by mass\n * const gravity = Forces.accelerationForce({ x: 0, y: 0.0001 }, `multiply`);\n *\n * // Friction is calculated based on velocity. Force is magnified by mass\n * const friction = Forces.velocityForce(0.00001, `multiply`);\n *\n *  // Flip movement velocity if we hit a wall. And dampen it by 10%\n * const bouncer = Forces.constrainBounce({ width: 1, height: 1 }, 0.9);\n *\n * let t = {\n *  position: Points.random(),\n *  mass: 0.1\n * };\n *\n * // Apply list of forces, returning a new version of the thing\n * t = Forces.apply(t,\n *   gravity,\n *   wind,\n *   friction,\n *   bouncer\n * );\n * ```\n */\nexport const apply = (\n  t: ForceAffected,\n  ...accelForces: ReadonlyArray<ForceKind>\n): ForceAffected => {\n  if (t === undefined) throw new Error(`t parameter is undefined`);\n\n  for (const f of accelForces) {\n    if (f === null || f === undefined) continue;\n    t = typeof f === `function` ? f(t) : {\n      ...t,\n      acceleration: Points.sum(t.acceleration ?? Points.Empty, f),\n    };\n  }\n\n  // Integate velocity from acceleration\n  const velo = computeVelocity(\n    t.acceleration ?? Points.Empty,\n    t.velocity ?? Points.Empty\n  );\n\n  // Compute position\n  const pos = computePositionFromVelocity(t.position ?? Points.Empty, velo);\n\n  const ff: ForceAffected = {\n    ...t,\n    position: pos,\n    velocity: velo,\n    // Clear accel, because it has been integrated into velocity\n    acceleration: Points.Empty,\n  };\n  return ff;\n};\n\n/**\n * Apples `vector` to acceleration, scaling according to mass, based on the `mass` option.\n * It returns a function which can later be applied to a thing.\n *\n * ```js\n * import { Forces } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * // Acceleration vector of (0.1, 0), ie moving straight on horizontal axis\n * const f = Forces.accelerationForce({ x:0.1, y:0 }, `dampen`);\n *\n * // Thing to move\n * let t = { position: ..., acceleration: ... }\n *\n * // Apply force\n * t = f(t);\n * ```\n * @param vector\n * @returns Force function\n */\nexport const accelerationForce =\n  (vector: Point, mass: MassApplication = `ignored`): ForceFn =>\n    (t: ForceAffected) =>\n      Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vector, t, mass), //Points.sum(t.acceleration ?? Points.Empty, op(t.mass ?? 1))\n      });\n\n/**\n * Returns an acceleration vector with mass either dampening or multiplying it.\n * The passed-in `thing` is not modified.\n *\n * ```js\n * // Initial acceleration vector\n * const accel = { x: 0.1, y: 0};\n *\n * // Thing being moved\n * const thing = { mass: 0.5, position: ..., acceleration: ... }\n *\n * // New acceleration vector, affected by mass of `thing`\n * const accelWithMass = massApplyAccel(accel, thing, `dampen`);\n * ```\n * Mass of thing can be factored in, according to `mass` setting. Use `dampen`\n * to reduce acceleration with greater mass of thing. Use `multiply` to increase\n * the effect of acceleration with a greater mass of thing. `ignored` means\n * mass is not taken into account.\n *\n * If `t` has no mass, the `mass` setting is ignored.\n *\n * This function is used internally by the predefined forces.\n *\n * @param vector Vector force\n * @param thing Thing being affected\n * @param mass How to factor in mass of thing (default ignored)\n * @returns Acceleration vector\n */\nconst massApplyAccel = (\n  vector: Point,\n  thing: ForceAffected,\n  mass: MassApplication = `ignored`\n) => {\n\n  let op;\n  switch (mass) {\n    case `dampen`: {\n      op = (mass: number) => PointDivide(vector, mass, mass);\n\n      break;\n    }\n    case `multiply`: {\n      op = (mass: number) => Points.multiply(vector, mass, mass);\n\n      break;\n    }\n    case `ignored`: {\n      op = (_mass: number) => vector;\n\n      break;\n    }\n    default: {\n      throw new Error(\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Unknown 'mass' parameter '${ mass }. Expected 'dampen', 'multiply' or 'ignored'`\n      );\n    }\n  }\n  return Points.sum(thing.acceleration ?? Points.Empty, op(thing.mass ?? 1));\n  // if (t.mass) {\n  //   if (dampen) return Points.sum(t.acceleration ?? Points.Empty, Points.divide(v, t.mass ?? 1));\n  //   else return Points.sum(t.acceleration ?? Points.Empty, Points.multiply(v, t.mass ?? 1));\n  // }\n  // return v;\n};\n\n/**\n * A force based on the square of the thing's velocity.\n * It's like {@link velocityForce}, but here the velocity has a bigger impact.\n *\n * ```js\n * const thing = {\n *  position: { x: 0.5, y:0.5 },\n *  velocity: { x: 0.001, y:0 }\n * };\n * const drag = magnitudeForce(0.1);\n *\n * // Apply drag force to thing, returning result\n * const t = Forces.apply(thing, drag);\n * ```\n * @param force Force value\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const magnitudeForce =\n  (force: number, mass: MassApplication = `ignored`): ForceFn =>\n    (t: ForceAffected): ForceAffected => {\n      if (t.velocity === undefined) return t;\n\n      const mag = Points.distance(Points.normalise(t.velocity));\n      const magSq = force * mag * mag;\n      const vv = Points.multiply(Points.invert(t.velocity), magSq);\n      return Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vv, t, mass),\n      });\n    };\n\n/**\n * Null force does nothing\n * @returns A force that does nothing\n */\nexport const nullForce = (t: ForceAffected): ForceAffected => t;\n\n/**\n * Force calculated from velocity of object. Reads velocity and influences acceleration.\n *\n * ```js\n * let t = { position: Points.random(), mass: 0.1 };\n * const friction = velocityForce(0.1, `dampen`);\n *\n * // Apply force, updating position and velocity\n * t = Forces.apply(t, friction);\n * ```\n * @param force Force\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const velocityForce = (\n  force: number,\n  mass: MassApplication\n): ForceFn => {\n  // Invert velocity and then multiply by force\n  const pipeline = Points.pipeline(\n    // Points.normalise,\n    Points.invert,\n    (v: Point) => Points.multiply(v, force)\n  );\n\n  return (t: ForceAffected): ForceAffected => {\n    if (t.velocity === undefined) return t;\n\n    // Apply pipeline\n    const v = pipeline(t.velocity);\n    return Object.freeze({\n      ...t,\n      acceleration: massApplyAccel(v, t, mass),\n    });\n  };\n};\n\n/**\n * Sets angle, angularVelocity and angularAcceleration based on\n *  angularAcceleration, angularVelocity, angle\n * @returns\n */\nexport const angularForce = () => (t: ForceAffected) => {\n  const accumulator = t.angularAcceleration ?? 0;\n  const vel = t.angularVelocity ?? 0;\n  const angle = t.angle ?? 0;\n\n  const v = vel + accumulator;\n  const a = angle + v;\n\n  return Object.freeze({\n    ...t,\n    angle: a,\n    angularVelocity: v,\n    angularAcceleration: 0,\n  });\n};\n\n// export const positionFromAngleForce = () => (t:ForceAffected) => {\n//   return Object.freeze({\n//     ...t,\n//     position: computePositionFromAngle()\n//   });\n// };\n\n/**\n * Yields a force function that applies the thing's acceleration.x to its angular acceleration.\n * @param scaling Use this to scale the accel.x value. Defaults to 20 (ie accel.x*20). Adjust if rotation is too much or too little\n * @returns\n */\nexport const angleFromAccelerationForce =\n  (scaling = 20) =>\n    (t: ForceAffected) => {\n      const accel = t.acceleration ?? Points.Empty;\n      return Object.freeze({\n        ...t,\n        angularAcceleration: accel.x * scaling,\n      });\n    };\n\n/**\n * Yields a force function that applies the thing's velocity to its angle.\n * This will mean it points in the direction of travel.\n * @param interpolateAmt If provided, the angle will be interpolated toward by this amount. Defaults to 1, no interpolation\n * @returns\n */\nexport const angleFromVelocityForce =\n  (interpolateAmt = 1) =>\n    (t: ForceAffected) => {\n      const a = Points.angleRadian(t.velocity ?? Points.Empty);\n      return Object.freeze({\n        ...t,\n        angle:\n          interpolateAmt < 1\n            ? interpolateAngle(interpolateAmt, t.angle ?? 0, a)\n            : a,\n      });\n    };\n\n/**\n * Spring force\n *\n *  * ```js\n * // End of spring that moves\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Anchored other end of spring\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const springForce = Forces.springForce(pinnedAt, 0.4);\n *\n * continuously(() => {\n *  // Apply force\n *  thing = Forces.apply(thing, springForce);\n * }).start();\n * ```\n * [Read more](https://www.joshwcomeau.com/animation/a-friendly-introduction-to-spring-physics/)\n *\n * @param pinnedAt Anchored end of the spring\n * @param restingLength Length of spring-at-rest (default: 0.5)\n * @param k Spring stiffness (default: 0.0002)\n * @param damping Damping factor to apply, so spring slows over time. (default: 0.995)\n * @returns\n */\nexport const springForce =\n  (\n    pinnedAt: Point,\n    restingLength = 0.5,\n    k = 0.0002,\n    damping = 0.999\n  ) =>\n    (t: ForceAffected): ForceAffected => {\n      const direction = Points.subtract(t.position ?? Points.Empty, pinnedAt);\n      const mag = Points.distance(direction);\n      const stretch = Math.abs(restingLength - mag);\n\n      const f = Points.pipelineApply(direction, Points.normalise, (p) =>\n        Points.multiply(p, -k * stretch)\n      );\n\n      const accel = massApplyAccel(f, t, `dampen`);\n      const velo = computeVelocity(\n        accel ?? Points.Empty,\n        t.velocity ?? Points.Empty\n      );\n      const veloDamped = Points.multiply(velo, damping, damping);\n      return {\n        ...t,\n        velocity: veloDamped,\n        acceleration: Points.Empty,\n      };\n    };\n\n/**\n * Pendulum force options\n */\nexport type PendulumOpts = {\n  /**\n   * Length of 'string' thing is hanging from. If\n   * undefined, the current length between thing and\n   * pinnedAt is used.\n   */\n  readonly length?: number;\n  /**\n   * Max speed of swing. Slower speed can reach equilibrium faster, since it\n   * might not swing past resting point.\n   * Default 0.001.\n   */\n  readonly speed?: number;\n  /**\n   * Damping, how much to reduce velocity. Default 0.995 (ie 0.5% loss)\n   */\n  readonly damping?: number;\n};\n/**\n * The pendulum force swings something back and forth.\n *\n * ```js\n * // Swinger\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Position thing swings from (middle of screen)\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const pendulumForce = Forces.pendulumForce(pinnedAt, { length: 0.4 });\n *\n * continuously(() => {\n *  // Apply force\n *  // Returns a new thing with recalculated angularVelocity, angle and position.\n *  thing = Forces.apply(thing, pendulumForce);\n * }).start();\n * ```\n *\n * [Read more](https://natureofcode.com/book/chapter-3-oscillation/)\n *\n * @param pinnedAt Location to swing from (x:0.5, y:0.5 default)\n * @param opts Options\n * @returns\n */\nexport const pendulumForce =\n  (pinnedAt?: Point, opts: PendulumOpts = {}) =>\n    (t: ForceAffected): ForceAffected => {\n      if (!pinnedAt) pinnedAt = { x: 0, y: 0 };\n      const length =\n        opts.length ?? Points.distance(pinnedAt, t.position ?? Points.Empty);\n      const speed = opts.speed ?? 0.001;\n      const damping = opts.damping ?? 0.995;\n\n      let angle = t.angle;\n      if (angle === undefined) {\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (t.position) {\n          angle = Points.angleRadian(pinnedAt, t.position) - Math.PI / 2;\n        } else {\n          angle = 0; // Position wherever\n        }\n      }\n      const accel = ((-1 * speed) / length) * Math.sin(angle);\n      const v = (t.angularVelocity ?? 0) + accel;\n      angle += v;\n\n      return Object.freeze({\n        angularVelocity: v * damping,\n        angle,\n        position: computePositionFromAngle(length, angle + Math.PI / 2, pinnedAt),\n      });\n    };\n\n/**\n * Compute velocity based on acceleration and current velocity\n * @param acceleration Acceleration\n * @param velocity Velocity\n * @param velocityMax If specified, velocity will be capped at this value\n * @returns\n */\nexport const computeVelocity = (\n  acceleration: Point,\n  velocity: Point,\n  velocityMax?: number\n): Point => {\n  const p = Points.sum(velocity, acceleration);\n  return velocityMax === undefined ? p : Points.clampMagnitude(p, velocityMax);\n};\n\n/**\n * Returns the acceleration to get from `currentPos` to `targetPos`.\n *\n * @example Barebones usage:\n * ```js\n * const accel = Forces.computeAccelerationToTarget(targetPos, currentPos);\n * const vel = Forces.computeVelocity(accel, currentVelocity);\n *\n * // New position:\n * const pos = Points.sum(currentPos, vel);\n * ```\n *\n * @example Implementation:\n * ```js\n * const direction = Points.subtract(targetPos, currentPos);\n * const accel = Points.multiply(direction, diminishBy);\n * ```\n * @param currentPos Current position\n * @param targetPos Target position\n * @param opts Options\n * @returns\n */\nexport const computeAccelerationToTarget = (\n  targetPos: Point,\n  currentPos: Point,\n  opts: TargetOpts = {}\n) => {\n  const diminishBy = opts.diminishBy ?? 0.001;\n\n  // Compare to current position of thing to get vector direction\n  const direction = Points.subtract(targetPos, currentPos);\n\n  if (opts.range && // If direction is less than range, return { x: 0, y: 0}\n    Points.compare(Points.abs(direction), opts.range) === -2) {\n    return Points.Empty;\n  }\n\n  // Diminish vector to make a meaningful acceleration\n  return Points.multiply(direction, diminishBy);\n};\n\n/**\n * Compute a new position based on existing position and velocity vector\n * @param position Position Current position\n * @param velocity Velocity vector\n * @returns Point\n */\nexport const computePositionFromVelocity = (\n  position: Point,\n  velocity: Point\n): Point => Points.sum(position, velocity);\n\n/**\n * Compute a position based on distance and angle from origin\n * @param distance Distance from origin\n * @param angleRadians Angle, in radians from origin\n * @param origin Origin point\n * @returns Point\n */\nexport const computePositionFromAngle = (\n  distance: number,\n  angleRadians: number,\n  origin: Point\n) => Polar.toCartesian(distance, angleRadians, origin);\n\nconst _angularForce = angularForce();\nconst _angleFromAccelerationForce = angleFromAccelerationForce();\n\n/**\n * A force that orients things according to direction of travel.\n *\n * Under the hood, it applies:\n * * angularForce,\n * * angleFromAccelerationForce, and\n * * angleFromVelocityForce\n * @param interpolationAmt\n * @returns\n */\nexport const orientationForce = (interpolationAmt = 0.5): ForceFn => {\n  const angleFromVel = angleFromVelocityForce(interpolationAmt);\n\n  return (t: ForceAffected) => {\n    t = _angularForce(t);\n    t = _angleFromAccelerationForce(t);\n    t = angleFromVel(t);\n    return t;\n  };\n};\n","import {\n  float as randomFloat\n} from '../random/index.js';\nimport { floatSource as randomFloatFunction } from '../random/FloatSource.js';\nimport { clamp } from '../numbers/Clamp.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { defaultRandom, type RandomSource } from '../random/Types.js';\n\nexport type JitterOpts = {\n  readonly relative?: number;\n  readonly absolute?: number;\n  readonly clamped?: boolean;\n  readonly source?: RandomSource;\n};\n\nexport type Jitterer = (value: number) => number;\n\n/**\n * Returns a {@link Jitterer} that works with absolute values,\n * ie. values outside of 0..1 range.\n * \n * Jitter amount is _absolute_, meaning a fixed value regardless of input value,\n * or _relative_, meaning it is scaled according to input value.\n * \n * ```js\n * // Jitter by -10 to +10 (absolute value: 10)\n * const j1 = jitterAbsolute({ absolute: 10 });\n * j1(100); // Produces range of 90...110\n * \n * // Jitter by -20 to +20 (relative value 20%)\n * const j2 = jitterAbsolute({ relative: 0.20 });\n * j2(100); // Produces a range of -80...120\n * ```\n * \n * The expected used case is calling `jitterAbsolute` to set up a jitterer\n * and then reusing it with different input values, as above with the `j1` and `j2`.\n * \n * However to use it 'one-off', just call the returned function immediately:\n * ```js\n * const v = jitterAbsolute({ absolute: 10 })(100); // v is in range of 90-110\n * ```\n * \n * When `clamped` is true, return value is clamped to 0...value.\n * That is, rather than the usual bipolar jittering, the jittering only goes below.\n * ```js\n * const j = jitterAbsolute({ absolute: 10, clamped: true })\n * j(100); // Produces range of 90-100\n * ```\n * @param options\n * @returns \n */\nexport const jitterAbsolute = (options: JitterOpts): Jitterer => {\n  const { relative, absolute } = options;\n  const clamped = options.clamped ?? false;\n  const source = options.source ?? defaultRandom;\n  if (absolute !== undefined) {\n    return (value: number) => {\n      const abs = (source() * absolute * 2) - absolute;\n      const valueNew = value + abs;\n      if (clamped) return clamp(valueNew, 0, value);\n      return valueNew;\n    }\n  }\n  if (relative !== undefined) {\n    return (value: number) => {\n      const rel = value * relative;\n      const abs = (source() * rel * 2) - rel;\n      const valueNew = value + abs;\n      if (clamped) return clamp(valueNew, 0, value);\n      return valueNew;\n    }\n  }\n  throw new Error(`Either absolute or relative fields expected`);\n}\n\n/**\n * Jitters `value` by the absolute `jitter` amount. Returns a function.\n *\n * All values should be on a 0..1 scale, and the return value is by default clamped to 0..1.\n * Pass `clamped:false` as an option to allow for arbitary ranges.\n *\n * `jitter` returns a function that calculates jitter. If you only need a one-off\n * jitter, you can immediately execute the returned function:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Compute 10% jitter of input 0.5\n * const value = jitter({ relative: 0.1 })(0.5);\n * ```\n *\n * However, if the returned jitter function is to be used again,\n * assign it to a variable:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * const myJitter = jitter({ absolute: 0.5 });\n *\n * // Jitter an input value 1.0\n * const value = myJitter(1);\n * ```\n *\n * A custom source for random numbers can be provided. Eg, use a weighted\n * random number generator:\n *\n * ```js\n * import { weighted } from 'https://unpkg.com/ixfx/dist/random.js';\n * jitter({ relative: 0.1, source: weighted });\n * ```\n *\n * Options\n * * clamped: If false, `value`s out of percentage range can be used and return value may be beyond percentage range. True by default\n * * random: Random source (default is Math.random)\n * @param options Options\n * @returns Function that performs jitter\n */\nexport const jitter = (options: JitterOpts = {}): Jitterer => {\n  const clamped = options.clamped ?? true;\n  let r = (_: number) => 0;\n  if (options.absolute !== undefined) {\n    throwNumberTest(\n      options.absolute,\n      clamped ? `percentage` : `bipolar`,\n      `opts.absolute`\n    );\n    const absRand = randomFloatFunction({\n      min: -options.absolute,\n      max: options.absolute,\n      source: options.source,\n    });\n    r = (v: number) => v + absRand();\n  } else if (options.relative === undefined) {\n    throw new TypeError(`Either absolute or relative jitter amount is required.`);\n  } else {\n    const rel = options.relative ?? 0.1;\n    throwNumberTest(\n      rel,\n      clamped ? `percentage` : `bipolar`,\n      `opts.relative`\n    );\n    r = (v: number) =>\n      v +\n      randomFloat({\n        min: -Math.abs(rel * v),\n        max: Math.abs(rel * v),\n        source: options.source,\n      });\n  }\n\n  const compute = (value: number) => {\n    throwNumberTest(value, clamped ? `percentage` : `bipolar`, `value`);\n    //eslint-disable-next-line functional/no-let\n    let v = r(value);\n    if (clamped) v = clamp(v);\n    return v;\n  };\n  return compute;\n};\n","import { interpolate } from \"src/numbers/Interpolate.js\";\nimport type { Modulate } from \"./Types.js\";\n\n/**\n * Mixes in modulation\n * \n * ```js\n * // Modulates the value of 100 by 90% at 100% strength \n * mix(1, 0.5, 0.9);\n * ```\n * @param amount Amount of modulation (0..1). 0 means modulation value has no effect\n * @param original Original value to modulate\n * @param modulation Modulation amount (0..1)\n * @returns \n */\nexport const mix = (amount: number, original: number, modulation: number) => {\n  const m = modulation * amount;\n  const base = (1 - amount) * original;\n  return base + (original * m);\n};\n\n/**\n * Returns a mix of two modulate functions which are\n * both given the same input value.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Get a 50/50 mix of two easing functions\n * const mix = Easings.mix(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param balance Mix between a and b\n * @param a\n * @param b\n * @returns Numeric value\n */\nexport const mixModulators = (\n  balance: number,\n  a: Modulate,\n  b: Modulate\n): Modulate => (amt: number) => interpolate(balance, a(amt), b(amt));\n\n/**\n * Returns a 'crossfade' of two easing functions, synchronised with the progress through the easing. That is:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of a, 20% of b, with both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of a, 80% of a, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower valus.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * Easings.crossFade(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param a\n * @param b\n * @returns Numeric value\n */\nexport const crossfade = (a: Modulate, b: Modulate): Modulate => {\n  return (amt: number) => {\n    const mixer = mixModulators(amt, a, b);\n    return mixer(amt);\n  }\n}","import type { Modulate } from \"./Types.js\";\n\n/**\n * A 'no-op' function. Returns the input value without modification.\n * Useful for when some default is needed\n * @param v \n * @returns \n */\nexport const noop: Modulate = (v: number) => v;\n","import * as Timers from '../flow/Timer.js';\nconst piPi = Math.PI * 2;\n\n\n\n/**\n * Sine oscillator.\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.sine(frequencyTimer(10));\n * const osc = Oscillators.sine(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n *\n * @example Saw/tri pinch\n * ```js\n * const v = Math.pow(osc.value, 2);\n * ```\n *\n * @example Saw/tri bulge\n * ```js\n * const v = Math.pow(osc.value, 0.5);\n * ```\n *\n */\n//eslint-disable-next-line func-style\nexport function* sine(timerOrFreq: Timers.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n\n  while (true) {\n    // Rather than -1 to 1, we want 0 to 1\n    yield (Math.sin(timerOrFreq.elapsed * piPi) + 1) / 2;\n  }\n}\n\n/**\n * Bipolar sine (-1 to 1)\n * @param timerOrFreq\n */\n//eslint-disable-next-line func-style\nexport function* sineBipolar(timerOrFreq: Timers.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield Math.sin(timerOrFreq.elapsed * piPi);\n  }\n}\n\n/**\n * Triangle oscillator\n *\n * ```js\n * // Setup\n * const osc = triangle(Timers.frequencyTimer(0.1));\n * const osc = triangle(0.1);\n *\n * // Call whenver a value is needed\n * const v = osc.next().value;\n * ```\n */\n//eslint-disable-next-line func-style\nexport function* triangle(timerOrFreq: Timers.Timer | number) {\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    // elapsed is repeatedly 0->1\n    //eslint-disable-next-line functional/no-let\n    let v = timerOrFreq.elapsed;\n    // /2 = 0->0.5\n    if (v < 0.5) {\n      // Upward\n      v *= 2;\n    } else {\n      // Downward\n      v = 2 - v * 2;\n    }\n    yield v;\n  }\n}\n\n/**\n * Saw oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.saw(Timers.frequencyTimer(0.1));\n *\n * // Or\n * const osc = Oscillators.saw(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n */\n//eslint-disable-next-line func-style\nexport function* saw(timerOrFreq: Timers.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield timerOrFreq.elapsed;\n  }\n}\n\n/**\n * Square oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n *\n * // Setup\n * const osc = Oscillators.square(Timers.frequencyTimer(0.1));\n * const osc = Oscillators.square(0.1);\n *\n * // Call whenever a value is needed\n * osc.next().value;\n * ```\n */\n//eslint-disable-next-line func-style\nexport function* square(timerOrFreq: Timers.Timer | number) {\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield timerOrFreq.elapsed < 0.5 ? 0 : 1;\n  }\n}\n","import { throwNumberTest } from '../util/GuardNumbers.js';\n\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (\n  interval = 0.1,\n  lower?: number,\n  upper?: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) lower = 0;\n  if (upper === undefined) upper = 1;\n  if (start === undefined) start = lower;\n\n  throwNumberTest(interval, `bipolar`, `interval`);\n  throwNumberTest(upper, `bipolar`, `end`);\n  throwNumberTest(start, `bipolar`, `offset`);\n  throwNumberTest(lower, `bipolar`, `start`);\n  return pingPong(interval, lower, upper, start, rounding);\n};\n\n/**\n * Ping-pongs continually back and forth a `lower` and `upper` value (both inclusive) by a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (\n  interval: number,\n  lower: number,\n  upper: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\n  if (interval === undefined) {\n    throw new Error(`Parameter 'interval' is undefined`);\n  }\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\n\n  if (rounding === undefined && interval <= 1 && interval >= 0) {\n    rounding = 10 / interval;\n  } else if (rounding === undefined) rounding = 1234;\n\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\n\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\n  const distance = upper - lower;\n  if (Math.abs(interval) >= distance) {\n    throw new Error(`Interval should be between -${ distance } and ${ distance }`);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let incrementing = interval > 0;\n\n  // Scale up values by rounding factor\n  upper = Math.floor(upper * rounding);\n  lower = Math.floor(lower * rounding);\n  interval = Math.floor(Math.abs(interval * rounding));\n\n  if (interval === 0) {\n    throw new Error(`Interval is zero (rounding: ${ rounding })`);\n  }\n  start = start === undefined ? lower : Math.floor(start * rounding);\n  if (start > upper || start < lower) {\n    throw new Error(\n      `Start (${ start / rounding }) must be within lower (${ lower / rounding\n      }) and upper (${ upper / rounding })`\n    );\n  }\n\n  let v = start;\n  yield v / rounding;\n  let firstLoop = true;\n  while (true) {\n    v = v + (incrementing ? interval : -interval);\n    if (incrementing && v >= upper) {\n      incrementing = false;\n      v = upper;\n      if (v === upper && firstLoop) {\n        // Edge case where we start at upper bound and increment\n        v = lower;\n        incrementing = true;\n      }\n    } else if (!incrementing && v <= lower) {\n      incrementing = true;\n      v = lower;\n      if (v === lower && firstLoop) {\n        // Edge case where we start at lower bound and decrement\n        v = upper;\n        incrementing = false;\n      }\n    }\n    yield v / rounding;\n    firstLoop = false;\n  }\n};\n","import * as Timers from '../flow/Timer.js';\nimport type { Modulate, SpringOptions } from './Types.js';\n\n/**\n * Produces values according to rough spring physics.\n * ```js\n * import { continuously } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * \n * const s = spring();\n *\n * continuously(() => {\n *  const result = s.next();\n *  if (result.done) return false; // Exit loop\n *  const value = result.value;\n *  // Value is mostly within 0..1 range but will exceed these limits\n * }, 10).start();\n * ```\n *\n * Parameters to the spring can be provided.\n * ```js\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = spring({\n *  mass: 5,\n *  damping: 10\n *  stiffness: 100\n * });\n * ```\n * \n * If you don't want to use a generator: {@link springValue}.\n * \n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n * \n * @param opts Options for spring\n * @param timerOrFreq Timer to use, or frequency\n */\nexport function* spring(\n  opts: SpringOptions = {},\n  timerOrFreq?: Timers.Timer | number | undefined\n) {\n  if (timerOrFreq === undefined) timerOrFreq = Timers.elapsedMillisecondsAbsolute();\n  else if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n\n  const fn = springShape(opts);\n\n  // Give it some iterations to settle\n  let doneCountdown = opts.countdown ?? 10;\n\n  while (doneCountdown > 0) {\n    const s = fn(timerOrFreq.elapsed / 1000);\n    yield s;\n    if (s === 1) {\n      doneCountdown--;\n    } else {\n      doneCountdown = 100;\n    }\n  }\n}\n\n/**\n * The same as {@link spring} but instead of a generator we get\n * a value. When the spring is done, 1 is returned instead of undefined.\n * \n * ```js\n * import { springValue } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = springValue();\n * s(); // 0..1 (roughly - exceeding 1 is possible)\n * ```\n * \n * Options can be provided:\n * ```js\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = springValue({\n *  stiffness: 100,\n *  damping: 10\n * })\n * ```\n * @example Applied\n * ```js\n * import { Modulation, Data } from  \"https://unpkg.com/ixfx/dist/bundle.js\"\n * let state = {\n *  spring: Modulation.springValue()\n * }\n * \n * function loop() {\n *  const d = Data.resolveFields(state);\n * \n *  // Apply calculated spring value to compute x value\n *  const x = window.innerWidth * d.spring;\n * \n *  \n *  window.requestAnimationFrame(loop);\n * }\n * loop();\n * ```\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n * \n * @param opts \n * @param timerOrFreq \n * @returns \n */\nexport function springValue(opts: SpringOptions = {},\n  timerOrFreq?: Timers.Timer | number | undefined) {\n  const s = spring(opts, timerOrFreq);\n  return () => {\n    const v = s.next();\n    if (v.done) return 1;\n    return v.value;\n  }\n}\n\n/**\n * Spring-dynamics modulator.\n * To have spring driven by time or ticks, use {@link spring} or {@link springValue}.\n * This is a lower-level function.\n * @param opts \n * @returns \n */\nexport const springShape = (opts: SpringOptions = {}): Modulate => {\n  /** MIT License github.com/pushkine/ */\n  const from = 0;\n  const to = 1;\n  const mass = opts.mass ?? 1;\n  const stiffness = opts.stiffness ?? 100;\n  const soft = opts.soft ?? false;\n  const damping = opts.damping ?? 10;\n  const velocity = opts.velocity ?? 0.1;\n  const delta = to - from;\n  if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n    const angularFrequency = -Math.sqrt(stiffness / mass);\n    const leftover = -angularFrequency * delta - velocity;\n    return (t: number) =>\n      to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n  } else {\n    const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n    const leftover =\n      (damping * delta - 2 * mass * velocity) / dampingFrequency;\n    const dfm = (0.5 * dampingFrequency) / mass;\n    const dm = -(0.5 * damping) / mass;\n    return (t: number) =>\n      to -\n      (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n      Math.E ** (t * dm);\n  }\n};","import { throwIntegerTest } from \"../util/GuardNumbers.js\";\nimport type { ModSettable, ModSettableFeedback, ModSettableOptions, Modulate } from \"./Types.js\";\nimport * as Sources from './source/index.js';\n\nexport type Waveforms = `sine` | `sine-bipolar` | `saw` | `triangle` | `square` | `arc`;\n/**\n * Options for the wave function. Defaults to a sine wave of one cycle per-second.\n */\nexport type WaveOptions = ModSettableOptions & {\n  period: number\n  /**\n   * Clock source. Set this or ticks, hertz, secs or millis\n   * @returns \n   */\n  source: () => number,\n  /**\n   * Waveshape. Default 'sine'\n   */\n  shape: Waveforms\n  /**\n   * Number of ticks per cycle\n   * (Set either ticks, hertz, secs or millis)\n   */\n  ticks: number\n  /**\n   * Number of cycles per second\n   * (Set either ticks, hertz, secs or millis)\n   */\n  hertz: number\n  /**\n   * Number of seconds per cycle. Defaults to one second.\n   * (Set either ticks, hertz, secs or millis)\n   */\n  secs: number\n  /**\n   * Number of milliseconds per cycle\n   * (Set either ticks, hertz, secs or millis)\n   */\n  millis: number\n  /**\n   * If _true_, shape is inverted\n   */\n  invert: boolean\n}\n/**\n * Returns a function that shapes a 0..1 value as a \n * triangle waveform.\n * \n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function triangleShape(period = 1): Modulate {\n  period = 1 / period;\n  const halfPeriod = period / 2;\n  return (t: number) => {\n    const v = Math.abs((t % period) - halfPeriod);\n    //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n    return v;\n  }\n}\n\n/**\n * Returns a function that shapes a 0..1 value as a square waveform.\n * `period` sets the number of cycles in the 0..1 range.\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function squareShape(period = 1): Modulate {\n  period = 1 / period;\n  const halfPeriod = period / 2;\n  return (t: number) => {\n    return (t % period) < halfPeriod ? 1 : 0;\n    //console.log(`square: ${ t } v: ${ v }`);\n    //return v;\n  }\n}\n\n/**\n * Returns a function that shapes a 0..1 value as a sine waveform.\n * ```js\n * const s = sineShape();\n * // Calculate value of sine wave at 50%\n * // By default there is one oscillation, thus\n * // it will be the middle of the cycle.\n * s(0.5); \n * ```\n * \n * The `period` determines number of cycles for\n * an input value of 1.\n * ```js\n * // Oscillate twice in 0..1 range\n * const s = sineShape(2);\n * ```\n * \n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function sineShape(period = 1): Modulate {\n  period = period * (Math.PI * 2);\n  return (t: number) => {\n    const v = (Math.sin(t * period) + 1) / 2;\n    //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n    return v;\n  }\n}\n\n/**\n * A series of arcs, sort of like a bouncing ball.\n * @param period \n * @returns \n */\nexport function arcShape(period = 1): Modulate {\n  period = period * (Math.PI * 2);\n  return (t: number) => Math.abs(Math.sin(t * period));\n}\n\nexport function sineBipolarShape(period = 1): Modulate {\n  period = period * (Math.PI * 2);\n  return (t: number) => Math.sin(t * period);\n}\n\n/**\n * Creates a wave modulator. Defaults to 5-second sine wave. \n * ```js\n * import { wave } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Triangle wave that has a single cycle over two seconds\n * const m = wave({ secs: 2, shape: `triangle`});\n * \n * // Call m() to get current value of wave, eg in\n * // an animation loop\n * const v = m();\n * ```\n * \n * @param options \n * @returns \n */\nexport function wave(options: Partial<WaveOptions>) {\n  const shape = options.shape ?? `sine`;\n  const invert = options.invert ?? false;\n  const period = options.period ?? 1;\n  let sourceFn;\n\n  throwIntegerTest(period, `aboveZero`, `period`);\n\n  const sourceOptions = {\n    ...options\n  }\n  if (options.ticks) {\n    sourceFn = Sources.ticks(options.ticks, sourceOptions);\n  } else if (options.hertz) {\n    sourceFn = Sources.hertz(options.hertz, sourceOptions);\n  } else if (options.millis) {\n    sourceFn = Sources.elapsed(options.millis, sourceOptions);\n  } else if (options.source) {\n    sourceFn = options.source;\n  } else {\n    const secs = options.secs ?? 5;\n    sourceFn = Sources.elapsed(secs * 1000, sourceOptions);\n  }\n\n  let shaperFn;\n  switch (shape) {\n    case `saw`:\n      shaperFn = (v: number) => v;\n      break;\n    case `sine`:\n      shaperFn = sineShape(period);\n      break;\n    case `sine-bipolar`:\n      shaperFn = sineBipolarShape(period);\n      break;\n    case `square`:\n      shaperFn = squareShape(period);\n      break;\n    case `triangle`:\n      shaperFn = triangleShape(period);\n      break;\n    case `arc`:\n      shaperFn = arcShape(period);\n      break;\n    default:\n      throw new Error(`Unknown wave shape '${ shape }'. Expected: sine, sine-bipolar, saw, triangle, arc or square`);\n  }\n  return waveFromSource(sourceFn, shaperFn, invert);\n}\n\nexport type WaveShaperFeedback = {\n  /**\n   * Data to feedback to clock source\n   */\n  clock: ModSettableFeedback\n  /**\n   * If set, source function is ignored and this value (0..1) is used instead\n   */\n  override: number\n}\n/**\n * Returns a wave-shaping modulator from a source and shaper\n * @param sourceFn \n * @param shaperFn \n * @returns \n */\nexport function waveFromSource(sourceFn: ModSettable, shaperFn: Modulate, invert = false) {\n  return (feedback?: Partial<WaveShaperFeedback>) => {\n    let v = sourceFn(feedback?.clock);\n    if (feedback?.override) v = feedback.override;\n    v = shaperFn(v);\n    if (invert) v = 1 - v;\n    return v;\n  }\n}","/**\n * Weighted average\n * \n * @param currentValue \n * @param targetValue \n * @param slowDownFactor \n * @returns \n */\nexport const weightedAverage = (currentValue: number, targetValue: number, slowDownFactor: number) => {\n  return ((currentValue * (slowDownFactor - 1)) + targetValue) / slowDownFactor\n}"],"mappings":"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","names":["elapsed","adsr","ticks","ticks","bpm","elapsed","elapsed","mass","ticks"]}