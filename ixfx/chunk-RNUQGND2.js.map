{"version":3,"sources":["../src/flow/index.ts","../src/flow/BehaviourTree.ts","../src/flow/Continuously.ts","../src/flow/Timeout.ts","../src/flow/Debounce.ts","../src/flow/Sleep.ts","../src/flow/Delay.ts","../src/flow/DispatchList.ts","../src/flow/Every.ts","../src/flow/ForEach.ts","../src/flow/Interval.ts","../src/flow/PromiseFromEvent.ts","../src/flow/PromiseWithResolvers.ts","../src/flow/RateMinimum.ts","../src/flow/Repeat.ts","../src/flow/RequestResponseMatch.ts","../src/flow/Retry.ts","../src/flow/RunOnce.ts","../src/flow/SyncWait.ts","../src/flow/TaskQueueMutable.ts","../src/flow/Throttle.ts","../src/flow/UpdateOutdated.ts","../src/flow/WaitFor.ts","../src/flow/WaitForValue.ts"],"sourcesContent":["export * as BehaviourTree from './BehaviourTree.js';\nexport * from './Continuously.js';\nexport * from './Debounce.js';\nexport * from './Delay.js';\nexport * from './DispatchList.js';\nexport * as Elapsed from './Elapsed.js';\nexport * from './Every.js';\nexport * from './Execute.js';\nexport * from './ForEach.js';\nexport * from './Interval.js';\nexport * from './IntervalType.js';\nexport * from './PromiseFromEvent.js';\nexport * from './PromiseWithResolvers.js';\nexport * from './RateMinimum.js';\nexport * from './Repeat.js';\nexport * from './RequestResponseMatch.js';\nexport * from './Retry.js';\nexport * from './RunOnce.js';\nexport * from './Sleep.js';\n/**\n * State Machine\n * See [here for usage](../classes/Flow.StateMachine.StateMachine.html).\n *\n * * {@link StateMachine.driver}: Drive a state machine\n * * {@link StateMachine.init}: Create a state machine from initial state and machine description\n * * {@link fromList}: Create a state machine from a simple list of states\n */\nexport * as StateMachine from './StateMachine.js';\nexport * from './SyncWait.js';\nexport * from './TaskQueueMutable.js';\nexport * from './Throttle.js';\nexport * from './Timeout.js';\nexport * from './Timer.js';\nexport * from './Types.js';\nexport * from './UpdateOutdated.js';\nexport * from './WaitFor.js';\nexport * from './WaitForValue.js';\nexport type * from './Types.js';\n\n\n","\n\nexport type TaskState = `Failed` | `Running` | `Success`;\nexport type Task = {\n  readonly state: TaskState\n}\nexport type Traversal = readonly [\n  node: BtNode,\n  path: string\n];\n\n// Sequence runs children until the first one fails (serial)\n// Selector runs children until the first succeeds\n\n/**\n * Node can have conditions as to whether they should even be considered\n * Conditions can have dependencies on values, ideally this is responsive\n * Conditions might abort sibling nodes, as in example: https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreesOverview/\n */\n\nexport type BtNodeBase = {\n  readonly name?: string\n}\n\nexport type SeqNode = BtNodeBase & {\n  readonly seq: ReadonlyArray<BtNode>\n}\nexport type SelNode = BtNodeBase & {\n  readonly sel: ReadonlyArray<BtNode>\n}\n\nexport type BtNode = SeqNode | SelNode | string;\n\nconst t: BtNode = {\n  name: `root`,\n  seq: [\n    `walk_to_door`,\n    {\n      name: `door_locked`,\n      sel: [\n        `open_door`,\n        {\n          name: `open_locked_door`,\n          seq: [ `unlock_door`, `open_door` ]\n        },\n        `smash_door` ]\n    },\n    `walk_through_door`,\n    `close_door`\n  ]\n};\n\n\n\nconst getName = (t: BtNode, defaultValue = ``) => {\n  if (typeof t === `object` && `name` in t && t.name !== undefined) return t.name;\n  return defaultValue;\n};\n\n//eslint-disable-next-line func-style\nexport function* iterateBreadth(t: BtNode, pathPrefix?: string): Generator<Traversal> {\n  if (typeof pathPrefix === `undefined`) {\n    pathPrefix = getName(t);\n  }\n\n  for (const [ index, n ] of entries(t)) {\n    yield [ n, pathPrefix ];\n  }\n  for (const [ index, n ] of entries(t)) {\n    const name = getName(n, `?`);\n    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n    yield* iterateBreadth(n, prefix);\n  }\n}\n\n//eslint-disable-next-line func-style\nexport function* iterateDepth(t: BtNode, pathPrefix?: string): Generator<Traversal> {\n  if (typeof pathPrefix === `undefined`) {\n    pathPrefix = getName(t);\n  }\n  for (const [ index, n ] of entries(t)) {\n    yield [ n, pathPrefix ];\n    const name = getName(n, `?`);\n    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n    yield* iterateBreadth(n, prefix);\n  }\n}\n\ntype ValidateOpts = {\n  readonly duplicatesAllowed: boolean\n}\n\n//eslint-disable-next-line func-style\nfunction isSeqNode(n: BtNode): n is SeqNode {\n  return (n as SeqNode).seq !== undefined;\n}\n\n//eslint-disable-next-line func-style\nfunction isSelNode(n: BtNode): n is SelNode {\n  return (n as SelNode).sel !== undefined;\n}\n\n//eslint-disable-next-line func-style\nfunction* entries(n: BtNode) {\n  if (isSeqNode(n)) {\n    yield* n.seq.entries();\n  } else if (isSelNode(n)) {\n    yield* n.sel.entries();\n  } else if (typeof n === `string`) {\n    // no-op\n  } else {\n    throw new TypeError(`Unexpected shape of node. seq/sel missing`);\n  }\n}\n\n// for (const tn of iterateBreadth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n\n// console.log(`---`);\n\n// for (const tn of iterateDepth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n","import { throwIntegerTest } from '../util/GuardNumbers.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport type { HasCompletion, HasCompletionRunStates } from './Types.js';\n/**\n * Runs a function continuously, returned by {@link continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, does nothing\n   */\n  start(): void;\n\n  /**\n   * (Re-)starts the loop. If an existing iteration has been\n   * scheduled, this is cancelled and started again.\n   *\n   * This can be useful when adjusting the interval\n   */\n  reset(): void;\n  /**\n   * How many milliseconds since loop was started after being stopped.\n   */\n  get elapsedMs(): number;\n  /**\n   * If disposed, the continuously instance won't be re-startable\n   */\n  get isDisposed(): boolean;\n  /**\n   * Stops loop. It can be restarted using .start()\n   */\n  cancel(): void;\n  /**\n   * Sets the interval speed of loop. Change will take effect on next loop. For it to kick\n   * in earlier, call .reset() after changing the value.\n   */\n  set interval(interval: Interval);\n  /**\n   * Gets the current interval, ie. speed of loop.\n   */\n  get interval(): Interval;\n};\n\nexport type ContinuouslySyncCallback = (\n  /**\n   * Number of times loop\n   * Ticks is reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => boolean | void;\n\nexport type ContinuouslyAsyncCallback = (\n  /**\n   * Number of times loop has run\n   * Reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits.\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => Promise<boolean | void>;\n\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type ContinuouslyOpts = Readonly<{\n  /**\n   * Abort signal to exit loop\n   */\n  signal: AbortSignal;\n  /**\n   * If _true_, callback runs before waiting period.\n   * Default: _false_\n   */\n  fireBeforeWait: boolean;\n  /**\n   * Called whenever .start() is invoked.\n   * If this function returns:\n   *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n   *  - `cancel`: loop stops, but can be re-started if .start() is called again\n   *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n   *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n   *\n   */\n  onStartCalled: (\n    /**\n     * Number of times loop has run\n     * Reset when loop is exits.\n     */\n    ticks?: number,\n    /**\n     * Elapsed milliseconds.\n     * Reset when loop is exits.\n     */\n    elapsedMs?: number\n  ) => OnStartCalled;\n}>;\n\n/**\n * Returns a {@link Continuously} that continuously at `intervalMs`, executing `callback`.\n * By default, first the sleep period happens and then the callback happens.\n * Use {@link Timeout} for a single event.\n *\n * If callback returns _false_, loop exits.\n *\n * Call `start` to begin/reset loop. `cancel` stops loop.\n *\n * @example Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example With delay\n * ```js\n * const fn = () => {\n *  console.log(`1 minute`);\n * }\n * const c = continuously(fn, 60*1000);\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval; // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n * \n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n * \n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n * \n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback Function to run. If it returns false, loop exits.\n * @param options Additional options\n * @param interval Speed of loop (default: 0)\n * @returns\n */\nexport const continuously = (\n  callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback,\n  interval?: Interval,\n  options: Partial<ContinuouslyOpts> = {}\n): Continuously => {\n  let intervalMs = intervalToMs(interval, 0);\n  throwIntegerTest(intervalMs, `positive`, `interval`);\n  const fireBeforeWait = options.fireBeforeWait ?? false;\n  const onStartCalled = options.onStartCalled;\n  const signal = options.signal;\n\n  let disposed = false;\n  let runState: HasCompletionRunStates = `idle`;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let startedAt = performance.now();\n  let intervalUsed = interval ?? 0;\n  let cancelled = false;\n  let currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const deschedule = () => {\n    if (currentTimer === undefined) return;\n    globalThis.clearTimeout(currentTimer);\n    currentTimer = undefined;\n    startCount = 0;\n    startedAt = Number.NaN;\n  }\n\n  const schedule = (scheduledCallback: () => void) => {\n    if (intervalMs === 0) {\n      if (typeof requestAnimationFrame === `undefined`) {\n        currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n      } else {\n        currentTimer = undefined;\n        requestAnimationFrame(scheduledCallback);\n      }\n    } else {\n      currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n    }\n  }\n\n  const cancel = () => {\n    if (cancelled) return;\n    cancelled = true;\n\n    if (runState === `idle`) return; // No need to cancel\n    runState = `idle`;\n    deschedule();\n  };\n\n  const loop = async () => {\n    if (signal?.aborted) {\n      runState = `idle`;\n    }\n    if (runState === `idle`) return;\n\n    runState = `running`\n    startCount++;\n    startCountTotal++;\n    const valueOrPromise = callback(startCount, performance.now() - startedAt);\n    const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n    if (cancelled) {\n      return;\n    }\n    runState = `scheduled`;\n\n    // Didn't get a value, exit out\n    if (value !== undefined && !value) {\n      cancel();\n      return;\n    }\n    if (cancelled) return; // has been cancelled\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    schedule(loop);\n  };\n\n  const start = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n\n    if (onStartCalled !== undefined) {\n      // A function governs whether to allow .start() to go ahead\n      const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n      switch (doWhat) {\n        case `cancel`: {\n          cancel();\n          return;\n        }\n        case `reset`: {\n          reset();\n          return;\n        }\n        case `dispose`: {\n          disposed = true;\n          cancel();\n          return;\n        }\n        // No default\n      }\n    }\n\n    if (runState === `idle`) {\n      // Start running\n      startCount = 0;\n      startedAt = performance.now();\n      runState = `scheduled`;\n      if (fireBeforeWait) {\n        void loop(); // Exec first, then wait\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop); // Wait first, then exec\n      }\n    } // else: already running, ignore\n  };\n\n  const reset = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n    startCount = 0;\n    startedAt = Number.NaN;\n\n    // Cancel scheduled iteration\n    if (runState !== `idle`) {\n      cancel();\n    }\n    start();\n  };\n\n  return {\n    start,\n    reset,\n    cancel,\n    get interval() {\n      return intervalUsed;\n    },\n    get runState() {\n      return runState;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    },\n    get startCount() {\n      return startCount;\n    },\n    set interval(interval: Interval) {\n      const ms = intervalToMs(interval, 0);\n      throwIntegerTest(ms, `positive`, `interval`);\n      intervalMs = ms;\n      intervalUsed = interval;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n  };\n};\n","import { throwIntegerTest, integerTest } from '../util/GuardNumbers.js';\nimport { type HasCompletion, type HasCompletionRunStates } from './Types.js';\n\nimport { intervalToMs, type Interval } from './IntervalType.js';\n\nexport type TimeoutSyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => void;\nexport type TimeoutAsyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => Promise<void>;\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  /**\n   * Starts the timer.\n   * If the timer has already been started and has a scheduled execution, this is cancelled \n   * and re-scheduled.\n   * @param altTimeoutMs Optional override for the interval. Use _undefined_ to use the original interval\n   * @param args \n   */\n  start(altTimeoutMs?: number, args?: ReadonlyArray<unknown>): void;\n  /**\n   * Cancels the timer, aborting any scheduled execution.\n   */\n  cancel(): void;\n};\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `timeoutMs`.\n * If `start()` is called again, the waiting period will be reset to `timeoutMs`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * \n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param timeoutMs\n * @returns {@link Timeout}\n */\nexport const timeout = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): Timeout => {\n  if (callback === undefined) {\n    throw new Error(`callback parameter is undefined`);\n  }\n  const intervalMs = intervalToMs(interval);\n  throwIntegerTest(intervalMs, `aboveZero`, `interval`);\n\n  let timer: ReturnType<typeof setTimeout>;\n  let startedAt = 0;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let state: HasCompletionRunStates = `idle`;\n\n  const clear = () => {\n    startedAt = 0;\n    globalThis.clearTimeout(timer);\n    state = `idle`;\n  }\n\n  const start = async (\n    altInterval: Interval = interval,\n    args: Array<unknown>\n  ): Promise<void> => {\n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      const altTimeoutMs = intervalToMs(altInterval);\n      const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      if (!it[ 0 ]) {\n        reject(new Error(it[ 1 ]));\n        return;\n      }\n\n      switch (state) {\n        case `scheduled`: {\n          // Cancel other scheduled execution\n          cancel();\n          break;\n        }\n        case `running`: {\n          //console.warn(`Timeout being rescheduled while task is already running`);\n          break;\n        }\n      }\n      state = `scheduled`;\n\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      timer = globalThis.setTimeout(async () => {\n        if (state !== `scheduled`) {\n          console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n          clear();\n          return;\n        }\n        const args_ = args ?? [];\n        startCount++;\n        startCountTotal++;\n        state = `running`;\n        await callback(performance.now() - startedAt, ...args_);\n        state = `idle`\n        clear();\n        resolve();\n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (state === `idle`) return;\n    clear();\n  };\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    start,\n    cancel,\n    get runState() {\n      return state;\n    },\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    }\n  };\n};\n\n\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });","import type { Interval } from './IntervalType.js';\nimport {\n  timeout,\n  type TimeoutSyncCallback,\n  type TimeoutAsyncCallback,\n} from './Timeout.js';\n\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param interval Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): DebouncedFunction => {\n  const t = timeout(callback, interval);\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return (...args: Array<unknown>) => { t.start(undefined, args); };\n};\n\n/**\n * Debounced function\n */\nexport type DebouncedFunction = (...args: ReadonlyArray<unknown>) => void;\n","import { throwNumberTest } from '../util/GuardNumbers.js';\nimport { type Interval, intervalToMs } from './IntervalType.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n  // eslint-disable-next-line unicorn/no-lonely-if\n  if (typeof window === `undefined`) {\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @param signal\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  throwNumberTest(timeoutMs, `positive`, `timeoutMs`);\n\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        clearTimeout(t);\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      const t = setTimeout(() => {\n        signal?.removeEventListener(`abort`, onAbortSignal);\n        if (signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate \n * @param checkInterval \n */\nexport const sleepWhile = async (predicate: () => boolean, checkInterval = 100) => {\n  while (predicate()) {\n    await sleep(checkInterval);\n  }\n}","import { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\n\n/**\n * Delay options\n */\nexport type DelayOpts = Interval & {\n  /**\n   * Signal for cancelling delay\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When delay is applied. \"before\" is default.\n   */\n  readonly delay?: `before` | `after` | `both`;\n};\n\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @template V\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async <V>(\n  callback: () => Promise<V>,\n  //eslint-disable-next-line functional/prefer-immutable-types\n  optsOrMillis: DelayOpts | number\n): Promise<V> => {\n  const opts =\n    typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n  const delayWhen = opts.delay ?? `before`;\n  if (delayWhen === `before` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  const r = Promise.resolve(await callback());\n  if (delayWhen === `after` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  return r;\n};\n\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n\n//     // Yield value\n//     yield v;\n\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n * \n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n * \n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n * \n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n * \n * The below example shows how to do this.\n * \n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n * \n * // Execution continues while loop also runs\n * ```\n *\n */\n//eslint-disable-next-line func-style\nasync function* delayAnimationLoop() {\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer = 0;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.requestAnimationFrame(callback);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    globalThis.cancelAnimationFrame(timer);\n  }\n}\n\n/**\n * Async generator that loops at a given interval.\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link interval} iterate over an iterable with a given delay\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @example Loop runs every second\n * ```\n * // Loop forever\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * @example For Await loop every second\n * ```\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\n//eslint-disable-next-line func-style\nexport async function* delayLoop(timeout: Interval) {\n  const timeoutMs = intervalToMs(timeout);\n  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);\n  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);\n  if (timeoutMs === 0) return yield* delayAnimationLoop();\n\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer: ReturnType<typeof globalThis.setTimeout> | undefined;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.setTimeout(callback, timeoutMs);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    if (timer !== undefined) globalThis.clearTimeout(timer);\n    timer = undefined;\n  }\n}\n","export type Dispatch<V> = (value: V) => void;\n\ntype Wrap<V> = {\n  readonly handler: Dispatch<V>\n  readonly id: string\n  readonly once: boolean\n}\n\nexport class DispatchList<V> {\n  #handlers: Array<Wrap<V>>\n  #counter = 0;\n  readonly #id = Math.floor(Math.random() * 100);\n  constructor() {\n\n    this.#handlers = [];\n  }\n\n  /**\n   * Returns _true_ if list is empty\n   * @returns \n   */\n  isEmpty() {\n    return this.#handlers.length === 0;\n  }\n\n  /**\n   * Adds a handler\n   * @param handler \n   * @param options \n   * @returns \n   */\n  add(handler: Dispatch<V>, options: { once?: boolean } = {}): string {\n    this.#counter++;\n    const once = options.once ?? false;\n    const wrap: Wrap<V> = {\n      id: `${ this.#id } - ${ this.#counter }`,\n      handler,\n      once\n    }\n    this.#handlers.push(wrap);\n    return wrap.id;\n  }\n\n  remove(id: string): boolean {\n    const length = this.#handlers.length;\n    this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n    return this.#handlers.length !== length;\n  }\n\n  notify(value: V) {\n    for (const handler of this.#handlers) {\n      handler.handler(value);\n      if (handler.once) {\n        this.remove(handler.id);\n      }\n    }\n  }\n\n  clear() {\n    this.#handlers = [];\n  }\n}","import { throwIntegerTest } from \"../util/GuardNumbers.js\";\n\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = <T>(nth: number, callback?: (data: T) => void) => {\n  throwIntegerTest(nth, `positive`, `nth`);\n\n  let counter = 0;\n\n  return (data: T) => {\n    counter++;\n    if (counter === nth) {\n      counter = 0;\n      if (callback) callback(data);\n      return true;\n    }\n    return false;\n  }\n};\n","import { sleep } from \"./Sleep.js\";\n\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEachAsync} if you want to use an async `iterator` and async `fn`.\n * \n * Alternatives:\n * * {@link repeat}/{@link repeatAwait}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam V Type of iterable\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport const forEach = <V>(\n  iterator: IterableIterator<V> | ReadonlyArray<V>,\n  fn: (v?: V) => boolean\n) => {\n  for (const x of iterator) {\n    const r = fn(x);\n    if (typeof r === `boolean` && !r) break;\n  }\n};\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * Use {@link forEach} for a synchronous version.\n *\n * ```\n * // Prints items from array every second\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEachAsync(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @typeParam V Type of iterable\n */\nexport const forEachAsync = async function <V>(\n  iterator: AsyncIterableIterator<V> | ReadonlyArray<V>,\n  fn: (v?: V) => Promise<boolean> | Promise<void>,\n  intervalMs?: number\n) {\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  }\n};\n","import { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\n\nimport { type AsyncPromiseOrGenerator } from './Types.js';\n\n/**\n * Options for interval\n */\nexport type IntervalOpts = {\n  /**\n   * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n   */\n  readonly fixed?: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  readonly minimum?: Interval;\n  /**\n   * Optional signal to abort\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When to perform delay. Default is before 'produce' is invoked.\n   * Default: 'before'\n   */\n  readonly delay?: `before` | `after`;\n};\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * @example Produce a random number every 500ms\n * ```\n * const randomGenerator = interval(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example Return values from a generator every 500ms\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * for await (const v of interval(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * Alternatives:\n * * {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * * {@link repeat}: run a function a certain number of times, collecting results\n *\n * @template V Returns value of `produce` function\n * @param produce Function/generator to use\n * @param optsOrFixedMs Options for interval, or millisecond delay\n * @template V Data type\n * @returns\n */\nexport const interval = async function* <V>(\n  produce: AsyncPromiseOrGenerator<V> | ArrayLike<V>,\n  optsOrFixedMs: IntervalOpts | number = {}\n): AsyncGenerator<V> {\n  const opts =\n    typeof optsOrFixedMs === `number`\n      ? { fixed: optsOrFixedMs }\n      : optsOrFixedMs;\n\n  const signal = opts.signal;\n  const when = opts.delay ?? `before`;\n  const minIntervalMs = opts.minimum ? intervalToMs(opts.minimum) : undefined;\n\n  let cancelled = false;\n  let sleepMs = intervalToMs(opts.fixed) ?? intervalToMs(opts.minimum, 0);\n  let started = performance.now();\n\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  // Get an iterator over array\n  if (Array.isArray(produce)) produce = produce.values();\n\n  const isGenerator =\n    typeof produce === `object` &&\n    `next` in produce &&\n    typeof produce.next === `function`;\n\n  try {\n    while (!cancelled) {\n      if (when === `before`) await doDelay();\n      if (typeof produce === `function`) {\n        // Returns V or Promise<V>\n        const result = await produce();\n        if (typeof result === `undefined`) return; // Done\n        yield result;\n      } else if (isGenerator) {\n        // Generator\n        const result = await (produce as AsyncGenerator<V>).next();\n        if (result.done) return;\n        yield result.value;\n      } else {\n        throw new Error(\n          `produce param does not seem to return a value/Promise and is not a generator?`\n        );\n      }\n\n      if (when === `after`) await doDelay();\n    }\n  } finally {\n    cancelled = true;\n  }\n};\n","export const promiseFromEvent = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      if (Array.isArray(args) && args.length === 1) resolve(args[ 0 ]);\n      else resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};","export function promiseWithResolvers<T>() {\n  let resolve: undefined | ((value: T) => void);\n  let reject: undefined | ((reason: any) => void);\n  const promise = new Promise<T>(\n    (_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return { promise, resolve: resolve!, reject: reject! };\n}","import type { Interval } from \"./IntervalType.js\";\nimport { timeout } from \"./Timeout.js\";\n\n\nexport type RateMinimumOptions<TInput> = Readonly<{\n  whatToCall: (args: TInput) => void\n  fallback: () => TInput\n  interval: Interval\n  abort?: AbortSignal\n}>;\n\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n * \n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n * \n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n * \n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ``` \n * \n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n * \n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n * \n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n * \n * @param options \n * @returns \n */\nexport const rateMinimum = <TInput>(options: RateMinimumOptions<TInput>) => {\n  let disposed = false;\n\n  const t = timeout(() => {\n    if (disposed) return;\n    t.start();\n    options.whatToCall(options.fallback());\n  }, options.interval);\n\n\n  if (options.abort) {\n    options.abort.addEventListener(`abort`, _ => {\n      disposed = true;\n      t.cancel();\n    });\n  }\n  t.start();\n\n  return (args: TInput) => {\n    if (disposed) throw new Error(`AbortSignal has been fired`);\n    t.start();\n    options.whatToCall(args);\n  }\n}","import { throwNumberTest } from \"../util/GuardNumbers.js\";\n/**\n * Logic for continuing repeats\n */\nexport type RepeatPredicate = (\n  repeats: number,\n  valuesProduced: number\n) => boolean;\n\n\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n * \n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n * \n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n * \n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n * \n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1); \n * });\n * ``` \n * \n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n * \n * ```js\n * async function task() {\n *  // do something\n * }\n * \n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n * \n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @template V Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\nexport function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined>): AsyncIterable<V> {\n  return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n}\n\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it. \n * \n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n * \n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n * \n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n * \n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n * \n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * \n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @template V Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\nexport function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n  return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n}\n\n\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate \n * @param fn \n * @template V Return type of repeating function\n */\nasync function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined>): AsyncGenerator<V> {\n  let repeats = 0;\n  let valuesProduced = 0;\n  while (predicate(repeats, valuesProduced)) {\n    repeats++;\n    const v = await fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @template V Return type of repeating function\n */\nfunction* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n  let repeats = 0;\n  let valuesProduced = 0;\n  while (predicate(repeats, valuesProduced)) {\n    repeats++;\n    const v = fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @template V Return type of repeating function\n */\nasync function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n  throwNumberTest(count, `positive`, `count`);\n  let valuesProduced = 0;\n  let repeats = 0;\n  while (count-- > 0) {\n    repeats++;\n    const v = await fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n * @template V Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\nfunction* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n  throwNumberTest(count, `positive`, `count`);\n  let valuesProduced = 0;\n  let repeats = 0;\n  while (count-- > 0) {\n    repeats++;\n    const v = fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @template V Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };","import { SimpleEventEmitter } from \"../Events.js\"\nimport { continuously } from \"./Continuously.js\"\n\nexport type RequestResponseOptions<TRequest, TResp> = {\n  timeoutMs: number\n  key: (requestOrResp: TRequest | TResp) => string\n  keyRequest: (request: TRequest) => string\n  keyResponse: (resp: TResp) => string\n  whenUnmatchedResponse: `ignore` | `throw`\n}\n\ntype SeenRequest<TRequest, TResp> = {\n  expiresAt: number\n  id: string\n  req: TRequest\n  promiseResolve?: (value: TResp) => void\n  promiseReject?: (message: string) => void\n  callback?: (error: boolean, value: TResp | string) => void\n}\n\nexport type RequestResponseMatchEvents<TRequest, TResp> = {\n  match: { request: TRequest, response: TResp }\n  completed: { request: TRequest, response: TResp | string, success: boolean }\n}\n\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n * \n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n * \n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n * \n * \n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id; \n *  }\n * });\n * ```\n * \n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id; \n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n * \n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport class RequestResponseMatch<TRequest, TResp> extends SimpleEventEmitter<RequestResponseMatchEvents<TRequest, TResp>> {\n  timeoutMs;\n  whenUnmatchedResponse;\n  keyRequest;\n  keyResponse;\n\n  #outgoing = new Map<string, SeenRequest<TRequest, TResp>>();\n  #maintainLoop;\n\n  constructor(options: Partial<RequestResponseOptions<TRequest, TResp>> = {}) {\n    super();\n    if (typeof window === `undefined`) {\n      (globalThis as any).window = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout\n      }\n    }\n    this.timeoutMs = options.timeoutMs ?? 1000;\n    this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;\n    this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);\n    if (options.key) {\n      if (options.keyRequest) throw new Error(`Cannot set 'keyRequest' when 'key' is set `);\n      if (options.keyResponse) throw new Error(`Cannot set 'keyResponse' when 'key' is set `);\n\n      this.keyRequest = options.key;\n      this.keyResponse = options.key;\n    } else {\n      if (!options.keyRequest || !options.keyResponse) {\n        throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);\n      }\n      this.keyRequest = options.keyRequest;\n      this.keyResponse = options.keyResponse;\n    }\n  }\n\n  #maintain() {\n    const values = [ ...this.#outgoing.values() ];\n    const now = Date.now();\n    for (const v of values) {\n      if (v.expiresAt <= now) {\n\n        if (v.promiseReject) {\n          v.promiseReject(`Request timeout`);\n        }\n        const callback = v.callback;\n        if (callback) {\n          setTimeout(() => {\n            callback(true, `Request timeout`);\n          }, 1);\n        }\n        this.fireEvent(`completed`, { request: v.req, response: `Request timeout`, success: false });\n        this.#outgoing.delete(v.id);\n      }\n    }\n    this.debugDump();\n    return this.#outgoing.size > 0;\n  }\n\n  debugDump() {\n    const values = [ ...this.#outgoing.values() ];\n    const now = Date.now();\n    for (const v of values) {\n      const expire = now - v.expiresAt;\n      console.log(`${ v.id } Expires in: ${ Math.floor(expire / 1000) }s`);\n    }\n  }\n\n  /**\n   * Make a request and get the outcome via a Promise\n   * @param request \n   */\n  request(request: TRequest): Promise<TResp>;\n\n  /**\n   * Makes a request with a callback for the outcome\n   * @param request \n   * @param callback \n   */\n  request(request: TRequest, callback: (error: boolean, response: TResp | string) => void): void;\n\n  /**\n   * Makes a request.\n   * If `callback` is set, it's equivalent to calling `requestCallback`.\n   * If `callback` is not set, a promise is returned\n   * @param request \n   * @param callback \n   * @returns \n   */\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n  request(request: TRequest, callback?: (error: boolean, response: TResp | string) => void): void | Promise<TResp> {\n    if (callback !== undefined) { this.#requestCallback(request, callback); return; }\n    return this.#requestAwait(request);\n  }\n\n  /**\n   * Make a request and don't wait for the outcome.\n   * @param request \n   */\n  requestAndForget(request: TRequest) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const r: SeenRequest<TRequest, TResp> = {\n      expiresAt: Date.now() + this.timeoutMs,\n      id,\n      req: request\n    };\n    this.#outgoing.set(id, r);\n    this.#maintainLoop.start();\n  }\n\n  /**\n   * Make a request, returning a Promise for the outcome.\n   * Errors will throw an exception.\n   * @param request \n   * @returns \n   */\n  #requestAwait(request: TRequest) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const p = new Promise<TResp>((resolve, reject) => {\n      const r: SeenRequest<TRequest, TResp> = {\n        expiresAt: Date.now() + this.timeoutMs,\n        id,\n        req: request,\n        promiseResolve: resolve,\n        promiseReject: reject\n      };\n      this.#outgoing.set(id, r);\n      this.#maintainLoop.start();\n\n    });\n    return p;\n  }\n\n  /**\n   * Make a request, and get notified of outcome with a callback\n   * @param request \n   * @param callback \n   */\n  #requestCallback(request: TRequest, callback: (error: boolean, response: TResp | string) => void) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const r: SeenRequest<TRequest, TResp> = {\n      expiresAt: Date.now() + this.timeoutMs,\n      id,\n      req: request,\n      callback\n    };\n    this.#outgoing.set(id, r);\n    this.#maintainLoop.start();\n  }\n\n  /**\n   * Response has been received\n   * @param response Response\n   * @returns _True_ if response matched a request \n   */\n  response(response: TResp, keepAlive: boolean): boolean {\n    const id = this.keyResponse(response);\n    const request = this.#outgoing.get(id);\n    if (!request) {\n      if (this.whenUnmatchedResponse === `throw`) throw new Error(`Unmatched response with id: '${ id }'`, { cause: response });\n      // otherwise ignore\n      return false;\n    }\n\n    if (keepAlive) {\n      // Continue life of request\n      request.expiresAt = Date.now() + this.timeoutMs\n    } else {\n      this.#outgoing.delete(id);\n    }\n    if (request.promiseResolve) {\n      request.promiseResolve(response);\n    }\n    if (request.callback) {\n      request.callback(false, response);\n    }\n    this.fireEvent(`match`, { request: request.req, response: response });\n    if (!keepAlive) {\n      this.fireEvent(`completed`, { request: request.req, response: response, success: true });\n    }\n    return true;\n  }\n}","import { sleep } from './Sleep.js';\nimport { resolveLogOption } from '../debug/Logger.js';\nimport { since, toString as elapsedToString } from './Elapsed.js';\nimport { throwIntegerTest, throwNumberTest } from '../util/GuardNumbers.js';\nimport { getErrorMessage } from '../debug/GetErrorMessage.js';\nimport type { Result } from '../util/Results.js';\n/**\n * Result of backoff\n */\nexport type RetryResult<V> = {\n  /**\n   * Message describing outcome.\n   *\n   * If retry was aborted, message will be abort reason.\n   */\n  readonly message?: string;\n  /**\n   * True if callback function was invoked once where it returned _true_\n   */\n  readonly success: boolean;\n  /**\n   * Number of times callback was attempted\n   */\n  readonly attempts: number;\n  /**\n   * Total elapsed time since beginning of call to `retry`\n   */\n  readonly elapsed: number;\n\n  /**\n   * Value returned by succeeding function,\n   * or _undefined_ if it failed\n   */\n  readonly value: V | undefined;\n};\n\nexport type BackoffOptions = {\n  /**\n   * Initial value.\n   * Default: 1\n   */\n  startAt: number,\n  /**\n   * Maximum times to run.\n   * Default: continues forever\n   */\n  limitAttempts: number,\n  /**\n   * Stop retrying if this maximum is reached\n   * Default: no limit\n   */\n  limitValue: number\n  /**\n   * Math power. \n   * Default: 1.1\n   */\n  power: number\n};\n\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n * \n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n * \n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n * \n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n * \n * @param options \n * @returns \n */\nexport function* backoffGenerator(options: Partial<BackoffOptions> = {}) {\n  const startAt = options.startAt ?? 1;\n  let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = options.limitValue;\n  const power = options.power ?? 1.1;\n  let value = startAt;\n  throwIntegerTest(limitAttempts, `aboveZero`, `limitAttempts`);\n  throwNumberTest(startAt, ``, `startAt`);\n  throwNumberTest(limitAttempts, ``, `limitAttempts`);\n  if (limitValue !== undefined) throwNumberTest(limitValue, ``, `limitValue`);\n  throwNumberTest(power, ``, `power`);\n\n  while (limitAttempts > 0) {\n    // Value has climbed to the limit\n    if (limitValue && value >= limitValue) return;\n    limitAttempts--;\n    yield value;\n\n    // Increase value for next iteration\n    value += Math.pow(value, power);\n  }\n}\n\n/**\n * Backoff options\n */\nexport type RetryOpts<T> = BackoffOptions & {\n  /**\n   * Initial waiting period before first attempt (optional)\n   */\n  readonly predelayMs: number;\n  /**\n   * Optional abort signal\n   */\n  readonly abort: AbortSignal;\n  /**\n   * Log: _true_ monitors the task execution by logging to console\n   */\n  readonly log: boolean;\n\n  /***\n   * Default task value to return if it fails\n   */\n  readonly taskValueFallback: T;\n};\n\nexport type RetryTask<T> = {\n  /**\n   * If `probe` returns {success:true} task is considered\n   * complete and retrying stops\n   * @returns \n   */\n  probe: (attempts: number) => Promise<Result<T>>\n}\n\n/**\n * Keeps calling `callback` until it returns something other than _undefined_. \n * There is an exponentially-increasing delay between each retry attempt.\n * \n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport const retryFunction = <T>(callback: () => Promise<T | undefined>, options: Partial<RetryOpts<T>> = {}) => {\n  const task: RetryTask<T> = {\n    async probe() {\n      try {\n        const v = await callback();\n        if (v === undefined) return { value: options.taskValueFallback, success: false };\n        return { value: v, success: true };\n      } catch (error) {\n        return { success: false, message: getErrorMessage(error) };\n      }\n    },\n  }\n  return retryTask(task, options);\n}\n\n/**\n * Keeps trying to run `task`.\n * \n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *  \n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n * \n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task \n * @param opts \n * @returns \n */\nexport const retryTask = async <V>(\n  task: RetryTask<V>,\n  opts: Partial<RetryOpts<V>> = {}\n): Promise<RetryResult<V>> => {\n  const signal = opts.abort;\n  const log = resolveLogOption(opts.log);\n  const predelayMs = opts.predelayMs ?? 0;\n  const startedAt = since();\n\n  let attempts = 0;\n  const initialValue = opts.startAt ?? 1000;\n  const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n\n  if (initialValue <= 0) throw new Error(`Param 'initialValue' must be above zero`);\n\n  if (predelayMs > 0) {\n    try {\n      await sleep({ millis: predelayMs, signal: signal });\n    } catch (error) {\n      // Could happen due to abort signal\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n        message: getErrorMessage(error),\n      };\n    }\n  }\n\n  for (const t of backoffGen) {\n    attempts++;\n\n    // Run task\n    const result = await task.probe(attempts);\n    if (result.success) {\n      return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n    }\n    log({\n      msg: `retry attempts: ${ attempts } t: ${ elapsedToString(t) }`,\n    });\n\n    // Did not succeed.\n    if (attempts >= limitAttempts) {\n      break; // Out of attempts, no point sleeping again\n    }\n    // Sleep\n    try {\n      await sleep({ millis: t, signal });\n    } catch (error) {\n      // Eg if abort signal fires\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        message: getErrorMessage(error),\n        elapsed: startedAt(),\n      };\n    }\n  }\n\n  return {\n    message: `Giving up after ${ attempts } attempts.`,\n    success: false,\n    attempts,\n    value: opts.taskValueFallback,\n    elapsed: startedAt(),\n  };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun: () => boolean): (() => boolean) => {\n  //eslint-disable-next-line functional/no-let\n  let run = false;\n  //eslint-disable-next-line functional/no-let\n  let success = false;\n  return () => {\n    if (run) return success;\n    run = true;\n    success = onRun();\n    return success;\n  };\n};\n","/**\n * Simple synchronisation. Supports only a single signal/waiter.\n * Expects one or more calls to .signal() for .forSignal() to resolve\n * \n * ```js\n * const sw = new SyncWait();\n * obj.addEventListener(`click`, () => {\n *  sw.signal();\n * });\n * \n * // Wait until click event\n * await sw.forSignal();\n * ```\n * \n * `forSignal` can also take a maximum time to wait. If the\n * time elapses, an exception is thrown.\n * \n * {@link didSignal} returns _true_/_false_ if signal happened rather\n * than throwing an exception.\n * \n */\nexport class SyncWait {\n  #resolve?: (value?: any) => void;\n  #reject?: (reason?: string) => void;\n  #promise?: Promise<any>;\n\n  signal() {\n    if (this.#resolve) {\n      this.#resolve();\n      this.#resolve = undefined;\n    }\n    this.#promise = Promise.resolve();\n  }\n\n  /**\n   * Throw away any previous signalled state.\n   * This will cause any currently waiters to throw\n   */\n  flush() {\n    if (this.#reject) {\n      this.#reject(`Flushed`);\n      this.#reject = undefined;\n    }\n    this.#resolve = undefined;\n    this.#promise = undefined;\n  }\n\n  #initPromise() {\n    const p = new Promise((resolve, reject) => {\n      this.#resolve = resolve;\n      this.#reject = reject;\n    });\n    this.#promise = p;\n    return p;\n  }\n\n  /**\n   * Call with `await` to wait until .signal() happens.\n   * If a wait period is specified, an exception is thrown if signal does not happen within this time.\n   * @param maximumWaitMs \n   */\n  async forSignal(maximumWaitMs?: number) {\n    let p = this.#promise;\n    if (!p) p = this.#initPromise();\n    if (maximumWaitMs) {\n      const reject = this.#reject;\n      setTimeout(() => {\n        if (reject) {\n          reject(`Timeout elapsed ${ maximumWaitMs }`);\n        }\n      }, maximumWaitMs);\n    }\n    await p;\n    this.#promise = undefined;\n    this.#resolve = undefined;\n    this.#reject = undefined;\n  }\n\n  /**\n   * An alternative to {@link forSignal}, returning _true_\n   * if signalled, or _false_ if wait period was exceeded \n   * \n   * ```js\n   * const s = await sw.didSignal(5000);\n   * ```\n   * @param maximumWaitMs \n   * @returns \n   */\n  async didSignal(maximumWaitMs: number): Promise<boolean> {\n    try {\n      await this.forSignal(maximumWaitMs);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}","import { SimpleEventEmitter } from '../Events.js';\nimport { mutable } from '../collections/queue/QueueMutable.js';\nimport { continuously } from './Continuously.js';\n\nexport type AsyncTask = () => Promise<void>;\n\nexport type TaskQueueEvents = {\n  /**\n   * Task queue has emptied.\n   * @returns\n   */\n  empty: any\n  /**\n   * Task queue was empty and now processing\n   * @returns \n   */\n  started: any\n}\n\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n * \n * The TaskQueueMutable is shared across your code,\n * so you don't create it directly. Rather, use:\n * \n * ```js\n * const queue = TaskQueueMutable.instance;\n * ```\n *\n * @example Usage\n * ```js\n * const queue = TaskQueueMutable.instance;\n * q.enqueue(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n * \n * You can listen to events from the TaskQueue:\n * ```js\n * TaskQueueMutable.shared.addEventListener(`started`, () => {\n *  // Queue was empty, now started processing\n * });\n * \n * TaskQueueMutable.shared.addEventListener(`empty`, () => {\n *  // Queue has finished processing all items\n * });\n * ```\n */\nexport class TaskQueueMutable extends SimpleEventEmitter<TaskQueueEvents> {\n  static readonly shared = new TaskQueueMutable();\n  private _loop;\n  private _queue;\n\n  private constructor() {\n    super();\n    this._queue = mutable<AsyncTask>();\n    this._loop = continuously(() => {\n      return this.processQueue();\n    }, 100);\n  }\n\n  /**\n   * Adds a task. This triggers processing loop if not already started.\n   *\n   * ```js\n   * queue.add(async () => {\n   *  await sleep(1000);\n   * });\n   * ```\n   * @param task Task to run\n   */\n  enqueue(task: () => Promise<void>) {\n    const length = this._queue.enqueue(task);\n    if (this._loop.runState === `idle`) {\n      this.fireEvent(`started`, {});\n      this._loop.start();\n    }\n    return length;\n  }\n\n  dequeue() {\n    return this._queue.dequeue();\n  }\n\n  private async processQueue() {\n    const task = this._queue.dequeue();\n    if (task === undefined) {\n      this.fireEvent(`empty`, {});\n      return false;\n\n    }\n\n    try {\n      await task();\n    } catch (error) {\n      console.error(error);\n    }\n\n  }\n\n  /**\n   * Clears all tasks, and stops any scheduled processing.\n   * Currently running tasks will continue.\n   * @returns \n   */\n  clear() {\n    if (this._queue.length === 0) return;\n    this._queue.clear();\n    this._loop.cancel();\n    this.fireEvent(`empty`, {});\n  }\n\n  /**\n  * Returns true if queue is empty\n  */\n  get isEmpty() {\n    return this._queue.isEmpty;\n  }\n\n\n  /**\n   * Number of items in queue\n   */\n  get length() {\n    return this._queue.length\n  }\n}\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (\n  callback: (\n    elapsedMs: number,\n    ...args: readonly unknown[]\n  ) => void | Promise<unknown>,\n  intervalMinMs: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let trigger = 0;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return async (...args: unknown[]) => {\n    const elapsed = performance.now() - trigger;\n    if (elapsed >= intervalMinMs) {\n      const r = callback(elapsed, ...args);\n      if (typeof r === `object`) await r;\n      trigger = performance.now();\n    }\n  };\n};\n","import { intervalToMs, type Interval } from \"./IntervalType.js\";\n\nexport type UpdateFailPolicy = `fast` | `slow` | `backoff`;\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `interval` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. Its minimum value will be `interval`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `interval` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param interval Maximum age of cached result\n * @param updateFail `slow` by default\n * @template V Type of return value\n * @returns Value\n */\nexport const updateOutdated = <V>(\n  fn: (elapsedMs?: number) => Promise<V>,\n  interval: Interval,\n  updateFail: UpdateFailPolicy = `slow`\n): (() => Promise<V>) => {\n  let lastRun = 0;\n  let lastValue: V | undefined;\n  let intervalMsCurrent = intervalToMs(interval, 1000);\n\n  return () =>\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    new Promise(async (resolve, reject) => {\n      const elapsed = performance.now() - lastRun;\n      if (lastValue === undefined || elapsed > intervalMsCurrent) {\n        try {\n          lastRun = performance.now();\n          lastValue = await fn(elapsed);\n          intervalMsCurrent = intervalToMs(interval, 1000);\n        } catch (error) {\n          if (updateFail === `fast`) {\n            lastValue = undefined;\n            lastRun = 0;\n          } else if (updateFail === `backoff`) {\n            intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n          }\n          // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n          reject(error);\n          return;\n        }\n      }\n      resolve(lastValue);\n    });\n};\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n * \n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n * \n * ```js\n * waitFor(1000, \n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n * \n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n * \n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n * \n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (\n  timeoutMs: number,\n  onAborted: (reason: string) => void,\n  onComplete?: (success: boolean) => void\n) => {\n  let t: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  let success = false;\n  const done = (error?: string) => {\n    if (t !== undefined) {\n      window.clearTimeout(t);\n      t = undefined;\n    }\n    if (error) {\n      onAborted(error);\n    } else {\n      success = true;\n    }\n    if (onComplete !== undefined) onComplete(success);\n  };\n\n  t = globalThis.setTimeout(() => {\n    t = undefined;\n    try {\n      onAborted(`Timeout after ${ timeoutMs }ms`);\n    } finally {\n      if (onComplete !== undefined) onComplete(success);\n    }\n  }, timeoutMs);\n\n  return done;\n};\n","import { promiseWithResolvers } from \"./PromiseWithResolvers.js\";\n\n/**\n * Queue of a single item, only once.\n * \n * Allows for simple synchronisation.\n * ```js\n * const q = Flow.waitForValue();\n * \n * // In some part of the code:\n * // wait for a value to be added\n * const value = await q.add();\n * \n * // Somewhere else\n * q.get(value);\n * ```\n * \n * It is not possible to `add` a second item, however\n * it is possible to call `get` as many times as you need.\n * \n * The `.isUsed` property allows you to to check if a value\n * has been already added to the queue.\n * \n * Based on: https://2ality.com/2024/05/proposal-promise-with-resolvers.html\n */\nexport class WaitForValue<T> {\n  #promise\n  #resolve\n  #written = false;\n  constructor() {\n    const { promise, resolve } = promiseWithResolvers<T>();\n    this.#promise = promise;\n    this.#resolve = resolve;\n  }\n\n\n  get(): Promise<T> {\n    return this.#promise;\n  }\n\n  add(value: T) {\n    if (this.#written) throw new Error(`QueueSingleUse has already been used`);\n    this.#written = true;\n    this.#resolve(value);\n  }\n\n  /**\n   * Returns _true_ if a value has been added\n   * and therefore no more values can be written\n   */\n  get isUsed() {\n    return this.#written;\n  }\n}\n\nexport const singleItem = <T>() => new WaitForValue<T>();"],"mappings":"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","names":["interval","interval","interval","timeout","run","interval"]}