{"version":3,"sources":["../src/collections/map/GetOrGenerate.ts","../src/debug/Logger.ts","../src/debug/GetErrorMessage.ts"],"sourcesContent":["import type { IMappish } from './IMappish.js';\nexport type GetOrGenerate<K, V, Z> = (key: K, args?: Z) => Promise<V>;\n\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const getOrGenerateSync =\n  <K, V, Z>(map: IMappish<K, V>, fn: (key: K, args?: Z) => V) =>\n    (key: K, args?: Z): V => {\n      //eslint-disable-next-line functional/no-let\n      let value = map.get(key);\n      if (value !== undefined) return value;\n      value = fn(key, args);\n      map.set(key, value);\n      return value;\n    };\n\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const getOrGenerate =\n  <K, V, Z>(\n    map: IMappish<K, V>,\n    fn: (key: K, args?: Z) => Promise<V> | V\n  ): GetOrGenerate<K, V, Z> =>\n    async (key: K, args?: Z): Promise<V> => {\n      //eslint-disable-next-line functional/no-let\n      let value = map.get(key);\n      if (value !== undefined) return value; //Promise.resolve(value);\n      value = await fn(key, args);\n      if (value === undefined) throw new Error(`fn returned undefined`);\n      map.set(key, value);\n      return value;\n    };","import { getOrGenerateSync } from '../collections/map/GetOrGenerate.js';\nimport type { MessageLogger, LogMessage } from \"./Types.js\";\n/**\n * Returns a console logging function which prefixes messages. This is\n * useful for tracing messages from different components. Each prefix\n * is assigned a colour, further helping to distinguish messages.\n *\n * Use {@link logSet} to get a bundled set.\n *\n * ```\n * // Initialise once\n * const log = logger(`a`);\n * const error = logger(`a`, `error`);\n * const warn = logger(`a`, `warn);\n *\n * // And then use\n * log(`Hello`);    // console.log(`a Hello`);\n * error(`Uh-oh`);  // console.error(`a Uh-oh`);\n * warn(`Eek!`);    // console.warn(`a Eeek!`);\n * ```\n *\n * Provide the `colourKey` parameter to make log messages\n * be coloured the same, even though the prefix is different.\n * ```js\n * // Both loggers will use the same colour because they\n * // share the colour key `system`\n * const log = logger(`a`,`log`,`system`);\n * const log2 = logger(`b`, `log`, `system`);\n * ```\n * @param prefix\n * @param kind\n * @param colourKey Optional key to colour log lines by instead of prefix\n * @returns\n */\n\n\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const logger =\n  (\n    prefix: string,\n    kind: `log` | `warn` | `error` = `log`,\n    colourKey?: string\n  ): MessageLogger =>\n    (m: any) => {\n      if (m === undefined) {\n        m = `(undefined)`;\n      } else if (typeof m === `object`) {\n        m = JSON.stringify(m);\n      }\n\n      const colour = colourKey ?? prefix;\n      switch (kind) {\n        case `log`: {\n          console.log(`%c${ prefix } ${ m }`, `color: ${ logColours(colour) }`);\n          break;\n        }\n        case `warn`: {\n          console.warn(prefix, m);\n          break;\n        }\n        case `error`: {\n          console.error(prefix, m);\n          break;\n        }\n      }\n    };\n\n/**\n* Returns a bundled collection of {@link logger}s\n*\n* ```js\n* const con = logSet(`a`);\n* con.log(`Hello`);  // console.log(`a Hello`);\n* con.warn(`Uh-oh`); // console.warn(`a Uh-oh`);\n* con.error(`Eek!`); // console.error(`a Eek!`);\n* ```\n*\n* By default each prefix is assigned a colour. To use\n* another logic, provide the `colourKey` parameter.\n*\n* ```js\n* // Both set of loggers will use same colour\n* const con = logSet(`a`, true, `system`);\n* const con2 = logSet(`b`, true, `system`);\n* ```\n* @param prefix Prefix for log messages\n* @param verbose True by default. If false, log() messages are a no-op\n* @param colourKey If specified, log messages will be coloured by this key instead of prefix (default)\n* @returns\n*/\nexport const logSet = (prefix: string, verbose = true, colourKey?: string) => {\n  if (verbose) {\n    return {\n      log: logger(prefix, `log`, colourKey),\n      warn: logger(prefix, `warn`, colourKey),\n      error: logger(prefix, `error`, colourKey),\n    };\n  }\n  return {\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    log: (_: any) => {\n      /** no-op */\n    },\n    warn: logger(prefix, `warn`, colourKey),\n    error: logger(prefix, `error`, colourKey),\n  };\n};\n\n/**\n * Either a flag for default console logging, or a simple log function\n */\nexport type LogOption = boolean | MessageLogger;\n\n/**\n * Resolve a LogOption to a function\n * @param l\n * @returns\n */\nexport const resolveLogOption = (\n  l?: LogOption,\n  defaults: { readonly category?: string; readonly kind?: string } = {}\n): MessageLogger => {\n  if (l === undefined || (typeof l === `boolean` && !l)) {\n    return (_: LogMessage | string) => {\n      /** no-op */\n    };\n  }\n  const defaultCat = defaults.category ?? ``;\n  const defaultKind = defaults.kind ?? undefined;\n\n  if (typeof l === `boolean`) {\n    return (messageOrString: LogMessage | string) => {\n      const m =\n        typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;\n      const kind = m.kind ?? defaultKind;\n      const category = m.category ?? defaultCat;\n      let message = m.msg;\n      if (category) message = `[${ category }] ${ message }`;\n      switch (kind) {\n        case `error`: {\n          console.error(message);\n          break;\n        }\n        case `warn`: {\n          console.warn(message);\n          break;\n        }\n        case `info`: {\n          console.info(message);\n          break;\n        }\n        default: {\n          console.log(message);\n        }\n      }\n    };\n  }\n  return l;\n};\n\n\n\n// eslint-disable-next-line functional/no-let\nlet logColourCount = 0;\nexport const logColours = getOrGenerateSync(new Map<string, string>(), () => {\n  const hue = ++logColourCount * 137.508; // use golden angle approximation\n  return `hsl(${ hue },50%,75%)`;\n});","export const getErrorMessage = (ex: unknown): string => {\n  if (typeof ex === `string`) return ex;\n  if (ex instanceof Error) {\n    return ex.message;\n  }\n  return ex as string;\n};"],"mappings":"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","names":[]}