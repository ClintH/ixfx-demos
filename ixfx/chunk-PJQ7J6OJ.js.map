{"version":3,"sources":["../src/generators/index.ts","../src/generators/chain/index.ts","../src/generators/Iterable.ts","../src/generators/chain/Util.ts","../src/generators/chain/Links.ts","../src/generators/chain/Dom.ts"],"sourcesContent":["import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\nimport { throwIntegerTest, throwNumberTest } from '../Guards.js';\nexport { pingPong, pingPongPercent } from '../modulation/PingPong.js';\nexport * as Async from './IterableAsync.js';\nexport * as Sync from './IterableSync.js';\nexport * as Chain from './chain/index.js';\n\nexport { interval } from '../flow/Interval.js';\nexport { delayLoop, type DelayOpts } from '../flow/Delay.js';\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsEndToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsEndToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsEndToStart(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsEndToStart(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsStartToEnd(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsStartToEnd(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * ```js\n * stringSegmentsStartToStart(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsStartToStart(source: string, delimiter = `.`) {\n  const orig = source;\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using\n * {@link Flow.repeat}.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/generators.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport const count = function* (amount: number, offset = 0) {\n  // Unit tested.\n  throwIntegerTest(amount, ``, `amount`);\n  throwIntegerTest(offset, ``, `offset`);\n\n  if (amount === 0) return;\n\n  let index = 0;\n  do {\n    yield (amount < 0 ? -index + offset : index + offset);\n  } while (index++ < Math.abs(amount) - 1);\n};\n\n/**\n * Returns a number range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};\n\nexport { integerUniqueGen as randomUniqueInteger } from '../random/index.js';","/* eslint-disable @typescript-eslint/require-await */\n/* eslint-disable unicorn/prefer-ternary */\nimport { Async } from \"../index.js\";\nimport { Elapsed } from \"../../flow/index.js\";\nimport { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { Queues } from \"../../collections/index.js\";\nimport { resolveToAsyncGen, resolveToGen } from \"./Util.js\";\nimport type { Link, GenFactoryNoInput, LazyChain, GenOrData, LinksWithSource, Gen, TickOptions, DelayOptions, RankArrayOptions, RankFunction, RankOptions } from \"./Types.js\";\nimport * as L from './Links.js';\nexport * as Dom from './Dom.js';\nexport * as Links from './Links.js';\nexport * from './Types.js';\n\nfunction isNoInput<Out>(c: Link<any, any>): c is GenFactoryNoInput<Out> {\n  if (`_allowNoInput` in c) return true;\n  return false;\n}\n\nexport function lazy<In, Out>(): LazyChain<In, Out> {\n  const chained: Array<Link<any, any>> = [];\n  let dataToUse: GenOrData<In> | undefined;\n\n  const asGenerator = <V>(data?: GenOrData<In>) => {\n    if (data === undefined) data = dataToUse;\n    let d = resolveToAsyncGen(data);\n    for (const c of chained) {\n      if (d === undefined) {\n        if (isNoInput<In>(c)) {\n          d = c();\n        } else {\n          throw new Error(`Function '${ getLinkName(c) }' requires input. Provide it to the function, or call 'input' earlier.`)\n        }\n      } else {\n        d = c(d);\n      }\n    }\n    return d as AsyncGenerator<V>\n  }\n\n  const w: LazyChain<In, Out> = {\n    rankArray: (r: RankFunction<In>, options: Partial<RankArrayOptions>): LazyChain<In, Out> => {\n      chained.push(L.rankArray(r, options));\n      return w;\n    },\n    rank: (r: RankFunction<In>, options: Partial<RankOptions>): LazyChain<In, Out> => {\n      chained.push(L.rank(r, options));\n      return w;\n    },\n    transform: (transformer: (v: any) => any) => {\n      chained.push(L.transform(transformer));\n      return w;\n    },\n    flatten: (flattener: (values: Array<any>) => any) => {\n      chained.push(L.flatten(flattener));\n      return w;\n    },\n    drop: (predicate: (v: In) => boolean) => {\n      chained.push(L.drop(predicate));\n      return w;\n    },\n    delay: (options: DelayOptions) => {\n      chained.push(L.delay(options));\n      return w;\n    },\n    duration: (elapsed: Interval) => {\n      chained.push(L.duration(elapsed));\n      return w;\n    },\n    debounce: (rate: Interval) => {\n      chained.push(L.debounce(rate));\n      return w;\n    },\n    fromFunction: (callback: () => any) => {\n      chained.push(fromFunction(callback));\n      return w;\n    },\n    take: (limit: number) => {\n      chained.push(L.take(limit));\n      return w;\n    },\n    chunk: (size: number, returnRemainders = true) => {\n      chained.push(L.chunk(size, returnRemainders))\n      return w;\n    },\n    filter: (predicate: (input: any) => boolean) => {\n      chained.push(L.filter(v => predicate(v)));\n      return w;\n    },\n    min: (): LazyChain<any, number> => {\n      chained.push(L.min());\n      return w as unknown as LazyChain<any, number>;\n    },\n    max: (): LazyChain<any, number> => {\n      chained.push(L.max());\n      return w as unknown as LazyChain<any, number>;\n    },\n    average: (): LazyChain<any, number> => {\n      chained.push(L.average());\n      return w as unknown as LazyChain<any, number>;\n    },\n    total: (): LazyChain<any, number> => {\n      chained.push(L.total());\n      return w as unknown as LazyChain<any, number>;\n    },\n    tally: (): LazyChain<any, number> => {\n      chained.push(L.tally());\n      return w as unknown as LazyChain<any, number>;\n    },\n    input(data: GenOrData<In>) {\n      dataToUse = data;\n      return w\n    },\n    asGenerator,\n    asAsync(data?: GenOrData<In>) {\n      let d = data ?? dataToUse;\n      for (const c of chained) {\n        if (d === undefined && isNoInput<In>(c)) {\n          d = c();\n        } else if (d === undefined) {\n          throw new Error(`Function '${ getLinkName(c) }' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n        } else {\n          d = c(d);\n        }\n      }\n      return w;\n    },\n    asArray: async (data?: GenOrData<In>): Promise<Array<Out>> => {\n      const g = asGenerator<Out>(data);\n      return await Async.toArray<Out>(g);\n    },\n    firstOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      const v = await g.next();\n      return v.value as Out;\n    },\n    lastOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      let lastValue: Out | undefined;\n      for await (const v of g) {\n        lastValue = v as Out;\n      }\n      return lastValue;\n    },\n  }\n  return w as unknown as LazyChain<In, Out>;\n}\n\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever. \n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n * \n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options \n * @returns \n */\nexport function tick(options: TickOptions): GenFactoryNoInput<number> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const asClockTime = options.asClockTime ?? false;\n  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n  let looped = 0;\n  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n\n  async function* ts(): AsyncGenerator<number> {\n    const elapsed = Elapsed.since();\n    while (looped < loops && elapsed() < durationTime) {\n      yield asClockTime ? Date.now() : elapsed();\n\n      // Adjust sleep period so timing errors don't accumulate\n      const expectedTimeDiff = (looped * intervalMs) - elapsed();\n      await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n      looped++;\n    }\n  }\n  ts._name = `timestamp`;\n  return ts;\n}\n\n/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n * \n * ```js\n * const callback = () => Math.random();\n * \n * const f = Chains.fromFunction(callback);\n * f(); // New random number\n * ```\n * \n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.fromFunction(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback \n * @returns \n */\nexport function fromFunction<Out>(callback: () => Promise<Out> | Out): GenFactoryNoInput<Out> {\n  async function* fromFunction(): AsyncGenerator<Out> {\n    while (true) {\n      const v = await callback();\n      if (v === undefined) break;\n      yield v;\n    }\n  }\n  fromFunction._name = `fromFunction`;\n  return fromFunction;\n}\n\nconst oncePromise = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};\n\nexport function fromEvent<Out>(target: EventTarget, name: string) {\n  async function* fromEvent(): AsyncGenerator<Out> {\n    while (true) {\n      yield await oncePromise(target, name) as Out;\n    }\n  }\n  fromEvent._name = `fromEvent`;\n  return fromEvent;\n}\n\n/**\n * Treats the chain/generator as a promise\n * \n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n * \n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap \n * @returns \n */\nexport function asPromise<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>) {\n  let lastValue: V | undefined;\n\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  async function asPromise(): Promise<V | undefined> {\n    const v = await outputType.next();\n    if (v.done) return;\n    lastValue = v.value;\n    return lastValue;\n  }\n  return asPromise;\n}\n\n/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n * \n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n * \n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n * \n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns \n */\nexport function asValue<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>, initialValue?: V) {\n  let lastValue: V | undefined = initialValue;\n  let awaiting = false;\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  function asValue(): V | undefined {\n    if (!awaiting) {\n      awaiting = true;\n      outputType.next().then(v => {\n        lastValue = v.value;\n        awaiting = false;\n      }).catch(error => {\n        awaiting = false;\n        throw error;\n      });\n    }\n    return lastValue;\n  }\n  return asValue;\n}\n\n/**\n * Calls `callback` whenever the chain/generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap \n * @param callback \n */\nexport async function asCallback<V>(valueToWrap: GenOrData<V> | GenFactoryNoInput<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\n\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n * @param valueToWrap \n * @returns \n */\nexport async function asArray<Out>(valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>): Promise<Array<Out>> {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  return Async.toArray(outputType);\n}\n\n/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n * \n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap \n * @param array \n */\nexport async function addToArray<Out>(array: Array<Out>, valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    array.push(value);\n  }\n}\n\n/**\n * Input a single value to the chain, return a single result\n * @param f \n * @param input \n * @returns \n */\nexport async function single<In, Out>(f: Link<In, Out>, input: In): Promise<Out | undefined> {\n  const iterator = await f([ input ]).next();\n  return iterator.value as Out | undefined;\n}\n\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n * \n * Alternatively:\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link synchronise} which releases a set of results when all inputs have emitted a value\n * @param sources \n */\nexport async function* mergeFlat<Out>(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Out> {\n  const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n  const buffer = Queues.mutable<Out>();\n  let completed = 0;\n\n  const schedule = async (source: AsyncGenerator<any> | undefined) => {\n    if (source === undefined) {\n      completed++;\n      return;\n    }\n\n    const x = await source.next();\n    if (x.done) {\n      completed++;\n    } else {\n      buffer.enqueue(x.value as Out);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(() => schedule(source), 1);\n    }\n  }\n\n  for (const source of sourcesInput) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(() => schedule(source), 1);\n  }\n\n  const loopSpeed = 10;\n  let loopFactor = 1;\n  while (completed < sourcesInput.length) {\n    const d = buffer.dequeue();\n    if (d === undefined) {\n      // Grow loop factor up to 10\n      loopFactor = Math.min(loopFactor + 1, 10);\n    } else {\n      yield d;\n      // Reset loop factor\n      loopFactor = 1;\n    }\n    await sleep(loopSpeed * loopFactor);\n  }\n}\n\n/**\n * Generate values for each source, returning results as an array.  \n * If a source finishes before another, null will be used at its position in the results.\n * Use {@link synchronise} instead to only release results when all sources have yielded a value.\n * \n * Finishes when all generators finish.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link synchronise} only return results when all sourcse have yielded a value\n * @param sources \n */\nexport async function* mergeAsArray(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingProduced = true;\n  while (somethingProduced) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingProduced = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (!v.done) {\n        data[ index ] = v.value;\n        somethingProduced = true;\n      }\n    }\n    if (somethingProduced) {\n      // Send data\n      yield data;\n      data = [];\n    }\n  }\n}\n\n/**\n * Synchronise several sources, releasing a set of results when every\n * source has produced something. Finishes as soon as _any_ source finishes.\n * \n * ie. the rate of emitting data is determined by the slowest source.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * @param sources \n */\nexport async function* synchronise(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingStopped = false;\n  while (!somethingStopped) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingStopped = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (v.done) {\n        somethingStopped = true;\n        break;\n      } else {\n        data[ index ] = v.value;\n      }\n    }\n\n    if (somethingStopped) break;\n    yield data;\n    data = [];\n  }\n}\n\nconst getLinkName = (c: Link<any, any>): string => {\n  if (`_name` in c) {\n    return c._name as string;\n  } else {\n    return c.name;\n  }\n}\n\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param functions \n * @returns \n */\nexport async function* runN<In, Out>(...functions: LinksWithSource<In, Out>): AsyncGenerator<Out> {\n  let input: Gen<In> | undefined;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v as Out;\n  }\n}\n\nexport function run<T1>(gen: GenOrData<T1> | GenFactoryNoInput<T1>): AsyncGenerator<T1>;\nexport function run<T1, T2>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>): AsyncGenerator<T2>;\nexport function run<T1, T2, T3>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>): AsyncGenerator<T3>;\nexport function run<T1, T2, T3, T4>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>): AsyncGenerator<T4>;\nexport function run<T1, T2, T3, T4, T5>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>): AsyncGenerator<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>): AsyncGenerator<T6>;\nexport function run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>, l5: Link<T6, T7>): AsyncGenerator<T7>;\n\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param gen \n * @param l0 \n * @param l1 \n * @param l2 \n * @param l3 \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0?: Link<T1, T2>, l1?: Link<T2, T3>, l2?: Link<T3, T4>, l3?: Link<T4, T5>, l4?: Link<T5, T6>, l5?: Link<T6, T7>): AsyncGenerator<T1> {\n  let input: Gen<any> | undefined;\n  // eslint-disable-next-line prefer-rest-params\n  const functions = arguments;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v;\n  }\n}\n\n\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\n// export function prepare<In, Out>(...functions: Links<In, Out>) {\n//   const r = (source: GenOrData<In> | GenFactoryNoInput<Out>) => {\n//     return run(source);\n//   }\n//   return r;\n// }\n","type WithEvents = {\n  addEventListener(type: string, callbackfn: any): void;\n  removeEventListener(type: string, callbackfn: any): void;\n}\n\n//export { eachInterval } from './flow/Interval.js';\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> =>\n  Symbol.asyncIterator in new Object(v);\n\nexport const isIterable = (v: any): v is Iterable<any> =>\n  Symbol.iterator in new Object(v);\n\nexport const eventsToIterable = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(error),\n      };\n    },\n  };\n  return r;\n};\n","import { Async } from \"../index.js\";\nimport type { GenOrData, GenFactoryNoInput, Gen } from \"./Types.js\";\nimport { isAsyncIterable } from \"../Iterable.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\n/**\n * Wrap the primitive value as generator\n * @param value \n */\nfunction* primitiveToGenerator(value: number | boolean | string) {\n  yield value;\n}\n\n/**\n * Wrap the primitive value as an async generator\n * @param value \n */\nasync function* primitiveToAsyncGenerator(value: number | boolean | string) {\n  yield value;\n  await sleep(1);\n}\n\n/**\n * Resolve the array, data or function to a Generator\n * @param input \n * @returns \n */\nexport function resolveToGen<V>(input: GenOrData<V> | GenFactoryNoInput<V>): Gen<V> {\n  if (Array.isArray(input)) {\n    const a = input.values();\n    (a as any)._name = `arrayInput`;\n    return a;\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToGenerator(input) as Gen<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  }\n  return input;\n}\n\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input \n * @returns \n */\nexport function resolveToAsyncGen<V>(input: GenOrData<V> | GenFactoryNoInput<V> | undefined): AsyncGenerator<V> | undefined {\n  if (input === undefined) return;\n  if (Array.isArray(input)) {\n    return Async.fromArray(input);\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToAsyncGenerator(input) as AsyncGenerator<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  } else if (isAsyncIterable(input)) {\n    return input;\n  }\n  return Async.fromIterable(input);\n}\n","import { intervalToMs, type Interval } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport type { Link, GenOrData, DelayOptions, RankFunction, RankOptions, RankArrayOptions } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { Elapsed } from \"../../flow/index.js\";\nimport { throwIntegerTest } from \"../../Guards.js\";\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (v: In) => Out): Link<In, Out> {\n  async function* transform(input: GenOrData<In>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield transformer(value);\n    }\n  }\n  transform._name = `transform`;\n  return transform;\n}\n\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit \n * @returns \n */\nexport function take<In>(limit: number): Link<In, In> {\n  async function* take(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let yielded = 0;\n    for await (const value of input) {\n      if (++yielded > limit) break;\n      yield value;\n    }\n  }\n  take._name = `take`;\n  return take;\n}\n\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `flattener` function.\n * \n * ```js\n * // Create a chain that flattens values\n * const flatten = Chains.flatten(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(flatten, [ 1, 2, 3]); // 3\n * ```\n * @param flattener Function to flatten array of values to a single value\n * @returns \n */\nexport function flatten<In, Out>(flattener: (v: Array<In>) => Out): Link<Array<In>, Out> {\n  async function* flatten(input: GenOrData<Array<In>>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield flattener(value);\n    }\n  }\n  flatten._name = `flatten`;\n  return flatten;\n}\n\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed \n * @returns \n */\nexport function duration<In>(elapsed: Interval): Link<In, In> {\n  const durationMs = intervalToMs(elapsed, 0);\n\n  async function* duration(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    const elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() > durationMs) break;\n      yield value;\n    }\n  }\n  duration._name = `duration`;\n  return duration;\n}\n\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options \n * @returns \n */\nexport function delay<In>(options: DelayOptions): Link<In, In> {\n  const before = intervalToMs(options.before, 0);\n  const after = intervalToMs(options.after, 0);\n\n  async function* delay(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (before > 0) {\n        await sleep(before);\n      }\n      yield value;\n      if (after > 0) {\n        await sleep(after);\n      }\n    }\n  }\n  delay._name = `delay`;\n  return delay;\n}\n\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n * \n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.chain(\n *  // Produce values every 10ms for 350ms\n *  Chains.tick({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.debounce(100)\n * );\n * ```\n * @param rate \n * @returns \n */\nexport function debounce<In>(rate: Interval): Link<In, In> {\n  const rateMs = intervalToMs(rate, 0);\n\n  async function* debounce(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() < rateMs) continue;\n      yield value;\n      elapsed = Elapsed.since();\n    }\n  }\n  debounce._name = `debounce`;\n  return debounce;\n}\n\n\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * \n * This is different than {@link total} which adds up numeric values\n * @returns \n */\nexport function tally<In>(): Link<In, number> {\n  async function* tally(input: GenOrData<In>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let count = 0;\n    for await (const _ of input) {\n      yield ++count;\n    }\n  }\n  tally._name = `tally`;\n  return tally;\n}\n\n/**\n * Returns the smallest value from the input.\n * Can work with numbers or number[] as input.\n * Non-numeric data is filtered out.\n * @returns \n */\nexport function min(): Link<number | Array<number>, number> {\n  async function* min(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let min = Number.MAX_SAFE_INTEGER;\n    for await (const value of input) {\n      const arrayValue = Array.isArray(value) ? value : [ value ]\n      for (const subValue of arrayValue) {\n        if (typeof subValue !== `number`) break;\n        min = Math.min(subValue, min);\n        yield min;\n      }\n\n      // if (typeof value !== `number`) break;\n      // min = Math.min(value, min);\n      // yield min;\n    }\n  }\n  min._name = `min`;\n  return min;\n}\n\n/**\n * Returns the largest value from the input\n * Non-numeric data is filtered out\n * @returns \n */\nexport function max(): Link<number | Array<number>, number> {\n  async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let max = Number.MIN_SAFE_INTEGER;\n    for await (const value of input) {\n      const valueArray = Array.isArray(value) ? value : [ value ];\n      for (const subValue of valueArray) {\n        if (typeof subValue !== `number`) break;\n        max = Math.max(subValue, max);\n        yield max;\n      }\n    }\n  }\n  max._name = `max`;\n  return max;\n}\n\n/**\n * Emits the currently ranked 'highest' value from a stream. Only\n * values exceeding the current highest are emitted.\n * \n * eg, if we are ranking on numerical value, an input stream of:\n * ```\n * 4, 1, 6, 10, 2, 4\n * ```\n * \n * Results in the output stream of:\n * ```\n * 4, 6, 10\n * ```\n * \n * @example \n * ```js\n * // Rank based on a field\n * Chains.Links.rank((a,b) => {\n *  if (a.size > b.size) return `a`;\n *  if (a.size < b.size) return `b`;\n *  return `eq`;\n * });\n * ```\n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}): Link<In, In> {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  async function* rank(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let best: In | undefined;\n    for await (const value of input) {\n      let emit = false;\n      if (includeType && typeof value !== includeType) continue;\n      if (best === undefined) {\n        best = value;\n        emit = true;\n      } else {\n        const result = r(value, best);\n        //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n        if (result == `a`) {\n          // New value is the current best\n          best = value;\n          emit = true;\n        } else if (result === `eq` && emitEqualRanked) {\n          // New value is same rank as previous, but we have flag on\n          emit = true;\n        } else if (emitRepeatHighest) {\n          // Emit current highest due to flag\n          emit = true;\n        }\n      }\n      if (emit) yield best;\n    }\n  }\n  rank._name = `rank`;\n  return rank;\n}\n\n/**\n * Emits the highest-ranked value from amongst an array of values.\n * \n * By default, it tracks the highest-ranked _between_ arrays.\n * \n * For example:\n * ```js\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Outputs:\n * [ 6 ]\n * ```\n * \n * This behaviour can be modified with an option to only compare _within_ arrays.\n * ```\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Output:\n * [ 6, 3 ]\n * ```\n * \n * Uses the `rank` option to determine which is more highly ranked.\n * ```js\n * Chains.Links.rankArray(\n *  (a, b) => {\n *    if (a > b) return `a`; // a is higher\n *    else if (b > a) return `b`; // b is higher\n *    return `eq`; // same\n *  }\n * )\n * ```\n * @param options \n * @returns \n */\nexport function rankArray<In>(r: RankFunction<In>, options: Partial<RankArrayOptions> = {}): Link<Array<In>, In> {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  const withinArrays = options.withinArrays ?? false;\n\n  async function* rankArray(input: GenOrData<Array<In>>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let best: In | undefined;\n    for await (const value of input) {\n      let emit = false;\n      if (withinArrays) best = undefined; // Reset\n      for (const subValue of value) {\n        if (includeType && typeof subValue !== includeType) continue;\n        if (best === undefined) {\n          best = subValue;\n          emit = true;\n        } else {\n          const result = r(subValue, best);\n          if (result == `a`) {\n            // New value is the current best\n            best = subValue;\n            emit = true;\n          } else if (result === `eq` && emitEqualRanked) {\n            // New value is same rank as previous, but we have flag on\n            emit = true;\n          } else if (emitRepeatHighest) {\n            // Emit current highest due to flag\n            emit = true;\n          }\n        }\n      }\n\n      if (emit && best) yield best;\n    }\n  }\n  rankArray._name = `rankArray`;\n  return rankArray;\n}\n\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function average(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    let count = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      count++;\n      total += value;\n      yield total / count;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function total(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      total += value;\n      yield total;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Chunks an input stream into `size` chunks.\n * \n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n * \n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size \n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns \n */\nexport function chunk<In>(size: number, returnRemainders = true): Link<In, Array<In>> {\n  throwIntegerTest(size, `aboveZero`, `size`);\n  async function* chunk(input: GenOrData<In>): AsyncGenerator<Array<In>> {\n    input = resolveToGen(input);\n    let buffer: Array<In> = [];\n    for await (const value of input) {\n      buffer.push(value);\n      if (buffer.length >= size) {\n        yield buffer;\n        buffer = []\n      }\n    }\n    if (returnRemainders && buffer.length > 0) yield buffer;\n  }\n  chunk._name = `chunk`;\n  return chunk;\n}\n\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n * \n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate \n * @returns \n */\nexport function filter<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* filter(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  filter._name = `filter`;\n  return filter;\n}\n\n\n\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n * \n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate \n * @returns \n */\nexport function drop<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* drop(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (!predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  drop._name = `drop`;\n  return drop;\n}\n","//import { query as DomQuery } from \"../../dom/Query.js\";\n\nimport type { GenOrData, Link } from \"./Types.js\";\nimport { resolveToGen } from \"./Util.js\";\nimport { resolveEl } from \"../../dom/ResolveEl.js\";\nimport { toStringDefault } from \"../../Util.js\";\n\nexport type QueryOptions = {\n  baseElement: HTMLElement;\n}\n\nexport type CreateOptions<In> = {\n  /**\n   * Parent element to create elements in. Defaults to `document.body`.\n   */\n  parentEl: string | HTMLElement\n  /**\n   * When set, provide a custom function to return a unique key for a value.\n   * This is used for matching values with elements when using immutable data.\n   * \n   * By default uses the\n   * JSON.stringify() representation.\n   * \n   * To match elements with values by reference, set `byReference` instead.\n   * \n   * @param value \n   * @returns \n   */\n  key: (value: In) => string\n  /**\n   * Default: _false_. When _true_, associate created elements\n   * to values by reference rather than value. This can be useful with mutable values.\n   * \n   * Use this _or_ the `key` option.\n   */\n  byReference: boolean\n  /**\n   * What kind of HTML element to make, defaults to DIV\n   */\n  tagName: string\n  /**\n   * Called whenever an element is created but not yet added to parent element\n   * @param element \n   * @returns \n   */\n  beforeInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element is inserted to the parent element\n   */\n  afterInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element has been removed\n   * @param element \n   * @returns \n   */\n  beforeRemove: (element: HTMLElement) => void\n}\n\nconst createMap = <T, TValue>(key?: (value: T) => string) => {\n  const keyFunction = key ?? ((value: T) => value);\n\n  const map = new Map<ReturnType<typeof keyFunction>, TValue>();\n  return {\n    has(key: T) {\n      return map.has(keyFunction(key));\n    },\n    get(key: T) {\n      return map.get(keyFunction(key));\n    },\n    set(key: T, value: TValue) {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      //console.log(`Chains.Dom.createMap: key: ${ keyFunction(key) } value: ${ value }`);\n      map.set(keyFunction(key), value);\n    },\n    entries() {\n      return map.entries();\n    },\n    delete(key: T | string) {\n      map.delete(key);\n    }\n  }\n\n}\n\nexport type ElementWithValue<T> = {\n  el: HTMLElement\n  value: T\n}\n\n/**\n * Creates a HTML element per value. By default compares\n * values by `JSON.stringify`. Set `byReference:true` to\n * compare values based on reference. Or provide a toString\n * function via `key`.\n * \n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n * \n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n * ```\n */\nexport function perValue<In>(options: Partial<CreateOptions<In>> = {}): Link<In, ElementWithValue<In>> {\n  const byReference = options.byReference;\n  const tagName = options.tagName ?? `div`;\n  if (byReference && options.key) throw new Error(`byReference and key options are mutually exclusive`);\n  const keyFunction = byReference ? undefined : options.key ?? toStringDefault;\n  const map = createMap<In, HTMLElement>(keyFunction);\n  const parentElementOrQuery = options.parentEl ?? document.body;\n  const parentEl = resolveEl(parentElementOrQuery);\n\n  const usedElements = new Set<HTMLElement>();\n\n  async function* perValue(input: GenOrData<In>): AsyncGenerator<ElementWithValue<In>> {\n    for await (const value of resolveToGen(input)) {\n      let el = map.get(value);\n      if (!el) {\n        el = document.createElement(tagName);\n        map.set(value, el);\n        if (options.beforeInsert) options.beforeInsert(el);\n        parentEl.append(el);\n        if (options.afterInsert) options.afterInsert(el);\n      }\n      usedElements.add(el);\n      yield { el, value };\n    }\n\n    // Remove unused elements\n    for (const [ id, el ] of map.entries()) {\n      if (usedElements.has(el)) continue;\n      if (options.beforeRemove) options.beforeRemove(el);\n      el.remove();\n      map.delete(id);\n    }\n  }\n  perValue._name = `dom.perValue`;\n  return perValue;\n}\n\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options \n * @returns \n */\nexport function query(options: Partial<QueryOptions> = {}): Link<string, HTMLElement> {\n  const baseElement = options.baseElement ?? document;\n\n  async function* query(input: GenOrData<string>): AsyncGenerator<HTMLElement> {\n    const gen = resolveToGen(input);\n    for await (const value of gen) {\n      for (const element of baseElement.querySelectorAll(value)) {\n        yield element as HTMLElement;\n      }\n    }\n  }\n  query._name = `dom.query`;\n  return query;\n}\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACOO,IAAM,kBAAkB,CAAC,MAC9B,OAAO,iBAAiB,IAAI,OAAO,CAAC;;;ACAtC,UAAU,qBAAqB,OAAkC;AAC/D,QAAM;AACR;AAMA,gBAAgB,0BAA0B,OAAkC;AAC1E,QAAM;AACN,QAAM,MAAM,CAAC;AACf;AAOO,SAAS,aAAgB,OAAoD;AAClF,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,UAAM,IAAI,MAAM,OAAO;AACvB,IAAC,EAAU,QAAQ;AACnB,WAAO;AAAA,EACT,WAAW,OAAO,UAAU,YAAY,OAAO,UAAU,aAAa,OAAO,UAAU,UAAU;AAE/F,WAAO,qBAAqB,KAAK;AAAA,EACnC,WAAW,OAAO,UAAU,YAAY;AACtC,WAAO,MAAM;AAAA,EACf;AACA,SAAO;AACT;AAOO,SAAS,kBAAqB,OAAuF;AAC1H,MAAI,UAAU;AAAW;AACzB,MAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,WAAO,sBAAM,UAAU,KAAK;AAAA,EAC9B,WAAW,OAAO,UAAU,YAAY,OAAO,UAAU,aAAa,OAAO,UAAU,UAAU;AAE/F,WAAO,0BAA0B,KAAK;AAAA,EACxC,WAAW,OAAO,UAAU,YAAY;AACtC,WAAO,MAAM;AAAA,EACf,WAAW,gBAAgB,KAAK,GAAG;AACjC,WAAO;AAAA,EACT;AACA,SAAO,sBAAM,aAAa,KAAK;AACjC;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWO,SAAS,UAAmB,aAA4C;AAC7E,kBAAgBA,WAAU,OAA2C;AACnE,YAAQ,aAAa,KAAK;AAC1B,qBAAiB,SAAS,OAAO;AAC/B,YAAM,YAAY,KAAK;AAAA,IACzB;AAAA,EACF;AACA,EAAAA,WAAU,QAAQ;AAClB,SAAOA;AACT;AAOO,SAAS,KAAS,OAA6B;AACpD,kBAAgBC,MAAK,OAA0C;AAC7D,YAAQ,aAAa,KAAK;AAC1B,QAAI,UAAU;AACd,qBAAiB,SAAS,OAAO;AAC/B,UAAI,EAAE,UAAU;AAAO;AACvB,YAAM;AAAA,IACR;AAAA,EACF;AACA,EAAAA,MAAK,QAAQ;AACb,SAAOA;AACT;AAeO,SAAS,QAAiB,WAAwD;AACvF,kBAAgBC,SAAQ,OAAkD;AACxE,YAAQ,aAAa,KAAK;AAC1B,qBAAiB,SAAS,OAAO;AAC/B,YAAM,UAAU,KAAK;AAAA,IACvB;AAAA,EACF;AACA,EAAAA,SAAQ,QAAQ;AAChB,SAAOA;AACT;AAQO,SAAS,SAAa,SAAiC;AAC5D,QAAM,aAAa,aAAa,SAAS,CAAC;AAE1C,kBAAgBC,UAAS,OAA0C;AACjE,YAAQ,aAAa,KAAK;AAC1B,UAAMC,WAAU,gBAAQ,MAAM;AAC9B,qBAAiB,SAAS,OAAO;AAC/B,UAAIA,SAAQ,IAAI;AAAY;AAC5B,YAAM;AAAA,IACR;AAAA,EACF;AACA,EAAAD,UAAS,QAAQ;AACjB,SAAOA;AACT;AAOO,SAAS,MAAU,SAAqC;AAC7D,QAAM,SAAS,aAAa,QAAQ,QAAQ,CAAC;AAC7C,QAAM,QAAQ,aAAa,QAAQ,OAAO,CAAC;AAE3C,kBAAgBE,OAAM,OAA0C;AAC9D,YAAQ,aAAa,KAAK;AAC1B,qBAAiB,SAAS,OAAO;AAC/B,UAAI,SAAS,GAAG;AACd,cAAM,MAAM,MAAM;AAAA,MACpB;AACA,YAAM;AACN,UAAI,QAAQ,GAAG;AACb,cAAM,MAAM,KAAK;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AACA,EAAAA,OAAM,QAAQ;AACd,SAAOA;AACT;AAkBO,SAAS,SAAa,MAA8B;AACzD,QAAM,SAAS,aAAa,MAAM,CAAC;AAEnC,kBAAgBC,UAAS,OAA0C;AACjE,YAAQ,aAAa,KAAK;AAC1B,QAAI,UAAU,gBAAQ,MAAM;AAC5B,qBAAiB,SAAS,OAAO;AAC/B,UAAI,QAAQ,IAAI;AAAQ;AACxB,YAAM;AACN,gBAAU,gBAAQ,MAAM;AAAA,IAC1B;AAAA,EACF;AACA,EAAAA,UAAS,QAAQ;AACjB,SAAOA;AACT;AAUO,SAAS,QAA8B;AAC5C,kBAAgBC,OAAM,OAA8C;AAClE,YAAQ,aAAa,KAAK;AAC1B,QAAIC,SAAQ;AACZ,qBAAiB,KAAK,OAAO;AAC3B,YAAM,EAAEA;AAAA,IACV;AAAA,EACF;AACA,EAAAD,OAAM,QAAQ;AACd,SAAOA;AACT;AAQO,SAAS,MAA4C;AAC1D,kBAAgBE,KAAI,OAAkE;AACpF,YAAQ,aAAa,KAAK;AAC1B,QAAIA,OAAM,OAAO;AACjB,qBAAiB,SAAS,OAAO;AAC/B,YAAM,aAAa,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAE,KAAM;AAC1D,iBAAW,YAAY,YAAY;AACjC,YAAI,OAAO,aAAa;AAAU;AAClC,QAAAA,OAAM,KAAK,IAAI,UAAUA,IAAG;AAC5B,cAAMA;AAAA,MACR;AAAA,IAKF;AAAA,EACF;AACA,EAAAA,KAAI,QAAQ;AACZ,SAAOA;AACT;AAOO,SAAS,MAA4C;AAC1D,kBAAgBC,KAAI,OAAkE;AACpF,YAAQ,aAAa,KAAK;AAC1B,QAAIA,OAAM,OAAO;AACjB,qBAAiB,SAAS,OAAO;AAC/B,YAAM,aAAa,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAE,KAAM;AAC1D,iBAAW,YAAY,YAAY;AACjC,YAAI,OAAO,aAAa;AAAU;AAClC,QAAAA,OAAM,KAAK,IAAI,UAAUA,IAAG;AAC5B,cAAMA;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,EAAAA,KAAI,QAAQ;AACZ,SAAOA;AACT;AA4BO,SAAS,KAAS,GAAqB,UAAgC,CAAC,GAAiB;AAC9F,QAAM,cAAc,QAAQ;AAC5B,QAAM,kBAAkB,QAAQ,mBAAmB;AACnD,QAAM,oBAAoB,QAAQ,qBAAqB;AACvD,kBAAgBC,MAAK,OAA0C;AAC7D,YAAQ,aAAa,KAAK;AAC1B,QAAI;AACJ,qBAAiB,SAAS,OAAO;AAC/B,UAAI,OAAO;AACX,UAAI,eAAe,OAAO,UAAU;AAAa;AACjD,UAAI,SAAS,QAAW;AACtB,eAAO;AACP,eAAO;AAAA,MACT,OAAO;AACL,cAAM,SAAS,EAAE,OAAO,IAAI;AAE5B,YAAI,UAAU,KAAK;AAEjB,iBAAO;AACP,iBAAO;AAAA,QACT,WAAW,WAAW,QAAQ,iBAAiB;AAE7C,iBAAO;AAAA,QACT,WAAW,mBAAmB;AAE5B,iBAAO;AAAA,QACT;AAAA,MACF;AACA,UAAI;AAAM,cAAM;AAAA,IAClB;AAAA,EACF;AACA,EAAAA,MAAK,QAAQ;AACb,SAAOA;AACT;AAoCO,SAAS,UAAc,GAAqB,UAAqC,CAAC,GAAwB;AAC/G,QAAM,cAAc,QAAQ;AAC5B,QAAM,kBAAkB,QAAQ,mBAAmB;AACnD,QAAM,oBAAoB,QAAQ,qBAAqB;AACvD,QAAM,eAAe,QAAQ,gBAAgB;AAE7C,kBAAgBC,WAAU,OAAiD;AACzE,YAAQ,aAAa,KAAK;AAC1B,QAAI;AACJ,qBAAiB,SAAS,OAAO;AAC/B,UAAI,OAAO;AACX,UAAI;AAAc,eAAO;AACzB,iBAAW,YAAY,OAAO;AAC5B,YAAI,eAAe,OAAO,aAAa;AAAa;AACpD,YAAI,SAAS,QAAW;AACtB,iBAAO;AACP,iBAAO;AAAA,QACT,OAAO;AACL,gBAAM,SAAS,EAAE,UAAU,IAAI;AAC/B,cAAI,UAAU,KAAK;AAEjB,mBAAO;AACP,mBAAO;AAAA,UACT,WAAW,WAAW,QAAQ,iBAAiB;AAE7C,mBAAO;AAAA,UACT,WAAW,mBAAmB;AAE5B,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAEA,UAAI,QAAQ;AAAM,cAAM;AAAA,IAC1B;AAAA,EACF;AACA,EAAAA,WAAU,QAAQ;AAClB,SAAOA;AACT;AAOO,SAAS,UAAgC;AAC9C,kBAAgBC,SAAQ,OAAkD;AACxE,YAAQ,aAAa,KAAK;AAC1B,QAAIC,SAAQ;AACZ,QAAIN,SAAQ;AACZ,qBAAiB,SAAS,OAAO;AAC/B,UAAI,OAAO,UAAU;AAAU;AAC/B,MAAAA;AACA,MAAAM,UAAS;AACT,YAAMA,SAAQN;AAAA,IAChB;AAAA,EACF;AACA,EAAAK,SAAQ,QAAQ;AAChB,SAAOA;AACT;AAOO,SAAS,QAA8B;AAC5C,kBAAgBA,SAAQ,OAAkD;AACxE,YAAQ,aAAa,KAAK;AAC1B,QAAIC,SAAQ;AACZ,qBAAiB,SAAS,OAAO;AAC/B,UAAI,OAAO,UAAU;AAAU;AAC/B,MAAAA,UAAS;AACT,YAAMA;AAAA,IACR;AAAA,EACF;AACA,EAAAD,SAAQ,QAAQ;AAChB,SAAOA;AACT;AAgBO,SAAS,MAAU,MAAc,mBAAmB,MAA2B;AACpF,mBAAiB,MAAM,aAAa,MAAM;AAC1C,kBAAgBE,OAAM,OAAiD;AACrE,YAAQ,aAAa,KAAK;AAC1B,QAAI,SAAoB,CAAC;AACzB,qBAAiB,SAAS,OAAO;AAC/B,aAAO,KAAK,KAAK;AACjB,UAAI,OAAO,UAAU,MAAM;AACzB,cAAM;AACN,iBAAS,CAAC;AAAA,MACZ;AAAA,IACF;AACA,QAAI,oBAAoB,OAAO,SAAS;AAAG,YAAM;AAAA,EACnD;AACA,EAAAA,OAAM,QAAQ;AACd,SAAOA;AACT;AAUO,SAAS,OAAW,WAA6C;AACtE,kBAAgBC,QAAO,OAA0C;AAC/D,YAAQ,aAAa,KAAK;AAC1B,qBAAiB,SAAS,OAAO;AAC/B,UAAI,UAAU,KAAK,GAAG;AACpB,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,EAAAA,QAAO,QAAQ;AACf,SAAOA;AACT;AAWO,SAAS,KAAS,WAA6C;AACpE,kBAAgBC,MAAK,OAA0C;AAC7D,YAAQ,aAAa,KAAK;AAC1B,qBAAiB,SAAS,OAAO;AAC/B,UAAI,CAAC,UAAU,KAAK,GAAG;AACrB,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,EAAAA,MAAK,QAAQ;AACb,SAAOA;AACT;;;AC3cA;AAAA;AAAA;AAAA;AAAA;AA0DA,IAAM,YAAY,CAAY,QAA+B;AAC3D,QAAM,cAAc,QAAQ,CAAC,UAAa;AAE1C,QAAM,MAAM,oBAAI,IAA4C;AAC5D,SAAO;AAAA,IACL,IAAIC,MAAQ;AACV,aAAO,IAAI,IAAI,YAAYA,IAAG,CAAC;AAAA,IACjC;AAAA,IACA,IAAIA,MAAQ;AACV,aAAO,IAAI,IAAI,YAAYA,IAAG,CAAC;AAAA,IACjC;AAAA,IACA,IAAIA,MAAQ,OAAe;AAGzB,UAAI,IAAI,YAAYA,IAAG,GAAG,KAAK;AAAA,IACjC;AAAA,IACA,UAAU;AACR,aAAO,IAAI,QAAQ;AAAA,IACrB;AAAA,IACA,OAAOA,MAAiB;AACtB,UAAI,OAAOA,IAAG;AAAA,IAChB;AAAA,EACF;AAEF;AAiCO,SAAS,SAAa,UAAsC,CAAC,GAAmC;AACrG,QAAM,cAAc,QAAQ;AAC5B,QAAM,UAAU,QAAQ,WAAW;AACnC,MAAI,eAAe,QAAQ;AAAK,UAAM,IAAI,MAAM,oDAAoD;AACpG,QAAM,cAAc,cAAc,SAAY,QAAQ,OAAO;AAC7D,QAAM,MAAM,UAA2B,WAAW;AAClD,QAAM,uBAAuB,QAAQ,YAAY,SAAS;AAC1D,QAAM,WAAW,UAAU,oBAAoB;AAE/C,QAAM,eAAe,oBAAI,IAAiB;AAE1C,kBAAgBC,UAAS,OAA4D;AACnF,qBAAiB,SAAS,aAAa,KAAK,GAAG;AAC7C,UAAI,KAAK,IAAI,IAAI,KAAK;AACtB,UAAI,CAAC,IAAI;AACP,aAAK,SAAS,cAAc,OAAO;AACnC,YAAI,IAAI,OAAO,EAAE;AACjB,YAAI,QAAQ;AAAc,kBAAQ,aAAa,EAAE;AACjD,iBAAS,OAAO,EAAE;AAClB,YAAI,QAAQ;AAAa,kBAAQ,YAAY,EAAE;AAAA,MACjD;AACA,mBAAa,IAAI,EAAE;AACnB,YAAM,EAAE,IAAI,MAAM;AAAA,IACpB;AAGA,eAAW,CAAE,IAAI,EAAG,KAAK,IAAI,QAAQ,GAAG;AACtC,UAAI,aAAa,IAAI,EAAE;AAAG;AAC1B,UAAI,QAAQ;AAAc,gBAAQ,aAAa,EAAE;AACjD,SAAG,OAAO;AACV,UAAI,OAAO,EAAE;AAAA,IACf;AAAA,EACF;AACA,EAAAA,UAAS,QAAQ;AACjB,SAAOA;AACT;AASO,SAAS,MAAM,UAAiC,CAAC,GAA8B;AACpF,QAAM,cAAc,QAAQ,eAAe;AAE3C,kBAAgBC,OAAM,OAAuD;AAC3E,UAAM,MAAM,aAAa,KAAK;AAC9B,qBAAiB,SAAS,KAAK;AAC7B,iBAAW,WAAW,YAAY,iBAAiB,KAAK,GAAG;AACzD,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,EAAAA,OAAM,QAAQ;AACd,SAAOA;AACT;;;AJ9JA,SAAS,UAAe,GAAgD;AACtE,MAAI,mBAAmB;AAAG,WAAO;AACjC,SAAO;AACT;AAEO,SAAS,OAAoC;AAClD,QAAM,UAAiC,CAAC;AACxC,MAAI;AAEJ,QAAM,cAAc,CAAI,SAAyB;AAC/C,QAAI,SAAS;AAAW,aAAO;AAC/B,QAAI,IAAI,kBAAkB,IAAI;AAC9B,eAAW,KAAK,SAAS;AACvB,UAAI,MAAM,QAAW;AACnB,YAAI,UAAc,CAAC,GAAG;AACpB,cAAI,EAAE;AAAA,QACR,OAAO;AACL,gBAAM,IAAI,MAAM,aAAc,YAAY,CAAC,CAAE,wEAAwE;AAAA,QACvH;AAAA,MACF,OAAO;AACL,YAAI,EAAE,CAAC;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,QAAM,IAAwB;AAAA,IAC5B,WAAW,CAAC,GAAqB,YAA2D;AAC1F,cAAQ,KAAO,UAAU,GAAG,OAAO,CAAC;AACpC,aAAO;AAAA,IACT;AAAA,IACA,MAAM,CAAC,GAAqB,YAAsD;AAChF,cAAQ,KAAO,KAAK,GAAG,OAAO,CAAC;AAC/B,aAAO;AAAA,IACT;AAAA,IACA,WAAW,CAAC,gBAAiC;AAC3C,cAAQ,KAAO,UAAU,WAAW,CAAC;AACrC,aAAO;AAAA,IACT;AAAA,IACA,SAAS,CAAC,cAA2C;AACnD,cAAQ,KAAO,QAAQ,SAAS,CAAC;AACjC,aAAO;AAAA,IACT;AAAA,IACA,MAAM,CAAC,cAAkC;AACvC,cAAQ,KAAO,KAAK,SAAS,CAAC;AAC9B,aAAO;AAAA,IACT;AAAA,IACA,OAAO,CAAC,YAA0B;AAChC,cAAQ,KAAO,MAAM,OAAO,CAAC;AAC7B,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,YAAsB;AAC/B,cAAQ,KAAO,SAAS,OAAO,CAAC;AAChC,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,SAAmB;AAC5B,cAAQ,KAAO,SAAS,IAAI,CAAC;AAC7B,aAAO;AAAA,IACT;AAAA,IACA,cAAc,CAAC,aAAwB;AACrC,cAAQ,KAAK,aAAa,QAAQ,CAAC;AACnC,aAAO;AAAA,IACT;AAAA,IACA,MAAM,CAAC,UAAkB;AACvB,cAAQ,KAAO,KAAK,KAAK,CAAC;AAC1B,aAAO;AAAA,IACT;AAAA,IACA,OAAO,CAAC,MAAc,mBAAmB,SAAS;AAChD,cAAQ,KAAO,MAAM,MAAM,gBAAgB,CAAC;AAC5C,aAAO;AAAA,IACT;AAAA,IACA,QAAQ,CAAC,cAAuC;AAC9C,cAAQ,KAAO,OAAO,OAAK,UAAU,CAAC,CAAC,CAAC;AACxC,aAAO;AAAA,IACT;AAAA,IACA,KAAK,MAA8B;AACjC,cAAQ,KAAO,IAAI,CAAC;AACpB,aAAO;AAAA,IACT;AAAA,IACA,KAAK,MAA8B;AACjC,cAAQ,KAAO,IAAI,CAAC;AACpB,aAAO;AAAA,IACT;AAAA,IACA,SAAS,MAA8B;AACrC,cAAQ,KAAO,QAAQ,CAAC;AACxB,aAAO;AAAA,IACT;AAAA,IACA,OAAO,MAA8B;AACnC,cAAQ,KAAO,MAAM,CAAC;AACtB,aAAO;AAAA,IACT;AAAA,IACA,OAAO,MAA8B;AACnC,cAAQ,KAAO,MAAM,CAAC;AACtB,aAAO;AAAA,IACT;AAAA,IACA,MAAM,MAAqB;AACzB,kBAAY;AACZ,aAAO;AAAA,IACT;AAAA,IACA;AAAA,IACA,QAAQ,MAAsB;AAC5B,UAAI,IAAI,QAAQ;AAChB,iBAAW,KAAK,SAAS;AACvB,YAAI,MAAM,UAAa,UAAc,CAAC,GAAG;AACvC,cAAI,EAAE;AAAA,QACR,WAAW,MAAM,QAAW;AAC1B,gBAAM,IAAI,MAAM,aAAc,YAAY,CAAC,CAAE,wEAAwE;AAAA,QACvH,OAAO;AACL,cAAI,EAAE,CAAC;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,IACA,SAAS,OAAO,SAA8C;AAC5D,YAAM,IAAI,YAAiB,IAAI;AAC/B,aAAO,MAAM,sBAAM,QAAa,CAAC;AAAA,IACnC;AAAA,IACA,aAAa,OAAO,SAAmD;AACrE,YAAM,IAAI,YAAiB,IAAI;AAC/B,YAAM,IAAI,MAAM,EAAE,KAAK;AACvB,aAAO,EAAE;AAAA,IACX;AAAA,IACA,YAAY,OAAO,SAAmD;AACpE,YAAM,IAAI,YAAiB,IAAI;AAC/B,UAAI;AACJ,uBAAiB,KAAK,GAAG;AACvB,oBAAY;AAAA,MACd;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAWO,SAAS,KAAK,SAAiD;AACpE,QAAM,aAAa,aAAa,QAAQ,UAAU,CAAC;AACnD,QAAM,cAAc,QAAQ,eAAe;AAC3C,QAAM,QAAQ,QAAQ,SAAS,OAAO;AACtC,MAAI,SAAS;AACb,QAAM,eAAe,aAAa,QAAQ,SAAS,OAAO,gBAAgB;AAE1E,kBAAgB,KAA6B;AAC3C,UAAM,UAAU,gBAAQ,MAAM;AAC9B,WAAO,SAAS,SAAS,QAAQ,IAAI,cAAc;AACjD,YAAM,cAAc,KAAK,IAAI,IAAI,QAAQ;AAGzC,YAAM,mBAAoB,SAAS,aAAc,QAAQ;AACzD,YAAM,MAAM,KAAK,IAAI,GAAG,aAAa,gBAAgB,CAAC;AACtD;AAAA,IACF;AAAA,EACF;AACA,KAAG,QAAQ;AACX,SAAO;AACT;AA6BO,SAAS,aAAkB,UAA4D;AAC5F,kBAAgBC,gBAAoC;AAClD,WAAO,MAAM;AACX,YAAM,IAAI,MAAM,SAAS;AACzB,UAAI,MAAM;AAAW;AACrB,YAAM;AAAA,IACR;AAAA,EACF;AACA,EAAAA,cAAa,QAAQ;AACrB,SAAOA;AACT;AAEA,IAAM,cAAc,CAAC,QAAqB,SAA+B;AACvE,SAAO,IAAI,QAAQ,aAAW;AAC5B,UAAM,UAAU,IAAI,SAAqB;AACvC,aAAO,oBAAoB,MAAM,OAAO;AACxC,cAAQ,IAAI;AAAA,IACd;AACA,WAAO,iBAAiB,MAAM,OAAO;AAAA,EACvC,CAAC;AACH;AAEO,SAAS,UAAe,QAAqB,MAAc;AAChE,kBAAgBC,aAAiC;AAC/C,WAAO,MAAM;AACX,YAAM,MAAM,YAAY,QAAQ,IAAI;AAAA,IACtC;AAAA,EACF;AACA,EAAAA,WAAU,QAAQ;AAClB,SAAOA;AACT;AAeO,SAAS,UAAa,aAAuD;AAClF,MAAI;AAEJ,QAAM,aAAc,OAAO,gBAAgB,aAAc,YAAY,IAAI;AAEzE,iBAAeC,aAAoC;AACjD,UAAM,IAAI,MAAM,WAAW,KAAK;AAChC,QAAI,EAAE;AAAM;AACZ,gBAAY,EAAE;AACd,WAAO;AAAA,EACT;AACA,SAAOA;AACT;AAoBO,SAAS,QAAW,aAAuD,cAAkB;AAClG,MAAI,YAA2B;AAC/B,MAAI,WAAW;AACf,QAAM,aAAc,OAAO,gBAAgB,aAAc,YAAY,IAAI;AAEzE,WAASC,WAAyB;AAChC,QAAI,CAAC,UAAU;AACb,iBAAW;AACX,iBAAW,KAAK,EAAE,KAAK,OAAK;AAC1B,oBAAY,EAAE;AACd,mBAAW;AAAA,MACb,CAAC,EAAE,MAAM,WAAS;AAChB,mBAAW;AACX,cAAM;AAAA,MACR,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AACA,SAAOA;AACT;AAuBA,eAAsB,WAAc,aAAkD,UAA6B,QAAqB;AACtI,QAAM,aAAc,OAAO,gBAAgB,aAAc,YAAY,IAAI;AACzE,mBAAiB,SAAS,YAAY;AACpC,aAAS,KAAK;AAAA,EAChB;AACA,MAAI;AAAQ,WAAO;AACrB;AAYA,eAAsB,QAAa,aAAgF;AACjH,QAAM,aAAc,OAAO,gBAAgB,aAAc,YAAY,IAAI;AACzE,SAAO,sBAAM,QAAQ,UAAU;AACjC;AAcA,eAAsB,WAAgB,OAAmB,aAA2D;AAClH,QAAM,aAAc,OAAO,gBAAgB,aAAc,YAAY,IAAI;AACzE,mBAAiB,SAAS,YAAY;AACpC,UAAM,KAAK,KAAK;AAAA,EAClB;AACF;AAQA,eAAsB,OAAgB,GAAkB,OAAqC;AAC3F,QAAM,WAAW,MAAM,EAAE,CAAE,KAAM,CAAC,EAAE,KAAK;AACzC,SAAO,SAAS;AAClB;AAWA,gBAAuB,aAAkB,SAA8E;AACrH,QAAM,eAAe,QAAQ,IAAI,YAAU,kBAAkB,MAAM,CAAC;AACpE,QAAM,SAAS,cAAO,QAAa;AACnC,MAAI,YAAY;AAEhB,QAAM,WAAW,OAAO,WAA4C;AAClE,QAAI,WAAW,QAAW;AACxB;AACA;AAAA,IACF;AAEA,UAAM,IAAI,MAAM,OAAO,KAAK;AAC5B,QAAI,EAAE,MAAM;AACV;AAAA,IACF,OAAO;AACL,aAAO,QAAQ,EAAE,KAAY;AAE7B,iBAAW,MAAM,SAAS,MAAM,GAAG,CAAC;AAAA,IACtC;AAAA,EACF;AAEA,aAAW,UAAU,cAAc;AAEjC,eAAW,MAAM,SAAS,MAAM,GAAG,CAAC;AAAA,EACtC;AAEA,QAAM,YAAY;AAClB,MAAI,aAAa;AACjB,SAAO,YAAY,aAAa,QAAQ;AACtC,UAAM,IAAI,OAAO,QAAQ;AACzB,QAAI,MAAM,QAAW;AAEnB,mBAAa,KAAK,IAAI,aAAa,GAAG,EAAE;AAAA,IAC1C,OAAO;AACL,YAAM;AAEN,mBAAa;AAAA,IACf;AACA,UAAM,MAAM,YAAY,UAAU;AAAA,EACpC;AACF;AAcA,gBAAuB,gBAAgB,SAAqF;AAC1H,QAAM,eAAe,QAAQ,IAAI,YAAU,aAAa,MAAM,CAAC;AAC/D,MAAI,oBAAoB;AACxB,SAAO,mBAAmB;AACxB,QAAI,OAAO,CAAC;AACZ,aAAS,QAAQ,GAAG,QAAQ,aAAa,QAAQ,SAAS;AAExD,WAAM,KAAM,IAAI;AAAA,IAClB;AAEA,wBAAoB;AAEpB,eAAW,CAAE,OAAO,MAAO,KAAK,aAAa,QAAQ,GAAG;AACtD,YAAM,IAAI,MAAM,OAAO,KAAK;AAC5B,UAAI,CAAC,EAAE,MAAM;AACX,aAAM,KAAM,IAAI,EAAE;AAClB,4BAAoB;AAAA,MACtB;AAAA,IACF;AACA,QAAI,mBAAmB;AAErB,YAAM;AACN,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AACF;AAaA,gBAAuB,eAAe,SAAqF;AACzH,QAAM,eAAe,QAAQ,IAAI,YAAU,aAAa,MAAM,CAAC;AAC/D,MAAI,mBAAmB;AACvB,SAAO,CAAC,kBAAkB;AACxB,QAAI,OAAO,CAAC;AACZ,aAAS,QAAQ,GAAG,QAAQ,aAAa,QAAQ,SAAS;AAExD,WAAM,KAAM,IAAI;AAAA,IAClB;AAEA,uBAAmB;AAEnB,eAAW,CAAE,OAAO,MAAO,KAAK,aAAa,QAAQ,GAAG;AACtD,YAAM,IAAI,MAAM,OAAO,KAAK;AAC5B,UAAI,EAAE,MAAM;AACV,2BAAmB;AACnB;AAAA,MACF,OAAO;AACL,aAAM,KAAM,IAAI,EAAE;AAAA,MACpB;AAAA,IACF;AAEA,QAAI;AAAkB;AACtB,UAAM;AACN,WAAO,CAAC;AAAA,EACV;AACF;AAEA,IAAM,cAAc,CAAC,MAA8B;AACjD,MAAI,WAAW,GAAG;AAChB,WAAO,EAAE;AAAA,EACX,OAAO;AACL,WAAO,EAAE;AAAA,EACX;AACF;AAqBA,gBAAuB,QAAiB,WAA0D;AAChG,MAAI;AACJ,aAAW,YAAY,WAAW;AAChC,QAAI,OAAO,aAAa,YAAY;AAClC,cAAQ,SAAS,SAAS,CAAC,CAAC;AAAA,IAC9B,OAAO;AACL,cAAQ,aAAa,QAAQ;AAAA,IAC/B;AAAA,EACF;AACA,MAAI,UAAU;AAAW;AACzB,mBAAiB,KAAK,OAAO;AAC3B,UAAM;AAAA,EACR;AACF;AAkCA,gBAAuB,IAAgC,KAA4C,IAAmB,IAAmB,IAAmB,IAAmB,IAAmB,IAAuC;AACvO,MAAI;AAEJ,QAAM,YAAY;AAClB,aAAW,YAAY,WAAW;AAChC,QAAI,OAAO,aAAa,YAAY;AAElC,cAAQ,SAAS,SAAS,CAAC,CAAC;AAAA,IAC9B,OAAO;AACL,cAAQ,aAAa,QAAQ;AAAA,IAC/B;AAAA,EACF;AACA,MAAI,UAAU;AAAW;AACzB,mBAAiB,KAAK,OAAO;AAC3B,UAAM;AAAA,EACR;AACF;;;AD5jBO,IAAM,kBAAkB,WAC7BC,WACA,QAAQ,GACR,KACA,YAAY,OACZ;AACA,MAAIA,aAAY;AAAG,UAAM,IAAI,MAAM,uCAAuC;AAC1E,MAAI,QAAQ;AAAW,UAAM,OAAO;AACpC,MAAI,IAAI;AACR,KAAG;AACD,WAAO,IAAI,KAAK;AACd,YAAM;AACN,WAAKA;AAAA,IACP;AAAA,EACF,SAAS;AACX;AAkBO,UAAU,uBAAuB,QAAgB,YAAY,KAAK;AACvE,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM;AACN,UAAM,UAAU,WAAW,QAAQ,SAAS;AAC5C,QAAI,YAAY,QAAQ;AAEtB;AAAA,IACF;AACA,aAAS;AAAA,EACX;AACF;AAkBO,UAAU,yBAAyB,QAAgB,YAAY,KAAK;AACzE,MAAI,cAAc;AAClB,QAAM,OAAO;AACb,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM,KAAK,iBAAiB,QAAQ,WAAW,EAAE,SAAS,MAAM,WAAW,WAAW,CAAC;AACvF,QAAI,GAAI,CAAE,MAAM,GAAI,CAAE,KAAK,GAAI,CAAE,MAAM,QAAQ;AAE7C;AAAA,IACF;AACA,UAAM,IAAI,GAAI,CAAE,IAAI;AACpB,UAAM;AACN,kBAAc,YAAY;AAC1B,aAAS,GAAI,CAAE;AAAA,EACjB;AACA,QAAM;AACR;AAkBO,UAAU,yBAAyB,QAAgB,YAAY,KAAK;AACzE,MAAI,cAAc;AAClB,QAAM,OAAO;AACb,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM,KAAK,iBAAiB,QAAQ,WAAW,EAAE,WAAW,WAAW,CAAC;AACxE,QAAI,GAAI,CAAE,MAAM,UAAU,GAAI,CAAE,MAAM;AAAQ;AAC9C,mBAAe,GAAI,CAAE;AACrB,UAAM;AACN,mBAAe;AACf,aAAS,GAAI,CAAE;AAAA,EACjB;AACA,QAAM;AACR;AAcO,UAAU,2BAA2B,QAAgB,YAAY,KAAK;AAC3E,QAAM,OAAO;AACb,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM;AAEN,UAAM,IAAI,YAAY,QAAQ,WAAW,EAAE,WAAW,YAAY,SAAS,KAAK,CAAC;AACjF,QAAI,MAAM;AAAQ;AAClB,aAAS;AAAA,EACX;AACF;AA8BO,IAAM,eAAe,WAC1BA,WACA,QAAQ,GACR,KACA,YAAY,OACZ,UACA;AACA,kBAAgBA,WAAU,SAAS;AAEnC,QAAM,mBAAmBA,YAAW;AACpC,MAAI,QAAQ,QAAW;AAAA,EAEvB,OAAO;AACL,QAAI,oBAAoB,QAAQ,KAAK;AACnC,YAAM,IAAI;AAAA,QACR,eAAgBA,SAAS,uBAAwB,KAAM,OAAQ,GAAI;AAAA,MACrE;AAAA,IACF;AACA,QAAI,CAAC,oBAAoB,QAAQ,KAAK;AACpC,YAAM,IAAI;AAAA,QACR,eAAgBA,SAAS,uBAAwB,KAAM,OAAQ,GAAI;AAAA,MACrE;AAAA,IACF;AAAA,EACF;AAEA,aAAW,YAAY;AACvB,MAAI,QAAQ;AAAW,UAAM,OAAO;AAAA;AAC/B,WAAO;AACZ,EAAAA,YAAWA,YAAW;AAEtB,KAAG;AACD,QAAI,IAAI,QAAQ;AAChB,WAAQ,CAAC,oBAAoB,KAAK,OAAS,oBAAoB,KAAK,KAAM;AACxE,YAAM,IAAI;AACV,WAAKA;AAAA,IACP;AAAA,EACF,SAAS;AACX;AAoCO,IAAM,QAAQ,WAAW,QAAgB,SAAS,GAAG;AAE1D,mBAAiB,QAAQ,IAAI,QAAQ;AACrC,mBAAiB,QAAQ,IAAI,QAAQ;AAErC,MAAI,WAAW;AAAG;AAElB,MAAI,QAAQ;AACZ,KAAG;AACD,UAAO,SAAS,IAAI,CAAC,QAAQ,SAAS,QAAQ;AAAA,EAChD,SAAS,UAAU,KAAK,IAAI,MAAM,IAAI;AACxC;AAsBO,IAAM,iBAAiB,SAC5BA,YAAW,MACX,YAAY,OACZ,QAAQ,GACR,MAAM,GACN;AACA,kBAAgBA,WAAU,cAAc,UAAU;AAClD,kBAAgB,OAAO,cAAc,OAAO;AAC5C,kBAAgB,KAAK,cAAc,KAAK;AACxC,SAAO,aAAaA,WAAU,OAAO,KAAK,SAAS;AACrD;","names":["transform","take","flatten","duration","elapsed","delay","debounce","tally","count","min","max","rank","rankArray","average","total","chunk","filter","drop","key","perValue","query","fromFunction","fromEvent","asPromise","asValue","interval"]}