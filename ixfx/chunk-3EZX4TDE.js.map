{"version":3,"sources":["../src/modulation/easing/index.ts","../src/modulation/easing/EasingsNamed.ts","../src/numbers/Interpolate.ts","../src/modulation/easing/Factories.ts"],"sourcesContent":["import * as Timer from '../../flow/Timer.js';\nimport type { HasCompletion } from '../../flow/Types.js';\nimport * as Named from './EasingsNamed.js';\nimport { throwStringTest } from '../../util/GuardString.js';\nimport { intervalToMs, type Interval } from '../../flow/IntervalType.js';\nimport type { EaseValue } from './Types.js';\n\nexport type * from './Types.js';\nexport * from './Factories.js';\nexport * as Named from './EasingsNamed.js';\n\n/**\n * Easing name\n */\nexport type EasingName = keyof typeof Named;\n\n\n/**\n * A 'no-op' function. Returns the input value without modification.\n * Useful for when some default is needed\n * @param v \n * @returns \n */\nexport const noop: EaseValue = (v: number) => v;\n\nexport type Options = (EasingTickOptions | EasingTimeOptions) & {\n  name?: EasingName\n  fn?: EaseValue\n}\n\nexport type EasingTimeOptions = {\n  duration: Interval\n}\nexport type EasingTickOptions = {\n  ticks: number\n}\n\n/**\n * Creates an easing function\n * ```js\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({ \n *  duration: 1000, \n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options \n * @returns \n */\nexport const create = (options: Options): () => number => {\n  let name = resolveEasingName(options.name ?? `quintIn`);\n  const fn = name ?? options.fn;\n  if (!fn) throw new Error(`Either 'name' or 'fn' must be set`);\n\n  if (`duration` in options) {\n    return time(fn, options.duration);\n  } else if (`ticks` in options) {\n    return ticks(fn, options.ticks);\n  } else {\n    throw new Error(`Expected 'duration' or 'ticks' in options`);\n  }\n}\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * \n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * \n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): Easer => {\n  const fn = resolveEasingName(nameOrFunction);\n  const timer = Timer.elapsedMillisecondsAbsolute();\n  const durationMs = intervalToMs(duration);\n  if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  const relativeTimer = Timer.relative(\n    durationMs,\n    {\n      timer,\n      clampValue: true\n    });\n  return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n * \n * ```js\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  let relative: undefined | (() => number);\n  return () => {\n    if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link ticksEasing}.\n * \n * ```js\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  totalTicks: number\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  let relative: undefined | (() => number);\n  return () => {\n    if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    return fn(relative());\n  }\n}\n/**\n * Creates an easing based on ticks. \n * \n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  durationTicks: number\n): Easer => {\n  const fn = resolveEasingName(nameOrFunction);\n  const timer = Timer.elapsedTicksAbsolute();\n  const relativeTimer = Timer.relative(\n    durationTicks,\n    {\n      timer,\n      clampValue: true\n    });\n  return Timer.timerWithFunction(fn, relativeTimer);\n};\n\nconst resolveEasingName = (nameOrFunction: EasingName | ((v: number) => number)): EaseValue => {\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (fn === undefined) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n    throw error;\n  }\n  return fn;\n}\n/**\n * 'Ease' from `0` to `1` over a delicious curve. Commonly used for animation\n * and basic modelling of physical motion.\n *\n * Create via {@link tick} or {@link time}, call `compute` to calculate the next\n * value in the progression, until you reach `1` or `isDone` returns true.\n *\n */\nexport type Easer = HasCompletion & {\n  /**\n   * Computes the current value of the easing\n   *\n   * @returns {number}\n   */\n  compute(): number;\n\n  /**\n   * Reset the easing\n   */\n  reset(): void;\n  /**\n   * Returns true if the easing is complete\n   *\n   * @returns {boolean}\n   */\n  get isDone(): boolean;\n};\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, msElapsedTimer);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\n\n\nlet easingsMap: Map<string, ((v: number) => number)> | undefined;\n\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): EaseValue {\n  throwStringTest(easingName, `non-empty`, `easingName`);\n\n  const found = cacheEasings().get(easingName.toLowerCase());\n  if (found === undefined) throw new Error(`Easing not found: '${ easingName }'`);\n  return found;\n};\n\n// Cache named easings\nfunction cacheEasings() {\n  if (easingsMap === undefined) {\n    easingsMap = new Map();\n    for (const [ k, v ] of Object.entries(Named)) {\n      easingsMap.set(k.toLowerCase(), v);\n    }\n    return easingsMap\n  } else return easingsMap;\n}\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames(): Iterable<string> {\n  const map = cacheEasings();\n  yield* Object.keys(map.values);\n};\n","import { gaussian } from \"./Factories.js\";\n// Easings from https://easings.net/\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\nexport const bounceOut = (x: number) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nexport const quintIn = (x: number) => x * x * x * x * x;\nexport const quintOut = (x: number) => 1 - pow(1 - x, 5);\nexport const arch = (x: number) => x * (1 - x) * 4;\n\nexport const smoothstep = (x: number) => x * x * (3 - 2 * x);\nexport const smootherstep = (x: number) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x: number) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x: number) => sin((x * pi) / 2);\nexport const quadIn = (x: number) => x * x;\nexport const quadOut = (x: number) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x: number) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x: number) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x: number) => x * x * x;\nexport const cubicOut = (x: number) => 1 - pow(1 - x, 3);\nexport const quartIn = (x: number) => x * x * x * x;\nexport const quartOut = (x: number) => 1 - pow(1 - x, 4);\nexport const expoIn = (x: number) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x: number) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x: number) =>\n  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x: number) =>\n  x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? pow(2, 20 * x - 10) / 2\n        : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x: number) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x: number) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x: number) =>\n  x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n\nexport const backInOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c2 = c1 * 1.525;\n\n  return x < 0.5\n    ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n    : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\n\nexport const bounceIn = (x: number) => 1 - bounceOut(1 - x);\n\nexport const bell = gaussian();\n\nexport const elasticInOut = (x: number) => {\n  const c5 = (2 * pi) / 4.5;\n\n  return x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x: number) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import type { Interval } from '../flow/IntervalType.js';\nimport { wrap } from './Wrap.js';\nimport { ofTotal } from '../flow/Timer.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { clamp } from '../numbers/Clamp.js';\nimport { get as getEasing, type EasingName } from '../modulation/easing/index.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * \n * Limit\n * What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. \n */\nexport type InterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  easing: EasingName,\n  transform: (v: number) => number\n}\n\n\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide](https://clinth.github.io/ixfx-docs/modulation/interpolate/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * Interpolation is often used for animation. In that case, `amount`\n * would start at 0 and you would keep interpolating up to `1`\n * @example\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { percentPingPong } from 'https://unpkg.com/ixfx/dist/modulation.js'\n *\n * // Go back and forth between 0 and 1 by 0.1\n * let pp = percentPingPong(0.1);\n * continuously(() => {\n *  // Get position in ping-pong\n *  const amt = pp.next().value;\n *  // interpolate between Math.PI and Math.PI*2\n *  const v = interpolate(amt, Math.PI, Math.PI*2);\n *  // do something with v...\n * }).start();\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * If two parameters are given, it instead returns a function which interpolates:\n * ```js\n * const i = interpolate(100, 200);\n * i(0.5); // 150\n * \n * // Compared to:\n * interpolate(0.5, 100, 200); // 150\n * ```\n * \n * This is useful if you want to reuse the interpolator with fixed `a` and `b` values.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  //let opts: Partial<InterpolateOptions> = {};\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    throwNumberTest(_a, ``, `a`);\n    throwNumberTest(_b, ``, `b`);\n    throwNumberTest(_amt, ``, `amount`);\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easingFn = getEasing(o.easing);\n      if (!easingFn) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easingFn;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    let amount = handleAmount(pos1);\n    readOpts(pos2);\n    throwNumberTest(amount, ``, `amount`);\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options: Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n","import type { EaseValue } from \"./Types.js\";\nimport { interpolate } from '../../numbers/Interpolate.js';\nimport type { SpringOptions } from \"../Types.js\";\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\n/**\n * Returns a mix of two easing functions.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Get a 50/50 mix of two easing functions\n * const mix = Easings.mix(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param balance Mix between a and b\n * @param easingA\n * @param easingB\n * @returns Numeric value\n */\nexport const mix = (\n  balance: number,\n  easingA: EaseValue,\n  easingB: EaseValue\n): EaseValue => (amt: number) => interpolate(balance, easingA(amt), easingB(amt));\n\n\n/**\n * Returns a 'crossfade' of two easing functions, synchronised with the progress through the easing. That is:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of a, 20% of b, with both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of a, 80% of a, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower valus.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * Easings.crossFade(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param amt\n * @param easingA\n * @param easingB\n * @returns Numeric value\n */\nexport const crossfade = (easingA: EaseValue, easingB: EaseValue): EaseValue => {\n  return (amt: number) => {\n    const mixer = mix(amt, easingA, easingB);\n    return mixer(amt);\n  }\n}\n\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n  const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = a / standardDeviation;\n    // p:-8 pinched\n    let p = -2.5; // -1/1.25;\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n    return v;\n  };\n};\n\n\n/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @returns Value\n */\nexport const fromCubicBezier =\n  (b: number, d: number) =>\n    (t: number) => {\n      const s = 1 - t;\n      const s2 = s * s;\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n    };\n\n\nexport const spring = (opts: SpringOptions = {}): EaseValue => {\n  /** MIT License github.com/pushkine/ */\n  const from = 0;\n  const to = 1;\n  const mass = opts.mass ?? 1;\n  const stiffness = opts.stiffness ?? 100;\n  const soft = opts.soft ?? false;\n  const damping = opts.damping ?? 10;\n  const velocity = opts.velocity ?? 0.1;\n  const delta = to - from;\n  if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n    const angularFrequency = -Math.sqrt(stiffness / mass);\n    const leftover = -angularFrequency * delta - velocity;\n    return (t: number) =>\n      to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n  } else {\n    const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n    const leftover =\n      (damping * delta - 2 * mass * velocity) / dampingFrequency;\n    const dfm = (0.5 * dampingFrequency) / mass;\n    const dm = -(0.5 * damping) / mass;\n    return (t: number) =>\n      to -\n      (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n      Math.E ** (t * dm);\n  }\n};\n"],"mappings":"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","names":["sqrt","pow","pi","relative"]}