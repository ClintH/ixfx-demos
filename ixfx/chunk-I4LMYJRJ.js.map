{"version":3,"sources":["../src/numbers/index.ts","../src/numbers/ApplyToValues.ts","../src/numbers/AverageWeighted.ts","../src/numbers/Guard.ts","../src/numbers/Filter.ts","../src/numbers/Generate.ts","../src/numbers/IsApprox.ts","../src/numbers/MovingAverage.ts","../src/numbers/Normalise.ts","../src/numbers/Proportion.ts","../src/numbers/RelativeDifference.ts","../src/numbers/Softmax.ts"],"sourcesContent":["/**\n * * {@link average}, {@link max}, {@link min}, {@link total}: Calculate average/max/min/total\n * * {@link averageWeighted}: Calculate average, but applies a weighting function, eg to favour items at beginning of array\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * {@link maxIndex}, {@link minIndex}: Return index of largest/smallest value\n * * {@link dotProduct}: Returns the dot-product between two arrays\n * * {@link weight}: Applies a weighting function to all values based on their index\n * * See also {@link Numbers} module for working with numbers in general.\n * @module\n */\n\n\nexport * from './ApplyToValues.js';\nexport * from './AverageWeighted.js'\n/**\n * Work with bipolar values (-1...1)\n * \n * Import:\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Overview:\n * * {@link clamp}: Clamp on -1..1 scale\n * * {@link fromScalar}: Convert from 0..1 to -1..1\n * * {@link immutable}: Immutable wrapper around a value\n * * {@link random}: Create a random bipolar value\n * * {@link scale}: Scale a value to -1..1 (clamped)\n * * {@link scaleUnclamped} As {@link scale} but allowed to go outside of -1...1 range\n * * {@link toScalar}: Convert -1..1 to 0..1\n * * {@link towardZero}: Nudge a bipolar value towards zero\n */\nexport * as Bipolar from './Bipolar.js';\n\nexport * from './Clamp.js';\nexport * from './Count.js';\nexport * from './Filter.js';\nexport * from './Flip.js';\nexport * from './Generate.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './IsApprox.js';\nexport * from './LinearSpace.js';\nexport * from './MinMaxAvg.js';\nexport * from './MovingAverage.js';\n\n/**\n * Normalise module\n * * {@link array}: Normalises the contents of an array of known values.\n * * {@link stream}: Normalises a stream of unknown values.\n */\nexport * as Normalise from './Normalise.js';\nexport * from './NumericArrays.js';\nexport * from './Proportion.js';\nexport * from './Quantise.js';\nexport * from './RelativeDifference.js';\nexport * from './Round.js';\nexport * from './Scale.js';\nexport * from './Softmax.js';\nexport type * from './Types.js';\nexport * from './Wrap.js';\n","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n * \n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object \n * @param apply \n * @returns \n */\nexport const applyToValues = <T extends Record<string, any>>(object: T, apply: (v: number) => number): T => {\n  const o: T = { ...object };\n  for (const [ key, value ] of Object.entries(object)) {\n    if (typeof value === `number`) {\n      // Run number through function\n      //eslint-disable-next-line functional/immutable-data\n      (o as any)[ key ] = apply(value);\n    } else {\n      // Copy value\n      //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n      (o as any)[ key ] = value;\n    }\n  }\n  return o;\n}","import { zip } from '../data/arrays/Zip.js';\nimport { weight } from './NumericArrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * // All items weighted evenly\n * Arrays.averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * Arrays.averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * Arrays.averageWeighted[1,2,3], Easings.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * import { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * const data = [1,2,3];\n * const w = Arrays.weight(data, Easings.gaussian());\n * const avg = Arrays.averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n */\nexport const averageWeighted = (\n  data: Array<number> | ReadonlyArray<number>,\n  weightings: Array<number> | ReadonlyArray<number> | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n\n  const ww = zip(data, weightings);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const [ totalV, totalW ] = ww.reduce(\n    (accumulator: Array<number>, v: Array<number>) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber: unknown) => {\n  if (typeof possibleNumber !== `number`) return false;\n  if (Number.isNaN(possibleNumber)) return false;\n  return true;\n};","import { isValid } from './Guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filter(data)) {\n *  // 5\n * }\n * ```\n * @param it\n */\n//eslint-disable-next-line func-style\nexport function* filter(it: Iterable<unknown>) {\n  for (const v of it) {\n    if (isValid(v)) yield v;\n  }\n}\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\n\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n\n\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};","import { numberTest, throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { round } from \"./Round.js\";\n\n/**\n * Returns a function that checks if a value is within range of a base value\n * ```js\n * const tenPercent = isApprox(0.1);\n * // Check if 101 is within 10% range of 100\n * tenPercent(100, 101); \n * ```\n * @param rangePercent \n */\nexport function isApprox(\n  rangePercent: number\n): (baseValue: number, value: number) => boolean;\n\n/**\n * Returns a function to check if a value is within range of a base value\n * ```js\n * const close = isApprox(0.1, 100);\n * // Check if 101 is within 10% range of 100\n * close(101);\n * ```\n * @param rangePercent \n * @param baseValue \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n): (value: number) => boolean;\n\n/**\n * Returns _true/false_ if `value` is within `rangePercent` of `baseValue`.\n * \n * ```js\n * isApprox(0.1, 100, 101);\n * ```\n * @param rangePercent \n * @param baseValue \n * @param value \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n  value: number\n): boolean;\n\n\n/**\n * Checks if a value is within range of a base value\n * \n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n * \n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n * \n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n * \n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent \n * @param baseValue \n * @param v \n * @returns \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue?: number,\n  v?: number\n) {\n  throwNumberTest(rangePercent, `percentage`, `rangePercent`);\n\n  // Round percentages to avoid floating point nonsense\n  const range = Math.floor(rangePercent * 100);\n  const test = (base: number, value: number): boolean => {\n    try {\n      if (typeof value !== `number`) return false;\n      if (Number.isNaN(value)) return false;\n      if (!Number.isFinite(value)) return false;\n\n      // Round value\n      const diff = Math.abs(value - base)\n      const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n      //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n      return relative <= range;\n    } catch {\n      return false;\n    }\n  };\n\n  if (baseValue === undefined) return test;\n  throwNumberTest(baseValue, ``, `baseValue`);\n  if (v === undefined) {\n    return (value: number) => test(baseValue, value);\n  } else {\n    return test(baseValue, v);\n  }\n}\n","import type { Interval } from '../flow/IntervalType.js';\nimport { averageWeighted } from '../numbers/AverageWeighted.js';\nimport { average } from '../numbers/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { throwNumberTest, numberTest } from \"../util/GuardNumbers.js\";\nimport { rateMinimum } from '../flow/RateMinimum.js';\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * `add()` adds a new value and returns the calculated average.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma.add(50);  // 50\n * ma.add(100); // 75\n * ma.add(75);  // 75\n * ma.add(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * Use `clear()` to reset the moving average, or `compute()` to get the current value without adding.\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r[ 0 ] && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n\n  // let disposed = false;\n  // const ma: MovingAverage = {\n  //   dispose() {\n  //     disposed = true;\n  //   },\n  //   get isDisposed() {\n  //     return disposed;\n  //   },\n  //   add(v: number) {\n  //     if (disposed) throw new Error(`MovingAverage disposed, cannot add`);\n  //     count++;\n  //     average = average + (v - average) / Math.min(count, scaling);\n  //     return average;\n  //   },\n  //   clear() {\n  //     if (disposed) throw new Error(`MovingAverage disposed, cannot clear`);\n  //     average = 0;\n  //     count = 0;\n  //   },\n  //   compute() {\n  //     return average;\n  //   },\n  // };\n  // return ma;\n};\n\nexport type MovingAverageTimedOptions = Readonly<{\n  interval: Interval\n  default?: number\n  abort?: AbortSignal\n}>\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n * \n * mat(); // Get current average\n * ```\n * \n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * \n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options: MovingAverageTimedOptions) => {\n  const average = movingAverageLight();\n  const rm = rateMinimum({\n    ...options,\n    whatToCall: (distance: number) => {\n      average(distance);\n    },\n    fallback() {\n      return options.default ?? 0;\n    }\n  })\n\n  return (v: number) => {\n    rm(v);\n    return average();\n  }\n};\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n/**\n * Creates a moving average for a set number of `samples`.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n * `add` adds a number and returns the computed average. Call `compute` to\n * get the average without adding a new value.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma.add(10); // 10\n * ma.add(5);  // 7.5\n * ```\n *\n * `clear` clears the average.\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, Easings.gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  //let disposed = false;\n\n  const q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  return (v?: number | undefined) => {\n    const r = numberTest(v);\n    if (r[ 0 ] && v !== undefined) {\n      q.enqueue(v);\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n\n  // const clear = () => {\n  //   q = new QueueMutable<number>({\n  //     capacity: samples,\n  //     discardPolicy: `older`,\n  //   });\n  // };\n\n  // const compute = () => {\n  //   return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  // };\n\n  // const add = (v: number) => {\n  //   q.enqueue(v);\n  //   return compute();\n  // };\n\n  // const dispose = () => {\n  //   disposed = true;\n  // };\n\n  // return { add, compute, clear, dispose, isDisposed: disposed };\n};\n\n/**\n * Moving average.\n * Create via {@link movingAverage} or {@link movingAverageLight}.\n */\n// export type MovingAverage = {\n//   /**\n//    * Clear data\n//    */\n//   clear(): void;\n//   /**\n//    * Returns current average\n//    */\n//   compute(): number;\n//   /**\n//    * Adds a value, returning new average\n//    * @param v Value to add\n//    */\n//   add(v: number): number;\n\n//   dispose(): void;\n//   get isDisposed(): boolean;\n// };\n\nconst PiPi = Math.PI * 2;\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","\nimport { scale } from './Scale.js';\nimport { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { clamp } from './Clamp.js';\nimport { minMaxAvg } from './MinMaxAvg.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passingin `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * Note that if a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  //eslint-disable-next-line functional/no-let\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  throwNumberTest(minDefault);\n  throwNumberTest(maxDefault);\n\n  return (v: number): number => {\n    throwNumberTest(v);\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values: ReadonlyArray<number>,\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(`Param 'values' should be an array. Got: ${ typeof values }`);\n  }\n  const mma = minMaxAvg(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { type NumberFunction } from '../data/Types.js';\n\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * The utility of this function is that it sanity-checks that\n *  both parameters are in the 0..1 scale.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (\n  v: number | NumberFunction,\n  t: number | NumberFunction\n) => {\n  if (typeof v === `function`) v = v();\n  if (typeof t === `function`) t = t();\n\n  throwNumberTest(v, `percentage`, `v`);\n  throwNumberTest(t, `percentage`, `t`);\n  return v * t;\n};\n","/**\n * Returns the relative difference from the `initial` value\n * ```js\n * const rel = relativeDifference(100);\n * rel(100); // 1\n * rel(150); // 1.5\n * rel(50);  // 0.5\n * ```\n *\n * The code for this is simple:\n * ```js\n * const relativeDifference = (initial) => (v) => v/initial\n * ```\n * @param {number} initial\n * @returns\n */\nexport const relativeDifference = (initial: number) => (v: number) =>\n  v / initial;","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits \n * @returns \n */\nexport const softmax = (logits: Array<number>) => {\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n  const scores = logits.map((l) => Math.exp(l - maxLogit));\n  const denom = scores.reduce((a, b) => a + b);\n  return scores.map((s) => s / denom);\n}"],"mappings":"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","names":["average","count","smoothingFactor","min","max"]}