{"version":3,"sources":["../src/data/index.ts","../src/data/Normalise.ts","../src/data/FrequencyMutable.ts","../src/data/MovingAverage.ts","../src/data/IntervalTracker.ts","../src/data/Reactive.ts","../src/data/graphs/DirectedGraph.ts","../src/data/Table.ts","../src/data/Chain.ts","../src/Iterable.ts","../src/data/graphs/index.ts","../src/data/graphs/UndirectedGraph.ts","../src/data/TrackUnique.ts","../src/data/Correlate.ts","../src/data/Pool.ts"],"sourcesContent":["\n\n/**\n * Normalise module\n * * {@link array}: Normalises the contents of an array of known values.\n * * {@link stream}: Normalises a stream of unknown values.\n */\nexport * as Normalise from './Normalise.js';\n\nexport * from './FrequencyMutable.js';\nexport * from './MovingAverage.js';\nexport * from './NumberTracker.js';\nexport * from './IntervalTracker.js';\nexport * from './PointTracker.js';\nexport * from './TrackedValue.js';\nexport * from './TrackerBase.js';\nexport * from './PrimitiveTracker.js';\n\nexport * from './Clamp.js';\nexport * from './Scale.js';\nexport * from './Flip.js';\n\nexport * as Reactive from './Reactive.js';\nexport * as Chains from './Chain.js';\nexport * as Graphs from './graphs/index.js'\nexport * from './TrackUnique.js';\nexport * from './Table.js';\n\n/**\n * Work with bipolar values (-1...1)\n * \n * Import:\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Overview:\n * * {@link immutable}: Immutable wrapper around a value\n * * {@link clamp}: Clamp on -1..1 scale\n * * {@link scale}: Scale a value to -1..1\n * * {@link toScalar}: Convert -1..1 to 0..1\n * * {@link fromScalar}: Convert from 0..1 to -1..1\n * * {@link towardZero}: Nudge a bipolar value towards zero\n */\nexport * as Bipolar from './Bipolar.js';\nexport * from './Interpolate.js';\nexport * from './Wrap.js';\nexport * as Correlate from './Correlate.js';\nexport * as Pool from './Pool.js';\nexport * from './Types.js';\nexport const piPi = Math.PI * 2;\n\n","import { minMaxAvg } from '../collections/arrays/NumericArrays.js';\nimport { clamp } from './Clamp.js';\nimport { scale } from './Scale.js';\nimport { throwNumberTest } from '../Guards.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passingin `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * Note that if a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  //eslint-disable-next-line functional/no-let\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  throwNumberTest(minDefault);\n  throwNumberTest(maxDefault);\n\n  return (v: number): number => {\n    throwNumberTest(v);\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (\n  values: readonly number[],\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new Error(`values param should be an array`);\n  }\n  const mma = minMaxAvg(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","/// âœ” Unit tested!\n\nimport { type ToString } from '../Util.js';\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as KeyValueUtil from '../KeyValue.js';\nimport { KeyValues } from '../index.js';\n\nexport type FrequencyEventMap = {\n  readonly change: void;\n};\n\nexport class FrequencyMutable<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString: ToString<V> | undefined = undefined) {\n    super();\n    this.#store = new Map();\n\n    if (keyString === undefined) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        if (typeof a === `string`) {\n          return a;\n        } else {\n          return JSON.stringify(a);\n        }\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, undefined);\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): [key: string, count: number][] {\n    return Array.from(this.#store.entries());\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    //eslint-disable-next-line functional/no-let\n    let t = ``;\n    for (const [key, count] of this.#store.entries()) {\n      t += `${key}: ${count}, `;\n    }\n    if (t.endsWith(`, `)) return t.substring(0, t.length - 2);\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    //eslint-disable-next-line functional/no-let\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.minMaxAvg();\n    return freq / mma.total;\n  }\n\n  /**\n   * @returns Copy of entries as an array\n   */\n  entries(): Array<KeyValueUtil.KeyValue> {\n    return Array.from(this.#store.entries());\n  }\n\n  /**\n   *\n   * @returns Returns `{min,max,avg,total}`\n   */\n  minMaxAvg() {\n    return KeyValues.minMaxAvg(this.entries());\n  }\n\n  /**\n   *\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: `value` | `valueReverse` | `key` | `keyReverse` = `value`\n  ): ReadonlyArray<KeyValues.KeyValue> {\n    const s = KeyValueUtil.getSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   *\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  add(...values: V[]) {\n    if (values === undefined) throw new Error(`value parameter is undefined`);\n\n    const keys = values.map(this.#keyString);\n\n    //const key = this.#keyString(value);\n    keys.forEach((key) => {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    });\n    this.fireEvent(`change`, undefined);\n  }\n}\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link frequencyMutable}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = frequencyMutable();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = frequencyMutable();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequencyMutable( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @template V Type of items\n */\nexport const frequencyMutable = <V>(keyString?: ToString<V> | undefined) =>\n  new FrequencyMutable<V>(keyString);\n","import { averageWeighted } from '../collections/arrays/AverageWeighted.js';\nimport { average } from '../collections/arrays/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { throwNumberTest } from '../Guards.js';\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * `add()` adds a new value and returns the calculated average.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma.add(50);  // 50\n * ma.add(100); // 75\n * ma.add(75);  // 75\n * ma.add(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * Use `clear()` to reset the moving average, or `compute()` to get the current value without adding.\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns {@link MovingAverage}\n */\nexport const movingAverageLight = (scaling = 3): MovingAverage => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  //eslint-disable-next-line functional/no-let\n  let average = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n\n  //eslint-disable-next-line functional/no-let\n  let disposed = false;\n  const ma: MovingAverage = {\n    dispose() {\n      disposed = true;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    add(v: number) {\n      if (disposed) throw new Error(`MovingAverage disposed, cannot add`);\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n      return average;\n    },\n    clear() {\n      if (disposed) throw new Error(`MovingAverage disposed, cannot clear`);\n      average = 0;\n      count = 0;\n    },\n    compute() {\n      return average;\n    },\n  };\n  return ma;\n};\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * @param updateRateMs\n * @param value\n * @param scaling\n * @returns\n */\nexport const movingAverageTimed = (\n  updateRateMs = 200,\n  value = 0,\n  scaling = 3\n): MovingAverage => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n  const mal = movingAverageLight(scaling);\n\n  //eslint-disable-next-line functional/no-let\n  let timer = 0;\n\n  const reschedule = () => {\n    if (timer !== 0) clearTimeout(timer);\n    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n    // @ts-ignore\n    timer = setTimeout(decay, updateRateMs) as number;\n  };\n\n  const decay = () => {\n    mal.add(value);\n    if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n  };\n\n  const ma: MovingAverage = {\n    add(v: number) {\n      reschedule();\n      return mal.add(v);\n    },\n\n    dispose() {\n      mal.dispose();\n    },\n    clear: function (): void {\n      mal.clear();\n    },\n    compute: function (): number {\n      return mal.compute();\n    },\n    isDisposed: false,\n  };\n\n  return ma;\n};\n\n/**\n * Creates a moving average for a set number of `samples`.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n * `add` adds a number and returns the computed average. Call `compute` to\n * get the average without adding a new value.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma.add(10); // 10\n * ma.add(5);  // 7.5\n * ```\n *\n * `clear` clears the average.\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, Easings.gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): MovingAverage => {\n  //eslint-disable-next-line functional/no-let\n  let disposed = false;\n\n  //eslint-disable-next-line functional/no-let\n  let q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  const clear = () => {\n    q = new QueueMutable<number>({\n      capacity: samples,\n      discardPolicy: `older`,\n    });\n  };\n\n  const compute = () => {\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  };\n\n  const add = (v: number) => {\n    q.enqueue(v);\n    return compute();\n  };\n\n  const dispose = () => {\n    disposed = true;\n  };\n\n  return { add, compute, clear, dispose, isDisposed: disposed };\n};\n\n/**\n * Moving average.\n * Create via {@link movingAverage} or {@link movingAverageLight}.\n */\nexport type MovingAverage = {\n  /**\n   * Clear data\n   */\n  clear(): void;\n  /**\n   * Returns current average\n   */\n  compute(): number;\n  /**\n   * Adds a value, returning new average\n   * @param v Value to add\n   */\n  add(v: number): number;\n\n  dispose(): void;\n  get isDisposed(): boolean;\n};\n\nconst PiPi = Math.PI * 2;\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin \n * @param speedCoefficient \n * @param cutoffDefault \n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { NumberTracker } from './NumberTracker.js';\nimport { type TrackedValueOpts as TrackOpts } from './TrackedValue.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n *\n * @export\n * @class IntervalTracker\n * @extends {ValueTracker}\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(window.performance.now() - this.lastMark);\n    }\n    this.lastMark = window.performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { intervalTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const t = intervalTracker();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = intervalTracker({ resetAfterSamples: 100} );\n * ```\n * @param opts Options for tracker\n * @returns New interval tracker\n */\nexport const intervalTracker = (opts?: TrackOpts) => new IntervalTracker(opts);\n","import { intervalToMs, type Interval } from \"../flow/IntervalType.js\";\nimport { DispatchList, type Dispatch } from \"../flow/DispatchList.js\"\nimport * as Immutable from '../Immutable.js';\nimport { QueueMutable } from \"../collections/index.js\";\nimport * as DiGraph from \"./graphs/DirectedGraph.js\";\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport type SignalKinds = `done`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: `done`\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport function isSignal<V>(v: Passed<V> | PassedSignal): v is PassedSignal {\n  if (v.value !== undefined) return false;\n  if (`signal` in v && v.signal !== undefined) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function hasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive.\n   * Return result unsubscribes.\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): () => void\n}\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\nexport type ReactiveWritable<V> = {\n  set(value: V): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveDisposable = {\n  dispose(reason: string): void\n  isDisposed(): boolean\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n\n}\n\n// export type ReactiveCloseable = ReactiveFinite & {\n//   close(reason: string): void\n// }\n\nexport type ReactiveDiff<V> = ReactiveDisposable & ReactiveWritable<V> & {\n  onDiff(handler: (changes: Passed<Array<Immutable.Change<any>>>) => void): void\n  update(changedPart: Record<string, any>): void\n  updateField(field: string, value: any): void\n}\n\n// export function readable<V>(): ReactiveDisposable & Reactive<V> {\n//   const events = initEvent<V>();\n//   let disposed = false;\n//   return {\n//     dispose(reason) {\n//       if (disposed) return;\n//       disposed = true;\n//       events.signal(`done`, `Closed: ${ reason }`);\n//     },\n//     isDisposed() {\n//       return disposed;\n//     },\n//     on: events.on\n//   }\n// }\n\nexport function number(initialValue: number): ReactiveDisposable & ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveDisposable & ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveDisposable & ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initEvent<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.notify(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    set\n  }\n}\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source.\n * \n * @param values \n * @returns \n */\nexport function mergeAsArray<V>(...values: Array<Reactive<V>>): Reactive<Array<V | undefined>> {\n  const event = initEvent<Array<V | undefined>>();\n  const data: Array<V | undefined> = [];\n\n  for (const [ index, v ] of values.entries()) {\n    data[ index ] = undefined;\n    v.on(valueChanged => {\n      if (!isSignal(valueChanged)) {\n        data[ index ] = valueChanged.value;\n      }\n      event.notify(data);\n    });\n  }\n\n  return {\n    on: event.on\n  }\n}\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send a value.\n * \n * Each source's latest value is returned, in the case of some sources producing results\n * faster than others.\n * \n * If a value completes, we won't wait for it and the result set gets smaller.\n * @param sources \n * @returns \n */\nexport function synchronise<V>(...sources: Array<Reactive<V>>): Reactive<Array<V | undefined>> {\n  const event = initEvent<Array<V>>();\n  let data: Array<V | undefined> = [];\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    v.on(valueChanged => {\n      if (isSignal(valueChanged)) {\n        if (valueChanged.signal === `done`) {\n          sources.splice(index, 1);\n        }\n        return;\n      }\n      data[ index ] = valueChanged.value;\n\n      if (!data.includes(undefined)) {\n        // All array elements contain values\n        event.notify(data as Array<V>);\n        data = [];\n      }\n    });\n  }\n\n  return {\n    on: event.on\n  }\n}\n\n\n\nexport type ResolveAfterOptions = {\n  loops?: number\n  infinite?: boolean\n}\n\nexport function resolveAfter<V extends Record<string, any>>(interval: Interval, callbackOrValue: V | (() => V), options: ResolveAfterOptions = {}): Reactive<V> {\n  const intervalMs = intervalToMs(interval, 0);\n  const event = initEvent<V>();\n  const loops = options.infinite ? Number.MAX_SAFE_INTEGER : options.loops ?? 1;\n  let remaining = loops;\n\n  const run = () => {\n    if (typeof callbackOrValue === `function`) {\n      const value = callbackOrValue();\n      event.notify(value);\n    } else {\n      event.notify(callbackOrValue);\n    }\n    remaining--;\n    if (remaining > 0) {\n      setTimeout(run, intervalMs);\n    }\n  }\n  setTimeout(run, intervalMs);\n\n  const r: Reactive<V> = {\n    on: event.on\n  }\n  return r;\n}\n\nexport type EventOptions<V> = {\n  process: (args?: Event | undefined) => V\n  lazy?: boolean\n}\n\nexport function event<V extends Record<string, any>, EventName extends string>(target: EventTarget, name: EventName, options: EventOptions<V>): ReactiveInitial<V> & ReactiveDisposable;\n\nexport function event<V extends Record<string, any>, EventName extends string>(target: EventTarget, name: EventName, options?: Optional<EventOptions<V>, `process`>): ReactiveNonInitial<V> & ReactiveDisposable;\n\n/**\n * Subscribes to an event, emitting data\n * @param target Event emitter\n * @param name Event name\n * @param options Options\n * @returns \n */\nexport function event<V extends Record<string, any>, EventName extends string>(target: EventTarget, name: EventName, options: Partial<EventOptions<V>> = {}): (ReactiveInitial<V> | ReactiveNonInitial<V>) & ReactiveDisposable {\n  const process = options.process;\n  const initialValue = process ? process() : undefined;\n\n  const rxObject = initialValue ? object<V>(initialValue, { deepEntries: true }) : object<V>(undefined, { deepEntries: true });\n  const lazy = options.lazy ?? false;\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    rxObject.set(process ? process(args) : args);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<V>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    }\n  }\n  // const result = {\n  //   dispose: () => {\n  //     target.removeEventListener(name, callback)\n  //   },\n  //   [ `${ name }` ]: rxObject\n  // }\n\n  // return result as {\n  //   [ key in EventName ]: typeof rxObject\n  // } & {\n  //   dispose: () => void\n  // };\n}\n\nexport function manual<V>(): Reactive<V> & ReactiveWritable<V> {\n  const events = initEvent<V>();\n  return {\n    set(value: V) {\n      events.notify(value);\n    },\n    on: events.on\n  };\n}\n\nexport type ObjectOptions<V> = {\n  deepEntries: boolean\n  eq: Immutable.IsEqualContext<V>\n}\n\n//export function object<V extends Record<string, any>>(options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\n\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Emits when fields of the object change.\n * * `set()` updates the whole object\n * * `update()` changes a particular field\n * \n * `on` gets the whole object when it changes.\n * ```js\n * const o = object({ name: `bob`, level: 2 });\n * o.on(value => {\n *  const changed = value.value;\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `on` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the last set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * @param initialValue \n * @param eq \n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDisposable & ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? Immutable.isEqualContextString;\n  const setEvent = initEvent<V>();\n  const diffEvent = initEvent<Array<Immutable.Change<any>>>();\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    if (value !== undefined) {\n      const diff = Immutable.compareData(value, v, ``, options);\n      if (diff.length === 0) return;\n      diffEvent.notify(diff);\n    }\n\n    value = v;\n    setEvent.notify(v);\n  }\n\n\n  const update = (toMerge: Partial<V>) => {\n    const pd = Immutable.getPathsAndData(toMerge);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (value === undefined) {\n      value = toMerge as V;\n    } else {\n      const diff = Immutable.compareData(toMerge, value);\n      if (diff.length === 0) return; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      diffEvent.notify(pd);\n    }\n    setEvent.notify(value);\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    const existing = Immutable.getField<any>(value, path);\n    if (eq(existing, valueForField, path)) return;\n    const o = Immutable.updateByPath(value, path, valueForField);\n    value = o;\n    diffEvent.notify([ { path, value: valueForField, previous: existing } ]);\n    setEvent.notify(o);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onDiff: diffEvent.on,\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n\nexport type InitEventOptions = {\n  onFirstSubscribe: () => void\n  onNoSubscribers: () => void\n}\n\nfunction initEvent<V>(options: Partial<InitEventOptions> = {}) {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      //console.log(`initEvent dispose ${ reason }`);\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    clear: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    notify: (v: V) => {\n      if (disposed) throw new Error(`Disposed`);\n      dispatcher?.notify({ value: v });\n    },\n    through: (pass: Passed<V>) => {\n      if (disposed) throw new Error(`Disposed`);\n      dispatcher?.notify(pass)\n    },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`Disposed`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => {\n      if (disposed) throw new Error(`Disposed`);\n      if (dispatcher === undefined) dispatcher = new DispatchList();\n      const id = dispatcher.add(handler);\n      if (!firstSubscribe) {\n        firstSubscribe = true;\n        if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n      }\n      return () => {\n        dispatcher?.remove(id);\n        isEmpty();\n      }\n    }\n  }\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: boolean\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n}\n\nconst initUpstream = <In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>) => {\n  const lazy = options.lazy ?? true;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n\n  const start = () => {\n    if (unsub !== undefined) return;\n\n    if (options.onStart) options.onStart();\n    unsub = source.on(value => {\n      if (isSignal(value)) {\n        if (value.signal === `done`) {\n          stop();\n          if (disposeIfSourceDone) events.dispose(`Source is completed`);\n        } else {\n          events.through(value);\n        }\n      } else if (hasValue(value)) {\n        onValue(value.value);\n      }\n    });\n  }\n\n  const stop = () => {\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const initOpts: InitEventOptions = {\n    onFirstSubscribe() {\n      if (lazy) start();\n    },\n    onNoSubscribers() {\n      if (lazy) stop();\n    },\n  }\n  if (!lazy) start();\n  const events = initEvent<Out>(initOpts);\n  return events;\n}\n\nexport type FieldOptions<V> = InitEventOptions & {\n  /**\n   * If `field` is missing on a value, this value is used in its place.\n   * If not set, the value is skipped.\n   */\n  missingFieldDefault: V\n};\n/**\n * From a source value, yields a field from it.\n * \n * If a source value doesn't have that field, it is skipped.\n * \n * @param source \n * @param field \n * @returns \n */\nexport function field<In, Out>(fieldSource: ReactiveOrSource<In>, field: keyof In, options: Partial<FieldOptions<Out>> = {}): Reactive<Out> {\n  const upstream = initUpstream<In, Out>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      let t = (value as any)[ field ];\n      if (t === undefined && options.missingFieldDefault !== undefined) {\n        t = options.missingFieldDefault as Out;\n      }\n      upstream.notify(t as Out);\n    },\n  })\n\n  return {\n    on: upstream.on\n  }\n  // const source = resolveSource(fieldSource);\n  // const events = initEvent<Out>();\n  // source.on(value => {\n  //   if (isSignal(value)) {\n  //     if (value.signal === `done`) {\n  //       events.dispose(`Source stream closed`);\n  //     }\n  //     return;\n  //   }\n  //   if (value.value) {\n  //     const t = value.value[ field ];\n  //     events.notify(t as Out);\n  //   }\n  // })\n\n  // return {\n  //   on: events.on,\n  //   dispose: events.dispose,\n  //   isDisposed() {\n  //     return events.isDisposed();\n  //   },\n  // }\n}\n\nexport type TransformOpts = InitEventOptions;\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param source \n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const upstream = initUpstream<In, Out>(input, {\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      upstream.notify(t);\n    },\n  })\n\n  return {\n    on: upstream.on\n  }\n}\n\nexport type BatchOptions = InitEventOptions & {\n  /**\n   * If _true_ (default) remaining results are yielded\n   * if source closes. If _false_, only 'complete' batches are yielded.\n   */\n  returnRemainder: boolean\n  elapsed: Interval\n  limit: number\n  logic: `or` | `and`\n}\n\nexport type GeneratorOptions = {\n  /**\n   * By default (true) only accesses the generator if there is a subscriber.\n   */\n  lazy: boolean\n}\n/**\n * Creates a readable reactive based on a generator\n * ```js\n * // Generators that makes a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Reactive.generator(time);\n * // Get notified when there is a new value\n * r.on(v => {\n *   console.log(v.value);\n * });\n * ```\n * @param generator \n */\nexport function generator<V>(generator: IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): ReactiveDisposable & Reactive<V> {\n  const lazy = options.lazy ?? true;\n  let reading = false;\n\n  const eventOpts: InitEventOptions = {\n    onFirstSubscribe() {\n      if (lazy && !reading) {\n        readingStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy && reading) {\n        reading = false;\n      }\n    },\n  }\n  const events = initEvent<V>(eventOpts);\n\n  const read = async () => {\n    try {\n      const v = await generator.next();\n      if (v.done) {\n        events.dispose(`Generator complete`);\n        return;\n      }\n      if (!reading) return;\n      events.notify(v.value);\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    if (events.isDisposed()) return;\n    if (!reading) return;\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(read);\n  }\n\n  const readingStart = () => {\n    if (reading) return;\n    reading = true;\n    void read();\n  }\n  if (!lazy) readingStart();\n\n  return {\n    on: events.on,\n    dispose: events.dispose,\n    isDisposed: events.isDisposed\n  }\n}\n\nexport type ReactiveOrSource<V> = Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V>\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>): Reactive<V> => {\n  if (`on` in source) return source;\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return generator(source.values(), { lazy: true });\n  } else {\n    return generator(source, { lazy: true });\n  }\n}\n/**\n * Queue from `source`, emitting when thresholds are reached.\n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are ORed\n *\n * ```js\n * // Emit data in batches of 5 items\n * batch(source, { limit: 5 });\n * // Emit data every second\n * batch(source, { elapsed: 1000 });\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport function batch<V>(batchSource: ReactiveOrSource<V>, options: Partial<BatchOptions> = {}): Reactive<Array<V>> {\n  //const source = resolveSource(batchSource);\n  const elapsed = intervalToMs(options.elapsed, 0);\n  const queue = new QueueMutable<V>();\n  const limit = options.limit ?? 0;\n  const logic = options.logic ?? `or`;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  let lastFire = performance.now();\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.notify(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      trigger();\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(batchSource, upstreamOpts);\n\n  // let off: undefined | (() => void);\n\n  // const close = (reason: string) => {\n  //   console.log(`batch.close queue: ${ queue.length } returnRemainer: ${ returnRemainder }`);\n  //   if (off !== undefined) off();\n  //   if (returnRemainder && !queue.isEmpty) {\n  //     const data = queue.data;\n  //     queue.clear();\n  //     events.notify(data as Array<V>);\n  //   }\n  //   events.dispose(reason);\n  // }\n\n  // const initOpts: InitEventOptions = {\n  //   onFirstSubscribe() {\n  //     console.log(`batch onFirstSub`);\n  //     off = source.on(value => {\n  //       console.log(`batch value ${ JSON.stringify(value) }`);\n  //       if (isValue(value)) {\n  //         queue.enqueue(value.value);\n  //         trigger();\n  //       } else if (isSignal(value) && value.signal === `done`) {\n  //         close(`batch source closed`);\n  //       }\n  //     });\n  //   },\n  //   onNoSubscribers() {\n  //     close(`batch onNoSubscribers`);\n  //   },\n  // }\n  //const events = initEvent<Array<V>>(initOpts);\n\n  const trigger = () => {\n    const now = performance.now();\n    let byElapsed = false;\n    let byLimit = false;\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      byElapsed = true;\n    }\n    if (limit > 0 && queue.length >= limit) {\n      byLimit = true;\n    }\n    if (logic === `or` && (!byElapsed && !byLimit)) return;\n    if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    upstream.notify(data);\n  }\n\n  const r: Reactive<Array<V>> = {\n    on: upstream.on\n  }\n  return r;\n}\n\nexport type ToArrayOptions = {\n  limit: number\n  elapsed: number\n}\n\n/**\n * Reads the values of a reactive into an array.\n * Use the `limit` or `elapsed` to limit how many\n * items to read, and/or for how long.\n * @param reactive \n * @param options \n * @returns \n */\nexport const toArray = async <V>(reactiveSource: ReactiveOrSource<V>, options: Partial<ToArrayOptions> = {}): Promise<Array<V>> => {\n  const source = resolveSource(reactiveSource);\n  const maxValues = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maxDuration = options.elapsed ?? Number.MAX_SAFE_INTEGER;\n  let buffer: Array<V> = [];\n\n  let start = -1;\n  const promise = new Promise<Array<V>>((resolve, _reject) => {\n    const done = () => {\n      off();\n      resolve(buffer);\n      buffer = []\n    }\n\n    const off = source.on(value => {\n      if (start === -1) start = Date.now();\n      if (isSignal(value) && value.signal === `done`) {\n        done();\n      } else if (hasValue(value)) {\n        buffer.push(value.value);\n        if (buffer.length >= maxValues) {\n          done();\n        }\n      }\n      if (Date.now() - start > maxDuration) {\n        done();\n      }\n    });\n  })\n  return promise;\n}\n\nexport type ThrottleOptions = InitEventOptions & {\n  elapsed: Interval\n}\n\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    let byElapsed = false;\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      byElapsed = true;\n    }\n    if (!byElapsed) return;\n\n    if (lastValue !== undefined) {\n      upstream.notify(lastValue);\n    }\n  }\n\n  const r: Reactive<V> = {\n    on: upstream.on\n  }\n  return r;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = event(window, `resize`, {\n    lazy: true,\n    process: () => generateRect(),\n  });\n  const pointer = event(window, `pointermove`, {\n    lazy: true,\n    process: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n\n\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\nfunction isReactive(o: object): o is Reactive<any> {\n  if (typeof o !== `object`) return false;\n  if (`on` in o) {\n    return (typeof o.on === `function`);\n  }\n  return false;\n}\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param rx \n */\nexport function prepare<V extends Record<string, any>>(rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initEvent<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Reactive.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Reactive.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    graph: g,\n    on: events.on\n  }\n  return returnValue;\n}\n\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { QueueMutable, StackMutable } from \"../../collections/index.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport { Sync } from \"../../Generators.js\"\nimport { Table } from \"../Table.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. By default unidirectional.\n * Returns a new graph with the connection\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n  }\n\n  if (!bidi) return graph;\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n  }\n  return graph;\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    `${ v.id }`\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","/* eslint-disable @typescript-eslint/require-await */\n/* eslint-disable unicorn/prefer-ternary */\nimport { Async } from \"../Generators.js\";\nimport { Elapsed } from \"../flow/index.js\";\nimport { intervalToMs, type Interval } from \"../flow/IntervalType.js\";\nimport { sleep } from \"../flow/Sleep.js\";\nimport { isAsyncIterable } from \"../Iterable.js\";\nimport { Queues } from \"../collections/index.js\";\nimport { throwIntegerTest } from \"../Guards.js\";\n\n/**\n * A Generator, AsyncGenerator or IterableIterator\n */\nexport type Gen<V> = Generator<V> | AsyncGenerator<V> | IterableIterator<V>;\nexport type GenOrData<V> = Array<V> | Gen<V>;\n\nexport type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n\nexport type GenFactoryNoInput<Out> = () => AsyncGenerator<Out>;\n\n/**\n * An array of chain links where first one is a source\n */\nexport type LinksWithSource<In, Out> = [\n  Link<In, any> | GenOrData<In> | GenFactoryNoInput<In>,\n  ...Array<Link<any, any>>,\n  Link<any, Out>\n]\n\n\n/**\n * An array of chain links without a source\n */\nexport type Links<In, Out> = [\n  Link<In, any>,\n  ...Array<Link<any, any>>,\n  Link<any, Out>\n]\n\n/**\n * Wrap the primitive value as generator\n * @param value \n */\nfunction* primitiveToGenerator(value: number | boolean | string) {\n  yield value;\n}\n\n/**\n * Wrap the primitive value as an async generator\n * @param value \n */\nasync function* primitiveToAsyncGenerator(value: number | boolean | string) {\n  yield value;\n  await sleep(1);\n}\n\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input \n * @returns \n */\nfunction resolveToAsyncGen<V>(input: GenOrData<V> | GenFactoryNoInput<V> | undefined): AsyncGenerator<V> | undefined {\n  if (input === undefined) return;\n  if (Array.isArray(input)) {\n    return Async.fromArray(input);\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToAsyncGenerator(input) as AsyncGenerator<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  } else if (isAsyncIterable(input)) {\n    return input;\n  }\n  return Async.fromIterable(input);\n}\n\n/**\n * Resolve the array, data or function to a Generator\n * @param input \n * @returns \n */\nfunction resolveToGen<V>(input: GenOrData<V> | GenFactoryNoInput<V>): Gen<V> {\n  if (Array.isArray(input)) {\n    const a = input.values();\n    (a as any)._name = `arrayInput`;\n    return a;\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToGenerator(input) as Gen<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  }\n  return input;\n}\n\n/**\n * Delay options\n */\nexport type DelayOptions = {\n  /**\n   * Time before yielding\n   */\n  before?: Interval,\n  /**\n   * Time after yielding\n   */\n  after?: Interval\n}\n\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options \n * @returns \n */\nexport function delay<In>(options: DelayOptions): Link<In, In> {\n  const before = intervalToMs(options.before, 0);\n  const after = intervalToMs(options.after, 0);\n\n  async function* delay(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (before > 0) {\n        await sleep(before);\n      }\n      yield value;\n      if (after > 0) {\n        await sleep(after);\n      }\n    }\n  }\n  delay._name = `delay`;\n  return delay;\n}\n\nfunction isNoInput<Out>(c: Link<any, any>): c is GenFactoryNoInput<Out> {\n  if (`_allowNoInput` in c) return true;\n  return false;\n}\n\nexport type LazyChain<In, Out> = {\n  /**\n   * Return the chain as a regular generator, \n   * optionally providing the starting data\n   * @param data \n   * @returns \n   */\n  asGenerator: (data?: GenOrData<In>) => AsyncGenerator<Out>\n  asArray: (data?: GenOrData<In>) => Promise<Array<Out>>\n  lastOutput: (data?: GenOrData<In>) => Promise<Out | undefined>\n  firstOutput: (data?: GenOrData<In>) => Promise<Out | undefined>\n  fromFunction: (callback: () => any) => LazyChain<any, any>\n  take: (limit: number) => LazyChain<In, Out>\n  debounce: (duration: Interval) => LazyChain<In, Out>\n  delay: (options: DelayOptions) => LazyChain<In, Out>\n  chunk: (size: number, returnRemainers?: boolean) => LazyChain<In, Out>\n  filter: (predicate: (input: any) => boolean) => LazyChain<In, Out>\n  min: () => LazyChain<any, number>\n  max: () => LazyChain<any, number>\n  average: () => LazyChain<any, number>\n  total: () => LazyChain<In, number>\n  tally: () => LazyChain<In, number>\n  input: (data: GenOrData<In>) => LazyChain<In, Out>\n  drop: (predicate: (value: In) => boolean) => LazyChain<In, Out>\n  duration: (period: Interval) => LazyChain<In, Out>\n  flatten: (flattener: (values: Array<any>) => any) => LazyChain<In, Out>\n  transform: (transformer: (v: any) => any) => LazyChain<In, Out>\n}\n\nexport function lazy<In, Out>(): LazyChain<In, Out> {\n  const chained: Array<Link<any, any>> = [];\n  let dataToUse: GenOrData<In> | undefined;\n\n  const asGenerator = <V>(data?: GenOrData<In>) => {\n    if (data === undefined) data = dataToUse;\n    let d = resolveToAsyncGen(data);\n    for (const c of chained) {\n      if (d === undefined) {\n        if (isNoInput<In>(c)) {\n          d = c();\n        } else {\n          throw new Error(`Function '${ getName(c) }' requires input. Provide it to the function, or call 'input' earlier.`)\n        }\n      } else {\n        d = c(d);\n      }\n    }\n    return d as AsyncGenerator<V>\n  }\n\n  const w = {\n    asGenerator,\n    transform: (transformer: (v: any) => any) => {\n      chained.push(transform(transformer));\n      return w;\n    },\n    flatten: (flattener: (values: Array<any>) => any) => {\n      chained.push(flatten(flattener));\n      return w;\n    },\n    drop: (predicate: (v: In) => boolean) => {\n      chained.push(drop(predicate));\n      return w;\n    },\n    delay: (options: DelayOptions) => {\n      chained.push(delay(options));\n      return w;\n    },\n    duration: (elapsed: Interval) => {\n      chained.push(duration(elapsed));\n      return w;\n    },\n    debounce: (rate: Interval) => {\n      chained.push(debounce(rate));\n      return w;\n    },\n    fromFunction: (callback: () => any) => {\n      chained.push(fromFunction(callback));\n      return w;\n    },\n    take: (limit: number) => {\n      chained.push(take(limit));\n      return w;\n    },\n    chunk: (size: number, returnRemainders = true) => {\n      chained.push(chunk(size, returnRemainders))\n      return w;\n    },\n    filter: (predicate: (input: any) => boolean) => {\n      chained.push(filter(predicate));\n      return w;\n    },\n    min: (): LazyChain<any, number> => {\n      chained.push(min());\n      return w as unknown as LazyChain<any, number>;\n    },\n    max: (): LazyChain<any, number> => {\n      chained.push(max());\n      return w as unknown as LazyChain<any, number>;\n    },\n    average: (): LazyChain<any, number> => {\n      chained.push(average());\n      return w as unknown as LazyChain<any, number>;\n    },\n    total: (): LazyChain<any, number> => {\n      chained.push(total());\n      return w as unknown as LazyChain<any, number>;\n    },\n    tally: (): LazyChain<any, number> => {\n      chained.push(tally());\n      return w as unknown as LazyChain<any, number>;\n    },\n    input(data: GenOrData<In>) {\n      dataToUse = data;\n      return w\n    },\n    asAsync(data?: GenOrData<In>) {\n      let d = data ?? dataToUse;\n      for (const c of chained) {\n        if (d === undefined && isNoInput<In>(c)) {\n          d = c();\n        } else if (d === undefined) {\n          throw new Error(`Function '${ getName(c) }' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n        } else {\n          d = c(d);\n        }\n      }\n      return w;\n    },\n    asArray: async (data?: GenOrData<In>): Promise<Array<Out>> => {\n      const g = asGenerator<Out>(data);\n      return await Async.toArray<Out>(g);\n    },\n    firstOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      const v = await g.next();\n      return v.value as Out;\n    },\n    lastOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      let lastValue: Out | undefined;\n      for await (const v of g) {\n        lastValue = v as Out;\n      }\n      return lastValue;\n    },\n  }\n  return w as unknown as LazyChain<In, Out>;\n}\n\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n * \n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.chain(\n *  // Produce values every 10ms for 350ms\n *  Chains.tick({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.debounce(100)\n * );\n * ```\n * @param rate \n * @returns \n */\nexport function debounce<In>(rate: Interval): Link<In, In> {\n  const rateMs = intervalToMs(rate, 0);\n\n  async function* debounce(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() < rateMs) continue;\n      yield value;\n      elapsed = Elapsed.since();\n    }\n  }\n  debounce._name = `debounce`;\n  return debounce;\n}\n\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param duration \n * @returns \n */\nexport function duration<In>(elapsed: Interval): Link<In, In> {\n  const durationMs = intervalToMs(elapsed, 0);\n\n  async function* duration(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    const elapsed = Elapsed.since();\n    for await (const value of input) {\n      if (elapsed() > durationMs) break;\n      yield value;\n    }\n  }\n  duration._name = `duration`;\n  return duration;\n}\n\nexport type TickOptions = {\n  interval: Interval\n  loops?: number\n  elapsed?: Interval\n  asClockTime?: boolean\n}\n\n/**\n * Generate timestamp values\n * By default it runs forever. \n * Use `loops` or `elapsed` to set upper limits.\n * \n * Options:\n * - `asClockTime`: If true, yielded value will be clock time rather than elapsed\n * @param options \n * @returns \n */\nexport function tick(options: TickOptions): GenFactoryNoInput<number> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const asClockTime = options.asClockTime ?? false;\n  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n  let looped = 0;\n  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n\n  async function* ts(): AsyncGenerator<number> {\n    const elapsed = Elapsed.since();\n    while (looped < loops && elapsed() < durationTime) {\n      yield asClockTime ? Date.now() : elapsed();\n\n      // Adjust sleep period so timing errors don't accumulate\n      const expectedTimeDiff = (looped * intervalMs) - elapsed();\n      await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n      looped++;\n    }\n  }\n  ts._name = `timestamp`;\n  return ts;\n}\n\n/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n * \n * ```js\n * const callback = () => Math.random();\n * \n * const f = Chains.fromFunction(callback);\n * f(); // New random number\n * ```\n * \n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.fromFunction(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback \n * @returns \n */\nexport function fromFunction<Out>(callback: () => Promise<Out> | Out): GenFactoryNoInput<Out> {\n  async function* fromFunction(): AsyncGenerator<Out> {\n    while (true) {\n      const v = await callback();\n      if (v === undefined) break;\n      yield v;\n    }\n  }\n  fromFunction._name = `fromFunction`;\n  return fromFunction;\n}\n\nconst oncePromise = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};\n\nexport function fromEvent<Out>(target: EventTarget, name: string) {\n  async function* fromEvent(): AsyncGenerator<Out> {\n    while (true) {\n      yield await oncePromise(target, name) as Out;\n    }\n  }\n  fromEvent._name = `fromEvent`;\n  return fromEvent;\n}\n\n/**\n * Treats the chain/generator as a promise\n * \n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n * \n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap \n * @returns \n */\nexport function asPromise<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>) {\n  let lastValue: V | undefined;\n\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  async function asPromise(): Promise<V | undefined> {\n    const v = await outputType.next();\n    if (v.done) return;\n    lastValue = v.value;\n    return lastValue;\n  }\n  return asPromise;\n}\n\n/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n * \n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n * \n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n * \n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap \n * @param initialValue \n * @returns \n */\nexport function asValue<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>, initialValue?: V) {\n  let lastValue: V | undefined = initialValue;\n  let awaiting = false;\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  function asValue(): V | undefined {\n    if (!awaiting) {\n      awaiting = true;\n      outputType.next().then(v => {\n        lastValue = v.value;\n        awaiting = false;\n      }).catch(error => {\n        awaiting = false;\n        throw error;\n      });\n    }\n    return lastValue;\n  }\n  return asValue;\n}\n\n/**\n * Calls `callback` whenever the chain/generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap \n * @param callback \n */\nexport async function asCallback<V>(valueToWrap: GenOrData<V> | GenFactoryNoInput<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\n\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n * @param chain \n * @returns \n */\nexport async function asArray<Out>(valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>): Promise<Array<Out>> {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  return Async.toArray(outputType);\n}\n\n/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n * \n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param chain \n * @param array \n */\nexport async function addToArray<Out>(array: Array<Out>, valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    array.push(value);\n  }\n}\n\n/**\n * Input a single value to the chain, return a single result\n * @param f \n * @param input \n * @returns \n */\nexport async function single<In, Out>(f: Link<In, Out>, input: In): Promise<Out | undefined> {\n  const iterator = await f([ input ]).next();\n  return iterator.value as Out | undefined;\n}\n\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `flattener` function.\n * \n * ```js\n * // Create a chain that flattens values\n * const flatten = Chains.flatten(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(flatten, [ 1, 2, 3]); // 3\n * ```\n * @param flattener Function to flatten array of values to a single value\n * @returns \n */\nexport function flatten<In, Out>(flattener: (v: Array<In>) => Out): Link<Array<In>, Out> {\n  async function* flatten(input: GenOrData<Array<In>>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield flattener(value);\n    }\n  }\n  flatten._name = `flatten`;\n  return flatten;\n}\n\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (v: In) => Out): Link<In, Out> {\n  async function* transform(input: GenOrData<In>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield transformer(value);\n    }\n  }\n  transform._name = `transform`;\n  return transform;\n}\n\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n * \n * Alternatively:\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link synchronise} which releases a set of results when all inputs have emitted a value\n * @param sources \n */\nexport async function* mergeFlat<Out>(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Out> {\n  const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n  const buffer = Queues.mutable<Out>();\n  let completed = 0;\n\n  const schedule = async (source: AsyncGenerator<any> | undefined) => {\n    if (source === undefined) {\n      completed++;\n      return;\n    }\n\n    const x = await source.next();\n    if (x.done) {\n      completed++;\n    } else {\n      buffer.enqueue(x.value as Out);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(() => schedule(source), 1);\n    }\n  }\n\n  for (const source of sourcesInput) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(() => schedule(source), 1);\n  }\n\n  const loopSpeed = 10;\n  let loopFactor = 1;\n  while (completed < sourcesInput.length) {\n    const d = buffer.dequeue();\n    if (d === undefined) {\n      // Grow loop factor up to 10\n      loopFactor = Math.min(loopFactor + 1, 10);\n    } else {\n      yield d;\n      // Reset loop factor\n      loopFactor = 1;\n    }\n    await sleep(loopSpeed * loopFactor);\n  }\n}\n\n/**\n * Generate values for each source, returning results as an array.  \n * If a source finishes before another, null will be used at its position in the results.\n * Use {@link synchronise} instead to only release results when all sources have yielded a value.\n * \n * Finishes when all generators finish.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link synchronise} only return results when all sourcse have yielded a value\n * @param sources \n */\nexport async function* mergeAsArray(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingProduced = true;\n  while (somethingProduced) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingProduced = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (!v.done) {\n        data[ index ] = v.value;\n        somethingProduced = true;\n      }\n    }\n    if (somethingProduced) {\n      // Send data\n      yield data;\n      data = [];\n    }\n  }\n}\n\n/**\n * Synchronise several sources, releasing a set of results when every\n * source has produced something. Finishes as soon as _any_ source finishes.\n * \n * ie. the rate of emitting data is determined by the slowest source.\n * \n * Alternatively:\n * - {@link mergeFlat} interleaves streams as single values\n * - {@link mergeAsArray} emits snapshots of all the generators, as quickly as the fastest one\n * @param sources \n */\nexport async function* synchronise(...sources: Array<GenOrData<any> | GenFactoryNoInput<any>>): AsyncGenerator<Array<any>> {\n  const sourcesInput = sources.map(source => resolveToGen(source));\n  let somethingStopped = false;\n  while (!somethingStopped) {\n    let data = [];\n    for (let index = 0; index < sourcesInput.length; index++) {\n      // eslint-disable-next-line unicorn/no-null\n      data[ index ] = null;\n    }\n\n    somethingStopped = false;\n    // Request the next value from each source\n    for (const [ index, source ] of sourcesInput.entries()) {\n      const v = await source.next();\n      if (v.done) {\n        somethingStopped = true;\n        break;\n      } else {\n        data[ index ] = v.value;\n      }\n    }\n\n    if (somethingStopped) break;\n    yield data;\n    data = [];\n  }\n}\n\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit \n * @returns \n */\nexport function take<In>(limit: number): Link<In, In> {\n  async function* take(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let yielded = 0;\n    for await (const value of input) {\n      if (++yielded > limit) break;\n      yield value;\n    }\n  }\n  take._name = `take`;\n  return take;\n}\n\nconst getName = (c: Link<any, any>): string => {\n  if (`_name` in c) {\n    return c._name as string;\n  } else {\n    return c.name;\n  }\n}\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * \n * This is different than {@link total} which adds up numeric values\n * @param limit \n * @returns \n */\nexport function tally<In>(): Link<In, number> {\n  async function* tally(input: GenOrData<In>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let count = 0;\n    for await (const _ of input) {\n      yield ++count;\n    }\n  }\n  tally._name = `tally`;\n  return tally;\n}\n\n/**\n * Returns the smallest value from the input.\n * Non-numeric data is filtered out\n * @returns \n */\nexport function min(): Link<number, number> {\n  async function* min(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let min = Number.MAX_SAFE_INTEGER;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n\n      min = Math.min(value, min);\n      yield min;\n    }\n  }\n  min._name = `min`;\n  return min;\n}\n\n/**\n * Returns the largest value from the input\n * Non-numeric data is filtered out\n * @returns \n */\nexport function max(): Link<number, number> {\n  async function* max(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let max = Number.MIN_SAFE_INTEGER;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      max = Math.max(value, max);\n      yield max;\n    }\n  }\n  max._name = `max`;\n  return max;\n}\n\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function average(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    let count = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      count++;\n      total += value;\n      yield total / count;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function total(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    let total = 0;\n    for await (const value of input) {\n      if (typeof value !== `number`) break;\n      total += value;\n      yield total;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Chunks an input stream into `size` chunks.\n * @param size \n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns \n */\nexport function chunk<In>(size: number, returnRemainders = true): Link<In, Array<In>> {\n  throwIntegerTest(size, `aboveZero`, `size`);\n  async function* chunk(input: GenOrData<In>): AsyncGenerator<Array<In>> {\n    input = resolveToGen(input);\n    let buffer: Array<In> = [];\n    for await (const value of input) {\n      buffer.push(value);\n      if (buffer.length >= size) {\n        yield buffer;\n        buffer = []\n      }\n    }\n    if (returnRemainders && buffer.length > 0) yield buffer;\n  }\n  chunk._name = `chunk`;\n  return chunk;\n}\n\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n * \n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate \n * @returns \n */\nexport function filter<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* filter(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  filter._name = `filter`;\n  return filter;\n}\n\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n * \n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate \n * @returns \n */\nexport function drop<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* drop(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (!predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  drop._name = `drop`;\n  return drop;\n}\n\n/**\n * Chain functions together. First argument is the source.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * @param functions \n * @returns \n */\nexport async function* run<In, Out>(...functions: LinksWithSource<In, Out>): AsyncGenerator<Out> {\n  let input: Gen<In> | undefined;\n  for (const fnOrData of functions) {\n    if (typeof fnOrData === `function`) {\n      input = fnOrData(input ?? []);\n    } else {\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v as Out;\n  }\n}\n\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n * \n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n * \n * }\n * ```\n * @param functions \n * @returns \n */\nexport function prepare<In, Out>(...functions: Links<In, Out>) {\n  const r = (source: GenOrData<In> | GenFactoryNoInput<Out>) => {\n    return run(source, ...functions);\n  }\n  return r;\n}\n","type WithEvents = {\n  addEventListener(type: string, callbackfn: any): void;\n  removeEventListener(type: string, callbackfn: any): void;\n}\n\n//export { eachInterval } from './flow/Interval.js';\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> =>\n  Symbol.asyncIterator in new Object(v);\n\nexport const isIterable = (v: any): v is Iterable<any> =>\n  Symbol.iterator in new Object(v);\n\nexport const eventsToIterable = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(error),\n      };\n    },\n  };\n  return r;\n};\n","export * as Directed from './DirectedGraph.js';\nexport * as Undirected from './UndirectedGraph.js';","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { Table } from \"../Table.js\"\n\n\nexport type Vertex = Readonly<{\n  id: string\n}>\n\nexport type Edge = Readonly<{\n  a: string,\n  b: string,\n  weight?: number\n}>\n\nexport type Graph = Readonly<{\n  edges: ReadonlyArray<Edge>,\n  vertices: IMapImmutable<string, Vertex>\n}>\n\nexport type ConnectOptions = Readonly<{\n  a: string\n  b: string | Array<string>\n  weight?: number\n}>\n\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id\n  }\n}\n\nexport const updateGraphVertex = (graph: Graph, vertex: Vertex): Graph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\nexport const getOrCreate = (graph: Graph, id: string): Readonly<{ graph: Graph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\nfunction resolveVertex(graph: Graph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\nexport const hasConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): boolean => {\n  const edge = getConnection(graph, a, b);\n  return edge !== undefined;\n}\n\nexport const getConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): Edge | undefined => {\n  const aa = resolveVertex(graph, a);\n  const bb = resolveVertex(graph, b);\n  for (const edge of graph.edges) {\n    if (edge.a == aa.id && edge.b === bb.id) return edge;\n    if (edge.a == bb.id && edge.b === aa.id) return edge;\n  }\n  return;\n}\n\n/**\n * Connect A <-> B\n * @param graph \n * @param a \n * @param b \n * @param weight \n * @returns \n */\nexport function connectTo(graph: Graph, a: string, b: string, weight?: number): { graph: Graph, edge: Edge } {\n  const aResult = getOrCreate(graph, a);\n  graph = aResult.graph;\n  const bResult = getOrCreate(graph, b);\n  graph = bResult.graph;\n\n  let edge = getConnection(graph, a, b);\n  if (edge !== undefined) return { graph, edge };\n  edge = {\n    a,\n    b,\n    weight\n  }\n\n  const graphChanged: Graph = {\n    ...graph,\n    edges: [ ...graph.edges, edge ]\n  }\n  return { graph: graphChanged, edge }\n}\n\nexport function connect(graph: Graph, options: ConnectOptions): Graph {\n  const { a, weight, b } = options;\n  const destinations = Array.isArray(b) ? b : [ b ];\n\n  for (const destination of destinations) {\n    const result = connectTo(graph, a, destination, weight);\n    graph = result.graph;\n  }\n\n  return graph;\n}\n\nexport const graph = (...initialConnections: Array<ConnectOptions>): Graph => {\n  let g: Graph = {\n    vertices: immutableMap(),\n    edges: []\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\nexport function toAdjacencyMatrix(graph: Graph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    table.setRow(i, v.length, false);\n\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      const connected = hasConnection(graph, ii, jj);\n      if (connected) {\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: Graph): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: Graph): Array<string> => {\n  const r: Array<string> = [];\n\n  r.push(`Vertices: ${ [ ...graph.vertices.values() ].map(v => v.id).join(`, `) }`);\n  // eslint-disable-next-line unicorn/no-array-push-push\n  r.push(`Edges:`);\n  for (const edge of graph.edges) {\n    r.push(stringForEdge(edge));\n  }\n  return r;\n}\n\nconst stringForEdge = (edge: Edge) => {\n  const weight = edge.weight ? ` (${ edge.weight })` : ``;\n  return `${ edge.a } <-> ${ edge.b }${ weight }`\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield resolveVertex(graph, edge.b);\n    else if (edge.b === context) yield resolveVertex(graph, edge.a);\n  }\n}\n\nexport function* edgesForVertex(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield edge;\n    else if (edge.b === context) yield edge;\n  }\n}","import { toStringDefault, type ToString } from \"../Util.js\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values\n * \n * ```js\n * const t = trackUnique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = trackUnique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * @returns \n */\nexport const trackUnique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn\n * @param lastData\n * @param newData\n * @param opts\n * @returns\n */\n//eslint-disable-next-line functional/immutable-data\nexport const align = <V>(\n  similarityFn: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  opts: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = opts.matchThreshold ?? 0;\n  const debug = opts.debug ?? false;\n  const results = new Map();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map();\n  lastData?.forEach((d, index) => {\n    if (d === undefined) {\n      throw new Error(`'lastData' contains undefined (index: ${index})`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < newData.length; i++) {\n    const newD = newData[i];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${newD.id}`);\n\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: last.id,\n      score: last === null ? -1 : similarityFn(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n    //eslint-disable-next-line functional/immutable-data\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[0];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${top.score} id: ${newD.id}`\n        );\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score})`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    //eslint-disable-next-line functional/immutable-data\n    lastMap.delete(top.id);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn\n * @param opts\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, opts: AlignOpts = {}) => {\n  //eslint-disable-next-line functional/no-let\n  let lastData: readonly DataWithId<V>[] = [];\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, opts);\n    return [...lastData];\n  };\n  return compute;\n};\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as Debug from '../debug/index.js';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type Opts<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: Array<PoolUser<V>>;\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n */\nexport class Pool<V> {\n  private _resources: Array<Resource<V>>;\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet;\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param opts Pool options\n   */\n  constructor(opts: Opts<V> = {}) {\n    this.capacity = opts.capacity ?? -1;\n    this.fullPolicy = opts.fullPolicy ?? `error`;\n    this.capacityPerResource = opts.capacityPerResource ?? 1;\n    this.userExpireAfterMs = opts.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      opts.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = opts.generate;\n    this.freeResource = opts.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, opts.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    //eslint-disable-next-line functional/no-let\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a resource to the pool.\n   * Throws an error if the capacity limit is reached.\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new Error(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    //eslint-disable-next-line functional/no-let\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Array<Resource<V>> = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: Array<string> = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  private _findUser(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    //eslint-disable-next-line functional/no-let\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a user key.\n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * @param userKey\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this._findUser(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this._findUser(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param opts\n * @returns\n */\nexport const create = <V>(opts: Opts<V> = {}): Pool<V> => new Pool<V>(opts);\n"],"mappings":"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","names":["min","max","average","smoothingFactor","object","graph","vertices","stringForEdge","event","run","lazy","field","generator","average","mergeAsArray","prepare","synchronise","transform","delay","transform","average","debounce","duration","elapsed","fromFunction","fromEvent","asPromise","asValue","array","flatten","mergeAsArray","synchronise","take","tally","min","max","total","chunk","filter","drop","prepare","adjacentVertices","connect","connectTo","createVertex","dumpGraph","getOrCreate","graph","toAdjacencyMatrix","updateGraphVertex","createVertex","updateGraphVertex","graph","getOrCreate","resolveVertex","connectTo","connect","toAdjacencyMatrix","dumpGraph","debugGraphToArray","adjacentVertices","r"]}