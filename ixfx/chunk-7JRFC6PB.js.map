{"version":3,"sources":["../src/collections/arrays/index.ts","../src/collections/Map/MapFns.ts","../src/random/WeightedIndex.ts","../src/collections/GuardArray.ts","../src/collections/GuardIndex.ts","../src/collections/arrays/ValuesEqual.ts","../src/iterable/SliceSync.ts","../src/collections/FilterBetween.ts","../src/collections/MinMaxAvg.ts","../src/collections/arrays/NumericArrays.ts","../src/collections/ArrayCycle.ts","../src/collections/arrays/Zip.ts","../src/collections/arrays/AverageWeighted.ts","../src/collections/arrays/SortByNumericProperty.ts","../src/collections/Iterables.ts"],"sourcesContent":["/* eslint-disable indent */\n/**\n * Functions for working with primitive arrays, regardless of type\n * See Also: NumericArrays.ts\n */\n\nimport { throwIntegerTest } from '../../Guards.js';\nimport {\n  type ToString,\n  toStringDefault,\n} from '../../Util.js';\nimport {\n  type IsEqual,\n  isEqualDefault\n} from '../../IsEqual.js'\nimport { fromIterable as mapFromIterable } from '../map/MapFns.js';\nimport { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport { weightedIndex } from '../../random/WeightedIndex.js';\nimport { guardArray } from '../GuardArray.js';\nimport { guardIndex } from '../GuardIndex.js';\nimport { valuesEqual } from './ValuesEqual.js';\nexport * from './NumericArrays.js';\nexport * from '../ArrayCycle.js';\nexport * from '../FilterBetween.js';\nexport * from '../GuardArray.js';\nexport * from '../GuardIndex.js';\nexport * from './AverageWeighted.js';\nexport * from './NumericArrays.js';\nexport * from './Zip.js';\nexport * from './ValuesEqual.js';\nexport * from './SortByNumericProperty.js';\nexport { compareValues, compareValuesEqual } from '../Iterables.js';\n\n\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n * \n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also: \n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA \n * @param arrayB \n * @param equality \n * @returns \n */\nexport const intersection = <V>(\n  arrayA: ReadonlyArray<V> | Array<V>,\n  arrayB: ReadonlyArray<V> | Array<V>,\n  equality: IsEqual<V> = isEqualDefault\n) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array: ReadonlyArray<any> | Array<any>): Array<any> =>\n  [ ...array ].flat();\n\n\n\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * import { interleave } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = <V>(\n  ...arrays: ReadonlyArray<ReadonlyArray<V>> | Array<Array<V>>\n): Array<V> => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => a.length);\n  if (!valuesEqual(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue = [];\n  const length = lengths[ 0 ];\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < length; index++) {\n    //eslint-disable-next-line functional/no-let\n    for (const array of arrays) {\n      //eslint-disable-next-line functional/immutable-data\n      returnValue.push(array[ index ]);\n    }\n  }\n  return returnValue;\n};\n\n/**\n * Returns a copy of `data` with specified length.\n * If the input array is too long, it is truncated.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with `undefined`\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * ```js\n * import { ensureLength } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * ensureLength([1,2,3], 2); // [1,2]\n * ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expand Expand strategy\n * @typeParam V Type of array\n */\nexport const ensureLength = <V>(\n  data: ReadonlyArray<V> | Array<V>,\n  length: number,\n  expand: `undefined` | `repeat` | `first` | `last` = `undefined`\n): Array<V> => {\n  // Unit tested\n  if (data === undefined) throw new Error(`Data undefined`);\n  if (!Array.isArray(data)) throw new Error(`data is not an array`);\n  if (data.length === length) return [ ...data ];\n  if (data.length > length) {\n    return data.slice(0, length);\n  }\n  const d = [ ...data ];\n  const add = length - d.length;\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < add; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    switch (expand) {\n      case `undefined`: {\n        // @ts-expect-error\n        d.push(undefined);\n        break;\n      }\n      case `repeat`: {\n        d.push(data[ index % data.length ]);\n        break;\n      }\n      case `first`: {\n        d.push(data[ 0 ]);\n        break;\n      }\n      case `last`: {\n        // @ts-expect-error\n        d.push(data.at(-1));\n        break;\n      }\n      // No default\n    }\n  }\n  return d;\n};\n\n\n\n/**\n * Returns a random array index.\n *\n * ```js\n * import { randomIndex } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = defaultRandom\n): number => Math.floor(rand() * array.length);\n\n/**\n * Selects a random array index, biased by the provided `weightings`.\n * \n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ] \n * ```\n * @param array \n * @param weightings \n * @param randomSource \n */\nexport const randomElementWeightedSource = <V>(array: ArrayLike<V>, weightings: Array<number>, randomSource: RandomSource = defaultRandom) => {\n  if (array.length !== weightings.length) throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n  const r = weightedIndex(weightings, randomSource);\n  return (): V => {\n    const index = r();\n    return array[ index ];\n  }\n}\n\n\n\n\n/**\n * Returns random element.\n *\n * ```js\n * import { randomElement } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @params rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = defaultRandom\n): V => {\n  guardArray(array, `array`);\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n/**\n * Removes a random item from an array, returning both the item and the new array as a result.\n * Does not modify the original array unless `mutate` parameter is true.\n *\n * @example Without changing source\n * ```js\n * import { randomPluck } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [100, 20, 40];\n * const {value, array} = randomPluck(data);\n * // value: 20, array: [100, 40], data: [100, 20, 40];\n * ```\n *\n * @example Mutating source\n * ```js\n * import { randomPluck } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [100, 20, 40];\n * const {value} = randomPluck(data, true);\n * // value: 20, data: [100, 40];\n * ```\n *\n * @template V Type of array\n * @param array Array to pluck item from\n * @param mutate If _true_, changes input array. _False_ by default.\n * @param random Random generatr. `Math.random` by default.\n * @return Returns an object `{value:V|undefined, array:V[]}`\n *\n */\nexport const randomPluck = <V>(\n  array: ReadonlyArray<V> | Array<V>,\n  mutate = false,\n  rand: RandomSource = defaultRandom\n): { readonly value: V | undefined; readonly array: Array<V> } => {\n  if (array === undefined) throw new Error(`array is undefined`);\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\n  if (array.length === 0) return { value: undefined, array: [] };\n  const index = randomIndex(array, rand);\n  if (mutate) {\n    return {\n      value: array[ index ],\n      //eslint-disable-next-line functional/immutable-data\n      array: array.splice(index, 1),\n    };\n  } else {\n    // Copy array, remove item from that\n    const t = [ ...array ];\n    //eslint-disable-next-line functional/immutable-data\n    t.splice(index, 1);\n    return {\n      value: array[ index ],\n      array: t,\n    };\n  }\n};\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * import { shuffle } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @template V Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: ReadonlyArray<V>,\n  rand: RandomSource = defaultRandom\n): Array<V> => {\n  const array = [ ...dataToShuffle ];\n  // eslint-disable-next-line  functional/no-let\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};\n\n\n\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { without } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [100, 20, 40];\n * const filtered = without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { without } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { without } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @template V Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  sourceArray: ReadonlyArray<V> | Array<V>,\n  toRemove: V | Array<V>,\n  comparer: IsEqual<V> = isEqualDefault\n): Array<V> => {\n  if (Array.isArray(toRemove)) {\n    const returnArray = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}\n\nexport const withoutUndefined = <V>(data: ReadonlyArray<V> | Array<V>): Array<V> => {\n  return data.filter(v => v !== undefined);\n}\n/**\n * Returns all items in `data` for as long as `predicate` returns true.\n *\n * `predicate` returns an array of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = Arrays.until([1,2,3,4,5], v => [v === 3, 0]);\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport const until = <V, A>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V> | Array<V>,\n  predicate: (v: V, accumulator: A) => readonly [ stop: boolean, acc: A ],\n  initial: A\n): Array<V> => {\n  const returnValue = [];\n  //eslint-disable-next-line functional/no-let\n  let total = initial;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    const [ stop, accumulator ] = predicate(datum, total);\n    if (stop) break;\n\n    total = accumulator;\n\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push(datum);\n  }\n  return returnValue;\n};\n\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { remove } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V> | Array<V>,\n  index: number\n): Array<V> => {\n  // ✔️ Unit tested\n  if (!Array.isArray(data)) {\n    throw new TypeError(`'data' parameter should be an array`);\n  }\n  guardIndex(data, index, `index`);\n  return [ ...data.slice(0, index), ...data.slice(index + 1) ];\n};\n\n/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * import { groupBy } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [\n *  { age: 39, city: `London` }\n *  { age: 14, city: `Copenhagen` }\n *  { age: 23, city: `Stockholm` }\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = groupBy(data, item => data.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = <K, V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  array: Iterable<V>,\n  grouper: (item: V) => K\n) => {\n  const map = new Map<K, Array<V>>();\n\n  for (const a of array) {\n    const key = grouper(a);\n    //eslint-disable-next-line functional/no-let\n    let existing = map.get(key);\n    if (!existing) {\n      existing = [];\n      map.set(key, existing);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    existing.push(a);\n  }\n  return map;\n};\n\n/**\n * Samples array\n *\n * @example By percentage - get half of the items\n * ```\n * import { sample } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example By steps - every third\n * ```\n * import { sample } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = <V>(array: ArrayLike<V>, amount: number): Array<V> => {\n  //eslint-disable-next-line functional/no-let\n  let subsampleSteps = 1;\n  if (amount <= 1) {\n    // Subsample based on a percentage\n    const numberOfItems = array.length * amount;\n    subsampleSteps = Math.round(array.length / numberOfItems);\n  } else {\n    subsampleSteps = amount;\n  }\n\n  throwIntegerTest(subsampleSteps, `positive`, `amount`);\n  if (subsampleSteps > array.length - 1) {\n    throw new Error(`Subsample steps exceeds array length`);\n  }\n  const r: Array<V> = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n    //eslint-disable-next-line functional/immutable-data\n    r.push(array[ index ]);\n  }\n  return r;\n};\n\n/**\n * Return `arr` broken up into chunks of `size`\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param array\n * @param size\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function chunks<V>(\n  array: ReadonlyArray<V>,\n  size: number\n) {\n  // https://surma.github.io/underdash/\n  const output = [];\n  //eslint-disable-next-line  functional/no-let\n  for (let index = 0; index < array.length; index += size) {\n    //eslint-disable-next-line functional/immutable-data\n    output.push(array.slice(index, index + size));\n  }\n  return output;\n}\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also [Maps.mergeByKey](functions/Collections.Maps.mergeByKey.html) if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFn Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = <V>(\n  keyFunction: ToString<V>,\n  reconcile: MergeReconcile<V>,\n  ...arrays: ReadonlyArray<ReadonlyArray<V>>\n): Array<V> => {\n  const result = new Map<string, V>();\n  for (const m of arrays) {\n    for (const mv of m) {\n      if (mv === undefined) continue;\n      const mk = keyFunction(mv);\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return [ ...result.values() ];\n};\n\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const reducePairwise = <V, X>(\n  array: ReadonlyArray<V>,\n  reducer: (accumulator: X, a: V, b: V) => X,\n  initial: X\n) => {\n  guardArray(array, `arr`);\n  if (array.length < 2) return initial;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < array.length - 1; index++) {\n    initial = reducer(initial, array[ index ], array[ index + 1 ]);\n  }\n  return initial;\n};\n\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: ReadonlyArray<V>,\n  filter: (a: V) => boolean\n): [ a: Array<V>, b: Array<V> ] => {\n  const a: Array<V> = [];\n  const b: Array<V> = [];\n  for (const datum of data) {\n    //eslint-disable-next-line functional/immutable-data\n    if (filter(datum)) a.push(datum);\n    //eslint-disable-next-line functional/immutable-data\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Combines the values of one or more arrays, removing duplicates\n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | Array<Array<V>>\n    | Array<V>\n    | ReadonlyArray<V>\n    | ReadonlyArray<ReadonlyArray<V>>,\n  comparer = isEqualDefault<V>\n): ReadonlyArray<V> => {\n  const t: Array<V> = [];\n  for (const a of arrays) {\n    if (Array.isArray(a)) {\n      for (const v of additionalValues<V>(t, a, comparer)) {\n        t.push(v);\n      }\n    } else {\n      return [ ...additionalValues<V>([], arrays as Array<V>, comparer) ];\n    }\n  }\n  return t;\n};\n\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n * \n * Uses JSON.toString() by default to compare values.\n * \n * See also:\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link unique} Get unique set of values in an array\n * @param array Array to examine\n * @param comparer Comparer, uses JSON.toString by default\n * @returns\n */\nexport const containsDuplicateValues = <V>(\n  array: Array<V> | ReadonlyArray<V>,\n  keyFunction = toStringDefault<V>\n): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  try {\n    const _ = mapFromIterable(array, keyFunction);\n  } catch {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns _true_ if array contains duplicate instances.\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array \n * @returns \n */\nexport const containsDuplicateInstances = <V>(array: Array<V> | ReadonlyArray<V>): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  for (let index = 0; index < array.length; index++) {\n    for (let x = 0; x < array.length; x++) {\n      if (index === x) continue;\n      if (array[ index ] === array[ x ]) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if the two arrays have the same items at same indexes.\n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n * \n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n * \n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n * \n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA \n * @param arrayB \n * @param isEqual \n */\nexport const isEqual = <V>(arrayA: Array<V>, arrayB: Array<V>, isEqual = isEqualDefault<V>): boolean => {\n  if (!Array.isArray(arrayA)) throw new Error(`Parameter 'arrayA' is not actually an array`);\n  if (!Array.isArray(arrayB)) throw new Error(`Parameter 'arrayB' is not actually an array`);\n\n  if (arrayA.length !== arrayB.length) return false;\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    if (!(isEqual(arrayA[ indexA ], arrayB[ indexA ]))) return false;\n  }\n  return true;\n}\n/**\n * Returns _true_ if contents of `needles` is contained by `haystack`.\n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * @param haystack\n * @param needles\n * @param eq\n */\nexport const contains = <V>(\n  haystack: ArrayLike<V>,\n  needles: ArrayLike<V>,\n  eq = isEqualDefault<V>\n) => {\n  if (!Array.isArray(haystack)) {\n    throw new TypeError(`Expects haystack parameter to be an array`);\n  }\n  if (!Array.isArray(needles)) {\n    throw new TypeError(`Expects needles parameter to be an array`);\n  }\n\n  for (const needle of needles) {\n    //eslint-disable-next-line functional/no-let\n    let found = false;\n    for (const element of haystack) {\n      if (eq(needle, element)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Yield values from an iterable not present in the other.\n *\n * Assuming that `input` array is unique values, this function\n * yields items from `values` which are not present in `input`.\n *\n * Duplicate items in `values` are ignored - only the first is yielded.\n *\n * If `eq` function is not provided, values are compared using the\n * default === semantics (via {@link isEqualDefault})\n *\n * ```js\n * const existing = [ 1, 2, 3 ];\n * const newValues = [ 3, 4, 5];\n * const v = [...additionalValues(existing, newValues)];\n * // [ 1, 2, 3, 4, 5]\n * ```\n *\n * ```js\n * const existing = [ 1, 2, 3 ];\n * const newValues = [ 3, 4, 5 ];\n * for (const v of additionalValues(existing, newValues)) {\n *  // 4, 5\n * }\n * To combine one or more iterables, keeping only unique items, use {@link unique}\n * @param input\n * @param values\n */\nexport function* additionalValues<V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  input: Array<V>,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  values: Iterable<V>,\n  eq: IsEqual<V> = isEqualDefault\n): Iterable<V> {\n  // Keep track of values already yielded\n  const yielded: Array<V> = [];\n  for (const v of values) {\n    const found = input.find((index) => eq(index, v));\n    if (!found) {\n      const alreadyYielded = yielded.find((ii) => eq(ii, v));\n      if (!alreadyYielded) {\n        //eslint-disable-next-line functional/immutable-data\n        yielded.push(v);\n        yield v;\n      }\n    }\n  }\n}\n","import { isEqualDefault, type IsEqual } from '../../IsEqual.js';\nimport {\n  toStringDefault,\n  defaultComparer,\n  type ToString,\n} from '../../Util.js';\nimport type { IWithEntries } from './IMappish.js';\n\n// ✔ UNIT TESTED!\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (\n  data: ReadonlyMap<number, any>,\n  target: number\n): number => {\n  target = Math.round(target);\n  if (data.has(target)) {\n    return target;\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let offset = 1;\n    while (offset < 1000) {\n      if (data.has(target - offset)) return target - offset;\n      else if (data.has(target + offset)) return target + offset;\n      offset++;\n    }\n    throw new Error(`Could not find target ${ target }`);\n  }\n};\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  if (!map.has(key)) return false;\n  const values = [ ...map.values() ];\n  return values.some((v) => comparer(v, value));\n};\n\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\"\n *\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * Maps.deleteByValue(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer\n */\nexport const deleteByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n) => {\n  for (const entry of Object.entries(map)) {\n    if (comparer(entry[ 1 ], value)) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      (map as any).delete(entry[ 0 ]);\n    }\n  }\n};\n\n\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByIterablePredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByIterableValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByIterablePredicate = <K, V>(\n  map: IWithEntries<K, V>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (predicate(entry[ 1 ], entry[ 0 ])) return entry;\n  }\n};\n\n/**\n * Finds first entry by iterable value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByIterableValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByIterablePredicate} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByIterableValue = <K, V>(\n  map: IWithEntries<K, V>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (isEqual(entry[ 1 ], value)) return entry;\n  }\n};\n\n\n\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link Util.ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n *\n * @example\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\";\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * Maps.addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\nexport const addKeepingExisting = <V>(\n  set: ReadonlyMap<string, V> | undefined,\n  hasher: ToString<V>,\n  ...values: ReadonlyArray<V>\n) => {\n  const s = set === undefined ? new Map() : new Map(set);\n  for (const v of values) {\n    const hashResult = hasher(v);\n    if (s.has(hashResult)) continue;\n    s.set(hashResult, v);\n  }\n  return s;\n};\n\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  comparer?: (a: V, b: V) => number\n) => {\n  const f = comparer ?? defaultComparer;\n  [ ...map.entries() ].sort((a, b) => f(a[ 1 ], b[ 1 ]));\n};\n\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * cosnt m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = Maps.sortByValue(m, `name`);\n * ```\n * @param map Map to sort\n * @param prop Property of value\n * @param compareFn Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = <K, V, Z>(\n  map: ReadonlyMap<K, V>,\n  property: string,\n  compareFunction?: (a: Z, b: Z) => number\n) => {\n  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n  return [ ...map.entries() ].sort((aE, bE) => {\n    const a = aE[ 1 ];\n    const b = bE[ 1 ];\n    // @ts-expect-error\n    return cfn(a[ property ], b[ property ]);\n  });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  const entries = [ ...map.entries() ];\n  return entries.some((kv) => comparer(kv[ 1 ], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\n//eslint-disable-next-line func-style\nexport function* filter<V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = <V>(map: ReadonlyMap<string, V>): ReadonlyArray<V> =>\n  [ ...map.values() ];\n\n\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` }\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = Maps.fromIterable(data, v => v.fruit);\n * ```\n * @param data Input data\n * @param keyFn Function which returns a string id. By default uses the JSON value of the object.\n * @param allowOverwrites When set to _true_, items with same id will silently overwrite each other, with last write wins. _false_ by default.\n * @returns\n */\nexport const fromIterable = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>,\n  allowOverwrites = false\n): ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const id = keyFunction(d);\n    if (m.has(id) && !allowOverwrites) {\n      throw new Error(\n        `id ${ id } is already used and new data will overwrite it. `\n      );\n    }\n    m.set(id, d);\n  }\n  return m;\n};\n\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = Maps.fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObject}.\n * @param data\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const fromObject = <V>(data: any): ReadonlyMap<string, V> => {\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\n  const map = new Map<string, V>();\n  if (Array.isArray(data)) {\n    for (const d of data) addObject<V>(map, d);\n  } else {\n    addObject<V>(map, data);\n  }\n  return map;\n};\n\n/**\n * Adds an object to an existing map. It assumes a structure where\n * each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = new Map();\n * Maps.addObject(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const addObject = <V>(map: Map<string, V>, data: any) => {\n  const entries = Object.entries(data);\n  for (const [ key, value ] of entries) {\n    map.set(key, value as V);\n  }\n};\n/**\n * Returns the first found item that matches `predicate` or _undefined_.\n *\n * If you want all matches, use {@link filter}.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching item\n * @returns Found item or _undefined_\n */\nexport const find = <V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n): V | undefined => [ ...map.values() ].find(v => predicate(v));\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const mapToObjectTransform = <T, K>(\n  m: ReadonlyMap<string, T>,\n  valueTransform: (value: T) => K\n): Readonly<Record<string, K>> =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, unicorn/no-array-reduce\n  [ ...m ].reduce((object: any, [ key, value ]) => {\n    const t = valueTransform(value);\n    /* eslint-disable-next-line functional/immutable-data */\n    object[ key ] = t;\n    return object;\n  }, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = <V>(\n  keys: ReadonlyArray<string>,\n  values: ArrayLike<V | undefined>\n) => {\n  if (keys.length !== values.length) {\n    throw new Error(`Keys and values arrays should be same length`);\n  }\n  return Object.fromEntries(keys.map((k, index) => [ k, values[ index ] ]));\n};\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = <K, V, R>(\n  source: ReadonlyMap<K, V>,\n  transformer: (value: V, key: K) => R\n) => new Map(Array.from(source, (v) => [ v[ 0 ], transformer(v[ 1 ], v[ 0 ]) ]));\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport const toObject = <T>(\n  m: ReadonlyMap<string, T>\n): Readonly<Record<string, T>> =>\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  [ ...m ].reduce((object: any, [ key, value ]) => {\n    /* eslint-disable-next-line functional/immutable-data */\n    object[ key ] = value;\n    return object;\n  }, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = <K, V, R>(\n  m: ReadonlyMap<K, V>,\n  transformer: (key: K, item: V) => R\n): ReadonlyArray<R> => [ ...m.entries() ].map((x) => transformer(x[ 0 ], x[ 1 ]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also [Arrays.mergeByKey](functions/Collections.Arrays.mergeByKey.html) if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = <K, V>(\n  reconcile: MergeReconcile<V>,\n  ...maps: ReadonlyArray<ReadonlyMap<K, V>>\n): ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [ mk, mv ] of m) {\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return result;\n};\n","import { type RandomSource, defaultRandom } from \"./Types.js\";\n\n/**\n* Returns a random number from 0..weightings.length, distributed by the weighting values.\n* \n* eg: produces 0 20% of the time, 1 50% of the time, 2 30% of the time\n* ```js\n* weightedIndex([0.2, 0.5, 0.3]);\n* ```\n* @param weightings \n* @param rand \n* @returns \n*/\nexport const weightedIndex = (weightings: Array<number>, rand: RandomSource = defaultRandom): () => number => {\n  const precompute: Array<number> = [];\n  let total = 0;\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let index = 0; index < weightings.length; index++) {\n    total += weightings[ index ];\n    precompute[ index ] = total;\n  }\n  if (total !== 1) throw new Error(`Weightings should add up to 1. Got: ${ total }`);\n\n  return (): number => {\n    const v = rand();\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < precompute.length; index++) {\n      if (v <= precompute[ index ]) return index;\n    }\n    throw new Error(`Bug: weightedIndex could not select index`);\n  }\n}","/**\n * Throws an error if `array` parameter is not a valid array\n *\n * ```js\n * import { guardArray } from 'https://unpkg.com/ixfx/dist/arrays.js';\n * guardArray(someVariable);\n * ```\n * @private\n * @param array\n * @param name\n */\nexport const guardArray = <V>(array: ArrayLike<V>, name = `?`) => {\n  if (array === undefined) {\n    throw new TypeError(`Param '${ name }' is undefined. Expected array.`);\n  }\n  if (array === null) {\n    throw new TypeError(`Param '${ name }' is null. Expected array.`);\n  }\n  if (!Array.isArray(array)) {\n    throw new TypeError(`Param '${ name }' not an array as expected`);\n  }\n};\n","import { guardArray } from \"./GuardArray.js\";\nimport { throwIntegerTest } from '../Guards.js';\n/**\n * Throws if `index` is an invalid array index for `array`, and if\n * `array` itself is not a valid array.\n * @param array\n * @param index\n */\nexport const guardIndex = <V>(\n  array: ArrayLike<V>,\n  index: number,\n  name = `index`\n) => {\n  guardArray(array);\n  throwIntegerTest(index, `positive`, name);\n  if (index > array.length - 1) {\n    throw new Error(\n      `'${ name }' ${ index } beyond array max of ${ array.length - 1 }`\n    );\n  }\n};","import { type IsEqual, isEqualValueDefault } from \"../../IsEqual.js\";\n\n/**\n * Returns _true_ if the contents of the array are all the same.\n * Uses value-based equality checking by default.\n * \n * @example Uses default equality function:\n * ```js\n * import { valuesEqual } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a1 = [ 10, 10, 10 ];\n * valuesEqual(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * valuesEqual(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * valuesEqual(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const valuesEqual = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  array: ReadonlyArray<V> | Array<V>,\n  equality?: IsEqual<V>\n): boolean => {\n  // Unit tested\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","/**\n * Returns a section from an iterable\n * @param it Iterable\n * @param start Start index\n * @param end End index (or until completion)\n */\n//eslint-disable-next-line func-style\nexport function* slice<V>(\n  it: Iterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.iterator ]();\n\n  for (; start > 0; start--, end--) iit.next();\n\n  for (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n","import { guardArray } from \"./GuardArray.js\";\nimport { guardIndex } from \"./GuardIndex.js\";\n\n/**\n * Return elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = filterBetween(people, person => person.registered, 5, 10);\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport const filterBetween = <V>(\n  array: ReadonlyArray<V> | Array<V>,\n  predicate: (\n    value: V,\n    index: number,\n    array: ReadonlyArray<V> | Array<V>\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Array<V> => {\n  guardArray(array);\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n  guardIndex(array, startIndex, `startIndex`);\n  guardIndex(array, endIndex - 1, `endIndex`);\n\n  const t: Array<V> = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = startIndex; index < endIndex; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    if (predicate(array[ index ], index, array)) t.push(array[ index ]);\n  }\n  return t;\n};","import { slice } from '../iterable/SliceSync.js';\nimport { filterBetween } from './FilterBetween.js';\n\nexport type MinMaxAvgTotal = {\n  /**\n   * Smallest value in array\n   */\n  readonly min: number;\n  /**\n   * Total of all items\n   */\n  readonly total: number;\n  /**\n   * Largest value in array\n   */\n  readonly max: number;\n  /**\n   * Average value in array\n   */\n  readonly avg: number;\n};\n\nexport type MinMaxAvgOpts = {\n  /**\n   * Start index, inclusive\n   */\n  readonly startIndex?: number;\n  /**\n   * End index, exclusive\n   */\n  readonly endIndex?: number;\n};\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * const v = [10, 2, 4.2, 99];\n * const mma = Arrays.minMaxAvg(v);\n * Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link average}, {@link max}, {@link min} or {@link total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * Arrays.minMaxAvg(count(5,1)); // Averages 1,2,3,4,5\n * ```\n * @param data\n * @param opts Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const minMaxAvg = (\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<number> | Array<number> | Iterable<number>,\n  opts: MinMaxAvgOpts = {}\n): MinMaxAvgTotal => {\n  if (data === undefined) throw new Error(`'data' is undefined`);\n  if (!Array.isArray(data)) {\n    if (`next` in data) {\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      if (opts.startIndex || opts.endIndex) {\n        data = slice(data, opts.startIndex, opts.endIndex);\n      }\n      //eslint-disable-next-line functional/no-let\n      let total = 0;\n      //eslint-disable-next-line functional/no-let\n      let min = Number.MAX_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let max = Number.MIN_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let samples = 0;\n      for (const v of data) {\n        if (typeof v !== `number`) {\n          throw new TypeError(`Generator should yield numbers. Got: ${ typeof v }`);\n        }\n        total += v;\n        samples++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n      }\n      return {\n        avg: total / samples,\n        total,\n        max,\n        min,\n      };\n    } else {\n      throw new Error(`'data' parameter is neither array or iterable`);\n    }\n  }\n\n  if (data.length === 0) {\n    return {\n      total: 0,\n      min: 0,\n      max: 0,\n      avg: 0,\n    };\n  }\n  const startIndex = opts.startIndex ?? 0;\n  const endIndex = opts.endIndex ?? data.length;\n\n  const validNumbers = filterBetween<number>(\n    data,\n    (d) => typeof d === `number` && !Number.isNaN(d),\n    startIndex,\n    endIndex\n  );\n  const total = validNumbers.reduce((accumulator, v) => accumulator + v, 0);\n  return {\n    total: total,\n    max: Math.max(...validNumbers),\n    min: Math.min(...validNumbers),\n    avg: total / validNumbers.length,\n  };\n};\n","export {\n  minMaxAvg,\n  type MinMaxAvgOpts,\n  type MinMaxAvgTotal,\n} from '../MinMaxAvg.js';\n\n\n/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * // Six items\n * Arrays.weight([1,1,1,1,1,1], Easings.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an {@link Modulation.Easings.EasingFn}. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * Arrays.weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Non-numbers in `data` will be silently ignored (this filtering happens first, so relative index values are sane still).\n *\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (\n  data: Array<number> | ReadonlyArray<number>,\n  fn?: (relativePos: number) => number\n): Array<number> => {\n  const f = fn ?? ((x: number) => x);\n  return validNumbers(data).map(\n    (v: number, index: number) => v * f(index / (validNumbers.length - 1))\n  );\n};\n\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data: ReadonlyArray<number>) =>\n  data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n\n/**\n * Returns the dot product of two arbitrary-sized arrays. Assumed they are of the same length.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (\n  values: ReadonlyArray<ReadonlyArray<number>>\n): number => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  const length = values[ 0 ].length;\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < length; index++) {\n    //eslint-disable-next-line functional/no-let\n    let t = 0;\n    //eslint-disable-next-line functional/no-let\n    for (const [ p, value ] of values.entries()) {\n      if (p === 0) t = value[ index ];\n      else {\n        t *= value[ index ];\n      }\n    }\n    r += t;\n  }\n  return r;\n};\n\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link minMaxAvg} if you want min, max and total as well.\n *\n * @example\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * // Average of a list\n * const avg = Arrays.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * let data = [100,200];\n * Arrays.average(data);\n * ```\n *\n * See also: [Numbers.average](Numbers.average.html) which takes a list of parameters\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data: ReadonlyArray<number>): number => {\n  // ✔ UNIT TESTED\n  if (data === undefined) throw new Error(`data parameter is undefined`);\n  const valid = validNumbers(data);\n  const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n  return total / valid.length;\n};\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data: ReadonlyArray<number>): number =>\n  Math.min(...validNumbers(data));\n\n/**\n * Returns the index of the largest value.\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * const v = [ 10, 40, 5 ];\n * Arrays.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value > array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * const v = [ 10, 40, 5 ];\n * Arrays.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value < array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data: ReadonlyArray<number>): number =>\n  Math.max(...validNumbers(data));\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce((previous, current) => {\n    if (typeof current !== `number`) return previous;\n    if (Number.isNaN(current)) return previous;\n    if (Number.isFinite(current)) return previous;\n    return previous + current;\n  }, 0);\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const maxFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = Number.MIN_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m = Math.max(m, datum);\n  }\n  return m;\n};\n\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const totalFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = 0;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m += datum;\n  }\n  return m;\n};\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const minFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = Number.MIN_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m = Math.min(m, datum);\n  }\n  return m;\n};\n","\n/**\n * Cycle through the contents of an array. By default starts at index 0.\n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n * \n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n * \n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n * \n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over \n * @returns \n */\nexport const cycle = <T>(options: ReadonlyArray<T> | Array<T>) => {\n  const opts = [ ...options ];\n  let index = 0;\n  const next = () => {\n    index++;\n    if (index === opts.length) index = 0;\n    return value();\n  }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  const prev = () => {\n    index--;\n    if (index === -1) index = opts.length - 1;\n    return value();\n  }\n\n  const value = (): typeof opts[ number ] => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return opts.at(index)!;\n  }\n\n  const select = (indexOrValue: number | typeof opts[ number ]) => {\n    if (typeof indexOrValue === `number`) {\n      index = indexOrValue;\n    } else {\n      const found = opts.indexOf(indexOrValue);\n      if (found === -1) throw new Error(`Could not find value`);\n      index = found;\n    }\n  }\n\n  const toArray = () => [ ...opts ];\n  return { toArray, next, prev, get current() { return value() }, select }\n}","import { valuesEqual } from \"./ValuesEqual.js\";\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { zip } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\n\n\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const zip = (\n  ...arrays: Array<Array<any>> | ReadonlyArray<Array<any>> | ReadonlyArray<ReadonlyArray<any>>\n): Array<any> => {\n  // Unit tested\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => a.length);\n  if (!valuesEqual(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","import { zip } from './Zip.js';\nimport { weight } from './NumericArrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * // All items weighted evenly\n * Arrays.averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * Arrays.averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * Arrays.averageWeighted[1,2,3], Easings.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * import { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * const data = [1,2,3];\n * const w = Arrays.weight(data, Easings.gaussian());\n * const avg = Arrays.averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n */\nexport const averageWeighted = (\n  data: Array<number> | ReadonlyArray<number>,\n  weightings: Array<number> | ReadonlyArray<number> | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n\n  const ww = zip(data, weightings);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const [ totalV, totalW ] = ww.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    (accumulator, v: Array<number>) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","import { guardArray } from '../GuardArray.js';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: ReadonlyArray<V> | Array<V>,\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  guardArray(data, `data`);\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});","import { isEqualDefault } from '../IsEqual.js'\n\nexport const max = <V>(iterable: Iterable<V>, scorer: (v: V) => number): V | undefined => {\n  let highestValue: V | undefined;\n  let highestScore = Number.MIN_SAFE_INTEGER;\n  for (const value of iterable) {\n    const score = scorer(value);\n    if (score >= highestScore) {\n      highestScore = score;\n      highestValue = value;\n    }\n  }\n  return highestValue;\n}\n\nexport const min = <V>(iterable: Iterable<V>, scorer: (v: V) => number): V | undefined => {\n  let lowestValue: V | undefined;\n  let lowestScore\n    = Number.MAX_SAFE_INTEGER;\n  for (const value of iterable) {\n    const score = scorer(value);\n    if (score <= lowestScore) {\n      lowestScore = score;\n      lowestValue = value;\n    }\n  }\n  return lowestValue;\n}\n\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n * \n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * compareValuesEqual(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * compareValuesEqual(a, b); \n * // True, since now we're comparing by value\n * compareValuesEqual(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param arrays\n * @param eq\n */\nexport const compareValuesEqual = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  iterableA: Iterable<V>,\n  iterableB: Iterable<V>,\n  eq = isEqualDefault<V>\n): boolean => {\n  const returnValue = compareValues(iterableA, iterableB, eq);\n  return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n\n\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common, and those unique in `a` or `b`.\n * Ignores ordering of values.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValues(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareValues = <V>(\n  a: Iterable<V>,\n  b: Iterable<V>,\n  eq = isEqualDefault<V>\n) => {\n  const shared = [];\n  const aUnique = [];\n  const bUnique = [];\n\n  for (const element of a) {\n    //eslint-disable-next-line functional/no-let\n    let seenInB = false;\n    for (const element_ of b) {\n      if (eq(element, element_)) {\n        seenInB = true;\n        break;\n      }\n    }\n    if (seenInB) {\n      //eslint-disable-next-line functional/immutable-data\n      shared.push(element);\n    } else {\n      //eslint-disable-next-line functional/immutable-data\n      aUnique.push(element);\n    }\n  }\n\n  for (const element of b) {\n    //eslint-disable-next-line functional/no-let\n    let seenInA = false;\n    for (const element_ of a) {\n      if (eq(element, element_)) {\n        seenInA = true;\n      }\n    }\n    if (!seenInA) {\n      //eslint-disable-next-line functional/immutable-data\n      bUnique.push(element);\n    }\n  }\n\n  return {\n    shared,\n    a: aUnique,\n    b: bUnique,\n  };\n};\n"],"mappings":"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","names":["mergeByKey","isEqual","total","total","min","max","validNumbers","total","toArray","max","min","max","min","total","mergeByKey","filter","isEqual"]}