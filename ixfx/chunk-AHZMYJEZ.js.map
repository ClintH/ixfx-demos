{"version":3,"sources":["../src/audio/index.ts","../src/audio/Analyser.ts","../src/audio/AudioVisualiser.ts","../src/temporal/Tracker.ts"],"sourcesContent":["export * as Analysers from './Analyser.js';\r\nexport * as Visualiser from './AudioVisualiser.js';","import {Arrays} from \"../collections/index.js\";\r\nimport AudioVisualiser from \"./AudioVisualiser.js\";\r\nimport {number as guardNumber, integer as guardInteger} from \"../Guards.js\";\r\nimport {isPowerOfTwo} from \"~/Util.js\";\r\n\r\n/**\r\n * Options for audio processing\r\n * \r\n * fftSize: Must be a power of 2, from 32 - 32768. Higher number means\r\n * more precision and higher CPU overhead\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\r\n * \r\n * smoothingTimeConstant: Range from 0-1, default is 0.8.\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\r\n * \r\n * debug: If true, additonal console logging will happen\r\n */\r\nexport type Opts = Readonly<{\r\n  readonly showVis?:boolean\r\n  /**\r\n   * FFT size. Must be a power of 2, from 32 - 32768. Higher number means\r\n   * more precision and higher CPU overhead\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\r\n   */\r\n  readonly fftSize?:number\r\n  /**\r\n   * Range from 0-1, default is 0.8\r\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\r\n   */\r\n  readonly smoothingTimeConstant?:number\r\n  readonly debug?:boolean\r\n}>;\r\n\r\nexport type DataAnalyser = (node:AnalyserNode, analyser:Analyser) => void;\r\n\r\n/**\r\n * Basic audio analyser. Returns back waveform and FFT analysis. Use {@link peakLevel} if you want sound level, or {@link freq} if you just want FFT results.\r\n * \r\n * ```js\r\n * const onData = (freq, wave, analyser) => {\r\n *  // Demo: Get FFT results just for 100Hz-1KHz.\r\n *  const freqSlice = analyser.sliceByFrequency(100,1000,freq);\r\n * \r\n *  // Demo: Get FFT value for a particular frequency (1KHz)\r\n *  const amt = freq[analyser.getIndexForFrequency(1000)];\r\n * }\r\n * basic(onData, {fftSize: 512});\r\n * ```\r\n * \r\n * An `Analyser` instance is returned and can be controlled:\r\n * ```js\r\n * const analyser = basic(onData);\r\n * analyser.paused = true;\r\n * ```\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler. \r\n * \r\n * @param onData Handler for data\r\n * @param opts Options\r\n * @returns Analyser instance\r\n */\r\nexport const basic = (onData:(freq:Float32Array, wave:Float32Array, analyser:Analyser) => void, opts:Opts = {}):Analyser => new Analyser((node, analyser) => {\r\n  // Get frequency and amplitude data\r\n  const freq = new Float32Array(node.frequencyBinCount);\r\n  const wave = new Float32Array(node.fftSize);\r\n\r\n  // Load arrays with data\r\n  node.getFloatFrequencyData(freq);\r\n  node.getFloatTimeDomainData(wave);\r\n\r\n  // Send back\r\n  onData(freq, wave, analyser);\r\n}, opts);\r\n\r\n/**\r\n * Basic audio analyser. Returns FFT analysis. Use {@link peakLevel} if you want the sound level, or {@link basic} if you also want the waveform.\r\n * \r\n * ```js\r\n * const onData = (freq, analyser) => {\r\n *  // Demo: Print out each sound frequency (Hz) and amount of energy in that band\r\n *  for (let i=0;i<freq.length;i++) {\r\n *    const f = analyser.getFrequencyAtIndex(0);\r\n *    console.log(`${i}. frequency: ${f} amount: ${freq[i]}`);\r\n *  }\r\n * }\r\n * freq(onData, {fftSize:512});\r\n * ```\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler. \r\n * \r\n * @param onData \r\n * @param opts \r\n * @returns \r\n */\r\nexport const freq = (onData:(freq:Float32Array, analyser:Analyser)=>void, opts:Opts={}):Analyser => new Analyser((node, analyser) => {\r\n  const freq = new Float32Array(node.frequencyBinCount);\r\n  node.getFloatFrequencyData(freq);\r\n  onData(freq, analyser);\r\n}, opts);\r\n\r\n/**\r\n * Basic audio analyser which reports the peak sound level.\r\n * \r\n * ```js\r\n * peakLevel(level => {\r\n *  console.log(level);\r\n * });\r\n * ```\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler. \r\n * @param onData \r\n * @param opts \r\n * @returns \r\n */\r\nexport const peakLevel = (onData:(level:number, analyser:Analyser)=>void, opts:Opts={}):Analyser => new Analyser((node, analyser) => {\r\n  const wave = new Float32Array(node.fftSize);\r\n  node.getFloatTimeDomainData(wave);\r\n  onData(Arrays.maxFast(wave), analyser);\r\n}, opts);\r\n\r\n/**\r\n * Helper for doing audio analysis. It takes case of connecting the audio stream, running in a loop and pause capability.\r\n * \r\n * Provide a function which works with an [AnalyserNode](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode), and does something with the result.\r\n * ```js\r\n * const myAnalysis = (node, analyser) => {\r\n *  const freq = new Float32Array(node.frequencyBinCount);\r\n *  node.getFloatFrequencyData(freq);\r\n *  // Do something with frequency data...\r\n * }\r\n * const a = new Analyser(myAnalysis);\r\n * ```\r\n * \r\n * Two helper functions provide ready-to-use Analysers:\r\n * * {@link peakLevel} peak decibel reading\r\n * * {@link freq} FFT results\r\n * * {@link basic} FFT results and waveform\r\n * \r\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\r\n *\r\n */\r\nexport class Analyser {\r\n  showVis:boolean;\r\n  fftSize:number;\r\n  smoothingTimeConstant:number;\r\n  #isPaused = false;\r\n  debug:boolean;\r\n  #initInProgress = false;\r\n\r\n  visualiser:AudioVisualiser|undefined;  \r\n  audioCtx:AudioContext|undefined;\r\n  analyserNode:AnalyserNode|undefined;\r\n\r\n  analyse:DataAnalyser;\r\n\r\n  constructor(analyse:DataAnalyser, opts:Opts = {}) {\r\n    this.showVis = opts.showVis ?? false;\r\n    this.fftSize = opts.fftSize ?? 1024;\r\n    this.debug = opts.debug ?? false;\r\n    this.smoothingTimeConstant = opts.smoothingTimeConstant ?? 0.8;\r\n\r\n    guardInteger(this.fftSize, `positive`, `opts.fftSize`);\r\n    guardNumber(this.smoothingTimeConstant, `percentage`, `opts.smoothingTimeConstant`);\r\n\r\n    if (!isPowerOfTwo(this.fftSize)) throw new Error(`fftSize must be a power of two from 32 to 32768 (${this.fftSize})`);\r\n    if(this.fftSize < 32) throw new Error(`fftSize must be at least 32`);\r\n    if (this.fftSize > 32768) throw new Error(`fftSize must be no greater than 32768`);\r\n\r\n    this.analyse = analyse;\r\n    this.paused = false;\r\n\r\n    this.init();\r\n\r\n    const visualiserEl = document.getElementById(`audio-visualiser`);\r\n    if (visualiserEl) {\r\n      const visualiser = new AudioVisualiser(visualiserEl, this);\r\n      visualiser.setExpanded(this.showVis);\r\n      this.visualiser = visualiser;\r\n    }\r\n  }\r\n\r\n  init() {\r\n    if (this.#initInProgress) {\r\n      if (this.debug) console.debug(`Init already in progress`);\r\n      return;\r\n    }\r\n    this.#initInProgress = true;\r\n\r\n    // Initalise microphone\r\n    navigator.mediaDevices.getUserMedia({audio: true})\r\n      .then(stream => {     \r\n        this.onMicSuccess(stream);\r\n      })\r\n      .catch(err => {\r\n        this.#initInProgress = false;\r\n        console.error(err);\r\n      });\r\n  }\r\n\r\n  get paused():boolean {\r\n    return this.#isPaused;\r\n  }\r\n\r\n  set paused(v:boolean) {\r\n    if (v === this.#isPaused) return;\r\n    this.#isPaused = v;\r\n    if (!v) {\r\n      if (this.debug) console.log(`Unpaused`);\r\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\r\n    } else {\r\n      if (this.debug) console.log(`Paused`);\r\n    }\r\n  }\r\n\r\n  private setup(audioCtx:AudioContext, stream:MediaStream) {\r\n    const analyser = audioCtx.createAnalyser();\r\n\r\n    // fftSize must be a power of 2. Higher values slower, more detailed\r\n    // Range is 32-32768\r\n    analyser.fftSize = this.fftSize;\r\n\r\n    // smoothingTimeConstant ranges from 0.0 to 1.0\r\n    // 0 = no averaging. Fast response, jittery\r\n    // 1 = maximum averaging. Slow response, smooth\r\n    analyser.smoothingTimeConstant = this.smoothingTimeConstant;\r\n\r\n    // Microphone -> analyser\r\n    const micSource = audioCtx.createMediaStreamSource(stream);\r\n    micSource.connect(analyser);\r\n    return analyser;\r\n  }\r\n\r\n  // Microphone successfully initalised, now have access to audio data\r\n  private onMicSuccess(stream:MediaStream) {\r\n    try {\r\n      const audioCtx = new AudioContext();\r\n\r\n      audioCtx.addEventListener(`statechange`, () => {\r\n        if (this.debug) console.log(`Audio context state: ${audioCtx.state}`);\r\n      });\r\n\r\n      this.audioCtx = audioCtx;\r\n      this.analyserNode = this.setup(audioCtx, stream);\r\n\r\n      // Start loop\r\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\r\n    } catch (ex) {\r\n      this.#initInProgress = false;\r\n      console.error(ex);\r\n    }\r\n  }\r\n\r\n  private analyseLoop() {\r\n    if (this.paused) {\r\n      if (this.debug) console.log(`Paused`);\r\n      return;\r\n    }\r\n\r\n    const a = this.analyserNode;\r\n    if (a === undefined) {\r\n      console.warn(`Analyser undefined`);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Perform analysis\r\n      this.analyse(a, this);\r\n    } catch (e) {\r\n      console.error(e);\r\n    }\r\n\r\n    // Run again\r\n    window.requestAnimationFrame(this.analyseLoop.bind(this));\r\n  }\r\n\r\n  // visualise(wave, freq) {\r\n  //   if (!this.visualiser) return;\r\n  //   this.visualiser.renderWave(wave, true);\r\n  //   this.visualiser.renderFreq(freq);\r\n  // }\r\n\r\n  /**\r\n   * Returns the maximum FFT value within the given frequency range\r\n   */\r\n  getFrequencyRangeMax(lowFreq:number, highFreq:number, freqData:readonly number[]):number {\r\n    const samples = this.sliceByFrequency(lowFreq, highFreq, freqData);\r\n    return Arrays.max(...samples);\r\n  }\r\n\r\n  /**\r\n   * Returns a sub-sampling of frequency analysis data that falls between\r\n   * `lowFreq` and `highFreq`.\r\n   * @param lowFreq Low frequency\r\n   * @param highFreq High frequency\r\n   * @param freqData Full-spectrum frequency data\r\n   * @returns Sub-sampling of analysis\r\n   */\r\n  sliceByFrequency(lowFreq:number, highFreq:number, freqData:readonly number[]) {\r\n    const lowIndex = this.getIndexForFrequency(lowFreq);\r\n    const highIndex = this.getIndexForFrequency(highFreq);\r\n\r\n    // Grab a 'slice' of the array between these indexes\r\n    const samples = freqData.slice(lowIndex, highIndex);\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * Returns the starting frequency for a given binned frequency index.\r\n   * @param index Array index\r\n   * @returns Sound frequency\r\n   */\r\n  getFrequencyAtIndex(index:number):number {\r\n    const a = this.analyserNode;\r\n    const ctx = this.audioCtx;\r\n    if (a === undefined) throw new Error(`Analyser not available`);\r\n    if (ctx === undefined) throw new Error(`Audio context not available`);\r\n\r\n    guardInteger(index, `positive`, `index`);\r\n    if (index > a.frequencyBinCount) throw new Error(`Index ${index} exceeds frequency bin count ${a.frequencyBinCount}`);\r\n\r\n    return index * ctx.sampleRate / (a.frequencyBinCount * 2);\r\n  }\r\n\r\n  /**\r\n   * Returns a binned array index for a given frequency\r\n   * @param freq Sound frequency\r\n   * @returns Array index into frequency bins\r\n   */\r\n  getIndexForFrequency(freq:number):number {\r\n    const a = this.analyserNode;\r\n    if (a === undefined) throw new Error(`Analyser not available`);\r\n\r\n    const nyquist = a.context.sampleRate / 2.0;\r\n    const index = Math.round(freq / nyquist * a.frequencyBinCount);\r\n    if (index < 0) return 0;\r\n    if (index >= a.frequencyBinCount) return a.frequencyBinCount - 1;\r\n    return index;\r\n  }\r\n}","/**\r\n * Visualiser component\r\n *\r\n * Usage: import visualiser.js. Instantiate on document load, and pass in the\r\n * parent element into the constructor.\r\n *\r\n * eg: const v = new Visualiser(document.getElementById('renderer'));\r\n *\r\n * Data must be passed to the component via renderFreq or renderWave.\r\n * \r\n * Draws on https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\r\n */\r\n\r\nimport {Arrays} from '~/collections/index.js';\r\nimport {Points} from '../geometry/index.js';\r\nimport {Tracker} from '../temporal/Tracker.js';\r\nimport {Analyser} from './Analyser.js';\r\n\r\n// TODO: This is an adaption of old code. Needs to be smartened up further\r\nexport default class Visualiser {\r\n  freqMaxRange = 200;\r\n  audio:Analyser;\r\n  parent:HTMLElement;\r\n \r\n  lastPointer:Points.Point = {x:0, y:0};\r\n  pointerDown = false;\r\n  pointerClicking = false;\r\n  pointerClickDelayMs = 100;\r\n  pointerDelaying = false;\r\n\r\n  waveTracker:Tracker;\r\n  freqTracker:Tracker;\r\n  el:HTMLElement;\r\n\r\n  constructor(parentElem:HTMLElement, audio:Analyser) {\r\n    this.audio = audio;\r\n    this.parent = parentElem;\r\n    this.waveTracker = new Tracker(`wave`);\r\n    this.freqTracker = new Tracker(`freq`);\r\n   \r\n    // Add HTML\r\n    parentElem.innerHTML = `\r\n    <section>\r\n      <button id=\"rendererComponentToggle\">ðŸ”¼</button>\r\n      <div>\r\n        <h1>Visualiser</h1>\r\n        <div style=\"display:flex; flex-wrap: wrap\">\r\n          <div class=\"visPanel\">\r\n            <h2>Frequency distribution</h2>\r\n            <br />\r\n            <canvas id=\"rendererComponentFreqData\" height=\"200\" width=\"400\"></canvas>\r\n          </div>\r\n          <div class=\"visPanel\">\r\n            <h2>Waveform</h2>\r\n            <button id=\"rendererComponentWaveReset\">Reset</button>\r\n            <div>\r\n              Press and hold on wave to measure\r\n            </div>\r\n            <br />\r\n            <canvas id=\"rendererComponentWaveData\" height=\"200\" width=\"400\"></canvas>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </section>\r\n    `;\r\n    this.el = parentElem.children[0] as HTMLElement;\r\n\r\n    document.getElementById(`rendererComponentToggle`)?.addEventListener(`click`, () => {\r\n      this.setExpanded(!this.isExpanded());\r\n    });\r\n    this.el.addEventListener(`pointermove`, (e) => this.onPointer(e));\r\n    //this.el.addEventListener(`touchbegin`, (e) => this.onPointer(e));\r\n    this.el.addEventListener(`pointerup`, () => { \r\n      this.pointerDelaying = false; \r\n      this.pointerDown = false;\r\n    });\r\n    this.el.addEventListener(`pointerdown`, () => {\r\n      this.pointerDelaying = true;\r\n      setTimeout(() => {\r\n        if (this.pointerDelaying) { this.pointerDelaying = false; this.pointerDown = true; }\r\n      }, this.pointerClickDelayMs);\r\n    });\r\n    this.el.addEventListener(`pointerleave`, () => { \r\n      this.pointerDelaying = false; \r\n      this.pointerDown = false; });\r\n\r\n    document.getElementById(`rendererComponentWaveReset`)?.addEventListener(`click`, () => {\r\n      this.clear();\r\n    });\r\n  }\r\n\r\n  renderFreq(freq:readonly number[]) {\r\n    if (!this.isExpanded()) return; // Don't render if collapsed\r\n    if (!freq) return; // Data is undefined/null\r\n\r\n    const canvas = document.getElementById(`rendererComponentFreqData`) as HTMLCanvasElement;\r\n    if (canvas === null) throw new Error(`Cannot find canvas element`);\r\n    const g = canvas.getContext(`2d`);\r\n    if (g === null) throw new Error(`Cannot create drawing context`);\r\n\r\n    const bins = freq.length;\r\n    const canvasWidth = canvas.clientWidth;\r\n    const canvasHeight = canvas.clientHeight;\r\n    g.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n    const pointer = this.getPointerRelativeTo(canvas);\r\n    const width = (canvasWidth / bins);\r\n    const minMax = Arrays.minMaxAvg(freq);\r\n\r\n    //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let i = 0; i < bins; i++) {\r\n      if (!Number.isFinite(freq[i])) continue;\r\n\r\n      const value = freq[i] - minMax.min;\r\n      const valueRelative = value / this.freqMaxRange;\r\n      const height = Math.abs(canvasHeight * valueRelative);\r\n      const offset = canvasHeight - height;\r\n\r\n      const hue = i / bins * 360;\r\n      const left = i * width;\r\n      g.fillStyle = `hsl(` + hue + `, 100%, 50%)`;\r\n\r\n      // Show info about data under pointer\r\n      if (pointer.y > 0 && pointer.y <= canvasHeight && pointer.x >= left && pointer.x <= left + width) {\r\n        // Keep track of data\r\n        if (this.freqTracker.id !== i.toString()) {\r\n          this.freqTracker.reset(i.toString());\r\n        }\r\n        this.freqTracker.seen(freq[i]);\r\n\r\n        const freqMma = this.freqTracker.getMinMaxAvg();\r\n\r\n        // Display\r\n        g.fillStyle = `black`;\r\n        if (this.audio) { \r\n          g.fillText(`Frequency (${i}) at pointer: ${this.audio.getFrequencyAtIndex(i).toLocaleString(`en`)} - ${this.audio.getFrequencyAtIndex(i + 1).toLocaleString(`en`)}`, 2, 10); \r\n        }\r\n        g.fillText(`Raw value: ${freq[i].toFixed(2)}`, 2, 20);\r\n        g.fillText(`Min: ${freqMma.min.toFixed(2)}`, 2, 40);\r\n        g.fillText(`Max: ${freqMma.max.toFixed(2)}`, 60, 40);\r\n        g.fillText(`Avg: ${freqMma.avg.toFixed(2)}`, 120, 40);\r\n\r\n      }\r\n      g.fillRect(left, offset, width, height);\r\n    }\r\n  }\r\n\r\n  isExpanded() {\r\n    const contentsElem = this.el.querySelector(`div`);\r\n    if (contentsElem === null) throw new Error(`contents div not found`);\r\n    return (contentsElem.style.display === ``);\r\n  }\r\n\r\n  setExpanded(value:boolean) {\r\n    const contentsElem = this.el.querySelector(`div`);\r\n    const button = this.el.querySelector(`button`);\r\n\r\n    if (button === null) throw new Error(`Button element not found`);\r\n    if (contentsElem === null) throw new Error(`Contents element not found`);\r\n    if (value) {\r\n      contentsElem.style.display = ``;\r\n      button.innerText = `ðŸ”¼`;\r\n    } else {\r\n      contentsElem.style.display = `none`;\r\n      button.innerText = `ðŸ”½`;\r\n    }\r\n  }\r\n\r\n  clear() {\r\n    this.clearCanvas(document.getElementById(`rendererComponentFreqData`) as HTMLCanvasElement);\r\n    this.clearCanvas(document.getElementById(`rendererComponentWaveData`) as HTMLCanvasElement);\r\n  }\r\n\r\n  // Clears a canvas to white\r\n  clearCanvas(canvas:HTMLCanvasElement|null) {\r\n    if (canvas === null) throw new Error(`Canvas is null`);\r\n    const g = canvas.getContext(`2d`);\r\n    if (g === null) throw new Error(`Cannot create drawing context`);\r\n    g.fillStyle = `white`;\r\n    g.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);\r\n  }\r\n\r\n  // Renders waveform data.\r\n  // Adapted from MDN's AnalyserNode.getFloatTimeDomainData() example\r\n  renderWave(wave:readonly number[], bipolar = true) {\r\n    if (!this.isExpanded()) return; // Don't render if collapsed\r\n    if (!wave) return; // Undefined or null data\r\n    const canvas = document.getElementById(`rendererComponentWaveData`) as HTMLCanvasElement;\r\n    if (canvas === null) throw new Error(`Cannot find wave canvas`);\r\n    \r\n    const g = canvas.getContext(`2d`);\r\n    if (g === null) throw new Error(`Cannot create drawing context for wave`);\r\n\r\n    const canvasWidth = canvas.clientWidth;\r\n    const canvasHeight = canvas.clientHeight;\r\n    const pointer = this.getPointerRelativeTo(canvas);\r\n    const infoAreaHeight = 20;\r\n    const infoAreaWidth = 60;\r\n    const bins = wave.length;\r\n    g.fillStyle = `white`;\r\n    g.fillRect(0, 0, infoAreaWidth, infoAreaHeight);\r\n\r\n    const width = canvasWidth / bins;\r\n\r\n    // Clears the screen with very light tint of white\r\n    // to fade out last waveform. Set this higher to remove effect\r\n    g.fillStyle = `rgba(255, 255, 255, 0.03)`;\r\n    g.fillRect(0, 20, canvasWidth, canvasHeight);\r\n\r\n    g.fillStyle = `red`;\r\n    if (bipolar) {\r\n      g.fillRect(0, canvasHeight / 2, canvasWidth, 1);\r\n    } else {\r\n      g.fillRect(0, canvasHeight - 1, canvasWidth, 1);\r\n    }\r\n\r\n    g.lineWidth = 1;\r\n    g.strokeStyle = `black`;\r\n    g.beginPath();\r\n\r\n    //eslint-disable-next-line functional/no-let\r\n    let x = 0;\r\n\r\n    //eslint-disable-next-line functional/no-loop-statement,functional/no-let\r\n    for (let i = 0; i < bins; i++) {\r\n      const height = wave[i] * canvasHeight;\r\n      const y = bipolar ? (canvasHeight / 2) - height : canvasHeight - height;\r\n\r\n      if (i === 0) {\r\n        g.moveTo(x, y);\r\n      } else {\r\n        g.lineTo(x, y);\r\n      }\r\n      x += width;\r\n\r\n      if (this.pointerDown) this.waveTracker.seen(wave[i]);\r\n    }\r\n    g.lineTo(canvasWidth, bipolar ? canvasHeight / 2 : canvasHeight);//canvas.height / 2);\r\n    g.stroke();\r\n\r\n    // Draw\r\n    if (this.pointerDown) {\r\n      const waveMma = this.waveTracker.getMinMaxAvg();\r\n      g.fillStyle = `rgba(255,255,0,1)`;\r\n      g.fillRect(infoAreaWidth, 0, 150, 20);\r\n      g.fillStyle = `black`;\r\n      g.fillText(`Min: ` + waveMma.min.toFixed(2), 60, 10);\r\n      g.fillText(`Max: ` + waveMma.max.toFixed(2), 110, 10);\r\n      g.fillText(`Avg: ` + waveMma.avg.toFixed(2), 160, 10);\r\n    } else {\r\n      this.waveTracker.reset();\r\n    }\r\n\r\n    // Show info about data under pointer\r\n    if (pointer.y > 0 && pointer.y <= canvasHeight && pointer.x >= 0 && pointer.x <= canvasWidth) {\r\n      g.fillStyle = `black`;\r\n      g.fillText(`Level: ` + (1.0 - (pointer.y / canvasHeight)).toFixed(2), 2, 10);\r\n    }\r\n\r\n  }\r\n\r\n  // Yields pointer position relative to given element\r\n  getPointerRelativeTo(elem:HTMLElement) {\r\n    const rect = elem.getBoundingClientRect();\r\n    return {\r\n      x: this.lastPointer.x - rect.left - window.scrollX, //elem.offsetLeft + window.scrollX,\r\n      y: this.lastPointer.y - rect.top - window.scrollY//elem.offsetTop + window.scrollY\r\n    };\r\n  }\r\n\r\n  // Keeps track of last pointer position in page coordinate space\r\n  onPointer(evt:MouseEvent|PointerEvent) {\r\n    this.lastPointer = {\r\n      x: evt.pageX,\r\n      y: evt.pageY\r\n    };\r\n    evt.preventDefault();\r\n  }\r\n\r\n  // getMinMax(data, start = 0, end = data.length) {\r\n  //   if (end > data.length) throw new Error(`end is past size of array`);\r\n  //   if (start < 0) throw new Error(`start should be at least 0`);\r\n  //   if (end <= start) throw new Error(`end should be greater than start`);\r\n\r\n  //   let max = Number.MIN_SAFE_INTEGER;\r\n  //   let min = Number.MAX_SAFE_INTEGER;\r\n  //   for (let i = start; i < end; i++) {\r\n  //     max = Math.max(data[i], max);\r\n  //     min = Math.min(data[i], min);\r\n  //   }\r\n  //   if (!Number.isFinite(max)) max = 0;\r\n  //   if (!Number.isFinite(min)) min = 0;\r\n\r\n  //   return {max: max, min: min};\r\n  // }\r\n}","/**\r\n * Keeps track of the min, max and avg in a stream of values without actually storing them.\r\n * \r\n * Usage:\r\n * \r\n * ```js\r\n *  const t = tracker(); \r\n *  t.seen(10);\r\n * \r\n *  t.avg / t.min/ t.max / t.getMinMax()\r\n * ```\r\n * \r\n * Use `reset()` to clear everything, or `resetAvg()` to only reset averaging calculation.\r\n * \r\n * Trackers can automatically reset after a given number of samples\r\n * ```\r\n * // reset after 100 samples\r\n * const t = tracker(`something`, 100);\r\n * ```\r\n * @class Tracker\r\n */\r\nexport class Tracker {\r\n  samples = 0;\r\n  total = 0;\r\n  min = 0;\r\n  max = 0;\r\n  id: string | undefined;\r\n  resetAfterSamples?:number;\r\n\r\n  constructor(id: string | undefined = undefined, resetAfterSamples?:number) {\r\n    this.id = id;\r\n    this.resetAfterSamples = resetAfterSamples;\r\n  }\r\n\r\n  get avg() { return this.total / this.samples; }\r\n\r\n  resetAvg(newId: string | null = null) {\r\n    if (newId !== null) this.id = newId;\r\n    this.total = 0;\r\n    this.samples = 0;\r\n  }\r\n\r\n  reset(newId: string | null = null) {\r\n    this.min = Number.MAX_SAFE_INTEGER;\r\n    this.max = Number.MIN_SAFE_INTEGER;\r\n    this.resetAvg(newId);\r\n  }\r\n\r\n  seen(sample: number) {\r\n    if (Number.isNaN(sample)) throw Error(`Cannot add NaN`);\r\n    if (this.resetAfterSamples !== undefined && this.samples > this.resetAfterSamples) this.reset();\r\n    this.samples++;\r\n    this.total += sample;\r\n    this.min = Math.min(sample, this.min);\r\n    this.max = Math.max(sample, this.max);\r\n  }\r\n\r\n  getMinMaxAvg() {\r\n    return {\r\n      min: this.min,\r\n      max: this.max,\r\n      avg: this.avg,\r\n    };\r\n  }\r\n}\r\n\r\nexport const tracker = (id?:string, resetAfterSamples?:number) => new Tracker(id, resetAfterSamples);\r\n\r\n/**\r\n * A `Tracker` that tracks interval between calls to `mark()`\r\n *\r\n * @export\r\n * @class IntervalTracker\r\n * @extends {Tracker}\r\n */\r\nexport class IntervalTracker extends Tracker {\r\n  lastMark = 0;\r\n  //perf;\r\n  constructor(id: string | undefined = undefined, resetAfterSamples?:number) {\r\n    super(id, resetAfterSamples);\r\n    // if (typeof window.performance === `undefined`) {\r\n    //   try {\r\n    //     //eslint-disable-next-line @typescript-eslint/no-var-requires\r\n    //     const p = require(`perf_hooks`);\r\n    //     this.perf = p.performance.now;\r\n    //   } catch (err) {\r\n    //     // no-op\r\n    //   }\r\n    // } else {\r\n    //   this.perf = window.performance.now;\r\n    // }\r\n  }\r\n\r\n  mark() {\r\n    if (this.lastMark > 0) {\r\n      this.seen(window.performance.now() - this.lastMark);\r\n    }\r\n    this.lastMark = window.performance.now();\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\r\n * records the interval between each call to `mark`.\r\n * \r\n * ```js\r\n * const t = intervalTracker();\r\n * \r\n * // Call `mark` to record an interval\r\n * t.mark();\r\n * ...\r\n * t.mark();\r\n * \r\n * // Get average time in milliseconds between calls to `mark`\r\n * t.avg;\r\n * \r\n * // Longest and shortest times are available too...\r\n * t.min; t.max\r\n * ```\r\n * \r\n * Interval tracker can automatically reset after a given number of samples:\r\n * ```\r\n * // Reset after 100 samples\r\n * const t = intervalTracker(`tracker`, 100);\r\n * ```\r\n * @param id Optional id of instance\r\n * @returns New interval tracker\r\n */\r\nexport const intervalTracker = (id?:string, resetAfterSamples?:number) => new IntervalTracker(id, resetAfterSamples);"],"mappings":"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","names":[]}