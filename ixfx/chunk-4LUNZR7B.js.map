{"version":3,"sources":["../src/flow/Timer.ts","../src/flow/Elapsed.ts"],"sourcesContent":["import { clamp } from '../data/Clamp.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * Implementations: {@link msElapsedTimer}, {@link ticksElapsedTimer}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relativeTimer}\n */\nexport type CompletionTimer = Timer & {\n  /**\n   * Returns _true_ if this timer has completed.\n   */\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link msElapsedTimer}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n * oneSecond(); // Returns _true_ when timer is done\n * ```\n *\n * See also {@link Elapsed.progress}.\n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relativeTimer(intervalToMs(elapsed, 0), { timer: msElapsedTimer() });\n  return () => t.isDone;\n}\n\nexport const frequencyTimerSource =\n  (frequency: number): TimerSource =>\n    () =>\n      frequencyTimer(frequency, { timer: msElapsedTimer() });\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total duration.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, milliseconds-based timer is used.\n *\n * ```js\n * const t = relativeTimer(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relativeTimer(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `msElapsedTimer()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = relativeTimer(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * @private\n * @param total Total time (milliseconds)\n * @param options Options\n * @returns Timer\n */\nexport const relativeTimer = (\n  total: number,\n  options: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  const clampValue = options.clampValue ?? false;\n  const wrapValue = options.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = options.timer ?? msElapsedTimer();\n\n  const computeElapsed = () => {\n    let v = timer.elapsed / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * @example Init a spring oscillator, with a half a cycle per second\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * Oscillators.spring({}, frequencyTimer(0.5));\n * ```\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency\n * @param timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  opts: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = opts.timer ?? msElapsedTimer();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = msElapsedTimer();\n * t.reset(); // reset start\n * t.elapsed; // ms since start\n * ```\n * \n * Like other {@link Timer} functions, it returns a `isDone` property,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const msElapsedTimer = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = ticksElapsedTimer();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {msElapsedTimer}\n */\nexport const ticksElapsedTimer = (): Timer => {\n  // eslint-disable-next-line functional/no-let\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n","import { round } from '../numbers/Round.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport { msElapsedTimer, relativeTimer } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since the initial call.\n * ```js\n * // Record start\n * const elapsed = Elapsed.since();\n *\n * // Get elapsed time in millis\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a elapsed timer, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Elapsed.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: Elapsed.since() }\n * ```\n *\n * See also:\n * * {@link once} if you want to measure a single period, and stop it.\n * * {@link interval} time _between_ calls\n * @returns\n */\nexport const since = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns the interval between the start and each subsequent call.\n * \n * ```js\n * const interval = Elapsed.interval();\n * interval(); // Time from Elapsed.interval()\n * interval(); // Time since last interval() call\n * ```\n * \n * See also:\n * * {@link since}: time since first call\n * * {@link once}: time between two events\n * @returns \n */\nexport const interval = (): Since => {\n  let start = performance.now();\n  return (): number => {\n    const now = performance.now();\n    const x = now - start;\n    start = now;\n    return x;\n  }\n}\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link since}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = Elapsed.once();\n * // ...do stuff\n * elapsed(); // Yields time since Elapsed.once() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n * \n * See also:\n * * {@link since}: elapsed time\n * * {@link interval}: time _between_ calls\n * @returns\n */\nexport const once = (): Since => {\n  const start = Date.now();\n  //eslint-disable-next-line functional/no-let\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `Elapsed.since` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = Elapsed.infinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Elapsed.since();\n * });\n * ```\n * @returns\n */\nexport const infinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts timing immediately.\n *\n * ```js\n * const timer = Elapsed.progress(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Elapsed.progress(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Elapsed.progress({ mins: 4 });\n * ```\n * See also {@link hasElapsed}.\n * @param duration\n * @returns\n */\nexport function progress(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`duration invalid`);\n  const timerOpts = {\n    ...opts,\n    timer: msElapsedTimer(),\n  };\n  const t = relativeTimer(totalMs, timerOpts);\n  return () => t.elapsed;\n}\n\nexport const toString = (millisOrFunction: number | Since | Interval, rounding = 2): string => {\n  //eslint-disable-next-line functional/no-let\n  let interval: number | undefined = {} = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return toString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};\n"],"mappings":"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","names":["interval"]}