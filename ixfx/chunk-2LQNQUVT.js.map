{"version":3,"sources":["../src/flow/IntervalType.ts"],"sourcesContent":["import { numberTest } from '../util/GuardNumbers.js';\nimport { round } from '../numbers/Round.js';\n\n/**\n * Interval types allows for more expressive coding, rather than embedding millisecond values.\n * \n * That is, we can use `{ mins: 5 }` to mean 5 minutes rather than `5*60*1000` \n * or worse, 300000, for the same value.\n *\n * @example\n * ```js\n * { hours: 1 };  // 1 hour\n * { mins: 5 };   // 5 mins\n * { secs: 5 };   // 5 secs\n * { millis: 5 }; // 5 milliseconds\n * ```\n * \n * If several fields are used, this sums their value\n * ```js\n * { secs: 2, millis: 1 }; // equal 2001 milliseconds.\n * ```\n * \n * Wherever ixfx takes an `Interval`, you can also just provide a number instead.\n * This will be taken as a millisecond value.\n * \n * @see {@link intervalToMs} to convert to milliseconds.\n * @see {@link isInterval} check whether input is an Interval type\n * @see {@link elapsedToHumanString} render interval in human-friendly form\n */\nexport type Interval =\n  | number\n  | {\n    readonly millis?: number;\n    readonly secs?: number;\n    readonly hours?: number;\n    readonly mins?: number;\n  };\n\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n\n\n/**\n * Return the millisecond value of an Interval.\n * \n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber?: number\n): number {\n  if (isInterval(interval)) {\n    // Number given, must be millis?\n    if (typeof interval === `number`) return interval;\n\n    let ms = interval.millis ?? 0;\n    ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n    ms += (interval.mins ?? 0) * 60 * 1000;\n    ms += (interval.secs ?? 0) * 1000;\n    return ms;\n  } else {\n    if (typeof defaultNumber !== `undefined`) return defaultNumber;\n    throw new Error(`Not a valid interval: ${ interval }`);\n  }\n}\n\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval \n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval: number | Interval | undefined): interval is Interval {\n  if (interval === undefined) return false;\n  if (interval === null) return false;\n  if (typeof interval === `number`) {\n    if (Number.isNaN(interval)) return false;\n    if (!Number.isFinite(interval)) return false;\n    return true;\n  } else if (typeof interval !== `object`) return false;\n\n  const hasMillis = `millis` in interval;\n  const hasSecs = `secs` in interval;\n  const hasMins = `mins` in interval;\n  const hasHours = `hours` in interval;\n  if (hasMillis && !numberTest(interval.millis)[ 0 ]) return false;\n  if (hasSecs && !numberTest(interval.secs)[ 0 ]) return false;\n  if (hasMins && !numberTest(interval.mins)[ 0 ]) return false;\n  if (hasHours && !numberTest(interval.hours)[ 0 ]) return false;\n  if (hasMillis || hasSecs || hasHours || hasMins) return true;\n  return false;\n}\n\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n * \n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns \n */\nexport const elapsedToHumanString = (millisOrFunction: number | (() => number) | Interval, rounding = 2): string => {\n  let interval: number | undefined = {} = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return elapsedToHumanString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};"],"mappings":";;;;;;;;AAkEO,SAAS,aACd,UACA,eACQ;AACR,MAAI,WAAW,QAAQ,GAAG;AAExB,QAAI,OAAO,aAAa,SAAU,QAAO;AAEzC,QAAI,KAAK,SAAS,UAAU;AAC5B,WAAO,SAAS,SAAS,KAAK,KAAK,KAAK;AACxC,WAAO,SAAS,QAAQ,KAAK,KAAK;AAClC,WAAO,SAAS,QAAQ,KAAK;AAC7B,WAAO;AAAA,EACT,OAAO;AACL,QAAI,OAAO,kBAAkB,YAAa,QAAO;AACjD,UAAM,IAAI,MAAM,yBAA0B,QAAS,EAAE;AAAA,EACvD;AACF;AAOO,SAAS,WAAW,UAA+D;AACxF,MAAI,aAAa,OAAW,QAAO;AACnC,MAAI,aAAa,KAAM,QAAO;AAC9B,MAAI,OAAO,aAAa,UAAU;AAChC,QAAI,OAAO,MAAM,QAAQ,EAAG,QAAO;AACnC,QAAI,CAAC,OAAO,SAAS,QAAQ,EAAG,QAAO;AACvC,WAAO;AAAA,EACT,WAAW,OAAO,aAAa,SAAU,QAAO;AAEhD,QAAM,YAAY,YAAY;AAC9B,QAAM,UAAU,UAAU;AAC1B,QAAM,UAAU,UAAU;AAC1B,QAAM,WAAW,WAAW;AAC5B,MAAI,aAAa,CAAC,WAAW,SAAS,MAAM,EAAG,CAAE,EAAG,QAAO;AAC3D,MAAI,WAAW,CAAC,WAAW,SAAS,IAAI,EAAG,CAAE,EAAG,QAAO;AACvD,MAAI,WAAW,CAAC,WAAW,SAAS,IAAI,EAAG,CAAE,EAAG,QAAO;AACvD,MAAI,YAAY,CAAC,WAAW,SAAS,KAAK,EAAG,CAAE,EAAG,QAAO;AACzD,MAAI,aAAa,WAAW,YAAY,QAAS,QAAO;AACxD,SAAO;AACT;AAgBO,IAAM,uBAAuB,CAAC,kBAAsD,WAAW,MAAc;AAClH,MAAI,WAA+B,CAAC,IAAI;AACxC,MAAI,OAAO,qBAAqB,YAAY;AAC1C,UAAM,iBAAiB,iBAAiB;AACxC,WAAO,qBAAqB,cAAc;AAAA,EAC5C,WAAW,OAAO,qBAAqB,UAAU;AAC/C,eAAW;AAAA,EACb,WAAW,OAAO,qBAAqB,UAAU;AAC/C,eAAW,aAAa,QAAQ;AAAA,EAClC;AAEA,MAAI,KAAK,aAAa,QAAQ;AAC9B,MAAI,OAAO,OAAO,YAAa,QAAO;AACtC,MAAI,KAAK,IAAM,QAAO,GAAI,MAAM,UAAU,EAAE,CAAE;AAC9C,QAAM;AACN,MAAI,KAAK,IAAK,QAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AACvC,QAAM;AACN,MAAI,KAAK,GAAI,QAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AACtC,QAAM;AACN,SAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AAC3B;","names":[]}