{"version":3,"sources":["../src/Events.ts","../src/DefaultKeyer.ts","../src/collections/map/MapMultiFns.ts","../src/collections/map/MapOfSimpleBase.ts","../src/collections/map/MapOfSimpleMutable.ts"],"sourcesContent":["\nimport type { ISimpleEventEmitter, Listener } from './ISimpleEventEmitter.js';\nimport { ofSimpleMutable } from './collections/map/MapOfSimpleMutable.js';\nimport { intervalToMs, type Interval } from './flow/IntervalType.js';\n\n/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n * \n * By default waits a maximum of 1 minute.\n * \n * Automatically unsubscribes on success or failure (ie. timeout)\n * \n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns \n */\nexport const eventRace = (target: EventTarget, eventNames: Array<string>, options: Partial<{ timeout: Interval, signal: AbortSignal }> = {}) => {\n  const intervalMs = intervalToMs(options.timeout, 60 * 1000);\n  const signal = options.signal;\n  let triggered = false;\n  let disposed = false;\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n\n  const promise = new Promise<Event>((resolve, reject) => {\n    const onEvent = (event: Event) => {\n      if (`type` in event) {\n        if (eventNames.includes(event.type)) {\n          triggered = true;\n          resolve(event);\n          dispose();\n        } else {\n          console.warn(`eventRace: Got event '${ event.type }' that is not in race list`);\n        }\n      } else {\n        console.warn(`eventRace: Event data does not have expected 'type' field`);\n        console.log(event);\n      }\n    }\n\n    for (const name of eventNames) {\n      target.addEventListener(name, onEvent);\n    }\n\n    const dispose = () => {\n      if (disposed) return;\n      if (timeout !== undefined) clearTimeout(timeout);\n      timeout = undefined;\n      disposed = true;\n      for (const name of eventNames) {\n        target.removeEventListener(name, onEvent);\n      }\n    }\n\n    timeout = setTimeout(() => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`eventRace: Events not fired within interval. Events: ${ JSON.stringify(eventNames) } Interval: ${ intervalMs }`));\n    }, intervalMs);\n\n\n    signal?.addEventListener(`abort`, () => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`Abort signal received ${ signal.reason }`));\n    });\n  });\n  return promise;\n}\n\n\nexport class SimpleEventEmitter<Events> implements ISimpleEventEmitter<Events> {\n  readonly #listeners = ofSimpleMutable<Listener<Events>>();\n\n  /**\n   * Fire event\n   * @param type Type of event\n   * @param args Arguments for event\n   * @returns\n   */\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[ K ]) {\n    const listeners = this.#listeners.get(type as string);\n    //console.log(`Firing ${type as string}`);\n    for (const l of listeners) {\n      l(args, this);\n    }\n  }\n\n  /**\n   * Adds event listener\n   *\n   * @template K\n   * @param {K} type\n   * @param {Listener<Events>} listener\n   * @memberof SimpleEventEmitter\n   */\n  addEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ): void {\n    // (this: any, ev: Events[K]) => any): void {\n    this.#listeners.addKeyedValues(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Remove event listener\n   *\n   * @param {Listener<Events>} listener\n   * @memberof SimpleEventEmitter\n   */\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ) {\n    // listener: Listener<Events>): void {\n    this.#listeners.deleteKeyValue(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Clear all event listeners\n   * @private\n   * @memberof SimpleEventEmitter\n   */\n  clearEventListeners() {\n    this.#listeners.clear();\n  }\n}\n\n// type TestEventMap = {\n//   readonly change: TestEvent\n//   readonly other: TestEvent2;\n// }\n\n// interface TestEvent2 {\n//   readonly something: string;\n// }\n// interface TestEvent {\n//   readonly blah: boolean;\n// }\n\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\n//   constructor() {\n//     super();\n//     this.addEventListener(`change`, (e) => {\n//       e.blah;\n//     });\n//   }\n// }\n\n/*\nexport class Event {\n  public target: any;\n  public type: string;\n  constructor(type: string, target: any) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  constructor(error: Error, target: any) {\n    super('error', target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  constructor(code = 1000, reason = '', target: any) {\n    super('close', target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nexport interface WebSocketEventListenerMap {\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\n}\n*/\n\nexport { type ISimpleEventEmitter, type Listener } from './ISimpleEventEmitter.js';","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};","// âœ” UNIT TESTED\n\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport type { IMapOf } from './IMapOf.js';\nimport type { IWithEntries } from '../../data/maps/IMappish.js';\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByIterablePredicate(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByIterableValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByIterablePredicate = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (predicate(subValue, e[ 0 ])) return e;\n    }\n  }\n};\n\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = <V>(map: IMapOf<V>): number => {\n  //eslint-disable-next-line functional/no-let\n  let largest: readonly [ string, number ] = [ '', 0 ];\n  for (const e of map.keysAndCounts()) {\n    if (e[ 1 ] > largest[ 1 ]) {\n      largest = e;\n    }\n  }\n  return largest[ 1 ];\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByIterableValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByIterablePredicate} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByIterableValue = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (isEqual(subValue, value)) return e;\n    }\n  }\n};\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport { firstEntryByIterableValue } from './MapMultiFns.js';\n\nexport class MapOfSimpleBase<V> {\n  protected map: Map<string, ReadonlyArray<V>>;\n  protected readonly groupBy;\n  protected valueEq;\n\n  /**\n   * Constructor\n   * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n   * @param valueEq Compare values. By default uses JS logic for equality\n   */\n  constructor(\n    groupBy: (value: V) => string = defaultKeyer,\n    valueEq: IsEqual<V> = isEqualDefault<V>,\n    initial: Array<[ string, ReadonlyArray<V> ]> = []\n  ) {\n    this.groupBy = groupBy;\n    this.valueEq = valueEq;\n    this.map = new Map(initial);\n  }\n\n\n  /**\n   * Iterate over all entries\n   */\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const key of this.map.keys()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      for (const value of this.map.get(key)!) {\n        yield [ key, value ];\n      }\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: Array<V> ]> {\n    for (const [ k, v ] of this.map.entries()) {\n      yield [ k, [ ...v ] ];\n    }\n  }\n\n  firstKeyByValue(value: V, eq: IsEqual<V> = isEqualDefault) {\n    const entry = firstEntryByIterableValue(this, value, eq);\n    if (entry) return entry[ 0 ];\n  }\n\n  /**\n   * Get all values under `key`\n   * @param key\n   * @returns\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.map.get(key);\n    if (!m) return;\n    yield* m.values();\n  }\n\n  /**\n   * Iterate over all keys\n   */\n  *keys(): IterableIterator<string> {\n    yield* this.map.keys();\n  }\n\n  /**\n   * Iterate over all values (regardless of key)\n   */\n  *valuesFlat(): IterableIterator<V> {\n    for (const entries of this.map) {\n      yield* entries[ 1 ];\n    }\n  }\n\n  /**\n   * Iterate over keys and length of values stored under keys\n   */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const entries of this.map) {\n      yield [ entries[ 0 ], entries[ 1 ].length ];\n    }\n  }\n\n  /**\n   * Returns _true_ if `key` exists\n   * @param key\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Returns _true_ if `value` exists under `key`.\n   * @param key Key\n   * @param value Value to seek under `key`\n   * @returns _True_ if `value` exists under `key`.\n   */\n  hasKeyValue(key: string, value: V): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    for (const v of values) {\n      if (this.valueEq(v, value)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Debug dump of contents\n   * @returns\n   */\n  debugString(): string {\n    // eslint-disable-next-line functional/no-let\n    let r = ``;\n    const keys = [ ...this.map.keys() ];\n    keys.every((k) => {\n      const v = this.map.get(k);\n      if (v === undefined) return;\n      r += k + ` (${ v.length }) = ${ JSON.stringify(v) }\\r\\n`;\n    });\n    return r;\n  }\n\n  /**\n   * _True_ if empty\n   */\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n  /**\n   * Return number of values stored under `key`.\n   * Returns 0 if `key` is not found.\n   * @param key\n   * @returns\n   */\n  count(key: string): number {\n    const values = this.map.get(key);\n    if (!values) return 0;\n    return values.length;\n  }\n\n  get lengthKeys() {\n    return this.map.size;\n  }\n\n}\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport type { IMapOfMutable } from './IMapOfMutable.js';\nimport { MapOfSimpleBase } from './MapOfSimpleBase.js';\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @template V Type of items\n */\nexport class MapOfSimpleMutable<V>\n  extends MapOfSimpleBase<V>\n  implements IMapOfMutable<V> {\n  addKeyedValues(key: string, ...values: ReadonlyArray<V>) {\n    const existing = this.map.get(key);\n    if (existing === undefined) {\n      this.map.set(key, values);\n    } else {\n      this.map.set(key, [ ...existing, ...values ]);\n    }\n  }\n\n\n  /**\n   * Adds a value, automatically extracting a key via the\n   * `groupBy` function assigned in the constructor options.\n   * @param values Adds several values\n   */\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) {\n      const key = this.groupBy(v);\n      this.addKeyedValues(key, v);\n    }\n  }\n\n  /**\n   * Delete `value` under a particular `key`\n   * @param key\n   * @param value\n   * @returns _True_ if `value` was found under `key`\n   */\n  deleteKeyValue(key: string, value: V): boolean {\n    const existing = this.map.get(key);\n    if (existing === undefined) return false;\n    const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n    this.map.set(key, without);\n    return without.length < existing.length;\n  }\n\n  /**\n   * Deletes `value` regardless of key.\n   *\n   * Uses the constructor-defined equality function.\n   * @param value Value to delete\n   * @returns\n   */\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let del = false;\n    const entries = [ ...this.map.entries() ];\n    for (const keyEntries of entries) {\n      for (const values of keyEntries[ 1 ]) {\n        if (this.valueEq(values, value)) {\n          del = true;\n          this.deleteKeyValue(keyEntries[ 0 ], value);\n        }\n      }\n    }\n    return del;\n  }\n\n  /**\n   * Deletes all values under `key`,\n   * @param key\n   * @returns _True_ if `key` was found and values stored\n   */\n  delete(key: string): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    if (values.length === 0) return false;\n    this.map.delete(key);\n    return true;\n  }\n\n  /**\n   * Clear contents\n   */\n  clear() {\n    this.map.clear();\n  }\n}\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @template V Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = <V>(\n  groupBy: (value: V) => string = defaultKeyer,\n  valueEq: IsEqual<V> = isEqualDefault<V>\n): IMapOfMutable<V> => new MapOfSimpleMutable<V>(groupBy, valueEq);\n"],"mappings":"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","names":[]}