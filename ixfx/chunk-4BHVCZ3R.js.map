{"version":3,"sources":["../src/flow/StateMachine.ts","../src/collections/arrays/index.ts","../src/collections/Map/MapFns.ts","../src/random/WeightedIndex.ts","../src/collections/GuardArray.ts","../src/collections/GuardIndex.ts","../src/collections/arrays/ValuesEqual.ts","../src/iterable/SliceSync.ts","../src/collections/FilterBetween.ts","../src/collections/MinMaxAvg.ts","../src/collections/arrays/NumericArrays.ts","../src/collections/ArrayCycle.ts","../src/collections/arrays/Zip.ts","../src/modulation/Easing.ts","../src/data/Wrap.ts","../src/data/Interpolate.ts","../src/flow/index.ts","../src/flow/Elapsed.ts","../src/numbers/Round.ts","../src/flow/Timer.ts","../src/data/Clamp.ts","../src/flow/DispatchList.ts","../src/flow/Interval.ts","../src/flow/Timeout.ts","../src/flow/UpdateOutdated.ts","../src/flow/Continuously.ts","../src/flow/Debounce.ts","../src/flow/Throttle.ts","../src/flow/WaitFor.ts","../src/flow/Delay.ts","../src/flow/Every.ts","../src/flow/RunOnce.ts","../src/flow/Retry.ts","../src/collections/queue/QueueFns.ts","../src/collections/queue/QueueMutable.ts","../src/flow/TaskQueue.ts","../src/collections/arrays/AverageWeighted.ts","../src/collections/Iterables.ts","../src/flow/StateMachineWithEvents.ts","../src/flow/Execute.ts","../src/flow/StateMachineDriver.ts"],"sourcesContent":["import { unique } from '../collections/arrays/index.js';\nimport {\n  StateMachineWithEvents,\n  type Opts,\n  type StateMachineEventMap,\n  type StopEvent,\n} from './StateMachineWithEvents.js';\nexport {\n  StateMachineWithEvents as WithEvents,\n  type Opts as StateMachineWithEventsOpts,\n  type StateMachineEventMap,\n  type StopEvent,\n};\n\n/**\n * State machine driver\n */\nexport { init as driver } from './StateMachineDriver.js';\nexport type {\n  DriverOpts,\n  StatesHandler as DriverHandler,\n  Runner,\n  ExpressionOrResult as DriverExpression,\n  Result as DriverResult,\n} from './StateMachineDriver.js';\n\n/**\n * Transition result\n * * 'Ok': transition valid\n * * 'FromNotFound': the from state is missing from machine definition\n * * 'ToNotFound': the 'to' state is missing from machine definition\n * * 'Invalid': not allowed to transition to target state from the current state\n * * 'Terminal':  not allowed to transition because from state is the final state\n */\nexport type TransitionResult =\n  | 'Ok'\n  | 'FromNotFound'\n  | 'ToNotFound'\n  | 'Invalid'\n  | 'Terminal';\n\nexport type TransitionCondition<V extends Transitions> = {\n  readonly hasPriorState: readonly StateNames<V>[];\n  readonly isInState: StateNames<V>;\n};\n\nexport type StateTargetStrict<V extends Transitions> = {\n  readonly state: StateNames<V> | null;\n  readonly preconditions?: readonly TransitionCondition<V>[];\n};\n\n/**\n * Possible state transitions, or _null_ if final state.\n */\n//export type StateTarget<V extends Transitions> = StateTargetExt<V> | null;\n\nexport type StateTarget<V extends Transitions> =\n  | string\n  //eslint-disable-next-line functional/prefer-readonly-type\n  | string[]\n  | readonly string[]\n  | null\n  | StateTargetStrict<V>;\n//eslint-disable-next-line functional/prefer-readonly-type\n// | StateTargetStrict<V>[]\n// | readonly StateTargetStrict<V>[];\n\n/**\n * Maps state to allowable next states\n */\nexport type Transitions = {\n  readonly [ key: string ]: StateTarget<Transitions>;\n};\n\nexport type TransitionsStrict = {\n  readonly [ key: string ]: readonly StateTargetStrict<Transitions>[];\n};\n/**\n * List of possible states\n */\nexport type StateNames<V extends Transitions> = keyof V & string;\n\nexport type Machine<V extends Transitions> = {\n  /**\n   * Allowable state transitions\n   */\n  readonly states: V;\n};\n\n/**\n * Encapsulation of a 'running' machine description and state.\n *\n * See:\n * - {@link cloneState}\n */\nexport type MachineState<V extends Transitions> = {\n  /**\n   * Current state\n   */\n  readonly value: StateNames<V>;\n  /**\n   * List of unique states visited. Won't contain the current\n   * state unless it has already been visited.\n   */\n  readonly visited: readonly StateNames<V>[];\n\n  //readonly machine: Machine<V>;\n  readonly machine: {\n    readonly [ key in StateNames<V> ]: readonly StateTargetStrict<V>[];\n  };\n};\n\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = <V extends Transitions>(\n  toClone: MachineState<V>\n): MachineState<V> => {\n  return Object.freeze({\n    value: toClone.value,\n    visited: [ ...toClone.visited ],\n    machine: toClone.machine,\n  });\n};\n/**\n * Initialises a state machine\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * StateMachineLight.done(sm); // false\n * StateMachineLight.possible(sm); // [ 'shirt' ]\n * ```\n * @param sm\n * @param initialState\n * @returns\n */\nexport const init = <V extends Transitions>(\n  stateMachine: Machine<V> | Transitions | TransitionsStrict,\n  initialState?: StateNames<V>\n): MachineState<V> => {\n  const [ machine, machineValidationError ] = validateMachine(stateMachine);\n  if (!machine) throw new Error(machineValidationError);\n\n  const state: StateNames<V> =\n    (initialState as StateNames<V>) ?? Object.keys(machine.states)[ 0 ];\n  if (typeof machine.states[ state ] === 'undefined') {\n    throw new Error(`Initial state not found`);\n  }\n\n  // Normalise states\n  const transitions = validateAndNormaliseTransitions(machine.states);\n  if (transitions === undefined) {\n    throw new Error(`Could not normalise transitions`);\n  }\n  // @ts-ignore\n  return Object.freeze({\n    value: state,\n    visited: [],\n    machine: Object.fromEntries(transitions),\n  });\n};\n\nexport const reset = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  // @ts-ignore\n  return init<V>(sm.machine);\n};\n\nexport const validateMachine = <V extends Transitions>(\n  smOrTransitions: Machine<V> | Transitions | TransitionsStrict\n): [ machine: Machine<V> | undefined, msg: string ] => {\n  if (typeof smOrTransitions === 'undefined') {\n    return [ undefined, 'Parameter undefined' ];\n  }\n  if (smOrTransitions === null) {\n    return [ undefined, 'Parameter null' ];\n  }\n  if (`states` in smOrTransitions) {\n    // Assume Machine type\n    return [ smOrTransitions as Machine<V>, '' ];\n  }\n  if (typeof smOrTransitions === `object`) {\n    return [\n      {\n        // @ts-ignore\n        states: smOrTransitions,\n      },\n      '',\n    ];\n  }\n  return [\n    undefined,\n    `Unexpected type: ${ typeof smOrTransitions }. Expected object`,\n  ];\n};\n\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n\n/**\n * Returns _true_ if `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const done = <V extends Transitions>(sm: MachineState<V>): boolean => {\n  return possible(sm).length === 0;\n};\n\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = <V extends Transitions>(\n  sm: MachineState<V>\n): readonly StateTargetStrict<V>[] => {\n  // Validate current state\n  validateMachineState(sm);\n  // get list of possible targets\n  const fromS = sm.machine[ sm.value ];\n\n  if (fromS.length === 1 && fromS[ 0 ].state === null) return [];\n  return fromS;\n};\n\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = <V extends Transitions>(\n  sm: MachineState<V>\n): (StateNames<V> | null)[] => {\n  const targets = possibleTargets(sm);\n  return targets.map((v) => v.state);\n};\n\nexport const normaliseTargets = <V extends Transitions>(\n  targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    //eslint-disable-next-line functional/prefer-readonly-type\n    | StateTargetStrict<V>\n): StateTargetStrict<V>[] | null | undefined => {\n  const normaliseSingleTarget = (\n    target: string | undefined | null | object\n  ): StateTargetStrict<V> | undefined => {\n    // Terminal target\n    if (target === null) return { state: null };\n    // String is the target state\n    if (typeof target === 'string') {\n      return {\n        state: target,\n      };\n    } else if (typeof target === 'object' && 'state' in target) {\n      const targetState = target.state;\n      if (typeof targetState !== 'string') {\n        throw new Error(\n          `Target 'state' field is not a string. Got: ${ typeof targetState }`\n        );\n      }\n      if (`preconditions` in target) {\n        return {\n          state: targetState,\n          preconditions: target.preconditions as TransitionCondition<V>[],\n        };\n      }\n      return { state: targetState };\n    } else {\n      throw new Error(\n        `Unexpected type: ${ typeof target }. Expected string or object with 'state' field.`\n      );\n    }\n  };\n\n  // Array of targets (either strings or objects)\n  if (Array.isArray(targets)) {\n    //eslint-disable-next-line functional/no-let\n    let containsNull = false;\n    const mapResults = targets.map((t) => {\n      const r = normaliseSingleTarget(t);\n      if (!r) throw new Error(`Invalid target`);\n      containsNull = containsNull || r.state === null;\n      return r;\n    });\n    if (containsNull && mapResults.length > 1) {\n      throw new Error(`Cannot have null as an possible state`);\n    }\n    return mapResults;\n  } else {\n    const target = normaliseSingleTarget(targets);\n    if (!target) return;\n    return [ target ];\n  }\n};\n\nconst validateAndNormaliseTransitions = (\n  d: Transitions\n): Map<string, StateTargetStrict<typeof d>[]> | undefined => {\n  const returnMap = new Map<string, StateTargetStrict<typeof d>[]>();\n\n  // 1. Index top-level states\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    if (typeof topLevelState === `undefined`) {\n      throw new Error(`Top-level undefined state`);\n    }\n    if (typeof topLevelTargets === `undefined`) {\n      throw new Error(`Undefined target state for ${ topLevelState }`);\n    }\n    if (returnMap.has(topLevelState)) {\n      throw new Error(`State defined twice: ${ topLevelState }`);\n    }\n    if (topLevelState.includes(' ')) {\n      throw new Error('State names cannot contain spaces');\n    }\n    returnMap.set(topLevelState, []);\n  }\n\n  // 2. Normalise target\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    const targets = normaliseTargets(topLevelTargets);\n    if (targets === undefined) throw new Error(`Could not normalise target`);\n    if (targets !== null) {\n      // Check that they all exist as top-level states\n      const seenStates = new Set();\n      for (const target of targets) {\n        if (seenStates.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' already exists for '${ topLevelState }'`\n          );\n        }\n        seenStates.add(target.state);\n        if (target.state === null) continue;\n        if (!returnMap.has(target.state as string)) {\n          throw new Error(\n            `Target state '${ target.state }' is not defined as a top-level state. Defined under: '${ topLevelState }'`\n          );\n        }\n      }\n      returnMap.set(topLevelState, targets);\n    }\n  }\n  return returnMap;\n};\n\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = <V extends Transitions>(\n  state: MachineState<V>\n): void => {\n  if (typeof state === 'undefined') {\n    throw new Error(`Parameter 'state' is undefined`);\n  }\n  if (typeof state.value !== 'string') {\n    throw new Error('Existing state is not a string');\n  }\n};\n\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): MachineState<V> => {\n  validateMachineState(sm); // throws if not OK\n  validateTransition(sm, toState); // throws if not OK\n  return Object.freeze({\n    value: toState,\n    machine: sm.machine,\n    visited: unique<string>([ sm.visited as string[], [ sm.value ] as string[] ]),\n  });\n};\n\nexport const next = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  //validateMachineState(sm);\n  const first = possibleTargets(sm).at(0);\n  if (!first || first.state === null) {\n    throw new Error(\n      `Not possible to move to a next state from '${ sm.value as string }`\n    );\n  }\n  return to(sm, first.state);\n};\n\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): boolean => {\n  try {\n    validateTransition(sm, toState);\n    return true;\n  } catch (ex) {\n    return false;\n  }\n};\n\nexport const validateTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): void => {\n  if (toState === null) throw new Error(`Cannot transition to null state`);\n  if (toState === undefined) {\n    throw new Error(`Cannot transition to undefined state`);\n  }\n  if (typeof toState !== 'string') {\n    throw new Error(\n      `Parameter 'toState' should be a string. Got: ${ typeof toState }`\n    );\n  }\n\n  //const toS = sm.machine[toState];\n  //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n\n  const p = possible(sm);\n  if (p.length === 0) throw new Error('Machine is in terminal state');\n  if (!p.includes(toState)) {\n    throw new Error(\n      `Target state '${ toState }' not available at current state '${ sm.value\n      }'. Possible states: ${ p.join(', ') }`\n    );\n  }\n};\n\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n *\n * ```js\n * const transitions = [`a`, `b`, `c`, `d`];\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states: readonly string[]): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length <= 2) throw new Error(`Expects at least two states`);\n  for (let i = 0; i < states.length; i++) {\n    const s = states[ i ];\n    if (typeof s !== `string`) {\n      throw new Error(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ i }`\n      );\n    }\n    if (i === states.length - 1) {\n      /** @ts-ignore */\n      //eslint-disable-next-line functional/immutable-data\n      t[ s ] = null;\n    } else {\n      /** @ts-ignore */\n      //eslint-disable-next-line functional/immutable-data\n      t[ s ] = states[ i + 1 ];\n    }\n  }\n  return t;\n};\n\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n * ```js\n * const transitions = [`a`, `b`, `c`, `d`];\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const bidirectionalFromList = (\n  ...states: readonly string[]\n): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length < 2) throw new Error(`Expects at least two states`);\n\n  for (let i = 0; i < states.length; i++) {\n    const s = states[ i ];\n    if (typeof s !== `string`) {\n      throw new Error(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ i }`\n      );\n    }\n\n    /** @ts-ignore */\n    //eslint-disable-next-line functional/immutable-data\n    t[ s ] = [];\n  }\n\n  for (let i = 0; i < states.length; i++) {\n    /** @ts-ignore */\n    const v = t[ states[ i ] ] as string[];\n    if (i === states.length - 1) {\n      if (states.length > 1) {\n        //eslint-disable-next-line functional/immutable-data\n        v.push(states[ i - 1 ]);\n      } else {\n        /** @ts-ignore */\n        //eslint-disable-next-line functional/immutable-data\n        t[ states[ i ] ] = null;\n      }\n    } else {\n      //eslint-disable-next-line functional/immutable-data\n      v.push(states[ i + 1 ]);\n      //eslint-disable-next-line functional/immutable-data\n      if (i > 0) v.push(states[ i - 1 ]);\n    }\n  }\n  return t;\n};\n","/* eslint-disable indent */\n/**\n * Functions for working with primitive arrays, regardless of type\n * See Also: NumericArrays.ts\n */\n\nimport { throwIntegerTest } from '../../Guards.js';\nimport {\n  type ToString,\n  toStringDefault,\n} from '../../Util.js';\nimport {\n  type IsEqual,\n  isEqualDefault\n} from '../../IsEqual.js'\nimport { fromIterable as mapFromIterable } from '../map/MapFns.js';\nimport { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport { weightedIndex } from '../../random/WeightedIndex.js';\nimport { guardArray } from '../GuardArray.js';\nimport { guardIndex } from '../GuardIndex.js';\nimport { valuesEqual } from './ValuesEqual.js';\nexport * from './NumericArrays.js';\nexport * from '../ArrayCycle.js';\nexport * from '../FilterBetween.js';\nexport * from '../GuardArray.js';\nexport * from '../GuardIndex.js';\nexport * from './AverageWeighted.js';\nexport * from './NumericArrays.js';\nexport * from './Zip.js';\nexport * from './ValuesEqual.js';\n\nexport { compareValues, compareValuesEqual } from '../Iterables.js';\n\n\n\n\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n * \n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also: \n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA \n * @param arrayB \n * @param equality \n * @returns \n */\nexport const intersection = <V>(\n  arrayA: ReadonlyArray<V> | Array<V>,\n  arrayB: ReadonlyArray<V> | Array<V>,\n  equality: IsEqual<V> = isEqualDefault\n) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array: ReadonlyArray<any> | Array<any>): Array<any> =>\n  [ ...array ].flat();\n\n\n\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * import { interleave } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = <V>(\n  ...arrays: ReadonlyArray<ReadonlyArray<V>> | Array<Array<V>>\n): Array<V> => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => a.length);\n  if (!valuesEqual(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue = [];\n  const length = lengths[ 0 ];\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < length; index++) {\n    //eslint-disable-next-line functional/no-let\n    for (const array of arrays) {\n      //eslint-disable-next-line functional/immutable-data\n      returnValue.push(array[ index ]);\n    }\n  }\n  return returnValue;\n};\n\n/**\n * Returns a copy of `data` with specified length.\n * If the input array is too long, it is truncated.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with `undefined`\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * ```js\n * import { ensureLength } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * ensureLength([1,2,3], 2); // [1,2]\n * ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expand Expand strategy\n * @typeParam V Type of array\n */\nexport const ensureLength = <V>(\n  data: ReadonlyArray<V> | Array<V>,\n  length: number,\n  expand: `undefined` | `repeat` | `first` | `last` = `undefined`\n): Array<V> => {\n  // Unit tested\n  if (data === undefined) throw new Error(`Data undefined`);\n  if (!Array.isArray(data)) throw new Error(`data is not an array`);\n  if (data.length === length) return [ ...data ];\n  if (data.length > length) {\n    return data.slice(0, length);\n  }\n  const d = [ ...data ];\n  const add = length - d.length;\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < add; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    switch (expand) {\n      case `undefined`: {\n        // @ts-expect-error\n        d.push(undefined);\n        break;\n      }\n      case `repeat`: {\n        d.push(data[ index % data.length ]);\n        break;\n      }\n      case `first`: {\n        d.push(data[ 0 ]);\n        break;\n      }\n      case `last`: {\n        // @ts-expect-error\n        d.push(data.at(-1));\n        break;\n      }\n      // No default\n    }\n  }\n  return d;\n};\n\n\n\n/**\n * Returns a random array index.\n *\n * ```js\n * import { randomIndex } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = defaultRandom\n): number => Math.floor(rand() * array.length);\n\n/**\n * Selects a random array index, biased by the provided `weightings`.\n * \n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ] \n * ```\n * @param array \n * @param weightings \n * @param randomSource \n */\nexport const randomElementWeightedSource = <V>(array: ArrayLike<V>, weightings: Array<number>, randomSource: RandomSource = defaultRandom) => {\n  if (array.length !== weightings.length) throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n  const r = weightedIndex(weightings, randomSource);\n  return (): V => {\n    const index = r();\n    return array[ index ];\n  }\n}\n\n\n\n\n/**\n * Returns random element.\n *\n * ```js\n * import { randomElement } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @params rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = defaultRandom\n): V => {\n  guardArray(array, `array`);\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n/**\n * Removes a random item from an array, returning both the item and the new array as a result.\n * Does not modify the original array unless `mutate` parameter is true.\n *\n * @example Without changing source\n * ```js\n * import { randomPluck } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [100, 20, 40];\n * const {value, array} = randomPluck(data);\n * // value: 20, array: [100, 40], data: [100, 20, 40];\n * ```\n *\n * @example Mutating source\n * ```js\n * import { randomPluck } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [100, 20, 40];\n * const {value} = randomPluck(data, true);\n * // value: 20, data: [100, 40];\n * ```\n *\n * @template V Type of array\n * @param array Array to pluck item from\n * @param mutate If _true_, changes input array. _False_ by default.\n * @param random Random generatr. `Math.random` by default.\n * @return Returns an object `{value:V|undefined, array:V[]}`\n *\n */\nexport const randomPluck = <V>(\n  array: ReadonlyArray<V> | Array<V>,\n  mutate = false,\n  rand: RandomSource = defaultRandom\n): { readonly value: V | undefined; readonly array: Array<V> } => {\n  if (array === undefined) throw new Error(`array is undefined`);\n  if (!Array.isArray(array)) throw new Error(`'array' param is not an array`);\n  if (array.length === 0) return { value: undefined, array: [] };\n  const index = randomIndex(array, rand);\n  if (mutate) {\n    return {\n      value: array[ index ],\n      //eslint-disable-next-line functional/immutable-data\n      array: array.splice(index, 1),\n    };\n  } else {\n    // Copy array, remove item from that\n    const t = [ ...array ];\n    //eslint-disable-next-line functional/immutable-data\n    t.splice(index, 1);\n    return {\n      value: array[ index ],\n      array: t,\n    };\n  }\n};\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * import { shuffle } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @template V Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: ReadonlyArray<V>,\n  rand: RandomSource = defaultRandom\n): Array<V> => {\n  const array = [ ...dataToShuffle ];\n  // eslint-disable-next-line  functional/no-let\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};\n\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: ReadonlyArray<V> | Array<V>,\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  guardArray(data, `data`);\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});\n\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { without } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [100, 20, 40];\n * const filtered = without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { without } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { without } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @template V Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  sourceArray: ReadonlyArray<V> | Array<V>,\n  toRemove: V | Array<V>,\n  comparer: IsEqual<V> = isEqualDefault\n): Array<V> => {\n  if (Array.isArray(toRemove)) {\n    const returnArray = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}\n\nexport const withoutUndefined = <V>(data: ReadonlyArray<V> | Array<V>): Array<V> => {\n  return data.filter(v => v !== undefined);\n}\n/**\n * Returns all items in `data` for as long as `predicate` returns true.\n *\n * `predicate` returns an array of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = Arrays.until([1,2,3,4,5], v => [v === 3, 0]);\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport const until = <V, A>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V> | Array<V>,\n  predicate: (v: V, accumulator: A) => readonly [ stop: boolean, acc: A ],\n  initial: A\n): Array<V> => {\n  const returnValue = [];\n  //eslint-disable-next-line functional/no-let\n  let total = initial;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    const [ stop, accumulator ] = predicate(datum, total);\n    if (stop) break;\n\n    total = accumulator;\n\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push(datum);\n  }\n  return returnValue;\n};\n\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { remove } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V> | Array<V>,\n  index: number\n): Array<V> => {\n  // ✔️ Unit tested\n  if (!Array.isArray(data)) {\n    throw new TypeError(`'data' parameter should be an array`);\n  }\n  guardIndex(data, index, `index`);\n  return [ ...data.slice(0, index), ...data.slice(index + 1) ];\n};\n\n/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * import { groupBy } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const data = [\n *  { age: 39, city: `London` }\n *  { age: 14, city: `Copenhagen` }\n *  { age: 23, city: `Stockholm` }\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = groupBy(data, item => data.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = <K, V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  array: Iterable<V>,\n  grouper: (item: V) => K\n) => {\n  const map = new Map<K, Array<V>>();\n\n  for (const a of array) {\n    const key = grouper(a);\n    //eslint-disable-next-line functional/no-let\n    let existing = map.get(key);\n    if (!existing) {\n      existing = [];\n      map.set(key, existing);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    existing.push(a);\n  }\n  return map;\n};\n\n/**\n * Samples array\n *\n * @example By percentage - get half of the items\n * ```\n * import { sample } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example By steps - every third\n * ```\n * import { sample } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = <V>(array: ArrayLike<V>, amount: number): Array<V> => {\n  //eslint-disable-next-line functional/no-let\n  let subsampleSteps = 1;\n  if (amount <= 1) {\n    // Subsample based on a percentage\n    const numberOfItems = array.length * amount;\n    subsampleSteps = Math.round(array.length / numberOfItems);\n  } else {\n    subsampleSteps = amount;\n  }\n\n  throwIntegerTest(subsampleSteps, `positive`, `amount`);\n  if (subsampleSteps > array.length - 1) {\n    throw new Error(`Subsample steps exceeds array length`);\n  }\n  const r: Array<V> = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n    //eslint-disable-next-line functional/immutable-data\n    r.push(array[ index ]);\n  }\n  return r;\n};\n\n/**\n * Return `arr` broken up into chunks of `size`\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param arr\n * @param size\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function chunks<V>(\n  array: ReadonlyArray<V>,\n  size: number\n) {\n  // https://surma.github.io/underdash/\n  const output = [];\n  //eslint-disable-next-line  functional/no-let\n  for (let index = 0; index < array.length; index += size) {\n    //eslint-disable-next-line functional/immutable-data\n    output.push(array.slice(index, index + size));\n  }\n  return output;\n}\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also [Maps.mergeByKey](functions/Collections.Maps.mergeByKey.html) if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFn Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = <V>(\n  keyFunction: ToString<V>,\n  reconcile: MergeReconcile<V>,\n  ...arrays: ReadonlyArray<ReadonlyArray<V>>\n): Array<V> => {\n  const result = new Map<string, V>();\n  for (const m of arrays) {\n    for (const mv of m) {\n      if (mv === undefined) continue;\n      const mk = keyFunction(mv);\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return [ ...result.values() ];\n};\n\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param arr\n * @param reducer\n * @param initial\n * @returns\n */\nexport const reducePairwise = <V, X>(\n  array: ReadonlyArray<V>,\n  reducer: (accumulator: X, a: V, b: V) => X,\n  initial: X\n) => {\n  guardArray(array, `arr`);\n  if (array.length < 2) return initial;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < array.length - 1; index++) {\n    initial = reducer(initial, array[ index ], array[ index + 1 ]);\n  }\n  return initial;\n};\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: ReadonlyArray<V>,\n  filter: (a: V) => boolean\n): [ a: Array<V>, b: Array<V> ] => {\n  const a: Array<V> = [];\n  const b: Array<V> = [];\n  for (const datum of data) {\n    //eslint-disable-next-line functional/immutable-data\n    if (filter(datum)) a.push(datum);\n    //eslint-disable-next-line functional/immutable-data\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Combines the values of one or more arrays, removing duplicates\n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | Array<Array<V>>\n    | Array<V>\n    | ReadonlyArray<V>\n    | ReadonlyArray<ReadonlyArray<V>>,\n  comparer = isEqualDefault<V>\n): ReadonlyArray<V> => {\n  const t: Array<V> = [];\n  for (const a of arrays) {\n    if (Array.isArray(a)) {\n      for (const v of additionalValues<V>(t, a, comparer)) {\n        t.push(v);\n      }\n    } else {\n      return [ ...additionalValues<V>([], arrays as Array<V>, comparer) ];\n    }\n  }\n  return t;\n};\n\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n * \n * Uses JSON.toString() by default to compare values.\n * \n * See also:\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link unique} Get unique set of values in an array\n * @param array Array to examine\n * @param comparer Comparer, uses JSON.toString by default\n * @returns\n */\nexport const containsDuplicateValues = <V>(\n  array: Array<V> | ReadonlyArray<V>,\n  keyFunction = toStringDefault<V>\n): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  try {\n    const _ = mapFromIterable(array, keyFunction);\n  } catch {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns _true_ if array contains duplicate instances.\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array \n * @returns \n */\nexport const containsDuplicateInstances = <V>(array: Array<V> | ReadonlyArray<V>): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  for (let index = 0; index < array.length; index++) {\n    for (let x = 0; x < array.length; x++) {\n      if (index === x) continue;\n      if (array[ index ] === array[ x ]) return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if contents of `needles` is contained by `haystack`.\n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * @param haystack\n * @param needles\n * @param eq\n */\nexport const contains = <V>(\n  haystack: ArrayLike<V>,\n  needles: ArrayLike<V>,\n  eq = isEqualDefault<V>\n) => {\n  if (!Array.isArray(haystack)) {\n    throw new TypeError(`Expects haystack parameter to be an array`);\n  }\n  if (!Array.isArray(needles)) {\n    throw new TypeError(`Expects needles parameter to be an array`);\n  }\n\n  for (const needle of needles) {\n    //eslint-disable-next-line functional/no-let\n    let found = false;\n    for (const element of haystack) {\n      if (eq(needle, element)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Yield values from an iterable not present in the other.\n *\n * Assuming that `input` array is unique values, this function\n * yields items from `values` which are not present in `input`.\n *\n * Duplicate items in `values` are ignored - only the first is yielded.\n *\n * If `eq` function is not provided, values are compared using the\n * default === semantics (via {@link isEqualDefault})\n *\n * ```js\n * const existing = [ 1, 2, 3 ];\n * const newValues = [ 3, 4, 5];\n * const v = [...additionalValues(existing, newValues)];\n * // [ 1, 2, 3, 4, 5]\n * ```\n *\n * ```js\n * const existing = [ 1, 2, 3 ];\n * const newValues = [ 3, 4, 5 ];\n * for (const v of additionalValues(existing, newValues)) {\n *  // 4, 5\n * }\n * To combine one or more iterables, keeping only unique items, use {@link unique}\n * @param input\n * @param values\n */\nexport function* additionalValues<V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  input: Array<V>,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  values: Iterable<V>,\n  eq: IsEqual<V> = isEqualDefault\n): Iterable<V> {\n  // Keep track of values already yielded\n  const yielded: Array<V> = [];\n  for (const v of values) {\n    const found = input.find((index) => eq(index, v));\n    if (!found) {\n      const alreadyYielded = yielded.find((ii) => eq(ii, v));\n      if (!alreadyYielded) {\n        //eslint-disable-next-line functional/immutable-data\n        yielded.push(v);\n        yield v;\n      }\n    }\n  }\n}\n","import { isEqualDefault, type IsEqual } from '../../IsEqual.js';\nimport {\n  toStringDefault,\n  defaultComparer,\n  type ToString,\n} from '../../Util.js';\nimport type { IWithEntries } from './IMappish.js';\n\n// ✔ UNIT TESTED!\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (\n  data: ReadonlyMap<number, any>,\n  target: number\n): number => {\n  target = Math.round(target);\n  if (data.has(target)) {\n    return target;\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let offset = 1;\n    while (offset < 1000) {\n      if (data.has(target - offset)) return target - offset;\n      else if (data.has(target + offset)) return target + offset;\n      offset++;\n    }\n    throw new Error(`Could not find target ${ target }`);\n  }\n};\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  if (!map.has(key)) return false;\n  const values = [ ...map.values() ];\n  return values.some((v) => comparer(v, value));\n};\n\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\"\n *\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * Maps.deleteByValue(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer\n */\nexport const deleteByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n) => {\n  for (const entry of Object.entries(map)) {\n    if (comparer(entry[ 1 ], value)) {\n      (map as any).delete(entry[ 0 ]);\n    }\n  }\n};\n\n\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByIterablePredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByIterableValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByIterablePredicate = <K, V>(\n  map: IWithEntries<K, V>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: V ] | undefined => {\n  for (const e of map.entries()) {\n    if (predicate(e[ 1 ], e[ 0 ])) return e;\n  }\n};\n\n/**\n * Finds first entry by iterable value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByIterableValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByIterablePredicate} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByIterableValue = <K, V>(\n  map: IWithEntries<K, V>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (isEqual(entry[ 1 ], value)) return entry;\n  }\n};\n\n\n\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link Util.ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n *\n * @example\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\";\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * Maps.addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\nexport const addKeepingExisting = <V>(\n  set: ReadonlyMap<string, V> | undefined,\n  hasher: ToString<V>,\n  ...values: readonly V[]\n) => {\n  const s = set === undefined ? new Map() : new Map(set);\n  for (const v of values) {\n    const hashResult = hasher(v);\n    if (s.has(hashResult)) continue;\n    s.set(hashResult, v);\n  }\n  return s;\n};\n\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  comparer?: (a: V, b: V) => number\n) => {\n  const f = comparer ?? defaultComparer;\n  [ ...map.entries() ].sort((a, b) => f(a[ 1 ], b[ 1 ]));\n};\n\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * cosnt m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = Maps.sortByValue(m, `name`);\n * ```\n * @param map Map to sort\n * @param prop Property of value\n * @param compareFn Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = <K, V, Z>(\n  map: ReadonlyMap<K, V>,\n  prop: string,\n  compareFn?: (a: Z, b: Z) => number\n) => {\n  const cfn = typeof compareFn === `undefined` ? defaultComparer : compareFn;\n  return [ ...map.entries() ].sort((aE, bE) => {\n    const a = aE[ 1 ];\n    const b = bE[ 1 ];\n    // @ts-ignore\n    return cfn(a[ prop ], b[ prop ]);\n  });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  const entries = Array.from(map.entries());\n  return entries.some((kv) => comparer(kv[ 1 ], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\n//eslint-disable-next-line func-style\nexport function* filter<V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = <V>(map: ReadonlyMap<string, V>): ReadonlyArray<V> =>\n  Array.from(map.values());\n\n\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` }\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = Maps.fromIterable(data, v => v.fruit);\n * ```\n * @param data Input data\n * @param keyFn Function which returns a string id. By default uses the JSON value of the object.\n * @param allowOverwrites When set to _true_, items with same id will silently overwrite each other, with last write wins. _false_ by default.\n * @returns\n */\nexport const fromIterable = <V>(\n  data: Iterable<V>,\n  keyFn = toStringDefault<V>,\n  allowOverwrites = false\n): ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const id = keyFn(d);\n    if (m.has(id) && !allowOverwrites) {\n      throw new Error(\n        `id ${ id } is already used and new data will overwrite it. `\n      );\n    }\n    m.set(id, d);\n  }\n  return m;\n};\n\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = Maps.fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObject}.\n * @param data\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const fromObject = <V>(data: any): ReadonlyMap<string, V> => {\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\n  const map = new Map<string, V>();\n  if (Array.isArray(data)) {\n    data.forEach((d) => addObject<V>(map, d));\n  } else {\n    addObject<V>(map, data);\n  }\n  return map;\n};\n\n/**\n * Adds an object to an existing map. It assumes a structure where\n * each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = new Map();\n * Maps.addObject(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any,functional/prefer-readonly-type\nexport const addObject = <V>(map: Map<string, V>, data: any) => {\n  const entries = Object.entries(data);\n  for (const [ key, value ] of entries) {\n    map.set(key, value as V);\n  }\n};\n/**\n * Returns the first found item that matches `predicate` or _undefined_.\n *\n * If you want all matches, use {@link filter}.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching item\n * @returns Found item or _undefined_\n */\nexport const find = <V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n): V | undefined => Array.from(map.values()).find(predicate);\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const mapToObjTransform = <T, K>(\n  m: ReadonlyMap<string, T>,\n  valueTransform: (value: T) => K\n): { readonly [ key: string ]: K } =>\n  Array.from(m).reduce((obj: any, [ key, value ]) => {\n    const t = valueTransform(value);\n    /* eslint-disable-next-line functional/immutable-data */\n    obj[ key ] = t;\n    return obj;\n  }, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = <V>(\n  keys: ReadonlyArray<string>,\n  values: ArrayLike<V | undefined>\n) => {\n  if (keys.length !== values.length) {\n    throw new Error(`Keys and values arrays should be same length`);\n  }\n  return Object.fromEntries(keys.map((k, i) => [ k, values[ i ] ]));\n};\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = <K, V, R>(\n  source: ReadonlyMap<K, V>,\n  transformer: (value: V, key: K) => R\n) => new Map(Array.from(source, (v) => [ v[ 0 ], transformer(v[ 1 ], v[ 0 ]) ]));\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nexport const toObject = <T>(\n  m: ReadonlyMap<string, T>\n): { readonly [ key: string ]: T } =>\n  Array.from(m).reduce((obj: any, [ key, value ]) => {\n    /* eslint-disable-next-line functional/immutable-data */\n    obj[ key ] = value;\n    return obj;\n  }, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = <K, V, R>(\n  m: ReadonlyMap<K, V>,\n  transformer: (key: K, item: V) => R\n): readonly R[] => Array.from(m.entries()).map((x) => transformer(x[ 0 ], x[ 1 ]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also [Arrays.mergeByKey](functions/Collections.Arrays.mergeByKey.html) if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = <K, V>(\n  reconcile: MergeReconcile<V>,\n  ...maps: readonly ReadonlyMap<K, V>[]\n): ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [ mk, mv ] of m) {\n      //eslint-disable-next-line functional/no-let\n      let v = result.get(mk);\n      if (v) {\n        v = reconcile(v, mv);\n      } else {\n        v = mv;\n      }\n      result.set(mk, v);\n    }\n  }\n  return result;\n};\n","import { type RandomSource, defaultRandom } from \"./Types.js\";\n\n/**\n* Returns a random number from 0..weightings.length, distributed by the weighting values.\n* \n* eg: produces 0 20% of the time, 1 50% of the time, 2 30% of the time\n* ```js\n* weightedIndex([0.2, 0.5, 0.3]);\n* ```\n* @param weightings \n* @param rand \n* @returns \n*/\nexport const weightedIndex = (weightings: Array<number>, rand: RandomSource = defaultRandom): () => number => {\n  const precompute: Array<number> = [];\n  let total = 0;\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let index = 0; index < weightings.length; index++) {\n    total += weightings[ index ];\n    precompute[ index ] = total;\n  }\n  if (total !== 1) throw new Error(`Weightings should add up to 1. Got: ${ total }`);\n\n  return (): number => {\n    const v = rand();\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < precompute.length; index++) {\n      if (v <= precompute[ index ]) return index;\n    }\n    throw new Error(`Bug: weightedIndex could not select index`);\n  }\n}","/**\n * Throws an error if `array` parameter is not a valid array\n *\n * ```js\n * import { guardArray } from 'https://unpkg.com/ixfx/dist/arrays.js';\n * guardArray(someVariable);\n * ```\n * @private\n * @param array\n * @param name\n */\nexport const guardArray = <V>(array: ArrayLike<V>, name = `?`) => {\n  if (array === undefined) {\n    throw new TypeError(`Param '${ name }' is undefined. Expected array.`);\n  }\n  if (array === null) {\n    throw new TypeError(`Param '${ name }' is null. Expected array.`);\n  }\n  if (!Array.isArray(array)) {\n    throw new TypeError(`Param '${ name }' not an array as expected`);\n  }\n};\n","import { guardArray } from \"./GuardArray.js\";\nimport { throwIntegerTest } from '../Guards.js';\n/**\n * Throws if `index` is an invalid array index for `array`, and if\n * `array` itself is not a valid array.\n * @param array\n * @param index\n */\nexport const guardIndex = <V>(\n  array: ArrayLike<V>,\n  index: number,\n  name = `index`\n) => {\n  guardArray(array);\n  throwIntegerTest(index, `positive`, name);\n  if (index > array.length - 1) {\n    throw new Error(\n      `'${ name }' ${ index } beyond array max of ${ array.length - 1 }`\n    );\n  }\n};","import { type IsEqual, isEqualValueDefault } from \"../../IsEqual.js\";\n\n/**\n * Returns _true_ if all the contents of the array are identical.\n *\n * @example Uses default equality function:\n * ```js\n * import { valuesEqual } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a1 = [10, 10, 10];\n * valuesEqual(a1); // True\n *\n * const a2 = [ {name:`Jane`}, {name:`John} ];\n * valuesEqual(a2); // True, because JSON version captures value\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * valuesEqual(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const valuesEqual = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  array: ReadonlyArray<V> | Array<V>,\n  equality?: IsEqual<V>\n): boolean => {\n  // Unit tested\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","/**\n * Returns a section from an iterable\n * @param it Iterable\n * @param start Start index\n * @param end End index (or until completion)\n */\n//eslint-disable-next-line func-style\nexport function* slice<V>(\n  it: Iterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.iterator ]();\n\n  for (; start > 0; start--, end--) iit.next();\n\n  for (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n","import { guardArray } from \"./GuardArray.js\";\nimport { guardIndex } from \"./GuardIndex.js\";\n\n/**\n * Return elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = filterBetween(people, person => person.registered, 5, 10);\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport const filterBetween = <V>(\n  array: ReadonlyArray<V> | Array<V>,\n  predicate: (\n    value: V,\n    index: number,\n    array: ReadonlyArray<V> | Array<V>\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Array<V> => {\n  guardArray(array);\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n  guardIndex(array, startIndex, `startIndex`);\n  guardIndex(array, endIndex - 1, `endIndex`);\n\n  const t: Array<V> = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = startIndex; index < endIndex; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    if (predicate(array[ index ], index, array)) t.push(array[ index ]);\n  }\n  return t;\n};","import { slice } from '../iterable/SliceSync.js';\nimport { filterBetween } from './FilterBetween.js';\n\nexport type MinMaxAvgTotal = {\n  /**\n   * Smallest value in array\n   */\n  readonly min: number;\n  /**\n   * Total of all items\n   */\n  readonly total: number;\n  /**\n   * Largest value in array\n   */\n  readonly max: number;\n  /**\n   * Average value in array\n   */\n  readonly avg: number;\n};\n\nexport type MinMaxAvgOpts = {\n  /**\n   * Start index, inclusive\n   */\n  readonly startIndex?: number;\n  /**\n   * End index, exclusive\n   */\n  readonly endIndex?: number;\n};\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * const v = [10, 2, 4.2, 99];\n * const mma = Arrays.minMaxAvg(v);\n * Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link average}, {@link max}, {@link min} or {@link total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * Arrays.minMaxAvg(count(5,1)); // Averages 1,2,3,4,5\n * ```\n * @param data\n * @param opts Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const minMaxAvg = (\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<number> | Array<number> | Iterable<number>,\n  opts: MinMaxAvgOpts = {}\n): MinMaxAvgTotal => {\n  if (data === undefined) throw new Error(`'data' is undefined`);\n  if (!Array.isArray(data)) {\n    if (`next` in data) {\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      if (opts.startIndex || opts.endIndex) {\n        data = slice(data, opts.startIndex, opts.endIndex);\n      }\n      //eslint-disable-next-line functional/no-let\n      let total = 0;\n      //eslint-disable-next-line functional/no-let\n      let min = Number.MAX_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let max = Number.MIN_SAFE_INTEGER;\n      //eslint-disable-next-line functional/no-let\n      let samples = 0;\n      for (const v of data) {\n        if (typeof v !== `number`) {\n          throw new TypeError(`Generator should yield numbers. Got: ${ typeof v }`);\n        }\n        total += v;\n        samples++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n      }\n      return {\n        avg: total / samples,\n        total,\n        max,\n        min,\n      };\n    } else {\n      throw new Error(`'data' parameter is neither array or iterable`);\n    }\n  }\n\n  if (data.length === 0) {\n    return {\n      total: 0,\n      min: 0,\n      max: 0,\n      avg: 0,\n    };\n  }\n  const startIndex = opts.startIndex ?? 0;\n  const endIndex = opts.endIndex ?? data.length;\n\n  const validNumbers = filterBetween<number>(\n    data,\n    (d) => typeof d === `number` && !Number.isNaN(d),\n    startIndex,\n    endIndex\n  );\n  const total = validNumbers.reduce((accumulator, v) => accumulator + v, 0);\n  return {\n    total: total,\n    max: Math.max(...validNumbers),\n    min: Math.min(...validNumbers),\n    avg: total / validNumbers.length,\n  };\n};\n","export {\n  minMaxAvg,\n  type MinMaxAvgOpts,\n  type MinMaxAvgTotal,\n} from '../MinMaxAvg.js';\n\n\n/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * // Six items\n * Arrays.weight([1,1,1,1,1,1], Easings.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an {@link Modulation.Easings.EasingFn}. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * Arrays.weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Non-numbers in `data` will be silently ignored (this filtering happens first, so relative index values are sane still).\n *\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (\n  data: Array<number> | ReadonlyArray<number>,\n  fn?: (relativePos: number) => number\n): Array<number> => {\n  const f = fn ?? ((x: number) => x);\n  return validNumbers(data).map(\n    (v: number, index: number) => v * f(index / (validNumbers.length - 1))\n  );\n};\n\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data: ReadonlyArray<number>) =>\n  data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n\n/**\n * Returns the dot product of two arbitrary-sized arrays. Assumed they are of the same length.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (\n  values: ReadonlyArray<ReadonlyArray<number>>\n): number => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  const length = values[ 0 ].length;\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < length; index++) {\n    //eslint-disable-next-line functional/no-let\n    let t = 0;\n    //eslint-disable-next-line functional/no-let\n    for (const [ p, value ] of values.entries()) {\n      if (p === 0) t = value[ index ];\n      else {\n        t *= value[ index ];\n      }\n    }\n    r += t;\n  }\n  return r;\n};\n\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link minMaxAvg} if you want min, max and total as well.\n *\n * @example\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n *\n * // Average of a list\n * const avg = Arrays.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * let data = [100,200];\n * Arrays.average(data);\n * ```\n *\n * See also: [Numbers.average](Numbers.average.html) which takes a list of parameters\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data: ReadonlyArray<number>): number => {\n  // ✔ UNIT TESTED\n  if (data === undefined) throw new Error(`data parameter is undefined`);\n  const valid = validNumbers(data);\n  const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n  return total / valid.length;\n};\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data: ReadonlyArray<number>): number =>\n  Math.min(...validNumbers(data));\n\n/**\n * Returns the index of the largest value.\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * const v = [ 10, 40, 5 ];\n * Arrays.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value > array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * const v = [ 10, 40, 5 ];\n * Arrays.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value < array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data: ReadonlyArray<number>): number =>\n  Math.max(...validNumbers(data));\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data: ReadonlyArray<number>): number =>\n  // eslint-disable-next-line unicorn/no-array-reduce\n  data.reduce((previous, current) => {\n    if (typeof current !== `number`) return previous;\n    if (Number.isNaN(current)) return previous;\n    if (Number.isFinite(current)) return previous;\n    return previous + current;\n  }, 0);\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const maxFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = Number.MIN_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m = Math.max(m, datum);\n  }\n  return m;\n};\n\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const totalFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = 0;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m += datum;\n  }\n  return m;\n};\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * Arrays.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const minFast = (data: ReadonlyArray<number> | Float32Array): number => {\n  //eslint-disable-next-line functional/no-let\n  let m = Number.MIN_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  for (const datum of data) {\n    m = Math.min(m, datum);\n  }\n  return m;\n};\n","\n/**\n * Cycle through the contents of an array. By default starts at index 0.\n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n * \n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n * \n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n * \n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over \n * @returns \n */\nexport const cycle = <T>(options: ReadonlyArray<T> | Array<T>) => {\n  const opts = [ ...options ];\n  let index = 0;\n  const next = () => {\n    index++;\n    if (index === opts.length) index = 0;\n    return value();\n  }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  const prev = () => {\n    index--;\n    if (index === -1) index = opts.length - 1;\n    return value();\n  }\n\n  const value = (): typeof opts[ number ] => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return opts.at(index)!;\n  }\n\n  const select = (indexOrValue: number | typeof opts[ number ]) => {\n    if (typeof indexOrValue === `number`) {\n      index = indexOrValue;\n    } else {\n      const found = opts.indexOf(indexOrValue);\n      if (found === -1) throw new Error(`Could not find value`);\n      index = found;\n    }\n  }\n\n  const toArray = () => [ ...opts ];\n  return { toArray, next, prev, get current() { return value() }, select }\n}","import { valuesEqual } from \"./ValuesEqual.js\";\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { zip } from 'https://unpkg.com/ixfx/dist/arrays.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\n\n\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const zip = (\n  ...arrays: Array<Array<any>> | ReadonlyArray<Array<any>> | ReadonlyArray<ReadonlyArray<any>>\n): Array<any> => {\n  // Unit tested\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => a.length);\n  if (!valuesEqual(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","// Easings from https://easings.net/\nimport { interpolate } from '../data/Interpolate.js';\nimport {\n  msElapsedTimer,\n  type HasCompletion,\n  relativeTimer,\n  ticksElapsedTimer,\n  type TimerSource,\n} from '../flow/index.js';\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst pi = Math.PI;\nconst sin = Math.sin;\n/*\ntype RelativeTimer = {\n  reset(): void\n  elapsed(): number\n  isDone(): boolean\n}\n\ntype TimerSource = (upperBound: number) => RelativeTimer;\n\nconst msRelativeTimer = function (upperBound: number): RelativeTimer {\n  let start = performance.now();\n  return {\n    reset: () => {\n      start = performance.now();\n    },\n    elapsed: () => clamp((performance.now() - start) / upperBound),\n    isDone: () => (performance.now() - start) >= upperBound,\n  };\n};\n\nconst tickRelativeTimer = function (upperBound: number): RelativeTimer {\n  let start = 0;\n  return {\n    reset: () => {\n      start = 0;\n    },\n    elapsed: () => clamp(start++ / upperBound),\n    isDone: () => start >= upperBound,\n  };\n};\n*/\n\nexport type EasingFn = (x: number) => number;\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.time(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationMs Duration in milliseconds\n * @returns Easing\n */\nexport const time = function (\n  nameOrFunction: EasingName | EasingFn,\n  durationMs: number\n): Easing {\n  return create(nameOrFunction, durationMs, msElapsedTimer);\n};\n\n/**\n * Creates an easing based on ticks\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tick(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFn Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tick = function (\n  nameOrFunction: EasingName | EasingFn,\n  durationTicks: number\n): Easing {\n  return create(nameOrFunction, durationTicks, ticksElapsedTimer);\n};\n\n/**\n * 'Ease' from `0` to `1` over a delicious curve. Commonly used for animation\n * and basic modelling of phyical motion.\n *\n * Create via {@link tick} or {@link time}, call `compute` to calculate the next\n * value in the progression, until you reach `1` or `isDone` returns true.\n *\n */\nexport type Easing = HasCompletion & {\n  /**\n   * Computes the current value of the easing\n   *\n   * @returns {number}\n   */\n  compute(): number;\n\n  /**\n   * Reset the easing\n   */\n  reset(): void;\n  /**\n   * Returns true if the easing is complete\n   *\n   * @returns {boolean}\n   */\n  get isDone(): boolean;\n};\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, msElapsedTimer);\n * ```\n * @param nameOrFn Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source. Eg {@link tickRelativeTimer}, {@link msRelativeTimer}\n * @returns\n */\nconst create = function (\n  nameOrFunction: EasingName | EasingFn,\n  duration: number,\n  timerSource: TimerSource\n): Easing {\n  //eslint-disable-next-line functional/no-let\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (fn === undefined) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: ${ nameOrFunction }`) : new Error(`Easing function not found`);\n    throw error;\n  }\n\n  // Get a relative version of timer\n  const timer = relativeTimer(duration, {\n    timer: timerSource(),\n    clampValue: true,\n  });\n\n  return {\n    get isDone() {\n      return timer.isDone;\n    },\n    compute: () => {\n      const relative = timer.elapsed;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return fn(relative);\n    },\n    reset: () => {\n      timer.reset();\n    },\n  };\n};\n\n/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @param t\n * @returns Value\n */\nexport const fromCubicBezier =\n  (b: number, d: number): EasingFn =>\n    (t: number) => {\n      const s = 1 - t;\n      const s2 = s * s;\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n    };\n\n/**\n * Returns a mix of two easing functions.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Get a 50/50 mix of two easing functions at t=0.25\n * Easings.mix(0.5, 0.25, Easings.functions.sineIn, Easings.functions.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.functions.sineIn, Easings.functions.sineOut);\n * ```\n * @param amt 'Progress' value passed to the easing functions\n * @param balance Mix between a and b\n * @param easingA\n * @param easingB\n * @returns Numeric value\n */\nexport const mix = (\n  amt: number,\n  balance: number,\n  easingA: EasingFn,\n  easingB: EasingFn\n) => interpolate(balance, easingA(amt), easingB(amt));\n\n/**\n * Returns a 'crossfade' of two easing functions, synchronised with the progress through the easing. That is:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of a, 20% of b, with both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of a, 80% of a, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower valus.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * Easings.crossFade(0.5, Easings.functions.sineIn, Easings.functions.sineOut);\n * ```\n * @param amt\n * @param easingA\n * @param easingB\n * @returns Numeric value\n */\nexport const crossfade = (amt: number, easingA: EasingFn, easingB: EasingFn) =>\n  mix(amt, amt, easingA, easingB);\n\n/**\n * Easing name\n */\nexport type EasingName = keyof typeof functions;\n\n/**\n * Returns an easing function by name, or _undefined_ if not found.\n * This is a manual way of working with easing functions. If you want to\n * ease over time or ticks, use `Flow.Timer.msElapsedTimer` or `Flow.Timer.ticksElapsedTimer`.\n *\n * ```js\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n *\n * This function is useful if trying to resolve an easing by string. If you\n * know in advance what easing to use, you could also access it via\n * `Easings.functions.NAME`, eg `Easings.functions.sineIn`.\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): EasingFn | undefined {\n  if (easingName === null) throw new Error(`easingName is null`);\n  if (easingName === undefined) throw new Error(`easingName is undefined`);\n  const name = easingName.toLocaleLowerCase();\n  const found = Object.entries(functions).find(\n    ([ k, _v ]) => k.toLocaleLowerCase() === name\n  );\n\n  if (found === undefined) return found;\n  return found[ 1 ];\n};\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasings(): Iterable<string> {\n  yield* Object.keys(functions);\n};\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4): EasingFn => {\n  const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = a / standardDeviation;\n    // p:-8 pinched\n    //eslint-disable-next-line functional/no-let\n    let p = -2.5; // -1/1.25;\n    //eslint-disable-next-line functional/no-let\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n\n    //if (v >1) console.log(v);\n    //if (v < 0) console.log(v);\n    return v;\n  };\n};\n\nconst bounceOut = function (x: number): number {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nconst quintIn = (x: number): number => x * x * x * x * x;\nconst quintOut = (x: number): number => 1 - pow(1 - x, 5);\nconst arch = (x: number): number => x * (1 - x) * 4;\n\n/**\n * Weighted average\n * \n * `slowDownFactor` \n * @param currentValue \n * @param targetValue \n * @param slowDownFactor \n * @returns \n */\nexport const weightedAverage = (currentValue: number, targetValue: number, slowDownFactor: number) => {\n  return ((currentValue * (slowDownFactor - 1)) + targetValue) / slowDownFactor\n}\n\nexport const functions = {\n  smoothstep: (x: number): number => x * x * (3 - 2 * x),\n  smootherstep: (x: number): number => (x * (x * 6 - 15) + 10) * x * x * x,\n  arch,\n  bell: gaussian(),\n  sineIn: (x: number): number => 1 - cos((x * pi) / 2),\n  sineOut: (x: number): number => sin((x * pi) / 2),\n  quadIn: (x: number): number => x * x,\n  quadOut: (x: number): number => 1 - (1 - x) * (1 - x),\n  sineInOut: (x: number): number => -(cos(pi * x) - 1) / 2,\n  quadInOut: (x: number): number =>\n    x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2,\n  cubicIn: (x: number): number => x * x * x,\n  cubicOut: (x: number): number => 1 - pow(1 - x, 3),\n  quartIn: (x: number): number => x * x * x * x,\n  quartOut: (x: number): number => 1 - pow(1 - x, 4),\n  quintIn,\n  quintOut, //: (x: number): number => 1 - pow(1 - x, 5),\n  expoIn: (x: number): number => (x === 0 ? 0 : pow(2, 10 * x - 10)),\n  expoOut: (x: number): number => (x === 1 ? 1 : 1 - pow(2, -10 * x)),\n  quintInOut: (x: number): number =>\n    x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2,\n  expoInOut: (x: number): number =>\n    x === 0\n      ? 0\n      : x === 1\n        ? 1\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : x < 0.5\n          ? pow(2, 20 * x - 10) / 2\n          : (2 - pow(2, -20 * x + 10)) / 2,\n  circIn: (x: number): number => 1 - sqrt(1 - pow(x, 2)),\n  circOut: (x: number): number => sqrt(1 - pow(x - 1, 2)),\n  backIn: (x: number): number => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n\n    return c3 * x * x * x - c1 * x * x;\n  },\n  backOut: (x: number): number => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n  },\n  circInOut: (x: number): number =>\n    x < 0.5\n      ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n      : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2,\n  backInOut: (x: number): number => {\n    const c1 = 1.701_58;\n    const c2 = c1 * 1.525;\n\n    return x < 0.5\n      ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n      : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n  },\n  elasticIn: (x: number): number => {\n    const c4 = (2 * pi) / 3;\n\n    return x === 0\n      ? 0\n      : (x === 1\n        ? 1\n        : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n  },\n  elasticOut: (x: number): number => {\n    const c4 = (2 * pi) / 3;\n\n    return x === 0\n      ? 0\n      : (x === 1\n        ? 1\n        : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n  },\n  bounceIn: (x: number): number => 1 - bounceOut(1 - x),\n  bounceOut: bounceOut,\n  elasticInOut: (x: number): number => {\n    const c5 = (2 * pi) / 4.5;\n\n    return x === 0\n      ? 0\n      : x === 1\n        ? 1\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : x < 0.5\n          ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n          : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n  },\n  bounceInOut: (x: number): number =>\n    x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,\n};\n","import { throwNumberTest, throwIntegerTest } from '../Guards.js';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min: number = 0, max: number = 360) => {\n  throwIntegerTest(v, undefined, `v`);\n  throwIntegerTest(min, undefined, `min`);\n  throwIntegerTest(max, undefined, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min: number = 0, max: number = 1) => {\n  throwNumberTest(v, ``, `min`);\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  // No wrapping\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","import { wrap } from './Wrap.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide](https://clinth.github.io/ixfx-docs/modulation/interpolate/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import {interpolate} from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * Interpolation is often used for animation. In that case, `amount`\n * would start at 0 and you would keep interpolating up to `1`\n * @example\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { percentPingPong } from 'https://unpkg.com/ixfx/dist/modulation.js'\n *\n * // Go back and forth between 0 and 1 by 0.1\n * let pp = percentPingPong(0.1);\n * continuously(() => {\n *  // Get position in ping-pong\n *  const amt = pp.next().value;\n *  // interpolate between Math.PI and Math.PI*2\n *  const v = interpolate(amt, Math.PI, Math.PI*2);\n *  // do something with v...\n * }).start();\n * ```\n *\n * See also {@link Visual.Colour.interpolate | Visual.Colour.interpolate }, {@link Geometry.Points.interpolate | Geometry.Points.interpolate}.\n * @param amount Interpolation amount, between 0 and 1 inclusive\n * @param a Start (ie when `amt` is 0)\n * @param b End (ie. when `amt` is 1)\n * @returns Interpolated value which will be between `a` and `b`.\n */\nexport const interpolate = (amount: number, a: number, b: number): number => {\n  const v = (1 - amount) * a + amount * b;\n  return v;\n};\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians\n * @param bRadians\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t));\n};\n","\nexport * as Elapsed from './Elapsed.js';\nexport * from './DispatchList.js';\n\nimport { throwNumberTest } from '../Guards.js';\nimport { sleep } from './Sleep.js';\n\nimport * as StateMachine from './StateMachine.js';\nimport * as Timer from './Timer.js';\nexport * from './Types.js';\n/**\n * State Machine\n * See [here for usage](../classes/Flow.StateMachine.StateMachine.html).\n *\n * * {@link StateMachine.driver}: Drive a state machine\n * * {@link StateMachine.init}: Create a state machine from initial state and machine description\n * * {@link fromList}: Create a state machine from a simple list of states\n */\nexport * as StateMachine from './StateMachine.js';\n\nexport * from './Timer.js';\n\nexport * from './Interval.js';\nexport * from './IntervalType.js';\nexport * from './Timeout.js';\nexport * from './UpdateOutdated.js';\nexport * from './Continuously.js';\nexport * from './Debounce.js';\nexport * from './Throttle.js';\nexport * from './Sleep.js';\nexport * from './WaitFor.js';\nexport * from './Delay.js';\nexport * from './Every.js';\nexport * from './RunOnce.js';\nexport * from './Retry.js';\nexport * from './Types.js';\n\nexport { TaskQueue } from './TaskQueue.js';\n\n\n\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEachAsync} if you want to use an async `iterator` and async `fn`.\n * @param iterator Iterable or array\n * @typeParam V Type of iterable\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport const forEach = <V>(\n  iterator: IterableIterator<V> | ReadonlyArray<V>,\n  fn: (v?: V) => boolean\n) => {\n  for (const x of iterator) {\n    const r = fn(x);\n    if (typeof r === `boolean` && !r) break;\n  }\n};\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * Use {@link forEach} for a synchronous version.\n *\n * ```\n * // Prints items from array every second\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * @example Retry `doSomething` up to five times, with 5 seconds between each attempt\n * ```\n * await forEachAsync(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @typeParam V Type of iterable\n */\nexport const forEachAsync = async function <V>(\n  iterator: AsyncIterableIterator<V> | ReadonlyArray<V>,\n  fn: (v?: V) => Promise<boolean> | Promise<void>,\n  intervalMs?: number\n) {\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  }\n};\n\nexport type RepeatPredicate = (\n  repeats: number,\n  valuesProduced: number\n) => boolean;\n/**\n * Runs `fn` a certain number of times, yielding results.\n * If `fn` returns undefined, the result is ignored, but loop continues.\n *\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Repeats can be specified as an integer (eg. 5 for five repeats), or a function\n * that gives _false_ when repeating should stop.\n *\n * ```js\n * // Keep running `fn` until we've accumulated 10 values\n * // Useful if `fn` sometimes returns _undefined_\n * const results = repeat((repeats, valuesProduced) => valuesProduced < 10, fn);\n * ```\n *\n * If you don't need to accumulate return values, consider {@link Generators.count | Generators.count} with {@link Flow.forEach | Flow.forEach}.\n * If you want to have a waiting period between each repetition, consider {@link Flow.interval}.\n * @param countOrPredicate Number of repeats or function returning false when to stop\n * @param fn Function to run, must return a value to accumulate into array or _undefined_\n * @returns Yields results, one at a time\n */\nexport function* repeat<V>(\n  countOrPredicate: number | RepeatPredicate,\n  fn: (repeats: number, valuesProduced: number) => V | undefined\n) {\n  // Unit tested: expected return array length\n  //eslint-disable-next-line functional/no-let\n  let repeats, valuesProduced;\n  repeats = valuesProduced = 0;\n\n  if (typeof countOrPredicate === `number`) {\n    throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n    while (countOrPredicate-- > 0) {\n      repeats++;\n      const v = fn(repeats, valuesProduced);\n      if (v === undefined) continue;\n      yield v;\n      valuesProduced++;\n    }\n  } else if (typeof countOrPredicate === `function`) {\n    while (countOrPredicate(repeats, valuesProduced)) {\n      repeats++;\n      const v = fn(repeats, valuesProduced);\n      if (v === undefined) continue;\n      yield v;\n      valuesProduced++;\n    }\n  } else {\n    throw new TypeError(\n      `countOrPredicate should be a number or function. Got: ${ typeof countOrPredicate }`\n    );\n  }\n}\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate\n * @param fn\n * @param initial\n * @param reduce\n * @returns\n */\nexport const repeatReduce = <V>(\n  countOrPredicate: number | RepeatPredicate,\n  fn: () => V | undefined,\n  initial: V,\n  reduce: (accumulator: V, value: V) => V\n): V => {\n  if (typeof countOrPredicate === `number`) {\n    throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n    while (countOrPredicate-- > 0) {\n      const v = fn();\n      if (v === undefined) continue;\n      initial = reduce(initial, v);\n    }\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let repeats, valuesProduced;\n    repeats = valuesProduced = 0;\n    while (countOrPredicate(repeats, valuesProduced)) {\n      repeats++;\n      const v = fn();\n      if (v === undefined) continue;\n      initial = reduce(initial, v);\n      valuesProduced++;\n    }\n  }\n  return initial;\n};\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Flow: { StateMachine, Timer, forEach, forEachAsync, repeat },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n","import { round } from '../numbers/Round.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport { msElapsedTimer, relativeTimer } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since initial call.\n * ```js\n * // Record start\n * const elapsed = Elapsed.since();\n *\n * // Get elapsed time in millis\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a elapsed timer, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Elapsed.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: Elapsed.since() }\n * ```\n *\n * Use {@link once} if you want to measure a single period, and stop it.\n * @returns\n */\nexport const since = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns elapsed time since initial call, however\n * timer stops when first invoked.\n *\n * ```js\n * const elapsed = Elapsed.once();\n * // ...do stuff\n * elapsed(); // Yields time since Elapsed.once() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n *\n * Use {@link since} to not have this stopping behaviour.\n * @returns\n */\nexport const once = (): Since => {\n  const start = Date.now();\n  //eslint-disable-next-line functional/no-let\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince`.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = Elapsed.infinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Elapsed.since();\n * });\n * ```\n * @returns\n */\nexport const infinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts timing immediately.\n *\n * ```js\n * const timer = Elapsed.progress(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Elapsed.progress(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Elapsed.progress({ mins: 4 });\n * ```\n * See also {@link hasElapsedMs}.\n * @param totalMs\n * @returns\n */\nexport function progress(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`duration invalid`);\n  const timerOpts = {\n    ...opts,\n    timer: msElapsedTimer(),\n  };\n  const t = relativeTimer(totalMs, timerOpts);\n  return () => t.elapsed;\n}\n\nexport const toString = (millisOrFunction: number | Since | Interval, rounding = 2): string => {\n  //eslint-disable-next-line functional/no-let\n  let interval: number | undefined = {} = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return toString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};\n","import { throwFromResult, integerTest } from \"../Guards.js\";\n\nexport function round(decimalPlaces: number, v: number): number;\nexport function round(decimalPlaces: number): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number) {\n  throwFromResult(integerTest(a, `positive`, `decimalPlaces`));\n\n  //eslint-disable-next-line functional/no-let\n  let rounder;\n  if (a === 0) rounder = Math.round;\n  else {\n    const p = Math.pow(10, a);\n    rounder = (v: number) => Math.floor(v * p) / p;\n  }\n\n  return b === undefined ? rounder : rounder(b);\n}","import { clamp } from '../data/Clamp.js';\nimport { type HasCompletion } from './index.js';\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * See {@link msElapsedTimer}, {@link ticksElapsedTimer}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void;\n  get elapsed(): number;\n};\n\nexport type ModulationTimer = Timer & {\n  mod(amt: number): void;\n};\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link msElapsedTimer}.\n   */\n  readonly timer?: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue?: boolean\n  readonly wrapValue?: boolean\n};\n\n/**\n * Returns a function that returns true if timer is complete\n *\n * ```js\n * const timer = hasElapsedMs(1000);\n * timer(); // Returns true if timer is done\n * ```\n *\n * See also {@link Elapsed.progress}.\n * @param totalMs\n * @returns\n */\nexport function hasElapsedMs(totalMs: number): () => boolean {\n  const t = relativeTimer(totalMs, { timer: msElapsedTimer() });\n  return () => t.isDone;\n}\n\nexport const frequencyTimerSource =\n  (frequency: number): TimerSource =>\n    () =>\n      frequencyTimer(frequency, { timer: msElapsedTimer() });\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total duration.\n *\n * If no timer is specified, milliseconds-based timer is used.\n *\n * ```js\n * const t = relativeTimer(1000);\n * t.isDone;\n * t.reset();\n * t.elapsed;\n * ```\n *\n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = relativeTimer(1000, { timer: ticksElapsedTimer(); clampValue:true });\n *\n * t.isDone;  // true if total has elapsed\n * t.reset(); // reset timer to 0\n * t.elapsed; // 0..1 scale of how close to completion\n * ```\n *\n * @private\n * @param total Total\n * @param opts Options\n * @returns Timer\n */\nexport const relativeTimer = (\n  total: number,\n  opts: RelativeTimerOpts = {}\n): ModulationTimer & HasCompletion => {\n  const timer = opts.timer ?? msElapsedTimer();\n  const clampValue = opts.clampValue ?? false;\n  const wrapValue = opts.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  //eslint-disable-next-line functional/no-let\n  let done = false;\n  //eslint-disable-next-line functional/no-let\n  let modulationAmount = 1;\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      return done;\n    },\n    reset: () => {\n      done = false;\n      timer.reset();\n    },\n    get elapsed() {\n      //eslint-disable-next-line functional/no-let\n      let v = timer.elapsed / (total * modulationAmount);\n      if (clampValue) v = clamp(v);\n      else if (wrapValue) {\n        if (v >= 1) v = v % 1;\n      } else {\n        if (v >= 1) done = true;\n      }\n      return v;\n    },\n  };\n};\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * @example Init a spring oscillator, with a half a cycle per second\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * Oscillators.spring({}, frequencyTimer(0.5));\n * ```\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency\n * @param timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  opts: TimerOpts = {}\n): ModulationTimer => {\n  const timer = opts.timer ?? msElapsedTimer();\n  const cyclesPerSecond = frequency / 1000;\n  //eslint-disable-next-line functional/no-let\n  let modulationAmount = 1;\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get elapsed() {\n      // Get position in a cycle\n      const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n      // Get fractional part\n      const f = v - Math.floor(v);\n      if (f < 0) {\n        throw new Error(\n          `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n        );\n      }\n      if (f > 1) {\n        throw new Error(\n          `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n        );\n      }\n      return f;\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = msElapsedTimer();\n * t.reset(); // reset start\n * t.elapsed; // ms since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const msElapsedTimer = (): Timer => {\n  // eslint-disable-next-line functional/no-let\n  let start = performance.now();\n  return {\n    reset: () => {\n      start = performance.now();\n    },\n    get elapsed() {\n      return performance.now() - start;\n    },\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = ticksElapsedTimer();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks\n * ```\n * @returns {Timer}\n * @see {msElapsedTimer}\n */\nexport const ticksElapsedTimer = (): Timer => {\n  // eslint-disable-next-line functional/no-let\n  let start = 0;\n  return {\n    reset: () => {\n      start = 0;\n    },\n    get elapsed() {\n      return ++start;\n    },\n  };\n};\n","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param Minimum value (inclusive)\n * @param Maximum value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value: number, min = 0, max = 1) => {\n  // ✔ UNIT TESTED\n  if (Number.isNaN(value)) throw new Error(`'value' parameter is NaN`);\n  if (Number.isNaN(min)) throw new Error(`'min' parameter is NaN`);\n  if (Number.isNaN(max)) throw new Error(`'max' parameter is NaN`);\n\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n};\n\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(4, myArray);    // 3\n * clampIndex(-1, myArray);   // 0\n *\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const clampIndex = (\n  v: number,\n  arrayOrLength: number | ReadonlyArray<any>\n): number => {\n  // ✔ UNIT TESTED\n  if (!Number.isInteger(v)) {\n    throw new TypeError(`v parameter must be an integer (${ v })`);\n  }\n  const length = Array.isArray(arrayOrLength)\n    ? arrayOrLength.length\n    : (arrayOrLength as number);\n\n  if (!Number.isInteger(length)) {\n    throw new TypeError(\n      `length parameter must be an integer (${ length }, ${ typeof length })`\n    );\n  }\n  v = Math.round(v);\n  if (v < 0) return 0;\n  if (v >= length) return length - 1;\n  return v;\n};\n","export type Dispatch<V> = (value: V) => void;\n\ntype Wrap<V> = {\n  readonly handler: Dispatch<V>\n  readonly id: string\n  readonly once: boolean\n}\n\nexport class DispatchList<V> {\n  #handlers: Array<Wrap<V>>\n  #counter = 0;\n  readonly #id = Math.floor(Math.random() * 100);\n  constructor() {\n\n    this.#handlers = [];\n  }\n\n  /**\n   * Returns _true_ if list is empty\n   * @returns \n   */\n  isEmpty() {\n    return this.#handlers.length === 0;\n  }\n\n  /**\n   * Adds a handler\n   * @param handler \n   * @param options \n   * @returns \n   */\n  add(handler: Dispatch<V>, options: { once?: boolean } = {}): string {\n    this.#counter++;\n    const once = options.once ?? false;\n    const wrap: Wrap<V> = {\n      id: this.#id + `-` + this.#counter,\n      handler,\n      once\n    }\n    this.#handlers.push(wrap);\n    return wrap.id;\n  }\n\n  remove(id: string): boolean {\n    const length = this.#handlers.length;\n    this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n    return this.#handlers.length !== length;\n  }\n\n  notify(value: V) {\n    for (const handler of this.#handlers) {\n      handler.handler(value);\n      if (handler.once) {\n        this.remove(handler.id);\n      }\n    }\n  }\n\n  clear() {\n    this.#handlers = [];\n  }\n}","import { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\n\nimport { type AsyncPromiseOrGenerator } from './Types.js';\n\nexport type IntervalOpts = {\n  /**\n   * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n   */\n  readonly fixed?: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  readonly minimum?: Interval;\n  /**\n   * Optional signal to abort\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When to perform delay. Default is before 'produce' is invoked.\n   */\n  readonly delay?: `before` | `after`;\n};\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n *\n * @example Produce a random number every 500ms:\n * ```\n * const randomGenerator = interval(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example Return values from a generator every 500ms:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/generators.js'\n * for await (const v of interval(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long).\n * The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If you just want to loop at a certain speed, consider using {@link continuously} instead.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * @template V Returns value of `produce` function\n * @param produce Function, generator to use\n * @param opts Options\n * @template V Data type\n * @returns\n */\nexport const interval = async function* <V>(\n  produce: AsyncPromiseOrGenerator<V> | ArrayLike<V>,\n  optsOrFixedMs: IntervalOpts | number = {}\n): AsyncGenerator<V> {\n  //eslint-disable-next-line functional/no-let\n  let cancelled = false;\n  const opts =\n    typeof optsOrFixedMs === `number`\n      ? { fixed: optsOrFixedMs }\n      : optsOrFixedMs;\n\n  const signal = opts.signal;\n  const when = opts.delay ?? `before`;\n  //eslint-disable-next-line functional/no-let\n  let sleepMs = intervalToMs(opts.fixed) ?? intervalToMs(opts.minimum, 0);\n  //eslint-disable-next-line functional/no-let\n  let started = performance.now();\n\n  const minIntervalMs = opts.minimum ? intervalToMs(opts.minimum) : undefined;\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  // Get an iterator over array\n  if (Array.isArray(produce)) produce = produce.values();\n\n  const isGenerator =\n    typeof produce === `object` &&\n    `next` in produce &&\n    typeof produce.next === `function`;\n\n  try {\n    while (!cancelled) {\n      if (when === `before`) await doDelay();\n      //if (cancelled) return;\n      if (typeof produce === `function`) {\n        // Returns V or Promise<V>\n        const result = await produce();\n        if (typeof result === `undefined`) return; // Done\n        yield result;\n      } else if (isGenerator) {\n        // Generator\n        const result = await (produce as AsyncGenerator<V>).next();\n        if (result.done) return;\n        yield result.value;\n      } else {\n        throw new Error(\n          `produce param does not seem to return a value/Promise and is not a generator?`\n        );\n      }\n\n      if (when === `after`) await doDelay();\n    }\n  } finally {\n    cancelled = true;\n  }\n};\n","import { throwIntegerTest, integerTest } from '../Guards.js';\nimport { type HasCompletion } from './index.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nexport type TimeoutSyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => void;\nexport type TimeoutAsyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => Promise<void>;\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  start(altTimeoutMs?: number, args?: ReadonlyArray<unknown>): void;\n  cancel(): void;\n  get isDone(): boolean;\n};\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `timeoutMs`.\n * If `start()` is called again, the waiting period will be reset to `timeoutMs`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * t.isDone;    // True if a scheduled event is pending\n * ```\n *\n * Callback function receives any additional parameters passed in from start.\n * This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param timeoutMs\n * @returns {@link Timeout}\n */\nexport const timeout = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): Timeout => {\n  if (callback === undefined) {\n    throw new Error(`callback parameter is undefined`);\n  }\n  const intervalMs = intervalToMs(interval);\n  throwIntegerTest(intervalMs, `aboveZero`, `interval`);\n\n  //eslint-disable-next-line functional/no-let\n  let timer = 0;\n  //eslint-disable-next-line functional/no-let\n  let startedAt = 0;\n  const start = async (\n    altInterval: Interval = interval,\n    args: Array<unknown>\n  ): Promise<void> => {\n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      const altTimeoutMs = intervalToMs(altInterval);\n      const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      if (!it[ 0 ]) {\n        reject(it[ 1 ]);\n        return;\n      }\n      if (timer !== 0) cancel();\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      timer = window.setTimeout(async () => {\n        const args_ = args ?? [];\n        await callback(performance.now() - startedAt, ...args_);\n        timer = 0;\n        resolve();\n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (timer === 0) return;\n    startedAt = 0;\n    window.clearTimeout(timer);\n  };\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    start,\n    cancel,\n    get isDone() {\n      return timer !== 0;\n    },\n  };\n};\n","export type UpdateFailPolicy = `fast` | `slow` | `backoff`;\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `intervalMs` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. It's\n * minimum value will be `intervalMs`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `intervalMs` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param intervalMs Maximum age of cached result\n * @param updateFail `slow` by default\n * @returns Value\n */\nexport const updateOutdated = <V>(\n  fn: (elapsedMs?: number) => Promise<V>,\n  intervalMs: number,\n  updateFail: UpdateFailPolicy = `slow`\n): (() => Promise<V>) => {\n  //eslint-disable-next-line functional/no-let\n  let lastRun = 0;\n  //eslint-disable-next-line functional/no-let\n  let lastValue: V | undefined;\n  //eslint-disable-next-line functional/no-let\n  let intervalMsCurrent = intervalMs;\n\n  //eslint-disable-next-line no-async-promise-executor\n  return () =>\n    new Promise(async (resolve, reject) => {\n      const elapsed = performance.now() - lastRun;\n      if (lastValue === undefined || elapsed > intervalMsCurrent) {\n        try {\n          lastRun = performance.now();\n          lastValue = await fn(elapsed);\n          intervalMsCurrent = intervalMs;\n        } catch (ex) {\n          if (updateFail === `fast`) {\n            lastValue = undefined;\n            lastRun = 0;\n          } else if (updateFail === `backoff`) {\n            intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n          }\n          reject(ex);\n          return;\n        }\n      }\n      resolve(lastValue);\n    });\n};\n","import { throwIntegerTest } from '../Guards.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport type { HasCompletion } from './Types.js';\n/**\n * Runs a function continuously, returned by {@link Continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, does nothing\n   */\n  start(): void;\n\n  /**\n   * (Re-)starts the loop. If an existing iteration has been\n   * scheduled, this is cancelled and started again.\n   *\n   * This can be useful when adjusting the interval\n   */\n  reset(): void;\n  /**\n   * How many milliseconds since start() was last called\n   */\n  get elapsedMs(): number;\n  /**\n   * How many iterations of the loop since start() was last called\n   */\n  get ticks(): number;\n  /**\n   * Returns true if the loop is not running (for some reason or another)\n   */\n  get isDone(): boolean;\n  /**\n   * If disposed, the continuously instance won't be re-startable\n   */\n  get isDisposed(): boolean;\n  /**\n   * Stops loop. It can be restarted using .start()\n   */\n  cancel(): void;\n  /**\n   * Set interval. Change will take effect on next loop. For it to kick\n   * in earlier, call .reset() after changing the value.\n   */\n  set interval(interval: Interval);\n  get interval(): Interval;\n};\n\nexport type ContinuouslySyncCallback = (\n  ticks?: number,\n  elapsedMs?: number\n) => boolean | void;\nexport type ContinuouslyAsyncCallback = (\n  ticks?: number,\n  elapsedMs?: number\n) => Promise<boolean | void>;\n\nconst raf =\n  typeof window !== `undefined`\n    ? (cb: () => void) => window.requestAnimationFrame(cb)\n    : (cb: () => void) => window.setTimeout(cb, 1);\n\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type ContinuouslyOpts = {\n  readonly fireBeforeWait?: boolean;\n  /**\n   * Called whenever .start() is invoked.\n   * If this function returns:\n   *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n   *  - `cancel`: loop stops, but can be re-started if .start() is called again\n   *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n   *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n   *\n   */\n  readonly onStartCalled?: (\n    ticks?: number,\n    elapsedMs?: number\n  ) => OnStartCalled;\n};\n\n/**\n * Returns a {@link Continuously} that continuously at `intervalMs`, executing `callback`.\n * By default, first the sleep period happens and then the callback happens.\n * Use {@link Timeout} for a single event.\n *\n * If callback returns _false_, loop exits.\n *\n * Call `start` to begin/reset loop. `cancel` stops loop.\n *\n * @example Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example With delay\n * ```js\n * const fn = () => {\n *  console.log(`1 minute`);\n * }\n * const c = continuously(fn, 60*1000);\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.intervalMs; // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback Function to run. If it returns false, loop exits.\n * @param opts Additional options\n * @param intervalMs\n * @returns\n */\nexport const continuously = (\n  callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback,\n  interval?: Interval,\n  opts: ContinuouslyOpts = {}\n): Continuously => {\n  //eslint-disable-next-line functional/no-let\n  let intervalMs = intervalToMs(interval, 0);\n  throwIntegerTest(intervalMs, `positive`, `interval`);\n\n  const fireBeforeWait = opts.fireBeforeWait ?? false;\n  const onStartCalled = opts.onStartCalled;\n\n  //eslint-disable-next-line functional/no-let\n  let disposed = false;\n  //eslint-disable-next-line functional/no-let\n  let running = false;\n  //eslint-disable-next-line functional/no-let\n  let ticks = 0;\n  //eslint-disable-next-line functional/no-let\n  let startedAt = performance.now();\n  //eslint-disable-next-line functional/no-let\n  let intervalUsed = interval ?? 0;\n  //eslint-disable-next-line functional/no-let\n  let currentTimer = 0;\n\n  const schedule =\n    intervalMs === 0\n      ? raf\n      : (cb: () => void) => window.setTimeout(cb, intervalMs);\n  const deschedule =\n    intervalMs === 0\n      ? (_: number) => {\n        /** no-op */\n      }\n      : (timer: number) => window.clearTimeout(timer);\n\n  const cancel = () => {\n    if (!running) return;\n    running = false;\n    ticks = 0;\n    if (currentTimer !== 0) deschedule(currentTimer);\n    currentTimer = 0;\n  };\n\n  const loop = async () => {\n    if (!running) return;\n    const valOrPromise = callback(ticks++, performance.now() - startedAt);\n    //eslint-disable-next-line functional/no-let\n    let val;\n    if (typeof valOrPromise === `object`) {\n      val = await valOrPromise;\n    } else {\n      val = valOrPromise;\n    }\n    if (val !== undefined && !val) {\n      cancel();\n      return;\n    }\n    currentTimer = schedule(loop);\n  };\n\n  const start = () => {\n    if (disposed) throw new Error(`Disposed`);\n\n    if (onStartCalled !== undefined) {\n      // Function governs whether to allow .start() to go ahead\n      const doWhat = onStartCalled(ticks, performance.now() - startedAt);\n      if (doWhat === `cancel`) {\n        cancel();\n        return;\n      } else if (doWhat === `reset`) {\n        reset();\n        return;\n      } else if (doWhat === `dispose`) {\n        disposed = true;\n        cancel();\n        return;\n      }\n    }\n\n    if (!running) {\n      // Start running\n      startedAt = performance.now();\n      running = true;\n      if (fireBeforeWait) {\n        loop(); // Exec first, then wait\n      } else {\n        currentTimer = schedule(loop); // Wait first, then exec\n      }\n    }\n  };\n\n  const reset = () => {\n    if (disposed) throw new Error(`Disposed`);\n\n    // Cancel scheduled iteration\n    if (running) {\n      cancel();\n    }\n    start();\n  };\n\n  return {\n    start,\n    reset,\n    cancel,\n    get interval() {\n      return intervalUsed;\n    },\n    set interval(interval: Interval) {\n      const ms = intervalToMs(interval, 0);\n      throwIntegerTest(ms, `positive`, `interval`);\n      intervalMs = ms;\n      intervalUsed = interval;\n    },\n    get isDone() {\n      return !running;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    get ticks() {\n      return ticks;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n  };\n};\n","import {\n  timeout,\n  type TimeoutSyncCallback,\n  type TimeoutAsyncCallback,\n} from './Timeout.js';\n\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param timeoutMs Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  timeoutMs: number\n): DebouncedFunction => {\n  const t = timeout(callback, timeoutMs);\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return (...args: unknown[]) => t.start(undefined, args);\n};\n\n/**\n * Debounced function\n */\nexport type DebouncedFunction = (...args: readonly unknown[]) => void;\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (\n  callback: (\n    elapsedMs: number,\n    ...args: readonly unknown[]\n  ) => void | Promise<unknown>,\n  intervalMinMs: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let trigger = 0;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return async (...args: unknown[]) => {\n    const elapsed = performance.now() - trigger;\n    if (elapsed >= intervalMinMs) {\n      const r = callback(elapsed, ...args);\n      if (typeof r === `object`) await r;\n      trigger = performance.now();\n    }\n  };\n};\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * @example Verbose example\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n * @example Compact example\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  },\n *  (success) => {\n *    console.log(`Completed. Success: ${success ?? `Yes!` : `No`}`)\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (\n  timeoutMs: number,\n  onAborted: (reason: string) => void,\n  onComplete?: (success: boolean) => void\n) => {\n  //eslint-disable-next-line functional/no-let\n  let success = false;\n  const done = (error?: string) => {\n    if (t !== 0) {\n      window.clearTimeout(t);\n      t = 0;\n    }\n    if (error) {\n      onAborted(error);\n    } else {\n      success = true;\n    }\n    if (onComplete !== undefined) onComplete(success);\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let t = window.setTimeout(() => {\n    t = 0;\n    try {\n      onAborted(`Timeout after ${timeoutMs}ms`);\n    } finally {\n      if (onComplete !== undefined) onComplete(success);\n    }\n  }, timeoutMs);\n\n  return done;\n};\n","import { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\n\n/**\n * Delay options\n */\nexport type DelayOpts = Interval & {\n  /**\n   * Signal for cancelling delay\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When delay is applied. \"before\" is default.\n   */\n  readonly delay?: `before` | `after` | `both`;\n};\n\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @template V\n * @param callback What to run after interval\n * @param opts Options for delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async <V>(\n  callback: () => Promise<V>,\n  //eslint-disable-next-line functional/prefer-immutable-types\n  optsOrMillis: DelayOpts | number\n): Promise<V> => {\n  const opts =\n    typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n  const delayWhen = opts.delay ?? `before`;\n  if (delayWhen === `before` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  const r = Promise.resolve(await callback());\n  if (delayWhen === `after` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  return r;\n};\n\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n\n//     // Yield value\n//     yield v;\n\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * ```\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * ```\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n */\n//eslint-disable-next-line func-style\nasync function* delayAnimationLoop() {\n  //eslint-disable-next-line functional/no-let,@typescript-eslint/no-explicit-any\n  let resolve: any;\n  //eslint-disable-next-line functional/no-let\n  let p = new Promise<undefined>((r) => (resolve = r));\n  //eslint-disable-next-line functional/no-let\n  let timer = 0;\n  const callback = () => {\n    resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = window.requestAnimationFrame(callback);\n      yield await p;\n    }\n  } finally {\n    resolve();\n    window.cancelAnimationFrame(timer);\n  }\n}\n\n/**\n * Async generator that loops at a given interval.\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link interval} iterate over an iterable with a given delay\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @example Loop runs every second\n * ```\n * // Loop forever\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * @example For Await loop every second\n * ```\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\n//eslint-disable-next-line func-style\nexport async function* delayLoop(timeout: Interval) {\n  const timeoutMs = intervalToMs(timeout);\n  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);\n  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);\n  if (timeoutMs === 0) return yield* delayAnimationLoop();\n\n  //eslint-disable-next-line functional/no-let,@typescript-eslint/no-explicit-any\n  let resolve: any;\n  //eslint-disable-next-line functional/no-let\n  let p = new Promise<undefined>((r) => (resolve = r));\n  //eslint-disable-next-line functional/no-let\n  let timer = 0;\n  const callback = () => {\n    resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = window.setTimeout(callback, timeoutMs);\n      yield await p;\n    }\n  } finally {\n    resolve();\n    window.clearTimeout(timer);\n  }\n}\n","import { throwIntegerTest } from '../Guards.js';\n\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = (\n  nth: number,\n  callback?: (...args: readonly unknown[]) => void\n) => {\n  throwIntegerTest(nth, `positive`, `nth`);\n\n  //eslint-disable-next-line functional/no-let\n  let counter = 0;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return (...args: unknown[]): boolean => {\n    if (++counter === nth) {\n      counter = 0;\n      if (callback) callback(...args);\n      return true;\n    }\n    return false;\n  };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun: () => boolean): (() => boolean) => {\n  //eslint-disable-next-line functional/no-let\n  let run = false;\n  //eslint-disable-next-line functional/no-let\n  let success = false;\n  return () => {\n    if (run) return success;\n    run = true;\n    success = onRun();\n    return success;\n  };\n};\n","import { sleep } from './Sleep.js';\nimport { resolveLogOption } from '../debug/Logger.js';\nimport { since, toString as elapsedToString } from './Elapsed.js';\nimport { throwIntegerTest } from '../Guards.js';\nimport { getErrorMessage } from '../debug/GetErrorMessage.js';\n/**\n * Result of backoff\n */\nexport type RetryResult<V> = {\n  /**\n   * Message describing outcome.\n   *\n   * If retry was aborted, message will be abort reason.\n   */\n  readonly message?: string;\n  /**\n   * True if callback function was invoked once where it returned _true_\n   */\n  readonly success: boolean;\n  /**\n   * Number of times callback was attempted\n   */\n  readonly attempts: number;\n  /**\n   * Total elapsed time since beginning of call to `retry`\n   */\n  readonly elapsed: number;\n\n  /**\n   * Value returned by succeeding function,\n   * or _undefined_ if it failed\n   */\n  readonly value: V | undefined;\n};\n\n/**\n * Backoff options\n */\nexport type RetryOpts<V> = {\n  /**\n   * Maximum number of attempts to make\n   */\n  readonly count: number;\n  /**\n   * Starting milliseconds for sleeping after failure\n   * Defaults to 1000.\n   * Must be above zero.\n   */\n  readonly startMs?: number;\n  /**\n   * Initial waiting period before first attempt (optional)\n   */\n  readonly predelayMs?: number;\n  /**\n   * Optional abort signal\n   */\n  readonly abort?: AbortSignal;\n  /**\n   * Log: _true_ logs to console\n   */\n  readonly log?: boolean;\n  /**\n   * Math.pow factor. Defaults to 1.1. How much slower to\n   * get with each retry.\n   */\n  readonly power?: number;\n\n  /***\n   * Default value to return if it fails\n   */\n  readonly defaultValue?: V;\n};\n\n/**\n * Keeps calling `cb` until it returns something other than _undefined_. If it throws an exception,\n * it will cancel the retry, bubbling the exception and cancelling the retry.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // 'failed'\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retry(flakyFn, {\n *  count: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retry(cb, { startMs: 6000, count: 1000, signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param opts Options\n * @returns\n */\nexport const retry = async <V>(\n  callback: () => Promise<V | undefined>,\n  //eslint-disable-next-line functional/prefer-immutable-types\n  opts: RetryOpts<V>\n): Promise<RetryResult<V>> => {\n  const signal = opts.abort;\n  const log = resolveLogOption(opts.log);\n  const power = opts.power ?? 1.1;\n  const predelayMs = opts.predelayMs ?? 0;\n  const startedAt = since();\n\n  //eslint-disable-next-line functional/no-let\n  let t = opts.startMs ?? 1000;\n  const count = opts.count;\n  //eslint-disable-next-line functional/no-let\n  let attempts = 0;\n\n  throwIntegerTest(count, `aboveZero`, `count`);\n  if (t <= 0) throw new Error(`startMs must be above zero`);\n\n  if (predelayMs > 0) await sleep({ millis: predelayMs, signal: signal });\n  if (signal?.aborted) {\n    return {\n      success: false,\n      attempts,\n      value: opts.defaultValue,\n      elapsed: startedAt(),\n      message: `Aborted during predelay`,\n    };\n  }\n  while (attempts < count) {\n    attempts++;\n    const callbackResult = await callback();\n    if (callbackResult !== undefined) {\n      return { value: callbackResult, success: true, attempts, elapsed: startedAt() };\n    }\n    log({\n      msg: `retry attempts: ${ attempts } t: ${ elapsedToString(t) }`,\n    });\n\n    // Did not succeed.\n    if (attempts >= count) {\n      break; // Out of attempts, no point sleeping again\n    }\n    // Sleep\n    try {\n      await sleep({ millis: t, signal });\n    } catch (error) {\n      // Eg if abort signal fires\n      return {\n        success: false,\n        attempts,\n        value: opts.defaultValue,\n        message: getErrorMessage(error),\n        elapsed: startedAt(),\n      };\n    }\n\n    // Increase sleep time for next fail\n    t = Math.floor(Math.pow(t, power));\n  }\n\n  return {\n    message: `Giving up after ${ attempts } attempts.`,\n    success: false,\n    attempts,\n    value: opts.defaultValue,\n    elapsed: startedAt(),\n  };\n};\n","import type { QueueOpts } from './index.js';\n\nexport const debug = (opts: QueueOpts<any>, message: string): void => {\n  /* eslint-disable-next-line functional/no-expression-statements */\n  opts.debug ? console.log(`queue:${ message }`) : null;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`: {\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [ ...queue, ...toAdd.slice(0, toRemove - 1) ];\n      }\n    }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`: {\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          return [ ...toAdd.slice(0, capacity - 1), toAdd.at(-1)! ];\n        }\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        //return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [ ...toKeep, ...toAddFinal ];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`: {\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [ ...queue, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown overflow policy ${ policy }`);\n    }\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [ ...queue, ...toAdd ];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${ toReturn.length\n      } capacity: ${ opts.capacity } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${ toReturn.length\n      } expected: ${ potentialLength } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[ 0 ];\n\nexport const isEmpty = <V>(opts: QueueOpts<V>, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import { type IQueueMutable } from './IQueueMutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './QueueFns.js';\nimport { type QueueOpts } from './QueueTypes.js';\nimport { without } from '../arrays/index.js';\nimport { isEqualDefault, type IsEqual } from '../../IsEqual.js';\n/**\n * Returns a mutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Items are added in array order. So first item will be at the front of the queue.\n */\nexport class QueueMutable<V> implements IQueueMutable<V> {\n  readonly opts: QueueOpts<V>;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V>;\n  eq: IsEqual<V>;\n\n  constructor(opts: QueueOpts<V> = {}, data: ReadonlyArray<V> = []) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.opts = opts;\n    this.data = data;\n    this.eq = opts.eq ?? isEqualDefault;\n  }\n\n  clear() {\n    this.data = [];\n  }\n\n  /**\n   * Return a copy of the array\n   * @returns \n   */\n  toArray() {\n    return [ ...this.data ];\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): number {\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = enqueue(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.opts, this.data);\n    if (v === undefined) return;\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.opts, this.data);\n    return v;\n  }\n\n  /**\n   * Remove item from queue, regardless of position.\n   * Returns _true_ if something was removed.\n   * @param v \n   */\n  remove(v: V, comparer?: IsEqual<V>): boolean {\n    const length = this.data.length;\n    this.data = without(this.data, v, comparer ?? this.eq);\n    return this.data.length !== length;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\nexport function mutable<V>(\n  opts: QueueOpts<V> = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueMutable<V> {\n  return new QueueMutable({ ...opts }, [ ...startingItems ]);\n}\n\n","import { QueueMutable } from '../collections/queue/QueueMutable.js';\n\ntype Task = () => void;\n\nexport type TaskQueueOpts = {\n  /**\n   * How long to wait before starting the queue 'thread'\n   * when something is added.\n   *\n   * Default: 500ms\n   */\n  readonly startDelayMs?: number;\n\n  /**\n   * Once running, sleeping period between each item\n   * being processed.\n   *\n   * Default: 100ms\n   */\n  readonly intervalMs?: number;\n};\n\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n *\n * @example Usage\n * ```js\n * const q = new TaskQueue();\n * q.add(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n */\nexport class TaskQueue {\n  static instance = new TaskQueue();\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _timer: any = 0;\n  private _queue;\n  private readonly _startDelayMs;\n  private readonly _intervalMs;\n\n  private constructor(opts: TaskQueueOpts = {}) {\n    this._startDelayMs = opts.startDelayMs ?? 500;\n    this._intervalMs = opts.intervalMs ?? 100;\n    this._queue = new QueueMutable<Task>();\n  }\n\n  /**\n   * Adds a task. This triggers processing loop if not already started.\n   *\n   * ```js\n   * queue.add(async () => {\n   *  await sleep(1000);\n   * });\n   * ```\n   * @param task Task to run\n   */\n  add(task: () => void) {\n    this._queue.enqueue(task);\n    if (this._timer === 0) this.schedule(this._startDelayMs);\n  }\n\n  private schedule(intervalMs: number) {\n    // If the queue is empty, allow loop to stop\n    if (this._queue.length === 0) {\n      //eslint-disable-next-line functional/immutable-data\n      this._timer = 0;\n      return;\n    }\n\n    if (this._timer !== 0) {\n      // Seems to be running\n      return;\n    }\n\n    // Start the processing loop\n    //eslint-disable-next-line functional/immutable-data\n    this._timer = setTimeout(() => {\n      this.processQueue();\n    }, intervalMs);\n  }\n\n  private async processQueue() {\n    const task = this._queue.dequeue();\n\n    //eslint-disable-next-line functional/immutable-data\n    this._timer = 0;\n    if (task !== undefined) {\n      try {\n        await task();\n        //eslint-disable-next-line functional/immutable-data\n        this._timer = 0;\n        this.schedule(this._intervalMs);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n  }\n}\n","import { zip } from './Zip.js';\nimport { weight } from './NumericArrays.js';\nimport { type EasingFn as EasingFunction } from '../../modulation/Easing.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * // All items weighted evenly\n * Arrays.averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * Arrays.averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * Arrays.averageWeighted[1,2,3], Easings.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n * import { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * const data = [1,2,3];\n * const w = Arrays.weight(data, Easings.gaussian());\n * const avg = Arrays.averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n */\nexport const averageWeighted = (\n  data: Array<number> | ReadonlyArray<number>,\n  weightings: Array<number> | ReadonlyArray<number> | EasingFunction\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n\n  const ww = zip(data, weightings);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const [ totalV, totalW ] = ww.reduce(\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    (accumulator, v: Array<number>) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","import { isEqualDefault } from '../IsEqual.js'\n\nexport const max = <V>(iterable: Iterable<V>, scorer: (v: V) => number): V | undefined => {\n  let highestValue: V | undefined;\n  let highestScore = Number.MIN_SAFE_INTEGER;\n  for (const value of iterable) {\n    const score = scorer(value);\n    if (score >= highestScore) {\n      highestScore = score;\n      highestValue = value;\n    }\n  }\n  return highestValue;\n}\n\nexport const min = <V>(iterable: Iterable<V>, scorer: (v: V) => number): V | undefined => {\n  let lowestValue: V | undefined;\n  let lowestScore\n    = Number.MAX_SAFE_INTEGER;\n  for (const value of iterable) {\n    const score = scorer(value);\n    if (score <= lowestScore) {\n      lowestScore = score;\n      lowestValue = value;\n    }\n  }\n  return lowestValue;\n}\n\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n * \n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * compareValuesEqual(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * compareValuesEqual(a, b); \n * // True, since now we're comparing by value\n * compareValuesEqual(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param arrays\n * @param eq\n */\nexport const compareValuesEqual = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  iterableA: Iterable<V>,\n  iterableB: Iterable<V>,\n  eq = isEqualDefault<V>\n): boolean => {\n  const returnValue = compareValues(iterableA, iterableB, eq);\n  return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n\n\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common, and those unique in `a` or `b`.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValues(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareValues = <V>(\n  a: Iterable<V>,\n  b: Iterable<V>,\n  eq = isEqualDefault<V>\n) => {\n  const shared = [];\n  const aUnique = [];\n  const bUnique = [];\n\n  for (const element of a) {\n    //eslint-disable-next-line functional/no-let\n    let seenInB = false;\n    for (const element_ of b) {\n      if (eq(element, element_)) {\n        seenInB = true;\n        break;\n      }\n    }\n    if (seenInB) {\n      //eslint-disable-next-line functional/immutable-data\n      shared.push(element);\n    } else {\n      //eslint-disable-next-line functional/immutable-data\n      aUnique.push(element);\n    }\n  }\n\n  for (const element of b) {\n    //eslint-disable-next-line functional/no-let\n    let seenInA = false;\n    for (const element_ of a) {\n      if (eq(element, element_)) {\n        seenInA = true;\n      }\n    }\n    if (!seenInA) {\n      //eslint-disable-next-line functional/immutable-data\n      bUnique.push(element);\n    }\n  }\n\n  return {\n    shared,\n    a: aUnique,\n    b: bUnique,\n  };\n};\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as StateMachine from './StateMachine.js';\n\nimport type { StateNames, Transitions, MachineState } from './StateMachine.js';\nimport { Elapsed } from './index.js';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type Opts<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = Elapsed.infinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param string initial Initial state\n   * @param MachineDescription m Machine description\n   * @param Options Options for machine (defaults to `{debug:false}`)\n   * @memberof StateMachine\n   */\n  constructor(m: V, opts: Opts<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value as string });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): readonly (StateNames<V> | null)[] {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): readonly StateNames<V>[] {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   * @memberof StateMachine\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[0] as string;\n    return p[0] as string;\n  }\n\n  /**\n   * Returns true if state machine is in its final state\n   *\n   * @returns\n   * @memberof StateMachine\n   */\n  get isDone(): boolean {\n    return StateMachine.done(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   *\n   * @memberof StateMachine\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n\n    //eslint-disable-next-line functional/immutable-data\n    this.#changedAt = Elapsed.since();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `StateMachine.isValid` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   *\n   * @memberof StateMachine\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value as string;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${priorState} -> ${newState as string}`);\n    }\n    this.#changedAt = Elapsed.since();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.done(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value as string;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n","import { defaultComparer, type Comparer } from '../Util.js';\nimport { shuffle } from '../collections/arrays/index.js';\n\nexport type ExpressionOrResult<ArgsType, ResultType> =\n  | ResultType\n  | ((\n    args: ArgsType | undefined\n  ) => Promise<ResultType | undefined> | ResultType | undefined | void);\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type RunOpts<ResultType> = {\n  /**\n   * If provided, filters the set of results prior to returning.\n   * @param result\n   * @returns\n   */\n  readonly filter?: (result: ResultType) => boolean;\n  /**\n   * If true, execution order is shuffled each time\n   */\n  readonly shuffle?: boolean;\n  /**\n   * Function to rank results. By default uses {@link defaultComparer} which orders\n   * by numeric value or alphabetical.\n   */\n  readonly rank?: Comparer<ResultType>;\n  /**\n   * If provided, stops execution if _true_ is returned.\n   * Result(s) include most recent execution.\n   * @param latest Latest result\n   * @param sorted Sorted list of current results, not including latest\n   * @returns\n   */\n  readonly stop?: (\n    latest: ResultType | undefined,\n    sorted: readonly ResultType[]\n  ) => boolean;\n};\n\nexport type RunSingleOpts<V> = RunOpts<V> & {\n  readonly at?: number;\n};\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = run([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async <ArgsType, ResultType>(\n  expressions: //eslint-disable-next-line functional/prefer-readonly-type\n    | ExpressionOrResult<ArgsType, ResultType>[]\n    | ExpressionOrResult<ArgsType, ResultType>\n    | readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType[]> => {\n  const results: ResultType[] = [];\n  const compareFn = opts.rank ?? defaultComparer;\n  //eslint-disable-next-line functional/no-let\n  let expressionsArray = Array.isArray(expressions)\n    ? (expressions as ExpressionOrResult<ArgsType, ResultType>[])\n    : [ expressions as ExpressionOrResult<ArgsType, ResultType> ];\n  if (opts.shuffle) expressionsArray = shuffle(expressionsArray);\n\n  for (let i = 0; i < expressionsArray.length; i++) {\n    const exp = expressionsArray[ i ];\n    //eslint-disable-next-line functional/no-let\n    let r: ResultType;\n    if (typeof exp === 'function') {\n      // @ts-ignore\n      r = await exp(args);\n    } else {\n      r = exp;\n    }\n    if (r !== undefined) {\n      //eslint-disable-next-line functional/immutable-data\n      results.push(r);\n      //eslint-disable-next-line functional/immutable-data\n      results.sort(compareFn);\n    }\n\n    if (typeof opts.stop !== 'undefined') {\n      if (opts.stop(r, results)) {\n        break;\n      }\n    }\n  }\n\n  if (opts.filter) {\n    return results.filter(opts.filter);\n  }\n  return results;\n};\n\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async <ArgsType, ResultType>(\n  expressions: readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunSingleOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType | undefined> => {\n  const results = await run(expressions, opts, args);\n  if (!results) return;\n  if (results.length === 0) return;\n  const at = opts.at ?? -1;\n  return results.at(at);\n};\n","import * as StateMachine from './StateMachine.js';\nimport * as Execute from './Execute.js';\nimport { type MachineState } from './StateMachine.js';\nimport { defaultComparer } from '../Util.js';\nimport { randomElement } from '../collections/arrays/index.js';\nimport * as Logger from '../debug/Logger.js';\n\nexport type Result<V extends StateMachine.Transitions> = {\n  /**\n   * Score of this result. This is used when a state\n   * has multiple handlers returning results separately.\n   * If not defined, 0 is used.\n   */\n  readonly score?: number;\n\n  //readonly state?: StateMachine.StateNames<V>;\n  /**\n   * If specified,the state to transition to. Use\n   * _true_ to attempt to automatically advance machine.\n   * This field is 2nd priority.\n   */\n  readonly next?: StateMachine.StateNames<V> | boolean;\n  /**\n   * If true, resets the machine.\n   * This flag is 1st priority, taking precedence over the `next` field.\n   */\n  readonly reset?: boolean;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type Runner<V extends StateMachine.Transitions> = {\n  readonly run: () => Promise<StateMachine.MachineState<V> | undefined>;\n  readonly getValue: () => StateMachine.StateNames<V>;\n  readonly reset: () => void;\n  readonly to: (\n    state: StateMachine.StateNames<V>\n  ) => StateMachine.MachineState<V>;\n};\n\nexport type StatesHandler<V extends StateMachine.Transitions> = {\n  readonly if:\n  | ReadonlyArray<StateMachine.StateNames<V>>\n  //eslint-disable-next-line functional/prefer-readonly-type\n  | Array<StateMachine.StateNames<V>>\n  | StateMachine.StateNames<V>;\n  readonly then: ReadonlyArray<ExpressionOrResult<V>> | ExpressionOrResult<V>;\n  /**\n   * Logic for choosing which result, if there are multiple expressions.\n   * By default 'highest' (for highest ranked result)\n   */\n  readonly resultChoice?: `first` | `highest` | `lowest` | `random`;\n};\n\n// export type Prerequisite<V extends StateMachine.Transitions> =\n//   | readonly StateMachine.StateNames<V>[]\n//   | ((\n//       potentialState: StateMachine.StateNames<V>,\n//       state: StateMachine.MachineState<V>\n//     ) => boolean);\n\n// export type StatePrerequisites<V extends StateMachine.Transitions> = {\n//   readonly states:\n//     | readonly StateMachine.StateNames<V>[]\n//     | StateMachine.StateNames<V>;\n//   readonly condition?: Prerequisite<V>;\n// };\n\nexport type DriverOpts<V extends StateMachine.Transitions> = {\n  readonly handlers: ReadonlyArray<StatesHandler<V>>;\n  //readonly prereqs?: StatePrerequisites<V>;\n  readonly debug?: Logger.LogOption;\n  /**\n   * If _true_ execution of handlers is shuffled each time\n   */\n  readonly shuffleHandlers?: boolean;\n};\n\n// async function run<V extends StateMachine.Transitions>(\n//   machine: StateMachine.Machine<V>,\n//   handlers: readonly StatesHandler<V>[]\n// );\n\nexport type ExpressionOrResult<Transitions extends StateMachine.Transitions> =\n  | Result<Transitions>\n  | ((\n    machine?: MachineState<Transitions>\n  ) => Result<Transitions> | undefined);\n\n/**\n * Drives a state machine.\n *\n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function init<V extends StateMachine.Transitions>(\n  machine: StateMachine.Machine<V> | StateMachine.Transitions,\n  handlersOrOpts: ReadonlyArray<StatesHandler<V>> | DriverOpts<V>\n): Promise<Runner<V>> {\n  const opts: DriverOpts<V> = Array.isArray(handlersOrOpts)\n    ? {\n      handlers: handlersOrOpts as ReadonlyArray<StatesHandler<V>>,\n    }\n    : (handlersOrOpts as DriverOpts<V>);\n\n  const debug = Logger.resolveLogOption(opts.debug, {\n    category: `StateMachineDriver`,\n  });\n\n  // Index handlers by state, making sure there are not multiple\n  // handlers for a given state.\n  const byState = new Map<string, StatesHandler<V>>();\n  for (const h of opts.handlers) {\n    const ifBlock = Array.isArray(h.if) ? h.if : [ h.if ];\n    for (const state of ifBlock) {\n      if (typeof state !== `string`) {\n        throw new TypeError(\n          `Expected single or array of strings for the 'if' field. Got: '${ typeof state }'.`\n        );\n      }\n\n      if (byState.has(state)) {\n        throw new Error(\n          `Multiple handlers defined for state '${ state\n          }'. There should be at most one.`\n        );\n      }\n      byState.set(state, h);\n    }\n  }\n\n  // const expressions: Expression<V>[] = [\n  //   (_machine) => {\n  //     const r: Result<V> = {\n  //       next: 'hello',\n  //     };\n  //     return r;\n  //   },\n  // ];\n\n  const runOpts: Execute.RunOpts<Result<V>> = {\n    // Rank results by score\n    rank: (a, b) => {\n      return defaultComparer(a.score ?? 0, b.score ?? 0);\n    },\n    shuffle: opts.shuffleHandlers ?? false,\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let sm = StateMachine.init(machine);\n\n  // Check that all 'if' states are actually defined on machine\n  for (const [ ifState ] of byState) {\n    // Check if state is defined\n    if (\n      typeof sm.machine[ ifState ] === `undefined` &&\n      ifState !== `__fallback`\n    ) {\n      throw new Error(\n        `StateMachineDriver handler references a state ('${ ifState }') which is not defined on the machine. Therefore this handler will never run.'`\n      );\n    }\n  }\n\n  const run = async (): Promise<StateMachine.MachineState<V> | undefined> => {\n    debug(`Run. State: ${ sm.value }`);\n    const state = sm.value;\n    //eslint-disable-next-line functional/no-let\n    let handler = byState.get(state);\n    if (handler === undefined) {\n      debug(`  No handler for state '${ state }', trying __fallback`);\n\n      // Is there a fallback?\n      handler = byState.get(`__fallback`);\n    }\n    if (handler === undefined) {\n      debug(`  No __fallback handler`);\n      return;\n    }\n\n    // If the `first` option is given, stop executing fns as soon as we get\n    // a valid result.\n    const runOptionsForHandler =\n      handler.resultChoice === `first`\n        ? {\n          ...runOpts,\n          stop: (latest: Result<V> | undefined) => {\n            if (!latest) return false;\n            if (`reset` in latest) return true;\n            if (`next` in latest && latest.next !== undefined) return true;\n            return false;\n          },\n        }\n        : runOpts;\n\n    const results = await Execute.run<MachineState<V>, Result<V>>(\n      handler.then,\n      runOptionsForHandler,\n      sm\n    );\n    debug(\n      `  In state '${ sm.value }' results: ${ results.length }. Choice: ${ handler.resultChoice\n      }`\n    );\n\n    // Apply selection logic\n    //eslint-disable-next-line functional/no-let\n    let r: Result<V> | undefined;\n    switch (handler.resultChoice ?? `highest`) {\n      case `highest`: {\n        r = results.at(-1);\n        break;\n      }\n      case `first`: {\n        r = results[ 0 ]; // Since we break on the first result\n        break;\n      }\n      case `lowest`: {\n        r = results.at(0);\n        break;\n      }\n      case `random`: {\n        r = randomElement(results);\n        break;\n      }\n      default: {\n        throw new Error(\n          `Unknown 'resultChoice' option: ${ handler.resultChoice }. Expected highest, first, lowest or random`\n        );\n      }\n    }\n\n    debug(`  Chosen result: ${ JSON.stringify(r) }`);\n    // Apply result\n    if (r && r.reset) {\n      sm = StateMachine.reset(sm);\n    } else if (r && r.next) {\n      if (typeof r.next === `boolean`) {\n        sm = StateMachine.next(sm);\n      } else {\n        debug(JSON.stringify(results));\n        sm = StateMachine.to(sm, r.next);\n      }\n    }\n    return sm;\n  };\n\n  return {\n    reset: () => {\n      sm = StateMachine.reset(sm);\n    },\n    getValue: () => sm.value,\n    run,\n    to: (state: StateMachine.StateNames<V>) => {\n      sm = StateMachine.to(sm, state);\n      return sm;\n    },\n  };\n}\n"],"mappings":"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","names":["init","mergeByKey","total","total","min","max","validNumbers","total","next","toArray","min","max","min","max","total","done","interval","once","wrap","interval","interval","reset","done","timeout","run","max","min","max","min","total","mergeByKey","filter","init","run"]}