{"version":3,"sources":["../src/flow/StateMachine.ts","../src/flow/Execute.ts","../src/flow/StateMachineDriver.ts","../src/flow/index.ts","../src/flow/Timer.ts","../src/flow/Elapsed.ts","../src/flow/DispatchList.ts","../src/flow/Interval.ts","../src/flow/Timeout.ts","../src/flow/UpdateOutdated.ts","../src/flow/Continuously.ts","../src/flow/Debounce.ts","../src/flow/Throttle.ts","../src/flow/WaitFor.ts","../src/flow/Delay.ts","../src/flow/Every.ts","../src/flow/RunOnce.ts","../src/flow/Retry.ts","../src/flow/RequestResponseMatch.ts","../src/flow/TaskQueue.ts","../src/flow/Repeat.ts","../src/flow/StateMachineWithEvents.ts"],"sourcesContent":["import { unique } from '../collections/arrays/index.js';\n\n\n\n/**\n * State machine driver\n */\nexport { init as driver } from './StateMachineDriver.js';\nexport type {\n  DriverOpts,\n  StatesHandler as DriverHandler,\n  Runner,\n  ExpressionOrResult as DriverExpression,\n  Result as DriverResult,\n} from './StateMachineDriver.js';\n\n/**\n * Transition result\n * * 'Ok': transition valid\n * * 'FromNotFound': the from state is missing from machine definition\n * * 'ToNotFound': the 'to' state is missing from machine definition\n * * 'Invalid': not allowed to transition to target state from the current state\n * * 'Terminal':  not allowed to transition because from state is the final state\n */\nexport type TransitionResult =\n  | `Ok`\n  | `FromNotFound`\n  | `ToNotFound`\n  | `Invalid`\n  | `Terminal`;\n\nexport type TransitionCondition<V extends Transitions> = {\n  readonly hasPriorState: ReadonlyArray<StateNames<V>>;\n  readonly isInState: StateNames<V>;\n};\n\nexport type StateTargetStrict<V extends Transitions> = {\n  readonly state: StateNames<V> | null;\n  readonly preconditions?: ReadonlyArray<TransitionCondition<V>>;\n};\n\n/**\n * Possible state transitions, or _null_ if final state.\n */\n//export type StateTarget<V extends Transitions> = StateTargetExt<V> | null;\n\nexport type StateTarget<V extends Transitions> =\n  | string\n  //eslint-disable-next-line functional/prefer-readonly-type\n  | Array<string>\n  | ReadonlyArray<string>\n  | null\n  | StateTargetStrict<V>;\n//eslint-disable-next-line functional/prefer-readonly-type\n// | StateTargetStrict<V>[]\n// | readonly StateTargetStrict<V>[];\n\n/**\n * Maps state to allowable next states\n */\nexport type Transitions = {\n  readonly [ key: string ]: StateTarget<Transitions>;\n};\n\nexport type TransitionsStrict = Readonly<Record<string, ReadonlyArray<StateTargetStrict<Transitions>>>>;\n/**\n * List of possible states\n */\nexport type StateNames<V extends Transitions> = keyof V & string;\n\nexport type Machine<V extends Transitions> = {\n  /**\n   * Allowable state transitions\n   */\n  readonly states: V;\n};\n\n/**\n * Encapsulation of a 'running' machine description and state.\n *\n * See:\n * - {@link cloneState}\n */\nexport type MachineState<V extends Transitions> = {\n  /**\n   * Current state\n   */\n  readonly value: StateNames<V>;\n  /**\n   * List of unique states visited. Won't contain the current\n   * state unless it has already been visited.\n   */\n  readonly visited: ReadonlyArray<StateNames<V>>;\n\n  //readonly machine: Machine<V>;\n  readonly machine: {\n    readonly [ key in StateNames<V> ]: ReadonlyArray<StateTargetStrict<V>>;\n  };\n};\n\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = <V extends Transitions>(\n  toClone: MachineState<V>\n): MachineState<V> => {\n  return Object.freeze({\n    value: toClone.value,\n    visited: [ ...toClone.visited ],\n    machine: toClone.machine,\n  });\n};\n/**\n * Initialises a state machine\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * StateMachineLight.done(sm); // false\n * StateMachineLight.possible(sm); // [ 'shirt' ]\n * ```\n * @param sm\n * @param initialState\n * @returns\n */\nexport const init = <V extends Transitions>(\n  stateMachine: Machine<V> | Transitions | TransitionsStrict,\n  initialState?: StateNames<V>\n): MachineState<V> => {\n  const [ machine, machineValidationError ] = validateMachine(stateMachine);\n  if (!machine) throw new Error(machineValidationError);\n\n  const state: StateNames<V> =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState!) ?? Object.keys(machine.states)[ 0 ];\n  if (machine.states[ state ] === undefined) {\n    throw new TypeError(`Initial state not found`);\n  }\n\n  // Normalise states\n  const transitions = validateAndNormaliseTransitions(machine.states);\n  if (transitions === undefined) {\n    throw new Error(`Could not normalise transitions`);\n  }\n  // @ts-expect-error\n  return Object.freeze({\n    value: state,\n    visited: [],\n    machine: Object.fromEntries(transitions),\n  });\n};\n\nexport const reset = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  // @ts-expect-error\n  return init<V>(sm.machine);\n};\n\nexport const validateMachine = <V extends Transitions>(\n  smOrTransitions: Machine<V> | Transitions | TransitionsStrict\n): [ machine: Machine<V> | undefined, msg: string ] => {\n  if (smOrTransitions === undefined) {\n    return [ undefined, `Parameter undefined` ];\n  }\n  if (smOrTransitions === null) {\n    return [ undefined, `Parameter null` ];\n  }\n  if (`states` in smOrTransitions) {\n    // Assume Machine type\n    return [ smOrTransitions as Machine<V>, `` ];\n  }\n  if (typeof smOrTransitions === `object`) {\n    return [\n      {\n        // @ts-expect-error\n        states: smOrTransitions,\n      },\n      ``,\n    ];\n  }\n  return [\n    undefined,\n    `Unexpected type: ${ typeof smOrTransitions }. Expected object`,\n  ];\n};\n\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n\n/**\n * Returns _true_ if `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const done = <V extends Transitions>(sm: MachineState<V>): boolean => {\n  return possible(sm).length === 0;\n};\n\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = <V extends Transitions>(\n  sm: MachineState<V>\n): ReadonlyArray<StateTargetStrict<V>> => {\n  // Validate current state\n  validateMachineState(sm);\n  // get list of possible targets\n  const fromS = sm.machine[ sm.value ];\n\n  if (fromS.length === 1 && fromS[ 0 ].state === null) return [];\n  return fromS;\n};\n\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = <V extends Transitions>(\n  sm: MachineState<V>\n): Array<StateNames<V> | null> => {\n  const targets = possibleTargets(sm);\n  return targets.map((v) => v.state);\n};\n\nexport const normaliseTargets = <V extends Transitions>(\n  targets:\n    | StateTarget<V>\n    | ReadonlyArray<StateTargetStrict<V>>\n    //eslint-disable-next-line functional/prefer-readonly-type\n    | StateTargetStrict<V>\n): Array<StateTargetStrict<V>> | null | undefined => {\n  const normaliseSingleTarget = (\n    target: string | undefined | null | object\n  ): StateTargetStrict<V> | undefined => {\n    // Terminal target\n    if (target === null) return { state: null };\n    // String is the target state\n    if (typeof target === `string`) {\n      return {\n        state: target,\n      };\n    } else if (typeof target === `object` && `state` in target) {\n      const targetState = target.state;\n      if (typeof targetState !== `string`) {\n        throw new TypeError(\n          `Target 'state' field is not a string. Got: ${ typeof targetState }`\n        );\n      }\n      if (`preconditions` in target) {\n        return {\n          state: targetState,\n          preconditions: target.preconditions as Array<TransitionCondition<V>>,\n        };\n      }\n      return { state: targetState };\n    } else {\n      throw new Error(\n        `Unexpected type: ${ typeof target }. Expected string or object with 'state' field.`\n      );\n    }\n  };\n\n  // Array of targets (either strings or objects)\n  if (Array.isArray(targets)) {\n    //eslint-disable-next-line functional/no-let\n    let containsNull = false;\n    const mapResults = targets.map((t) => {\n      const r = normaliseSingleTarget(t);\n      if (!r) throw new Error(`Invalid target`);\n      containsNull = containsNull || r.state === null;\n      return r;\n    });\n    if (containsNull && mapResults.length > 1) {\n      throw new Error(`Cannot have null as an possible state`);\n    }\n    return mapResults;\n  } else {\n    const target = normaliseSingleTarget(targets);\n    if (!target) return;\n    return [ target ];\n  }\n};\n\nconst validateAndNormaliseTransitions = (\n  d: Transitions\n): Map<string, Array<StateTargetStrict<typeof d>>> | undefined => {\n  const returnMap = new Map<string, Array<StateTargetStrict<typeof d>>>();\n\n  // 1. Index top-level states\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    if (typeof topLevelState === `undefined`) {\n      throw new TypeError(`Top-level undefined state`);\n    }\n    if (typeof topLevelTargets === `undefined`) {\n      throw new TypeError(`Undefined target state for ${ topLevelState }`);\n    }\n    if (returnMap.has(topLevelState)) {\n      throw new Error(`State defined twice: ${ topLevelState }`);\n    }\n    if (topLevelState.includes(` `)) {\n      throw new Error(`State names cannot contain spaces`);\n    }\n    returnMap.set(topLevelState, []);\n  }\n\n  // 2. Normalise target\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    const targets = normaliseTargets(topLevelTargets);\n    if (targets === undefined) throw new Error(`Could not normalise target`);\n    if (targets !== null) {\n      // Check that they all exist as top-level states\n      const seenStates = new Set();\n      for (const target of targets) {\n        if (seenStates.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' already exists for '${ topLevelState }'`\n          );\n        }\n        seenStates.add(target.state);\n        if (target.state === null) continue;\n        if (!returnMap.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' is not defined as a top-level state. Defined under: '${ topLevelState }'`\n          );\n        }\n      }\n      returnMap.set(topLevelState, targets);\n    }\n  }\n  return returnMap;\n};\n\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = <V extends Transitions>(\n  state: MachineState<V>\n): void => {\n  if (state === undefined) {\n    throw new TypeError(`Parameter 'state' is undefined`);\n  }\n  if (typeof state.value !== `string`) {\n    throw new TypeError(`Existing state is not a string`);\n  }\n};\n\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): MachineState<V> => {\n  validateMachineState(sm); // throws if not OK\n  validateTransition(sm, toState); // throws if not OK\n  return Object.freeze({\n    value: toState,\n    machine: sm.machine,\n    visited: unique<string>([ sm.visited as Array<string>, [ sm.value ] as Array<string> ]),\n  });\n};\n\nexport const next = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  //validateMachineState(sm);\n  const first = possibleTargets(sm).at(0);\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (!first || first.state === null) {\n    throw new Error(\n      `Not possible to move to a next state from '${ sm.value }`\n    );\n  }\n  return to(sm, first.state);\n};\n\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): boolean => {\n  try {\n    validateTransition(sm, toState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const validateTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): void => {\n  if (toState === null) throw new Error(`Cannot transition to null state`);\n  if (toState === undefined) {\n    throw new Error(`Cannot transition to undefined state`);\n  }\n  if (typeof toState !== `string`) {\n    throw new TypeError(\n      `Parameter 'toState' should be a string. Got: ${ typeof toState }`\n    );\n  }\n\n  //const toS = sm.machine[toState];\n  //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n\n  const p = possible(sm);\n  if (p.length === 0) throw new Error(`Machine is in terminal state`);\n  if (!p.includes(toState)) {\n    throw new Error(\n      `Target state '${ toState }' not available at current state '${ sm.value\n      }'. Possible states: ${ p.join(`, `) }`\n    );\n  }\n};\n\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n * \n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states: ReadonlyArray<string>): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length <= 2) throw new Error(`Expects at least two states`);\n  for (let index = 0; index < states.length; index++) {\n    const s = states[ index ];\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index }`\n      );\n    }\n    // @ts-expect-error\n    t[ s ] = index === states.length - 1 ? null : states[ index + 1 ];\n  }\n  return t;\n};\n\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n * \n * See also {@link fromList}.\n * \n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (\n  ...states: ReadonlyArray<string>\n): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length < 2) throw new Error(`Expects at least two states`);\n\n  for (const [ index, s ] of states.entries()) {\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index }`\n      );\n    }\n\n    /** @ts-expect-error */\n    //eslint-disable-next-line functional/immutable-data\n    t[ s ] = [];\n  }\n\n  for (let index = 0; index < states.length; index++) {\n    /** @ts-expect-error */\n    const v = t[ states[ index ] ] as Array<string>;\n    if (index === states.length - 1) {\n      if (states.length > 1) {\n        //eslint-disable-next-line functional/immutable-data\n        v.push(states[ index - 1 ]);\n      } else {\n        /** @ts-expect-error */\n        //eslint-disable-next-line functional/immutable-data\n        t[ states[ index ] ] = null;\n      }\n    } else {\n      //eslint-disable-next-line functional/immutable-data\n      v.push(states[ index + 1 ]);\n      //eslint-disable-next-line functional/immutable-data\n      if (index > 0) v.push(states[ index - 1 ]);\n    }\n  }\n  return t;\n};\n\nexport { StateMachineWithEvents as WithEvents, type Opts as StateMachineWithEventsOpts, type StateMachineEventMap, type StopEvent } from './StateMachineWithEvents.js';","import { defaultComparer, type Comparer } from '../Util.js';\nimport { shuffle } from '../collections/arrays/index.js';\n\nexport type ExpressionOrResult<ArgsType, ResultType> =\n  | ResultType\n  | ((\n    args: ArgsType | undefined\n  ) => Promise<ResultType | undefined> | ResultType | undefined | void);\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type RunOpts<ResultType> = {\n  /**\n   * If provided, filters the set of results prior to returning.\n   * @param result\n   * @returns\n   */\n  readonly filter?: (result: ResultType) => boolean;\n  /**\n   * If true, execution order is shuffled each time\n   */\n  readonly shuffle?: boolean;\n  /**\n   * Function to rank results. By default uses {@link defaultComparer} which orders\n   * by numeric value or alphabetical.\n   */\n  readonly rank?: Comparer<ResultType>;\n  /**\n   * If provided, stops execution if _true_ is returned.\n   * Result(s) include most recent execution.\n   * @param latest Latest result\n   * @param sorted Sorted list of current results, not including latest\n   * @returns\n   */\n  readonly stop?: (\n    latest: ResultType | undefined,\n    sorted: readonly ResultType[]\n  ) => boolean;\n};\n\nexport type RunSingleOpts<V> = RunOpts<V> & {\n  readonly at?: number;\n};\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = run([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async <ArgsType, ResultType>(\n  expressions: //eslint-disable-next-line functional/prefer-readonly-type\n    | ExpressionOrResult<ArgsType, ResultType>[]\n    | ExpressionOrResult<ArgsType, ResultType>\n    | readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType[]> => {\n  const results: ResultType[] = [];\n  const compareFn = opts.rank ?? defaultComparer;\n  //eslint-disable-next-line functional/no-let\n  let expressionsArray = Array.isArray(expressions)\n    ? (expressions as ExpressionOrResult<ArgsType, ResultType>[])\n    : [ expressions as ExpressionOrResult<ArgsType, ResultType> ];\n  if (opts.shuffle) expressionsArray = shuffle(expressionsArray);\n\n  for (let i = 0; i < expressionsArray.length; i++) {\n    const exp = expressionsArray[ i ];\n    //eslint-disable-next-line functional/no-let\n    let r: ResultType;\n    if (typeof exp === 'function') {\n      // @ts-ignore\n      r = await exp(args);\n    } else {\n      r = exp;\n    }\n    if (r !== undefined) {\n      //eslint-disable-next-line functional/immutable-data\n      results.push(r);\n      //eslint-disable-next-line functional/immutable-data\n      results.sort(compareFn);\n    }\n\n    if (typeof opts.stop !== 'undefined') {\n      if (opts.stop(r, results)) {\n        break;\n      }\n    }\n  }\n\n  if (opts.filter) {\n    return results.filter(opts.filter);\n  }\n  return results;\n};\n\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async <ArgsType, ResultType>(\n  expressions: readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunSingleOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType | undefined> => {\n  const results = await run(expressions, opts, args);\n  if (!results) return;\n  if (results.length === 0) return;\n  const at = opts.at ?? -1;\n  return results.at(at);\n};\n","import * as StateMachine from './StateMachine.js';\nimport * as Execute from './Execute.js';\nimport { type MachineState } from './StateMachine.js';\nimport { defaultComparer } from '../Util.js';\nimport { randomElement } from '../collections/arrays/index.js';\nimport * as Logger from '../debug/Logger.js';\n\nexport type Result<V extends StateMachine.Transitions> = {\n  /**\n   * Score of this result. This is used when a state\n   * has multiple handlers returning results separately.\n   * If not defined, 0 is used.\n   */\n  readonly score?: number;\n\n  //readonly state?: StateMachine.StateNames<V>;\n  /**\n   * If specified,the state to transition to. Use\n   * _true_ to attempt to automatically advance machine.\n   * This field is 2nd priority.\n   */\n  readonly next?: StateMachine.StateNames<V> | boolean;\n  /**\n   * If true, resets the machine.\n   * This flag is 1st priority, taking precedence over the `next` field.\n   */\n  readonly reset?: boolean;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type Runner<V extends StateMachine.Transitions> = {\n  readonly run: () => Promise<StateMachine.MachineState<V> | undefined>;\n  readonly getValue: () => StateMachine.StateNames<V>;\n  readonly reset: () => void;\n  readonly to: (\n    state: StateMachine.StateNames<V>\n  ) => StateMachine.MachineState<V>;\n};\n\nexport type StatesHandler<V extends StateMachine.Transitions> = {\n  readonly if:\n  | ReadonlyArray<StateMachine.StateNames<V>>\n  //eslint-disable-next-line functional/prefer-readonly-type\n  | Array<StateMachine.StateNames<V>>\n  | StateMachine.StateNames<V>;\n  readonly then: ReadonlyArray<ExpressionOrResult<V>> | ExpressionOrResult<V>;\n  /**\n   * Logic for choosing which result, if there are multiple expressions.\n   * By default 'highest' (for highest ranked result)\n   */\n  readonly resultChoice?: `first` | `highest` | `lowest` | `random`;\n};\n\n// export type Prerequisite<V extends StateMachine.Transitions> =\n//   | readonly StateMachine.StateNames<V>[]\n//   | ((\n//       potentialState: StateMachine.StateNames<V>,\n//       state: StateMachine.MachineState<V>\n//     ) => boolean);\n\n// export type StatePrerequisites<V extends StateMachine.Transitions> = {\n//   readonly states:\n//     | readonly StateMachine.StateNames<V>[]\n//     | StateMachine.StateNames<V>;\n//   readonly condition?: Prerequisite<V>;\n// };\n\nexport type DriverOpts<V extends StateMachine.Transitions> = {\n  readonly handlers: ReadonlyArray<StatesHandler<V>>;\n  //readonly prereqs?: StatePrerequisites<V>;\n  readonly debug?: Logger.LogOption;\n  /**\n   * If _true_ execution of handlers is shuffled each time\n   */\n  readonly shuffleHandlers?: boolean;\n};\n\n// async function run<V extends StateMachine.Transitions>(\n//   machine: StateMachine.Machine<V>,\n//   handlers: readonly StatesHandler<V>[]\n// );\n\nexport type ExpressionOrResult<Transitions extends StateMachine.Transitions> =\n  | Result<Transitions>\n  | ((\n    machine?: MachineState<Transitions>\n    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n  ) => Result<Transitions> | undefined | void);\n\n/**\n * Drives a state machine.\n *\n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function init<V extends StateMachine.Transitions>(\n  machine: StateMachine.Machine<V> | StateMachine.Transitions,\n  handlersOrOpts: ReadonlyArray<StatesHandler<V>> | DriverOpts<V>\n): Promise<Runner<V>> {\n  const opts: DriverOpts<V> = Array.isArray(handlersOrOpts)\n    ? {\n      handlers: handlersOrOpts as ReadonlyArray<StatesHandler<V>>,\n    }\n    : (handlersOrOpts as DriverOpts<V>);\n\n  const debug = Logger.resolveLogOption(opts.debug, {\n    category: `StateMachineDriver`,\n  });\n\n  // Index handlers by state, making sure there are not multiple\n  // handlers for a given state.\n  const byState = new Map<string, StatesHandler<V>>();\n  for (const h of opts.handlers) {\n    const ifBlock = Array.isArray(h.if) ? h.if : [ h.if ];\n    for (const state of ifBlock) {\n      if (typeof state !== `string`) {\n        throw new TypeError(\n          `Expected single or array of strings for the 'if' field. Got: '${ typeof state }'.`\n        );\n      }\n\n      if (byState.has(state)) {\n        throw new Error(\n          `Multiple handlers defined for state '${ state\n          }'. There should be at most one.`\n        );\n      }\n      byState.set(state, h);\n    }\n  }\n\n  // const expressions: Expression<V>[] = [\n  //   (_machine) => {\n  //     const r: Result<V> = {\n  //       next: 'hello',\n  //     };\n  //     return r;\n  //   },\n  // ];\n\n  const runOpts: Execute.RunOpts<Result<V>> = {\n    // Rank results by score\n    rank: (a, b) => {\n      return defaultComparer(a.score ?? 0, b.score ?? 0);\n    },\n    shuffle: opts.shuffleHandlers ?? false,\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let sm = StateMachine.init(machine);\n\n  // Check that all 'if' states are actually defined on machine\n  for (const [ ifState ] of byState) {\n    // Check if state is defined\n    if (\n      typeof sm.machine[ ifState ] === `undefined` &&\n      ifState !== `__fallback`\n    ) {\n      throw new Error(\n        `StateMachineDriver handler references a state ('${ ifState }') which is not defined on the machine. Therefore this handler will never run.'`\n      );\n    }\n  }\n\n  const run = async (): Promise<StateMachine.MachineState<V> | undefined> => {\n    debug(`Run. State: ${ sm.value }`);\n    const state = sm.value;\n    //eslint-disable-next-line functional/no-let\n    let handler = byState.get(state);\n    if (handler === undefined) {\n      debug(`  No handler for state '${ state }', trying __fallback`);\n\n      // Is there a fallback?\n      handler = byState.get(`__fallback`);\n    }\n    if (handler === undefined) {\n      debug(`  No __fallback handler`);\n      return;\n    }\n\n    // If the `first` option is given, stop executing fns as soon as we get\n    // a valid result.\n    const runOptionsForHandler =\n      handler.resultChoice === `first`\n        ? {\n          ...runOpts,\n          stop: (latest: Result<V> | undefined) => {\n            if (!latest) return false;\n            if (`reset` in latest) return true;\n            if (`next` in latest && latest.next !== undefined) return true;\n            return false;\n          },\n        }\n        : runOpts;\n\n    const results = await Execute.run<MachineState<V>, Result<V>>(\n      handler.then,\n      runOptionsForHandler,\n      sm\n    );\n    debug(\n      `  In state '${ sm.value }' results: ${ results.length }. Choice: ${ handler.resultChoice\n      }`\n    );\n\n    // Apply selection logic\n    //eslint-disable-next-line functional/no-let\n    let r: Result<V> | undefined;\n    switch (handler.resultChoice ?? `highest`) {\n      case `highest`: {\n        r = results.at(-1);\n        break;\n      }\n      case `first`: {\n        r = results[ 0 ]; // Since we break on the first result\n        break;\n      }\n      case `lowest`: {\n        r = results.at(0);\n        break;\n      }\n      case `random`: {\n        r = randomElement(results);\n        break;\n      }\n      default: {\n        throw new Error(\n          `Unknown 'resultChoice' option: ${ handler.resultChoice }. Expected highest, first, lowest or random`\n        );\n      }\n    }\n\n    debug(`  Chosen result: ${ JSON.stringify(r) }`);\n    // Apply result\n    if (r?.reset) {\n      sm = StateMachine.reset(sm);\n    } else if (r && r.next) {\n      if (typeof r.next === `boolean`) {\n        sm = StateMachine.next(sm);\n      } else {\n        debug(JSON.stringify(results));\n        sm = StateMachine.to(sm, r.next);\n      }\n    }\n    return sm;\n  };\n\n  return {\n    reset: () => {\n      sm = StateMachine.reset(sm);\n    },\n    getValue: () => sm.value,\n    run,\n    to: (state: StateMachine.StateNames<V>) => {\n      sm = StateMachine.to(sm, state);\n      return sm;\n    },\n  };\n}\n","\nimport { sleep } from './Sleep.js';\nimport * as StateMachine from './StateMachine.js';\nimport * as Timer from './Timer.js';\n\nexport * as Elapsed from './Elapsed.js';\nexport * from './DispatchList.js';\nexport * from './Types.js';\n/**\n * State Machine\n * See [here for usage](../classes/Flow.StateMachine.StateMachine.html).\n *\n * * {@link StateMachine.driver}: Drive a state machine\n * * {@link StateMachine.init}: Create a state machine from initial state and machine description\n * * {@link fromList}: Create a state machine from a simple list of states\n */\nexport * as StateMachine from './StateMachine.js';\n\nexport * from './Timer.js';\n\nexport * from './Interval.js';\nexport * from './IntervalType.js';\nexport * from './Timeout.js';\nexport * from './UpdateOutdated.js';\nexport * from './Continuously.js';\nexport * from './Debounce.js';\nexport * from './Throttle.js';\nexport * from './Sleep.js';\nexport * from './WaitFor.js';\nexport * from './Delay.js';\nexport * from './Every.js';\nexport * from './RunOnce.js';\nexport * from './Retry.js';\nexport * from './Types.js';\nexport * from './RequestResponseMatch.js';\n\nexport { TaskQueue } from './TaskQueue.js';\n\nimport { repeatAwait, repeat } from './Repeat.js';\nexport { repeatAwait, repeat, type RepeatPredicate } from './Repeat.js';\n\n\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEachAsync} if you want to use an async `iterator` and async `fn`.\n * \n * Alternatives:\n * * {@link repeat}/{@link repeatAwait}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam V Type of iterable\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport const forEach = <V>(\n  iterator: IterableIterator<V> | ReadonlyArray<V>,\n  fn: (v?: V) => boolean\n) => {\n  for (const x of iterator) {\n    const r = fn(x);\n    if (typeof r === `boolean` && !r) break;\n  }\n};\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * Use {@link forEach} for a synchronous version.\n *\n * ```\n * // Prints items from array every second\n * await forEachAsync([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEachAsync(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @typeParam V Type of iterable\n */\nexport const forEachAsync = async function <V>(\n  iterator: AsyncIterableIterator<V> | ReadonlyArray<V>,\n  fn: (v?: V) => Promise<boolean> | Promise<void>,\n  intervalMs?: number\n) {\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (intervalMs) await sleep(intervalMs);\n      if (typeof r === `boolean` && !r) break;\n    }\n  }\n};\n\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Flow: { StateMachine, Timer, forEach, forEachAsync, repeatAwait, repeat },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n","import { clamp } from '../data/Clamp.js';\nimport { intervalToMs, type Interval } from './index.js';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * See: {@link msElapsedTimer}, {@link ticksElapsedTimer}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion.\n * See {@link relativeTimer}\n */\nexport type CompletionTimer = Timer & {\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link msElapsedTimer}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n * oneSecond(); // Returns _true_ when timer is done\n * ```\n *\n * See also {@link Elapsed.progress}.\n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relativeTimer(intervalToMs(elapsed, 0), { timer: msElapsedTimer() });\n  return () => t.isDone;\n}\n\nexport const frequencyTimerSource =\n  (frequency: number): TimerSource =>\n    () =>\n      frequencyTimer(frequency, { timer: msElapsedTimer() });\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total duration.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, milliseconds-based timer is used.\n *\n * ```js\n * const t = relativeTimer(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relativeTimer(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `msElapsedTimer()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = relativeTimer(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * @private\n * @param total Total\n * @param opts Options\n * @returns Timer\n */\nexport const relativeTimer = (\n  total: number,\n  opts: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  const clampValue = opts.clampValue ?? false;\n  const wrapValue = opts.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = opts.timer ?? msElapsedTimer();\n\n  const computeElapsed = () => {\n    let v = timer.elapsed / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * @example Init a spring oscillator, with a half a cycle per second\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * Oscillators.spring({}, frequencyTimer(0.5));\n * ```\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency\n * @param timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  opts: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = opts.timer ?? msElapsedTimer();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = msElapsedTimer();\n * t.reset(); // reset start\n * t.elapsed; // ms since start\n * ```\n * \n * Like other {@link Timer} functions, it returns a `isDone` property,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const msElapsedTimer = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = ticksElapsedTimer();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {msElapsedTimer}\n */\nexport const ticksElapsedTimer = (): Timer => {\n  // eslint-disable-next-line functional/no-let\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n","import { round } from '../numbers/Round.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport { msElapsedTimer, relativeTimer } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since the initial call.\n * ```js\n * // Record start\n * const elapsed = Elapsed.since();\n *\n * // Get elapsed time in millis\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a elapsed timer, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Elapsed.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: Elapsed.since() }\n * ```\n *\n * See also:\n * * {@link once} if you want to measure a single period, and stop it.\n * * {@link interval} time _between_ calls\n * @returns\n */\nexport const since = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns the interval between the start and each subsequent call.\n * \n * ```js\n * const interval = Elapsed.interval();\n * interval(); // Time from Elapsed.interval()\n * interval(); // Time since last interval() call\n * ```\n * \n * See also:\n * * {@link since}: time since first call\n * * {@link once}: time between two events\n * @returns \n */\nexport const interval = (): Since => {\n  let start = performance.now();\n  return (): number => {\n    const now = performance.now();\n    const x = now - start;\n    start = now;\n    return x;\n  }\n}\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link since}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = Elapsed.once();\n * // ...do stuff\n * elapsed(); // Yields time since Elapsed.once() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n * \n * See also:\n * * {@link since}: elapsed time\n * * {@link interval}: time _between_ calls\n * @returns\n */\nexport const once = (): Since => {\n  const start = Date.now();\n  //eslint-disable-next-line functional/no-let\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `Elapsed.since` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = Elapsed.infinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Elapsed.since();\n * });\n * ```\n * @returns\n */\nexport const infinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts timing immediately.\n *\n * ```js\n * const timer = Elapsed.progress(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Elapsed.progress(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Elapsed.progress({ mins: 4 });\n * ```\n * See also {@link hasElapsed}.\n * @param duration\n * @returns\n */\nexport function progress(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`duration invalid`);\n  const timerOpts = {\n    ...opts,\n    timer: msElapsedTimer(),\n  };\n  const t = relativeTimer(totalMs, timerOpts);\n  return () => t.elapsed;\n}\n\nexport const toString = (millisOrFunction: number | Since | Interval, rounding = 2): string => {\n  //eslint-disable-next-line functional/no-let\n  let interval: number | undefined = {} = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return toString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};\n","export type Dispatch<V> = (value: V) => void;\n\ntype Wrap<V> = {\n  readonly handler: Dispatch<V>\n  readonly id: string\n  readonly once: boolean\n}\n\nexport class DispatchList<V> {\n  #handlers: Array<Wrap<V>>\n  #counter = 0;\n  readonly #id = Math.floor(Math.random() * 100);\n  constructor() {\n\n    this.#handlers = [];\n  }\n\n  /**\n   * Returns _true_ if list is empty\n   * @returns \n   */\n  isEmpty() {\n    return this.#handlers.length === 0;\n  }\n\n  /**\n   * Adds a handler\n   * @param handler \n   * @param options \n   * @returns \n   */\n  add(handler: Dispatch<V>, options: { once?: boolean } = {}): string {\n    this.#counter++;\n    const once = options.once ?? false;\n    const wrap: Wrap<V> = {\n      id: this.#id + `-` + this.#counter,\n      handler,\n      once\n    }\n    this.#handlers.push(wrap);\n    return wrap.id;\n  }\n\n  remove(id: string): boolean {\n    const length = this.#handlers.length;\n    this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n    return this.#handlers.length !== length;\n  }\n\n  notify(value: V) {\n    for (const handler of this.#handlers) {\n      handler.handler(value);\n      if (handler.once) {\n        this.remove(handler.id);\n      }\n    }\n  }\n\n  clear() {\n    this.#handlers = [];\n  }\n}","import { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\n\nimport { type AsyncPromiseOrGenerator } from './Types.js';\n\nexport type IntervalOpts = {\n  /**\n   * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n   */\n  readonly fixed?: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  readonly minimum?: Interval;\n  /**\n   * Optional signal to abort\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When to perform delay. Default is before 'produce' is invoked.\n   */\n  readonly delay?: `before` | `after`;\n};\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * @example Produce a random number every 500ms:\n * ```\n * const randomGenerator = interval(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example Return values from a generator every 500ms:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * for await (const v of interval(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long).\n * The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If you just want to loop at a certain speed, consider using {@link continuously} instead.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * @template V Returns value of `produce` function\n * @param produce Function, generator to use\n * @param opts Options\n * @template V Data type\n * @returns\n */\nexport const interval = async function* <V>(\n  produce: AsyncPromiseOrGenerator<V> | ArrayLike<V>,\n  optsOrFixedMs: IntervalOpts | number = {}\n): AsyncGenerator<V> {\n  //eslint-disable-next-line functional/no-let\n  let cancelled = false;\n  const opts =\n    typeof optsOrFixedMs === `number`\n      ? { fixed: optsOrFixedMs }\n      : optsOrFixedMs;\n\n  const signal = opts.signal;\n  const when = opts.delay ?? `before`;\n  //eslint-disable-next-line functional/no-let\n  let sleepMs = intervalToMs(opts.fixed) ?? intervalToMs(opts.minimum, 0);\n  //eslint-disable-next-line functional/no-let\n  let started = performance.now();\n\n  const minIntervalMs = opts.minimum ? intervalToMs(opts.minimum) : undefined;\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  // Get an iterator over array\n  if (Array.isArray(produce)) produce = produce.values();\n\n  const isGenerator =\n    typeof produce === `object` &&\n    `next` in produce &&\n    typeof produce.next === `function`;\n\n  try {\n    while (!cancelled) {\n      if (when === `before`) await doDelay();\n      //if (cancelled) return;\n      if (typeof produce === `function`) {\n        // Returns V or Promise<V>\n        const result = await produce();\n        if (typeof result === `undefined`) return; // Done\n        yield result;\n      } else if (isGenerator) {\n        // Generator\n        const result = await (produce as AsyncGenerator<V>).next();\n        if (result.done) return;\n        yield result.value;\n      } else {\n        throw new Error(\n          `produce param does not seem to return a value/Promise and is not a generator?`\n        );\n      }\n\n      if (when === `after`) await doDelay();\n    }\n  } finally {\n    cancelled = true;\n  }\n};\n","import { throwIntegerTest, integerTest } from '../Guards.js';\nimport { type HasCompletion, type HasCompletionRunStates } from './index.js';\n\nimport { intervalToMs, type Interval } from './IntervalType.js';\n\nexport type TimeoutSyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => void;\nexport type TimeoutAsyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => Promise<void>;\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  /**\n   * Starts the timer.\n   * If the timer has already been started and has a scheduled execution, this is cancelled \n   * and re-scheduled.\n   * @param altTimeoutMs Optional override for the interval. Use _undefined_ to use the original interval\n   * @param args \n   */\n  start(altTimeoutMs?: number, args?: ReadonlyArray<unknown>): void;\n  /**\n   * Cancels the timer, aborting any scheduled execution.\n   */\n  cancel(): void;\n};\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `timeoutMs`.\n * If `start()` is called again, the waiting period will be reset to `timeoutMs`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * t.isDone;    // True if a scheduled event is pending\n * ```\n *\n * Callback function receives any additional parameters passed in from start.\n * This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param timeoutMs\n * @returns {@link Timeout}\n */\nexport const timeout = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): Timeout => {\n  if (callback === undefined) {\n    throw new Error(`callback parameter is undefined`);\n  }\n  const intervalMs = intervalToMs(interval);\n  throwIntegerTest(intervalMs, `aboveZero`, `interval`);\n\n  let timer: ReturnType<typeof setTimeout>;\n  let startedAt = 0;\n  let startCount = 0;\n  let state: HasCompletionRunStates = `idle`;\n\n  const clear = () => {\n    startedAt = 0;\n    globalThis.clearTimeout(timer);\n    state = `idle`;\n  }\n\n  const start = async (\n    altInterval: Interval = interval,\n    args: Array<unknown>\n  ): Promise<void> => {\n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      const altTimeoutMs = intervalToMs(altInterval);\n      const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      if (!it[ 0 ]) {\n        reject(new Error(it[ 1 ]));\n        return;\n      }\n\n      switch (state) {\n        case `scheduled`: {\n          // Cancel other scheduled execution\n          cancel();\n          break;\n        }\n        case `running`: {\n          //console.warn(`Timeout being rescheduled while task is already running`);\n          break;\n        }\n      }\n      state = `scheduled`;\n\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      timer = globalThis.setTimeout(async () => {\n        if (state !== `scheduled`) {\n          console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n          clear();\n          return;\n        }\n        const args_ = args ?? [];\n        startCount++;\n        state = `running`;\n        await callback(performance.now() - startedAt, ...args_);\n        state = `idle`\n        clear();\n        resolve();\n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (state === `idle`) return;\n    clear();\n  };\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    start,\n    cancel,\n    get runState() {\n      return state;\n    },\n    get startCount() {\n      return startCount;\n    }\n  };\n};\n\n\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });","export type UpdateFailPolicy = `fast` | `slow` | `backoff`;\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `intervalMs` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. It's\n * minimum value will be `intervalMs`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `intervalMs` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param intervalMs Maximum age of cached result\n * @param updateFail `slow` by default\n * @returns Value\n */\nexport const updateOutdated = <V>(\n  fn: (elapsedMs?: number) => Promise<V>,\n  intervalMs: number,\n  updateFail: UpdateFailPolicy = `slow`\n): (() => Promise<V>) => {\n  //eslint-disable-next-line functional/no-let\n  let lastRun = 0;\n  //eslint-disable-next-line functional/no-let\n  let lastValue: V | undefined;\n  //eslint-disable-next-line functional/no-let\n  let intervalMsCurrent = intervalMs;\n\n  //eslint-disable-next-line no-async-promise-executor\n  return () =>\n    new Promise(async (resolve, reject) => {\n      const elapsed = performance.now() - lastRun;\n      if (lastValue === undefined || elapsed > intervalMsCurrent) {\n        try {\n          lastRun = performance.now();\n          lastValue = await fn(elapsed);\n          intervalMsCurrent = intervalMs;\n        } catch (ex) {\n          if (updateFail === `fast`) {\n            lastValue = undefined;\n            lastRun = 0;\n          } else if (updateFail === `backoff`) {\n            intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n          }\n          reject(ex);\n          return;\n        }\n      }\n      resolve(lastValue);\n    });\n};\n","import { throwIntegerTest } from '../Guards.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport type { HasCompletion, HasCompletionRunStates } from './Types.js';\n/**\n * Runs a function continuously, returned by {@link Continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, does nothing\n   */\n  start(): void;\n\n  /**\n   * (Re-)starts the loop. If an existing iteration has been\n   * scheduled, this is cancelled and started again.\n   *\n   * This can be useful when adjusting the interval\n   */\n  reset(): void;\n  /**\n   * How many milliseconds since start() was last called\n   */\n  get elapsedMs(): number;\n  /**\n   * How many iterations of the loop since start() was last called\n   */\n  //get ticks(): number;\n  /**\n   * Returns _true_ if the loop is not running. This could be because\n   * it was never started, or it started and was exited.\n   */\n  //get isDone(): boolean;\n  /**\n   * Returns _true_ if the loop is currently running.\n   */\n  //get isRunning(): boolean;\n  /**\n   * If disposed, the continuously instance won't be re-startable\n   */\n  get isDisposed(): boolean;\n  /**\n   * Stops loop. It can be restarted using .start()\n   */\n  cancel(): void;\n  /**\n   * Set interval. Change will take effect on next loop. For it to kick\n   * in earlier, call .reset() after changing the value.\n   */\n  set interval(interval: Interval);\n  get interval(): Interval;\n};\n\nexport type ContinuouslySyncCallback = (\n  ticks?: number,\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => boolean | void;\nexport type ContinuouslyAsyncCallback = (\n  ticks?: number,\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => Promise<boolean | void>;\n\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type ContinuouslyOpts = Readonly<{\n  signal: AbortSignal;\n  fireBeforeWait: boolean;\n  /**\n   * Called whenever .start() is invoked.\n   * If this function returns:\n   *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n   *  - `cancel`: loop stops, but can be re-started if .start() is called again\n   *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n   *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n   *\n   */\n  onStartCalled: (\n    ticks?: number,\n    elapsedMs?: number\n  ) => OnStartCalled;\n}>;\n\n/**\n * Returns a {@link Continuously} that continuously at `intervalMs`, executing `callback`.\n * By default, first the sleep period happens and then the callback happens.\n * Use {@link Timeout} for a single event.\n *\n * If callback returns _false_, loop exits.\n *\n * Call `start` to begin/reset loop. `cancel` stops loop.\n *\n * @example Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example With delay\n * ```js\n * const fn = () => {\n *  console.log(`1 minute`);\n * }\n * const c = continuously(fn, 60*1000);\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.intervalMs; // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback Function to run. If it returns false, loop exits.\n * @param opts Additional options\n * @param intervalMs\n * @returns\n */\nexport const continuously = (\n  callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback,\n  interval?: Interval,\n  opts: Partial<ContinuouslyOpts> = {}\n): Continuously => {\n  let intervalMs = intervalToMs(interval, 0);\n  throwIntegerTest(intervalMs, `positive`, `interval`);\n  const signal = opts.signal;\n  const fireBeforeWait = opts.fireBeforeWait ?? false;\n  const onStartCalled = opts.onStartCalled;\n\n  let disposed = false;\n  //let running = false;\n  let runState: HasCompletionRunStates = `idle`;\n  let startCount = 0;\n  let ticks = 0;\n  let startedAt = performance.now();\n  let intervalUsed = interval ?? 0;\n  let cancelled = false;\n  let currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const deschedule = () => {\n    if (currentTimer === undefined) return;\n    //console.log(`continuously.deschedule`);\n    globalThis.clearTimeout(currentTimer);\n    currentTimer = undefined;\n  }\n\n  const schedule = (scheduledCallback: () => void) => {\n    if (intervalMs === 0) {\n      if (typeof requestAnimationFrame === `undefined`) {\n        currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n      } else {\n        currentTimer = undefined;\n        requestAnimationFrame(scheduledCallback);\n      }\n    } else {\n      currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n    }\n  }\n  // const schedule =\n  //   intervalMs === 0\n  //     ? raf\n  //     : (callback_: () => void) => globalThis.setTimeout(callback_, intervalMs);\n  // const deschedule =\n  //   intervalMs === 0\n  //     ? (_: number) => {\n  //       /** no-op */\n  //     }\n  //     // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n  //     : (timer: number) => globalThis.clearTimeout(timer);\n\n  const cancel = () => {\n    //console.log(`continuously.cancel state: ${ runState }. cancelled: ${ cancelled }`);\n    if (cancelled) return;\n    cancelled = true;\n\n    if (runState === `idle`) return; // No need to cancel\n    runState = `idle`;\n    ticks = 0;\n    deschedule();\n  };\n\n  const loop = async () => {\n    //console.log(`continuously loop state: ${ runState } timer: ${ currentTimer }`);\n    if (opts.signal?.aborted) {\n      runState = `idle`;\n    }\n    if (runState === `idle`) return;\n\n    runState = `running`\n    startCount++;\n    const valueOrPromise = callback(ticks++, performance.now() - startedAt);\n    const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n    if (cancelled) {\n      //console.log(`continiously cancelled!`);\n      return;\n    }\n    runState = `scheduled`;\n\n    // Didn't get a value, exit out\n    if (value !== undefined && !value) {\n      cancel();\n      return;\n    }\n    if (cancelled) return; // has been cancelled\n    //console.log(`continuously.loop rescheduling`);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    schedule(loop);\n  };\n\n  const start = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n    if (onStartCalled !== undefined) {\n      // A function governs whether to allow .start() to go ahead\n      const doWhat = onStartCalled(ticks, performance.now() - startedAt);\n      switch (doWhat) {\n        case `cancel`: {\n          cancel();\n          return;\n        }\n        case `reset`: {\n          reset();\n          return;\n        }\n        case `dispose`: {\n          disposed = true;\n          cancel();\n          return;\n        }\n        // No default\n      }\n    }\n\n    //console.log(`continuously start runState: ${ runState }`);\n    if (runState === `idle`) {\n      // Start running\n      startedAt = performance.now();\n      runState = `scheduled`;\n      if (fireBeforeWait) {\n        void loop(); // Exec first, then wait\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop); // Wait first, then exec\n      }\n    }\n  };\n\n  const reset = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n\n    // Cancel scheduled iteration\n    if (runState !== `idle`) {\n      cancel();\n    }\n    start();\n  };\n\n  return {\n    start,\n    reset,\n    cancel,\n    get interval() {\n      return intervalUsed;\n    },\n    get runState() {\n      return runState;\n    },\n    get startCount() {\n      return startCount;\n    },\n    set interval(interval: Interval) {\n      const ms = intervalToMs(interval, 0);\n      throwIntegerTest(ms, `positive`, `interval`);\n      intervalMs = ms;\n      intervalUsed = interval;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n  };\n};\n","import type { Interval } from './IntervalType.js';\nimport {\n  timeout,\n  type TimeoutSyncCallback,\n  type TimeoutAsyncCallback,\n} from './Timeout.js';\n\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param interval Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): DebouncedFunction => {\n  const t = timeout(callback, interval);\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return (...args: Array<unknown>) => { t.start(undefined, args); };\n};\n\n/**\n * Debounced function\n */\nexport type DebouncedFunction = (...args: ReadonlyArray<unknown>) => void;\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (\n  callback: (\n    elapsedMs: number,\n    ...args: readonly unknown[]\n  ) => void | Promise<unknown>,\n  intervalMinMs: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let trigger = 0;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return async (...args: unknown[]) => {\n    const elapsed = performance.now() - trigger;\n    if (elapsed >= intervalMinMs) {\n      const r = callback(elapsed, ...args);\n      if (typeof r === `object`) await r;\n      trigger = performance.now();\n    }\n  };\n};\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n * \n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n * \n * ```js\n * waitFor(1000, \n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n * \n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n * \n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  },\n *  (success) => {\n *    console.log(`Completed. Success: ${success ?? `Yes!` : `No`}`)\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n * \n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (\n  timeoutMs: number,\n  onAborted: (reason: string) => void,\n  onComplete?: (success: boolean) => void\n) => {\n\n  let t: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  let success = false;\n  const done = (error?: string) => {\n    if (t !== undefined) {\n      window.clearTimeout(t);\n      t = undefined;\n    }\n    if (error) {\n      onAborted(error);\n    } else {\n      success = true;\n    }\n    if (onComplete !== undefined) onComplete(success);\n  };\n\n  t = globalThis.setTimeout(() => {\n    t = undefined;\n    try {\n      onAborted(`Timeout after ${ timeoutMs }ms`);\n    } finally {\n      if (onComplete !== undefined) onComplete(success);\n    }\n  }, timeoutMs);\n\n  return done;\n};\n","import { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\n\n/**\n * Delay options\n */\nexport type DelayOpts = Interval & {\n  /**\n   * Signal for cancelling delay\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When delay is applied. \"before\" is default.\n   */\n  readonly delay?: `before` | `after` | `both`;\n};\n\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @template V\n * @param callback What to run after interval\n * @param opts Options for delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async <V>(\n  callback: () => Promise<V>,\n  //eslint-disable-next-line functional/prefer-immutable-types\n  optsOrMillis: DelayOpts | number\n): Promise<V> => {\n  const opts =\n    typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n  const delayWhen = opts.delay ?? `before`;\n  if (delayWhen === `before` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  const r = Promise.resolve(await callback());\n  if (delayWhen === `after` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  return r;\n};\n\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n\n//     // Yield value\n//     yield v;\n\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n * \n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n * \n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n * \n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n * \n * The below example shows how to do this.\n * \n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n * \n * // Execution continues while loop also runs\n * ```\n *\n */\n//eslint-disable-next-line func-style\nasync function* delayAnimationLoop() {\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer = 0;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.requestAnimationFrame(callback);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    globalThis.cancelAnimationFrame(timer);\n  }\n}\n\n/**\n * Async generator that loops at a given interval.\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link interval} iterate over an iterable with a given delay\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @example Loop runs every second\n * ```\n * // Loop forever\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * @example For Await loop every second\n * ```\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\n//eslint-disable-next-line func-style\nexport async function* delayLoop(timeout: Interval) {\n  const timeoutMs = intervalToMs(timeout);\n  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);\n  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);\n  if (timeoutMs === 0) return yield* delayAnimationLoop();\n\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer: ReturnType<typeof globalThis.setTimeout> | undefined;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.setTimeout(callback, timeoutMs);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    if (timer !== undefined) globalThis.clearTimeout(timer);\n    timer = undefined;\n  }\n}\n","import { throwIntegerTest } from '../Guards.js';\n\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = (\n  nth: number,\n  callback?: (...args: readonly unknown[]) => void\n) => {\n  throwIntegerTest(nth, `positive`, `nth`);\n\n  //eslint-disable-next-line functional/no-let\n  let counter = 0;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  return (...args: unknown[]): boolean => {\n    if (++counter === nth) {\n      counter = 0;\n      if (callback) callback(...args);\n      return true;\n    }\n    return false;\n  };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun: () => boolean): (() => boolean) => {\n  //eslint-disable-next-line functional/no-let\n  let run = false;\n  //eslint-disable-next-line functional/no-let\n  let success = false;\n  return () => {\n    if (run) return success;\n    run = true;\n    success = onRun();\n    return success;\n  };\n};\n","import { sleep } from './Sleep.js';\nimport { resolveLogOption } from '../debug/Logger.js';\nimport { since, toString as elapsedToString } from './Elapsed.js';\nimport { throwIntegerTest, throwNumberTest } from '../Guards.js';\nimport { getErrorMessage } from '../debug/GetErrorMessage.js';\nimport type { Result } from '../Results.js';\n/**\n * Result of backoff\n */\nexport type RetryResult<V> = {\n  /**\n   * Message describing outcome.\n   *\n   * If retry was aborted, message will be abort reason.\n   */\n  readonly message?: string;\n  /**\n   * True if callback function was invoked once where it returned _true_\n   */\n  readonly success: boolean;\n  /**\n   * Number of times callback was attempted\n   */\n  readonly attempts: number;\n  /**\n   * Total elapsed time since beginning of call to `retry`\n   */\n  readonly elapsed: number;\n\n  /**\n   * Value returned by succeeding function,\n   * or _undefined_ if it failed\n   */\n  readonly value: V | undefined;\n};\n\nexport type BackoffOptions = {\n  /**\n   * Initial value.\n   * Default: 1\n   */\n  startAt: number,\n  /**\n   * Maximum times to run.\n   * Default: continues forever\n   */\n  limitAttempts: number,\n  /**\n   * Stop retrying if this maximum is reached\n   * Default: no limit\n   */\n  limitValue: number\n  /**\n   * Math power. \n   * Default: 1.1\n   */\n  power: number\n};\n\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n * \n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n * \n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n * \n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n * \n * @param options \n * @returns \n */\nexport function* backoffGenerator(options: Partial<BackoffOptions> = {}) {\n  const startAt = options.startAt ?? 1;\n  let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = options.limitValue;\n  const power = options.power ?? 1.1;\n  let value = startAt;\n  throwIntegerTest(limitAttempts, `aboveZero`, `limitAttempts`);\n  throwNumberTest(startAt, ``, `startAt`);\n  throwNumberTest(limitAttempts, ``, `limitAttempts`);\n  if (limitValue !== undefined) throwNumberTest(limitValue, ``, `limitValue`);\n  throwNumberTest(power, ``, `power`);\n\n  while (limitAttempts > 0) {\n    // Value has climbed to the limit\n    if (limitValue && value >= limitValue) return;\n    limitAttempts--;\n    yield value;\n\n    // Increase value for next iteration\n    value += Math.pow(value, power);\n  }\n}\n\n/**\n * Backoff options\n */\nexport type RetryOpts<T> = BackoffOptions & {\n  /**\n   * Initial waiting period before first attempt (optional)\n   */\n  readonly predelayMs: number;\n  /**\n   * Optional abort signal\n   */\n  readonly abort: AbortSignal;\n  /**\n   * Log: _true_ monitors the task execution by logging to console\n   */\n  readonly log: boolean;\n\n  /***\n   * Default task value to return if it fails\n   */\n  readonly taskValueFallback: T;\n};\n\nexport type RetryTask<T> = {\n  /**\n   * If `probe` returns {success:true} task is considered\n   * complete and retrying stops\n   * @returns \n   */\n  probe: (attempts: number) => Promise<Result<T>>\n}\n\n/**\n * Keeps calling `callback` until it returns something other than _undefined_. \n * There is an exponentially-increasing delay between each retry attempt.\n * \n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param opts Options\n * @returns\n */\nexport const retryFunction = <T>(callback: () => Promise<T | undefined>, opts: Partial<RetryOpts<T>> = {}) => {\n  const task: RetryTask<T> = {\n    async probe() {\n      try {\n        const v = await callback();\n        if (v === undefined) return { value: opts.taskValueFallback, success: false };\n        return { value: v, success: true };\n      } catch (error) {\n        return { success: false, message: getErrorMessage(error) };\n      }\n    },\n  }\n  return retryTask(task, opts);\n}\n\n/**\n * Keeps trying to run `task`.\n * \n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *  \n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n * \n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task \n * @param opts \n * @returns \n */\nexport const retryTask = async <V>(\n  task: RetryTask<V>,\n  opts: Partial<RetryOpts<V>> = {}\n): Promise<RetryResult<V>> => {\n  const signal = opts.abort;\n  const log = resolveLogOption(opts.log);\n  const predelayMs = opts.predelayMs ?? 0;\n  const startedAt = since();\n\n  let attempts = 0;\n  const initialValue = opts.startAt ?? 1000;\n  const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n\n  if (initialValue <= 0) throw new Error(`Param 'initialValue' must be above zero`);\n\n  if (predelayMs > 0) {\n    try {\n      await sleep({ millis: predelayMs, signal: signal });\n    } catch (error) {\n      // Could happen due to abort signal\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n        message: getErrorMessage(error),\n      };\n    }\n  }\n\n  for (const t of backoffGen) {\n    attempts++;\n\n    // Run task\n    const result = await task.probe(attempts);\n    if (result.success) {\n      return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n    }\n    log({\n      msg: `retry attempts: ${ attempts } t: ${ elapsedToString(t) }`,\n    });\n\n    // Did not succeed.\n    if (attempts >= limitAttempts) {\n      break; // Out of attempts, no point sleeping again\n    }\n    // Sleep\n    try {\n      await sleep({ millis: t, signal });\n    } catch (error) {\n      // Eg if abort signal fires\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        message: getErrorMessage(error),\n        elapsed: startedAt(),\n      };\n    }\n  }\n\n  return {\n    message: `Giving up after ${ attempts } attempts.`,\n    success: false,\n    attempts,\n    value: opts.taskValueFallback,\n    elapsed: startedAt(),\n  };\n};\n","import { SimpleEventEmitter } from \"../Events.js\"\nimport { continuously } from \"./Continuously.js\"\n\nexport type RequestResponseOptions<TRequest, TResp> = {\n  timeoutMs: number\n  key: (requestOrResp: TRequest | TResp) => string\n  keyRequest: (request: TRequest) => string\n  keyResponse: (resp: TResp) => string\n  whenUnmatchedResponse: `ignore` | `throw`\n}\n\ntype SeenRequest<TRequest, TResp> = {\n  expiresAt: number\n  id: string\n  req: TRequest\n  promiseResolve?: (value: TResp) => void\n  promiseReject?: (message: string) => void\n  callback?: (error: boolean, value: TResp | string) => void\n}\n\nexport type RequestResponseMatchEvents<TRequest, TResp> = {\n  match: { request: TRequest, response: TResp }\n  completed: { request: TRequest, response: TResp | string, success: boolean }\n}\n\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n * \n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n * \n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n * \n * \n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id; \n *  }\n * });\n * ```\n * \n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id; \n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n * \n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport class RequestResponseMatch<TRequest, TResp> extends SimpleEventEmitter<RequestResponseMatchEvents<TRequest, TResp>> {\n  timeoutMs;\n  whenUnmatchedResponse;\n  keyRequest;\n  keyResponse;\n\n  #outgoing = new Map<string, SeenRequest<TRequest, TResp>>();\n  #maintainLoop;\n\n  constructor(options: Partial<RequestResponseOptions<TRequest, TResp>> = {}) {\n    super();\n    if (typeof window === `undefined`) {\n      (globalThis as any).window = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout\n      }\n    }\n    this.timeoutMs = options.timeoutMs ?? 1000;\n    this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;\n    this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);\n    if (options.key) {\n      if (options.keyRequest) throw new Error(`Cannot set 'keyRequest' when 'key' is set `);\n      if (options.keyResponse) throw new Error(`Cannot set 'keyResponse' when 'key' is set `);\n\n      this.keyRequest = options.key;\n      this.keyResponse = options.key;\n    } else {\n      if (!options.keyRequest || !options.keyResponse) {\n        throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);\n      }\n      this.keyRequest = options.keyRequest;\n      this.keyResponse = options.keyResponse;\n    }\n  }\n\n  #maintain() {\n    const values = [ ...this.#outgoing.values() ];\n    const now = Date.now();\n    for (const v of values) {\n      if (v.expiresAt <= now) {\n\n        if (v.promiseReject) {\n          v.promiseReject(`Request timeout`);\n        }\n        const callback = v.callback;\n        if (callback) {\n          setTimeout(() => {\n            callback(true, `Request timeout`);\n          }, 1);\n        }\n        this.fireEvent(`completed`, { request: v.req, response: `Request timeout`, success: false });\n        this.#outgoing.delete(v.id);\n      }\n    }\n    this.debugDump();\n    return this.#outgoing.size > 0;\n  }\n\n  debugDump() {\n    const values = [ ...this.#outgoing.values() ];\n    const now = Date.now();\n    for (const v of values) {\n      const expire = now - v.expiresAt;\n      console.log(`${ v.id } Expires in: ${ Math.floor(expire / 1000) }s`);\n    }\n  }\n\n  /**\n   * Make a request and get the outcome via a Promise\n   * @param request \n   */\n  request(request: TRequest): Promise<TResp>;\n\n  /**\n   * Makes a request with a callback for the outcome\n   * @param request \n   * @param callback \n   */\n  request(request: TRequest, callback: (error: boolean, response: TResp | string) => void): void;\n\n  /**\n   * Makes a request.\n   * If `callback` is set, it's equivalent to calling `requestCallback`.\n   * If `callback` is not set, a promise is returned\n   * @param request \n   * @param callback \n   * @returns \n   */\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n  request(request: TRequest, callback?: (error: boolean, response: TResp | string) => void): void | Promise<TResp> {\n    if (callback !== undefined) { this.#requestCallback(request, callback); return; }\n    return this.#requestAwait(request);\n  }\n\n  /**\n   * Make a request and don't wait for the outcome.\n   * @param request \n   */\n  requestAndForget(request: TRequest) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const r: SeenRequest<TRequest, TResp> = {\n      expiresAt: Date.now() + this.timeoutMs,\n      id,\n      req: request\n    };\n    this.#outgoing.set(id, r);\n    this.#maintainLoop.start();\n  }\n\n  /**\n   * Make a request, returning a Promise for the outcome.\n   * Errors will throw an exception.\n   * @param request \n   * @returns \n   */\n  #requestAwait(request: TRequest) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const p = new Promise<TResp>((resolve, reject) => {\n      const r: SeenRequest<TRequest, TResp> = {\n        expiresAt: Date.now() + this.timeoutMs,\n        id,\n        req: request,\n        promiseResolve: resolve,\n        promiseReject: reject\n      };\n      this.#outgoing.set(id, r);\n      this.#maintainLoop.start();\n\n    });\n    return p;\n  }\n\n  /**\n   * Make a request, and get notified of outcome with a callback\n   * @param request \n   * @param callback \n   */\n  #requestCallback(request: TRequest, callback: (error: boolean, response: TResp | string) => void) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const r: SeenRequest<TRequest, TResp> = {\n      expiresAt: Date.now() + this.timeoutMs,\n      id,\n      req: request,\n      callback\n    };\n    this.#outgoing.set(id, r);\n    this.#maintainLoop.start();\n  }\n\n  /**\n   * Response has been received\n   * @param response Response\n   * @returns _True_ if response matched a request \n   */\n  response(response: TResp, keepAlive: boolean): boolean {\n    const id = this.keyResponse(response);\n    const request = this.#outgoing.get(id);\n    if (!request) {\n      if (this.whenUnmatchedResponse === `throw`) throw new Error(`Unmatched response with id: '${ id }'`, { cause: response });\n      // otherwise ignore\n      return false;\n    }\n\n    if (keepAlive) {\n      // Continue life of request\n      request.expiresAt = Date.now() + this.timeoutMs\n    } else {\n      this.#outgoing.delete(id);\n    }\n    if (request.promiseResolve) {\n      request.promiseResolve(response);\n    }\n    if (request.callback) {\n      request.callback(false, response);\n    }\n    this.fireEvent(`match`, { request: request.req, response: response });\n    if (!keepAlive) {\n      this.fireEvent(`completed`, { request: request.req, response: response, success: true });\n    }\n    return true;\n  }\n}","import { mutable } from '../collections/queue/QueueMutable.js';\n\ntype Task = () => Promise<void>;\n\nexport type TaskQueueOpts = {\n  /**\n   * How long to wait before starting the queue 'thread'\n   * when something is added.\n   *\n   * Default: 500ms\n   */\n  readonly startDelayMs?: number;\n\n  /**\n   * Once running, sleeping period between each item\n   * being processed.\n   *\n   * Default: 100ms\n   */\n  readonly intervalMs?: number;\n};\n\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n *\n * @example Usage\n * ```js\n * const q = new TaskQueue();\n * q.add(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n */\nexport class TaskQueue {\n  static instance = new TaskQueue();\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _timer: any = 0;\n  private _queue;\n  private readonly _startDelayMs;\n  private readonly _intervalMs;\n\n  private constructor(opts: TaskQueueOpts = {}) {\n    this._startDelayMs = opts.startDelayMs ?? 500;\n    this._intervalMs = opts.intervalMs ?? 100;\n    this._queue = mutable<Task>(); // new QueueMutable<Task>();\n  }\n\n  /**\n   * Adds a task. This triggers processing loop if not already started.\n   *\n   * ```js\n   * queue.add(async () => {\n   *  await sleep(1000);\n   * });\n   * ```\n   * @param task Task to run\n   */\n  add(task: () => Promise<void>) {\n    this._queue.enqueue(task);\n    if (this._timer === 0) this.schedule(this._startDelayMs);\n  }\n\n  private schedule(intervalMs: number) {\n    // If the queue is empty, allow loop to stop\n    if (this._queue.length === 0) {\n      //eslint-disable-next-line functional/immutable-data\n      this._timer = 0;\n      return;\n    }\n\n    if (this._timer !== 0) {\n      // Seems to be running\n      return;\n    }\n\n    // Start the processing loop\n    //eslint-disable-next-line functional/immutable-data\n    this._timer = setTimeout(() => {\n      void this.processQueue();\n    }, intervalMs);\n  }\n\n  private async processQueue() {\n    const task = this._queue.dequeue();\n\n    //eslint-disable-next-line functional/immutable-data\n    this._timer = 0;\n    if (task !== undefined) {\n      try {\n        await task();\n        //eslint-disable-next-line functional/immutable-data\n        this._timer = 0;\n        this.schedule(this._intervalMs);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n","import { throwNumberTest } from '../Guards.js';\n\nexport type RepeatPredicate = (\n  repeats: number,\n  valuesProduced: number\n) => boolean;\n\n\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously\n * The number of repeats is set by giving a number as the first parameter, or a function, which when returns _false, repeat stops.\n * Use {@link repeat} if `fn` does not need to be awaited. \n * \n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1); \n * });\n * ``` \n * \n * Using a function to dynamically determine number of repeats\n * ```js\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  async () => {\n *    await Flow.sleep(1);\n *  }\n * );\n * ```\n * \n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @returns Asynchronous generator of `fn` results.\n */\nexport function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined>): AsyncGenerator<V> {\n  return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n}\n\n/**\n * Calls `fn` repeatedly, yielding each result.\n * The number of repeats is set by giving a number as the first parameter, or a function, which when returns _false, repeat stops.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it. \n * \n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n * \n * Using a function to dynamically determine number of repeats\n * ```js\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  () => {\n *    // Do something\n *  }\n * );\n * ```\n * \n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * \n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @returns Asynchronous generator of `fn` results.\n */\nexport function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n  return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n}\n\n\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate \n * @param fn \n */\nasync function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined>): AsyncGenerator<V> {\n  let repeats = 0;\n  let valuesProduced = 0;\n  while (predicate(repeats, valuesProduced)) {\n    repeats++;\n    const v = await fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate \n * @param fn \n */\nfunction* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n  let repeats = 0;\n  let valuesProduced = 0;\n  while (predicate(repeats, valuesProduced)) {\n    repeats++;\n    const v = fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count \n * @param fn \n */\nasync function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n  throwNumberTest(count, `positive`, `count`);\n  let valuesProduced = 0;\n  let repeats = 0;\n  while (count-- > 0) {\n    repeats++;\n    const v = await fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n * @param count \n * @param fn \n */\nfunction* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n  throwNumberTest(count, `positive`, `count`);\n  let valuesProduced = 0;\n  let repeats = 0;\n  while (count-- > 0) {\n    repeats++;\n    const v = fn(repeats, valuesProduced);\n    if (v === undefined) continue;\n    yield v;\n    valuesProduced++;\n  }\n}\n\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate\n * @param fn\n * @param initial\n * @param reduce\n * @returns\n */\nexport const repeatReduce = <V>(\n  countOrPredicate: number | RepeatPredicate,\n  fn: () => V | undefined,\n  initial: V,\n  reduce: (accumulator: V, value: V) => V\n): V => {\n  if (typeof countOrPredicate === `number`) {\n    throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n    while (countOrPredicate-- > 0) {\n      const v = fn();\n      if (v === undefined) continue;\n      initial = reduce(initial, v);\n    }\n  } else {\n    //eslint-disable-next-line functional/no-let\n    let repeats, valuesProduced;\n    repeats = valuesProduced = 0;\n    while (countOrPredicate(repeats, valuesProduced)) {\n      repeats++;\n      const v = fn();\n      if (v === undefined) continue;\n      initial = reduce(initial, v);\n      valuesProduced++;\n    }\n  }\n  return initial;\n};","import { SimpleEventEmitter } from '../Events.js';\nimport * as StateMachine from './StateMachine.js';\n\nimport type { StateNames, Transitions, MachineState } from './StateMachine.js';\nimport { Elapsed } from './index.js';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type Opts<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\n/**\n * A state machine that fires events when state changes.\n * \n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = Elapsed.infinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param m Machine description\n   * @param opts Options for machine (defaults to `{debug:false}`)\n   */\n  constructor(m: V, opts: Opts<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): ReadonlyArray<StateNames<V> | null> {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): ReadonlyArray<StateNames<V>> {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   * @memberof StateMachine\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[ 0 ]!;\n    return p[ 0 ]!;\n  }\n\n  /**\n   * Returns _true_ if state machine is in its final state\n   *\n   * @returns\n   */\n  get isDone(): boolean {\n    return StateMachine.done(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n\n    //eslint-disable-next-line functional/immutable-data\n    this.#changedAt = Elapsed.since();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `isValid()` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   *\n   * @memberof StateMachine\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${ priorState } -> ${ newState }`);\n    }\n    this.#changedAt = Elapsed.since();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.done(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC6GO,IAAM,MAAM,OACjB,aAIA,OAA4B,CAAC,GAC7B,SAC0B;AAC1B,QAAM,UAAwB,CAAC;AAC/B,QAAM,YAAY,KAAK,QAAQ;AAE/B,MAAI,mBAAmB,MAAM,QAAQ,WAAW,IAC3C,cACD,CAAE,WAAwD;AAC9D,MAAI,KAAK;AAAS,uBAAmB,QAAQ,gBAAgB;AAE7D,WAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAChD,UAAM,MAAM,iBAAkB,CAAE;AAEhC,QAAI;AACJ,QAAI,OAAO,QAAQ,YAAY;AAE7B,UAAI,MAAM,IAAI,IAAI;AAAA,IACpB,OAAO;AACL,UAAI;AAAA,IACN;AACA,QAAI,MAAM,QAAW;AAEnB,cAAQ,KAAK,CAAC;AAEd,cAAQ,KAAK,SAAS;AAAA,IACxB;AAEA,QAAI,OAAO,KAAK,SAAS,aAAa;AACpC,UAAI,KAAK,KAAK,GAAG,OAAO,GAAG;AACzB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,KAAK,QAAQ;AACf,WAAO,QAAQ,OAAO,KAAK,MAAM;AAAA,EACnC;AACA,SAAO;AACT;;;ACtDA,eAAsBC,MACpB,SACA,gBACoB;AACpB,QAAM,OAAsB,MAAM,QAAQ,cAAc,IACpD;AAAA,IACA,UAAU;AAAA,EACZ,IACG;AAEL,QAAM,QAAe,iBAAiB,KAAK,OAAO;AAAA,IAChD,UAAU;AAAA,EACZ,CAAC;AAID,QAAM,UAAU,oBAAI,IAA8B;AAClD,aAAW,KAAK,KAAK,UAAU;AAC7B,UAAM,UAAU,MAAM,QAAQ,EAAE,EAAE,IAAI,EAAE,KAAK,CAAE,EAAE,EAAG;AACpD,eAAW,SAAS,SAAS;AAC3B,UAAI,OAAO,UAAU,UAAU;AAC7B,cAAM,IAAI;AAAA,UACR,iEAAkE,OAAO,KAAM;AAAA,QACjF;AAAA,MACF;AAEA,UAAI,QAAQ,IAAI,KAAK,GAAG;AACtB,cAAM,IAAI;AAAA,UACR,wCAAyC,KACzC;AAAA,QACF;AAAA,MACF;AACA,cAAQ,IAAI,OAAO,CAAC;AAAA,IACtB;AAAA,EACF;AAWA,QAAM,UAAsC;AAAA;AAAA,IAE1C,MAAM,CAAC,GAAG,MAAM;AACd,aAAO,gBAAgB,EAAE,SAAS,GAAG,EAAE,SAAS,CAAC;AAAA,IACnD;AAAA,IACA,SAAS,KAAK,mBAAmB;AAAA,EACnC;AAGA,MAAI,KAAkB,KAAK,OAAO;AAGlC,aAAW,CAAE,OAAQ,KAAK,SAAS;AAEjC,QACE,OAAO,GAAG,QAAS,OAAQ,MAAM,eACjC,YAAY,cACZ;AACA,YAAM,IAAI;AAAA,QACR,mDAAoD,OAAQ;AAAA,MAC9D;AAAA,IACF;AAAA,EACF;AAEA,QAAMC,OAAM,YAA+D;AACzE,UAAM,eAAgB,GAAG,KAAM,EAAE;AACjC,UAAM,QAAQ,GAAG;AAEjB,QAAI,UAAU,QAAQ,IAAI,KAAK;AAC/B,QAAI,YAAY,QAAW;AACzB,YAAM,2BAA4B,KAAM,sBAAsB;AAG9D,gBAAU,QAAQ,IAAI,YAAY;AAAA,IACpC;AACA,QAAI,YAAY,QAAW;AACzB,YAAM,yBAAyB;AAC/B;AAAA,IACF;AAIA,UAAM,uBACJ,QAAQ,iBAAiB,UACrB;AAAA,MACA,GAAG;AAAA,MACH,MAAM,CAAC,WAAkC;AACvC,YAAI,CAAC;AAAQ,iBAAO;AACpB,YAAI,WAAW;AAAQ,iBAAO;AAC9B,YAAI,UAAU,UAAU,OAAO,SAAS;AAAW,iBAAO;AAC1D,eAAO;AAAA,MACT;AAAA,IACF,IACE;AAEN,UAAM,UAAU,MAAc;AAAA,MAC5B,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,IACF;AACA;AAAA,MACE,eAAgB,GAAG,KAAM,cAAe,QAAQ,MAAO,aAAc,QAAQ,YAC7E;AAAA,IACF;AAIA,QAAI;AACJ,YAAQ,QAAQ,gBAAgB,WAAW;AAAA,MACzC,KAAK,WAAW;AACd,YAAI,QAAQ,GAAG,EAAE;AACjB;AAAA,MACF;AAAA,MACA,KAAK,SAAS;AACZ,YAAI,QAAS,CAAE;AACf;AAAA,MACF;AAAA,MACA,KAAK,UAAU;AACb,YAAI,QAAQ,GAAG,CAAC;AAChB;AAAA,MACF;AAAA,MACA,KAAK,UAAU;AACb,YAAI,cAAc,OAAO;AACzB;AAAA,MACF;AAAA,MACA,SAAS;AACP,cAAM,IAAI;AAAA,UACR,kCAAmC,QAAQ,YAAa;AAAA,QAC1D;AAAA,MACF;AAAA,IACF;AAEA,UAAM,oBAAqB,KAAK,UAAU,CAAC,CAAE,EAAE;AAE/C,QAAI,GAAG,OAAO;AACZ,WAAkB,MAAM,EAAE;AAAA,IAC5B,WAAW,KAAK,EAAE,MAAM;AACtB,UAAI,OAAO,EAAE,SAAS,WAAW;AAC/B,aAAkB,KAAK,EAAE;AAAA,MAC3B,OAAO;AACL,cAAM,KAAK,UAAU,OAAO,CAAC;AAC7B,aAAkB,GAAG,IAAI,EAAE,IAAI;AAAA,MACjC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,OAAO,MAAM;AACX,WAAkB,MAAM,EAAE;AAAA,IAC5B;AAAA,IACA,UAAU,MAAM,GAAG;AAAA,IACnB,KAAAA;AAAA,IACA,IAAI,CAAC,UAAsC;AACzC,WAAkB,GAAG,IAAI,KAAK;AAC9B,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;ACtQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6DO,SAAS,WAAW,SAAkC;AAC3D,QAAM,IAAI,cAAc,aAAa,SAAS,CAAC,GAAG,EAAE,OAAO,eAAe,EAAE,CAAC;AAC7E,SAAO,MAAM,EAAE;AACjB;AAEO,IAAM,uBACX,CAAC,cACC,MACE,eAAe,WAAW,EAAE,OAAO,eAAe,EAAE,CAAC;AA4CpD,IAAM,gBAAgB,CAC3B,OACA,OAAmC,CAAC,MAChB;AAEpB,QAAM,aAAa,KAAK,cAAc;AACtC,QAAM,YAAY,KAAK,aAAa;AACpC,MAAI,cAAc;AAAW,UAAM,IAAI,MAAM,iDAAiD;AAE9F,MAAI,mBAAmB;AAGvB,QAAM,QAAQ,KAAK,SAAS,eAAe;AAE3C,QAAM,iBAAiB,MAAM;AAC3B,QAAI,IAAI,MAAM,WAAW,QAAQ;AACjC,QAAI;AAAY,UAAI,MAAM,CAAC;AAAA,aAClB,aAAa,KAAK;AAAG,UAAI,IAAI;AACtC,WAAO;AAAA,EACT;AAEA,SAAO;AAAA,IACL,IAAI,KAAa;AACf,yBAAmB;AAAA,IACrB;AAAA,IACA,IAAI,SAAS;AACX,aAAO,eAAe,KAAK;AAAA,IAC7B;AAAA,IACA,IAAI,UAAU;AACZ,aAAO,eAAe;AAAA,IACxB;AAAA,IACA,OAAO,MAAM;AACX,YAAM,MAAM;AAAA,IACd;AAAA,EACF;AACF;AAgCO,IAAM,iBAAiB,CAC5B,WACA,OAA2B,CAAC,MACR;AACpB,QAAM,QAAQ,KAAK,SAAS,eAAe;AAC3C,QAAM,kBAAkB,YAAY;AACpC,MAAI,mBAAmB;AAEvB,QAAM,iBAAiB,MAAM;AAE3B,UAAM,IAAI,MAAM,WAAW,kBAAkB;AAG7C,UAAM,IAAI,IAAI,KAAK,MAAM,CAAC;AAC1B,QAAI,IAAI,GAAG;AACT,YAAM,IAAI;AAAA,QACR,mDAAoD,CAAE,OAAQ,CAAE;AAAA,MAClE;AAAA,IACF;AACA,QAAI,IAAI,GAAG;AACT,YAAM,IAAI;AAAA,QACR,mDAAoD,CAAE,OAAQ,CAAE;AAAA,MAClE;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AAAA,IACL,KAAK,CAAC,QAAgB;AACpB,yBAAmB;AAAA,IACrB;AAAA,IACA,OAAO,MAAM;AACX,YAAM,MAAM;AAAA,IACd;AAAA,IACA,IAAI,SAAS;AACX,aAAO,eAAe,KAAK;AAAA,IAC7B;AAAA,IACA,IAAI,UAAU;AACZ,aAAO,eAAe;AAAA,IACxB;AAAA,EACF;AACF;AAgBO,IAAM,iBAAiB,MAAa;AACzC,MAAI,QAAQ,YAAY,IAAI;AAC5B,SAAO;AAAA;AAAA;AAAA;AAAA,IAIL,OAAO,MAAM;AACX,cAAQ,YAAY,IAAI;AAAA,IAC1B;AAAA;AAAA;AAAA;AAAA,IAIA,IAAI,UAAU;AACZ,aAAO,YAAY,IAAI,IAAI;AAAA,IAC7B;AAAA,EACF;AACF;AAkBO,IAAM,oBAAoB,MAAa;AAE5C,MAAI,QAAQ;AACZ,SAAO;AAAA;AAAA;AAAA;AAAA,IAIL,OAAO,MAAM;AACX,cAAQ;AAAA,IACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,IAAI,UAAU;AACZ,aAAO,EAAE;AAAA,IACX;AAAA,EACF;AACF;;;AClSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkCO,IAAM,QAAQ,MAAa;AAChC,QAAM,QAAQ,YAAY,IAAI;AAC9B,SAAO,MAAc;AACnB,WAAO,YAAY,IAAI,IAAI;AAAA,EAC7B;AACF;AAgBO,IAAM,WAAW,MAAa;AACnC,MAAI,QAAQ,YAAY,IAAI;AAC5B,SAAO,MAAc;AACnB,UAAM,MAAM,YAAY,IAAI;AAC5B,UAAM,IAAI,MAAM;AAChB,YAAQ;AACR,WAAO;AAAA,EACT;AACF;AAkBO,IAAM,OAAO,MAAa;AAC/B,QAAM,QAAQ,KAAK,IAAI;AAEvB,MAAI,YAAY;AAChB,SAAO,MAAc;AACnB,QAAI,cAAc,GAAG;AACnB,kBAAY,KAAK,IAAI,IAAI;AAAA,IAC3B;AACA,WAAO;AAAA,EACT;AACF;AAgBO,IAAM,WAAW,MAAa;AACnC,SAAO,MAAc;AACnB,WAAO,OAAO;AAAA,EAChB;AACF;AAwBO,SAAS,SACd,UACA,OAAwE,CAAC,GAC3D;AACd,QAAM,UAAU,aAAa,QAAQ;AACrC,MAAI,CAAC;AAAS,UAAM,IAAI,MAAM,kBAAkB;AAChD,QAAM,YAAY;AAAA,IAChB,GAAG;AAAA,IACH,OAAO,eAAe;AAAA,EACxB;AACA,QAAM,IAAI,cAAc,SAAS,SAAS;AAC1C,SAAO,MAAM,EAAE;AACjB;AAEO,IAAM,WAAW,CAAC,kBAA6C,WAAW,MAAc;AAE7F,MAAIC,YAA+B,CAAC,IAAI;AACxC,MAAI,OAAO,qBAAqB,YAAY;AAC1C,UAAM,iBAAiB,iBAAiB;AACxC,WAAO,SAAS,cAAc;AAAA,EAChC,WAAW,OAAO,qBAAqB,UAAU;AAC/C,IAAAA,YAAW;AAAA,EACb,WAAW,OAAO,qBAAqB,UAAU;AAC/C,IAAAA,YAAW,aAAaA,SAAQ;AAAA,EAClC;AAGA,MAAI,KAAK,aAAaA,SAAQ;AAC9B,MAAI,OAAO,OAAO;AAAa,WAAO;AACtC,MAAI,KAAK;AAAM,WAAO,GAAI,MAAM,UAAU,EAAE,CAAE;AAC9C,QAAM;AACN,MAAI,KAAK;AAAK,WAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AACvC,QAAM;AACN,MAAI,KAAK;AAAI,WAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AACtC,QAAM;AACN,SAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AAC3B;;;ACnKO,IAAM,eAAN,MAAsB;AAAA,EAC3B;AAAA,EACA,WAAW;AAAA,EACF,MAAM,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,EAC7C,cAAc;AAEZ,SAAK,YAAY,CAAC;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AACR,WAAO,KAAK,UAAU,WAAW;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,SAAsB,UAA8B,CAAC,GAAW;AAClE,SAAK;AACL,UAAMC,QAAO,QAAQ,QAAQ;AAC7B,UAAM,OAAgB;AAAA,MACpB,IAAI,KAAK,MAAM,MAAM,KAAK;AAAA,MAC1B;AAAA,MACA,MAAAA;AAAA,IACF;AACA,SAAK,UAAU,KAAK,IAAI;AACxB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,OAAO,IAAqB;AAC1B,UAAM,SAAS,KAAK,UAAU;AAC9B,SAAK,YAAY,KAAK,UAAU,OAAO,aAAW,QAAQ,OAAO,EAAE;AACnE,WAAO,KAAK,UAAU,WAAW;AAAA,EACnC;AAAA,EAEA,OAAO,OAAU;AACf,eAAW,WAAW,KAAK,WAAW;AACpC,cAAQ,QAAQ,KAAK;AACrB,UAAI,QAAQ,MAAM;AAChB,aAAK,OAAO,QAAQ,EAAE;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AAAA,EAEA,QAAQ;AACN,SAAK,YAAY,CAAC;AAAA,EACpB;AACF;;;ACFO,IAAMC,YAAW,iBACtB,SACA,gBAAuC,CAAC,GACrB;AAEnB,MAAI,YAAY;AAChB,QAAM,OACJ,OAAO,kBAAkB,WACrB,EAAE,OAAO,cAAc,IACvB;AAEN,QAAM,SAAS,KAAK;AACpB,QAAM,OAAO,KAAK,SAAS;AAE3B,MAAI,UAAU,aAAa,KAAK,KAAK,KAAK,aAAa,KAAK,SAAS,CAAC;AAEtE,MAAI,UAAU,YAAY,IAAI;AAE9B,QAAM,gBAAgB,KAAK,UAAU,aAAa,KAAK,OAAO,IAAI;AAClE,QAAM,UAAU,YAAY;AAC1B,UAAM,UAAU,YAAY,IAAI,IAAI;AACpC,QAAI,OAAO,kBAAkB,aAAa;AACxC,gBAAU,KAAK,IAAI,GAAG,gBAAgB,OAAO;AAAA,IAC/C;AACA,QAAI,SAAS;AACX,YAAM,MAAM,EAAE,QAAQ,SAAS,OAAO,CAAC;AAAA,IACzC;AACA,cAAU,YAAY,IAAI;AAC1B,QAAI,QAAQ;AAAS,YAAM,IAAI,MAAM,kBAAmB,OAAO,MAAO,EAAE;AAAA,EAC1E;AAGA,MAAI,MAAM,QAAQ,OAAO;AAAG,cAAU,QAAQ,OAAO;AAErD,QAAM,cACJ,OAAO,YAAY,YACnB,UAAU,WACV,OAAO,QAAQ,SAAS;AAE1B,MAAI;AACF,WAAO,CAAC,WAAW;AACjB,UAAI,SAAS;AAAU,cAAM,QAAQ;AAErC,UAAI,OAAO,YAAY,YAAY;AAEjC,cAAM,SAAS,MAAM,QAAQ;AAC7B,YAAI,OAAO,WAAW;AAAa;AACnC,cAAM;AAAA,MACR,WAAW,aAAa;AAEtB,cAAM,SAAS,MAAO,QAA8B,KAAK;AACzD,YAAI,OAAO;AAAM;AACjB,cAAM,OAAO;AAAA,MACf,OAAO;AACL,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,UAAI,SAAS;AAAS,cAAM,QAAQ;AAAA,IACtC;AAAA,EACF,UAAE;AACA,gBAAY;AAAA,EACd;AACF;;;AC7CO,IAAM,UAAU,CACrB,UACAC,cACY;AACZ,MAAI,aAAa,QAAW;AAC1B,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACA,QAAM,aAAa,aAAaA,SAAQ;AACxC,mBAAiB,YAAY,aAAa,UAAU;AAEpD,MAAI;AACJ,MAAI,YAAY;AAChB,MAAI,aAAa;AACjB,MAAI,QAAgC;AAEpC,QAAM,QAAQ,MAAM;AAClB,gBAAY;AACZ,eAAW,aAAa,KAAK;AAC7B,YAAQ;AAAA,EACV;AAEA,QAAM,QAAQ,OACZ,cAAwBA,WACxB,SACkB;AAClB,UAAM,IAAI,IAAI,QAAc,CAAC,SAAS,WAAW;AAC/C,kBAAY,YAAY,IAAI;AAC5B,YAAM,eAAe,aAAa,WAAW;AAC7C,YAAM,KAAK,YAAY,cAAc,aAAa,cAAc;AAChE,UAAI,CAAC,GAAI,CAAE,GAAG;AACZ,eAAO,IAAI,MAAM,GAAI,CAAE,CAAC,CAAC;AACzB;AAAA,MACF;AAEA,cAAQ,OAAO;AAAA,QACb,KAAK,aAAa;AAEhB,iBAAO;AACP;AAAA,QACF;AAAA,QACA,KAAK,WAAW;AAEd;AAAA,QACF;AAAA,MACF;AACA,cAAQ;AAGR,cAAQ,WAAW,WAAW,YAAY;AACxC,YAAI,UAAU,aAAa;AACzB,kBAAQ,KAAK,2DAA2D;AACxE,gBAAM;AACN;AAAA,QACF;AACA,cAAM,QAAQ,QAAQ,CAAC;AACvB;AACA,gBAAQ;AACR,cAAM,SAAS,YAAY,IAAI,IAAI,WAAW,GAAG,KAAK;AACtD,gBAAQ;AACR,cAAM;AACN,gBAAQ;AAAA,MACV,GAAG,YAAY;AAAA,IACjB,CAAC;AACD,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,MAAM;AACnB,QAAI,UAAU;AAAQ;AACtB,UAAM;AAAA,EACR;AAEA,SAAO;AAAA;AAAA,IAEL;AAAA,IACA;AAAA,IACA,IAAI,WAAW;AACb,aAAO;AAAA,IACT;AAAA,IACA,IAAI,aAAa;AACf,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;AC7HO,IAAM,iBAAiB,CAC5B,IACA,YACA,aAA+B,WACR;AAEvB,MAAI,UAAU;AAEd,MAAI;AAEJ,MAAI,oBAAoB;AAGxB,SAAO,MACL,IAAI,QAAQ,OAAO,SAAS,WAAW;AACrC,UAAM,UAAU,YAAY,IAAI,IAAI;AACpC,QAAI,cAAc,UAAa,UAAU,mBAAmB;AAC1D,UAAI;AACF,kBAAU,YAAY,IAAI;AAC1B,oBAAY,MAAM,GAAG,OAAO;AAC5B,4BAAoB;AAAA,MACtB,SAAS,IAAI;AACX,YAAI,eAAe,QAAQ;AACzB,sBAAY;AACZ,oBAAU;AAAA,QACZ,WAAW,eAAe,WAAW;AACnC,8BAAoB,KAAK,MAAM,oBAAoB,GAAG;AAAA,QACxD;AACA,eAAO,EAAE;AACT;AAAA,MACF;AAAA,IACF;AACA,YAAQ,SAAS;AAAA,EACnB,CAAC;AACL;;;AC6FO,IAAM,eAAe,CAC1B,UACAC,WACA,OAAkC,CAAC,MAClB;AACjB,MAAI,aAAa,aAAaA,WAAU,CAAC;AACzC,mBAAiB,YAAY,YAAY,UAAU;AACnD,QAAM,SAAS,KAAK;AACpB,QAAM,iBAAiB,KAAK,kBAAkB;AAC9C,QAAM,gBAAgB,KAAK;AAE3B,MAAI,WAAW;AAEf,MAAI,WAAmC;AACvC,MAAI,aAAa;AACjB,MAAI,QAAQ;AACZ,MAAI,YAAY,YAAY,IAAI;AAChC,MAAI,eAAeA,aAAY;AAC/B,MAAI,YAAY;AAChB,MAAI;AAEJ,QAAM,aAAa,MAAM;AACvB,QAAI,iBAAiB;AAAW;AAEhC,eAAW,aAAa,YAAY;AACpC,mBAAe;AAAA,EACjB;AAEA,QAAM,WAAW,CAAC,sBAAkC;AAClD,QAAI,eAAe,GAAG;AACpB,UAAI,OAAO,0BAA0B,aAAa;AAChD,uBAAe,WAAW,WAAW,mBAAmB,CAAC;AAAA,MAC3D,OAAO;AACL,uBAAe;AACf,8BAAsB,iBAAiB;AAAA,MACzC;AAAA,IACF,OAAO;AACL,qBAAe,WAAW,WAAW,mBAAmB,UAAU;AAAA,IACpE;AAAA,EACF;AAaA,QAAM,SAAS,MAAM;AAEnB,QAAI;AAAW;AACf,gBAAY;AAEZ,QAAI,aAAa;AAAQ;AACzB,eAAW;AACX,YAAQ;AACR,eAAW;AAAA,EACb;AAEA,QAAM,OAAO,YAAY;AAEvB,QAAI,KAAK,QAAQ,SAAS;AACxB,iBAAW;AAAA,IACb;AACA,QAAI,aAAa;AAAQ;AAEzB,eAAW;AACX;AACA,UAAM,iBAAiB,SAAS,SAAS,YAAY,IAAI,IAAI,SAAS;AACtE,UAAM,QAAQ,OAAO,mBAAmB,WAAY,MAAM,iBAAkB;AAC5E,QAAI,WAAW;AAEb;AAAA,IACF;AACA,eAAW;AAGX,QAAI,UAAU,UAAa,CAAC,OAAO;AACjC,aAAO;AACP;AAAA,IACF;AACA,QAAI;AAAW;AAGf,aAAS,IAAI;AAAA,EACf;AAEA,QAAM,QAAQ,MAAM;AAClB,QAAI;AAAU,YAAM,IAAI,MAAM,UAAU;AACxC,gBAAY;AACZ,QAAI,kBAAkB,QAAW;AAE/B,YAAM,SAAS,cAAc,OAAO,YAAY,IAAI,IAAI,SAAS;AACjE,cAAQ,QAAQ;AAAA,QACd,KAAK,UAAU;AACb,iBAAO;AACP;AAAA,QACF;AAAA,QACA,KAAK,SAAS;AACZ,UAAAC,OAAM;AACN;AAAA,QACF;AAAA,QACA,KAAK,WAAW;AACd,qBAAW;AACX,iBAAO;AACP;AAAA,QACF;AAAA,MAEF;AAAA,IACF;AAGA,QAAI,aAAa,QAAQ;AAEvB,kBAAY,YAAY,IAAI;AAC5B,iBAAW;AACX,UAAI,gBAAgB;AAClB,aAAK,KAAK;AAAA,MACZ,OAAO;AAEL,iBAAS,IAAI;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAEA,QAAMA,SAAQ,MAAM;AAClB,QAAI;AAAU,YAAM,IAAI,MAAM,UAAU;AACxC,gBAAY;AAGZ,QAAI,aAAa,QAAQ;AACvB,aAAO;AAAA,IACT;AACA,UAAM;AAAA,EACR;AAEA,SAAO;AAAA,IACL;AAAA,IACA,OAAAA;AAAA,IACA;AAAA,IACA,IAAI,WAAW;AACb,aAAO;AAAA,IACT;AAAA,IACA,IAAI,WAAW;AACb,aAAO;AAAA,IACT;AAAA,IACA,IAAI,aAAa;AACf,aAAO;AAAA,IACT;AAAA,IACA,IAAI,SAASD,WAAoB;AAC/B,YAAM,KAAK,aAAaA,WAAU,CAAC;AACnC,uBAAiB,IAAI,YAAY,UAAU;AAC3C,mBAAa;AACb,qBAAeA;AAAA,IACjB;AAAA,IACA,IAAI,aAAa;AACf,aAAO;AAAA,IACT;AAAA,IACA,IAAI,YAAY;AACd,aAAO,YAAY,IAAI,IAAI;AAAA,IAC7B;AAAA,EACF;AACF;;;ACnQO,IAAM,WAAW,CACtB,UACAE,cACsB;AACtB,QAAM,IAAI,QAAQ,UAAUA,SAAQ;AAEpC,SAAO,IAAI,SAAyB;AAAE,MAAE,MAAM,QAAW,IAAI;AAAA,EAAG;AAClE;;;AClDO,IAAM,WAAW,CACtB,UAIA,kBACG;AAEH,MAAI,UAAU;AAEd,SAAO,UAAU,SAAoB;AACnC,UAAM,UAAU,YAAY,IAAI,IAAI;AACpC,QAAI,WAAW,eAAe;AAC5B,YAAM,IAAI,SAAS,SAAS,GAAG,IAAI;AACnC,UAAI,OAAO,MAAM;AAAU,cAAM;AACjC,gBAAU,YAAY,IAAI;AAAA,IAC5B;AAAA,EACF;AACF;;;ACqCO,IAAM,UAAU,CACrB,WACA,WACA,eACG;AAEH,MAAI;AAEJ,MAAI,UAAU;AACd,QAAMC,QAAO,CAAC,UAAmB;AAC/B,QAAI,MAAM,QAAW;AACnB,aAAO,aAAa,CAAC;AACrB,UAAI;AAAA,IACN;AACA,QAAI,OAAO;AACT,gBAAU,KAAK;AAAA,IACjB,OAAO;AACL,gBAAU;AAAA,IACZ;AACA,QAAI,eAAe;AAAW,iBAAW,OAAO;AAAA,EAClD;AAEA,MAAI,WAAW,WAAW,MAAM;AAC9B,QAAI;AACJ,QAAI;AACF,gBAAU,iBAAkB,SAAU,IAAI;AAAA,IAC5C,UAAE;AACA,UAAI,eAAe;AAAW,mBAAW,OAAO;AAAA,IAClD;AAAA,EACF,GAAG,SAAS;AAEZ,SAAOA;AACT;;;ACnDO,IAAM,QAAQ,OACnB,UAEA,iBACe;AACf,QAAM,OACJ,OAAO,iBAAiB,WAAW,EAAE,QAAQ,aAAa,IAAI;AAChE,QAAM,YAAY,KAAK,SAAS;AAChC,MAAI,cAAc,YAAY,cAAc,QAAQ;AAClD,UAAM,MAAM,IAAI;AAAA,EAClB;AACA,QAAM,IAAI,QAAQ,QAAQ,MAAM,SAAS,CAAC;AAC1C,MAAI,cAAc,WAAW,cAAc,QAAQ;AACjD,UAAM,MAAM,IAAI;AAAA,EAClB;AACA,SAAO;AACT;AAiGA,gBAAgB,qBAAqB;AACnC,MAAI;AACJ,MAAI,IAAI,IAAI,QAAmB,CAAC,MAAO,UAAU,CAAE;AACnD,MAAI,QAAQ;AACZ,QAAM,WAAW,MAAM;AACrB,QAAI;AAAS,cAAQ;AACrB,QAAI,IAAI,QAAmB,CAAC,MAAO,UAAU,CAAE;AAAA,EACjD;AAEA,MAAI;AACF,WAAO,MAAM;AACX,cAAQ,WAAW,sBAAsB,QAAQ;AAEjD,YAAM,IAAI,MAAM;AAChB,YAAM;AAAA,IACR;AAAA,EACF,UAAE;AACA,QAAI;AAAS,cAAQ;AACrB,eAAW,qBAAqB,KAAK;AAAA,EACvC;AACF;AAqCA,gBAAuB,UAAUC,UAAmB;AAClD,QAAM,YAAY,aAAaA,QAAO;AACtC,MAAI,OAAO,cAAc;AAAa,UAAM,IAAI,MAAM,sBAAsB;AAC5E,MAAI,YAAY;AAAG,UAAM,IAAI,MAAM,2BAA2B;AAC9D,MAAI,cAAc;AAAG,WAAO,OAAO,mBAAmB;AAEtD,MAAI;AACJ,MAAI,IAAI,IAAI,QAAmB,CAAC,MAAO,UAAU,CAAE;AACnD,MAAI;AACJ,QAAM,WAAW,MAAM;AACrB,QAAI;AAAS,cAAQ;AACrB,QAAI,IAAI,QAAmB,CAAC,MAAO,UAAU,CAAE;AAAA,EACjD;AAEA,MAAI;AACF,WAAO,MAAM;AACX,cAAQ,WAAW,WAAW,UAAU,SAAS;AAEjD,YAAM,IAAI,MAAM;AAChB,YAAM;AAAA,IACR;AAAA,EACF,UAAE;AACA,QAAI;AAAS,cAAQ;AACrB,QAAI,UAAU;AAAW,iBAAW,aAAa,KAAK;AACtD,YAAQ;AAAA,EACV;AACF;;;ACvOO,IAAM,WAAW,CACtB,KACA,aACG;AACH,mBAAiB,KAAK,YAAY,KAAK;AAGvC,MAAI,UAAU;AAEd,SAAO,IAAI,SAA6B;AACtC,QAAI,EAAE,YAAY,KAAK;AACrB,gBAAU;AACV,UAAI;AAAU,iBAAS,GAAG,IAAI;AAC9B,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;;;AC9BO,IAAM,UAAU,CAAC,UAA0C;AAEhE,MAAIC,OAAM;AAEV,MAAI,UAAU;AACd,SAAO,MAAM;AACX,QAAIA;AAAK,aAAO;AAChB,IAAAA,OAAM;AACN,cAAU,MAAM;AAChB,WAAO;AAAA,EACT;AACF;;;ACgEO,UAAU,iBAAiB,UAAmC,CAAC,GAAG;AACvE,QAAM,UAAU,QAAQ,WAAW;AACnC,MAAI,gBAAgB,QAAQ,iBAAiB,OAAO;AACpD,QAAM,aAAa,QAAQ;AAC3B,QAAM,QAAQ,QAAQ,SAAS;AAC/B,MAAI,QAAQ;AACZ,mBAAiB,eAAe,aAAa,eAAe;AAC5D,kBAAgB,SAAS,IAAI,SAAS;AACtC,kBAAgB,eAAe,IAAI,eAAe;AAClD,MAAI,eAAe;AAAW,oBAAgB,YAAY,IAAI,YAAY;AAC1E,kBAAgB,OAAO,IAAI,OAAO;AAElC,SAAO,gBAAgB,GAAG;AAExB,QAAI,cAAc,SAAS;AAAY;AACvC;AACA,UAAM;AAGN,aAAS,KAAK,IAAI,OAAO,KAAK;AAAA,EAChC;AACF;AA0EO,IAAM,gBAAgB,CAAI,UAAwC,OAA8B,CAAC,MAAM;AAC5G,QAAM,OAAqB;AAAA,IACzB,MAAM,QAAQ;AACZ,UAAI;AACF,cAAM,IAAI,MAAM,SAAS;AACzB,YAAI,MAAM;AAAW,iBAAO,EAAE,OAAO,KAAK,mBAAmB,SAAS,MAAM;AAC5E,eAAO,EAAE,OAAO,GAAG,SAAS,KAAK;AAAA,MACnC,SAAS,OAAO;AACd,eAAO,EAAE,SAAS,OAAO,SAAS,gBAAgB,KAAK,EAAE;AAAA,MAC3D;AAAA,IACF;AAAA,EACF;AACA,SAAO,UAAU,MAAM,IAAI;AAC7B;AAsBO,IAAM,YAAY,OACvB,MACA,OAA8B,CAAC,MACH;AAC5B,QAAM,SAAS,KAAK;AACpB,QAAM,MAAM,iBAAiB,KAAK,GAAG;AACrC,QAAM,aAAa,KAAK,cAAc;AACtC,QAAM,YAAY,MAAM;AAExB,MAAI,WAAW;AACf,QAAM,eAAe,KAAK,WAAW;AACrC,QAAM,gBAAgB,KAAK,iBAAiB,OAAO;AACnD,QAAM,aAAa,iBAAiB,EAAE,GAAG,MAAM,SAAS,cAAc,cAAc,CAAC;AAErF,MAAI,gBAAgB;AAAG,UAAM,IAAI,MAAM,yCAAyC;AAEhF,MAAI,aAAa,GAAG;AAClB,QAAI;AACF,YAAM,MAAM,EAAE,QAAQ,YAAY,OAAe,CAAC;AAAA,IACpD,SAAS,OAAO;AAEd,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,SAAS,UAAU;AAAA,QACnB,SAAS,gBAAgB,KAAK;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AAEA,aAAW,KAAK,YAAY;AAC1B;AAGA,UAAM,SAAS,MAAM,KAAK,MAAM,QAAQ;AACxC,QAAI,OAAO,SAAS;AAClB,aAAO,EAAE,SAAS,OAAO,SAAS,OAAO,OAAO,OAAO,UAAU,SAAS,UAAU,EAAE;AAAA,IACxF;AACA,QAAI;AAAA,MACF,KAAK,mBAAoB,QAAS,OAAQ,SAAgB,CAAC,CAAE;AAAA,IAC/D,CAAC;AAGD,QAAI,YAAY,eAAe;AAC7B;AAAA,IACF;AAEA,QAAI;AACF,YAAM,MAAM,EAAE,QAAQ,GAAG,OAAO,CAAC;AAAA,IACnC,SAAS,OAAO;AAEd,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,SAAS,gBAAgB,KAAK;AAAA,QAC9B,SAAS,UAAU;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AAAA,IACL,SAAS,mBAAoB,QAAS;AAAA,IACtC,SAAS;AAAA,IACT;AAAA,IACA,OAAO,KAAK;AAAA,IACZ,SAAS,UAAU;AAAA,EACrB;AACF;;;AC3MO,IAAM,uBAAN,cAAoD,mBAAgE;AAAA,EACzH;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,oBAAI,IAA0C;AAAA,EAC1D;AAAA,EAEA,YAAY,UAA4D,CAAC,GAAG;AAC1E,UAAM;AACN,QAAI,OAAO,WAAW,aAAa;AACjC,MAAC,WAAmB,SAAS;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,SAAK,YAAY,QAAQ,aAAa;AACtC,SAAK,wBAAwB,QAAQ,yBAAyB;AAC9D,SAAK,gBAAgB,aAAa,MAAM,KAAK,UAAU,GAAG,KAAK,YAAY,CAAC;AAC5E,QAAI,QAAQ,KAAK;AACf,UAAI,QAAQ;AAAY,cAAM,IAAI,MAAM,4CAA4C;AACpF,UAAI,QAAQ;AAAa,cAAM,IAAI,MAAM,6CAA6C;AAEtF,WAAK,aAAa,QAAQ;AAC1B,WAAK,cAAc,QAAQ;AAAA,IAC7B,OAAO;AACL,UAAI,CAAC,QAAQ,cAAc,CAAC,QAAQ,aAAa;AAC/C,cAAM,IAAI,MAAM,2EAA2E;AAAA,MAC7F;AACA,WAAK,aAAa,QAAQ;AAC1B,WAAK,cAAc,QAAQ;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,YAAY;AACV,UAAM,SAAS,CAAE,GAAG,KAAK,UAAU,OAAO,CAAE;AAC5C,UAAM,MAAM,KAAK,IAAI;AACrB,eAAW,KAAK,QAAQ;AACtB,UAAI,EAAE,aAAa,KAAK;AAEtB,YAAI,EAAE,eAAe;AACnB,YAAE,cAAc,iBAAiB;AAAA,QACnC;AACA,cAAM,WAAW,EAAE;AACnB,YAAI,UAAU;AACZ,qBAAW,MAAM;AACf,qBAAS,MAAM,iBAAiB;AAAA,UAClC,GAAG,CAAC;AAAA,QACN;AACA,aAAK,UAAU,aAAa,EAAE,SAAS,EAAE,KAAK,UAAU,mBAAmB,SAAS,MAAM,CAAC;AAC3F,aAAK,UAAU,OAAO,EAAE,EAAE;AAAA,MAC5B;AAAA,IACF;AACA,SAAK,UAAU;AACf,WAAO,KAAK,UAAU,OAAO;AAAA,EAC/B;AAAA,EAEA,YAAY;AACV,UAAM,SAAS,CAAE,GAAG,KAAK,UAAU,OAAO,CAAE;AAC5C,UAAM,MAAM,KAAK,IAAI;AACrB,eAAW,KAAK,QAAQ;AACtB,YAAM,SAAS,MAAM,EAAE;AACvB,cAAQ,IAAI,GAAI,EAAE,EAAG,gBAAiB,KAAK,MAAM,SAAS,GAAI,CAAE,GAAG;AAAA,IACrE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,QAAQ,SAAmB,UAAsF;AAC/G,QAAI,aAAa,QAAW;AAAE,WAAK,iBAAiB,SAAS,QAAQ;AAAG;AAAA,IAAQ;AAChF,WAAO,KAAK,cAAc,OAAO;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,SAAmB;AAClC,UAAM,KAAK,KAAK,WAAW,OAAO;AAClC,QAAI,KAAK,UAAU,IAAI,EAAE;AAAG,YAAM,IAAI,MAAM,sCAAuC,EAAG,GAAG;AAEzF,UAAM,IAAkC;AAAA,MACtC,WAAW,KAAK,IAAI,IAAI,KAAK;AAAA,MAC7B;AAAA,MACA,KAAK;AAAA,IACP;AACA,SAAK,UAAU,IAAI,IAAI,CAAC;AACxB,SAAK,cAAc,MAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cAAc,SAAmB;AAC/B,UAAM,KAAK,KAAK,WAAW,OAAO;AAClC,QAAI,KAAK,UAAU,IAAI,EAAE;AAAG,YAAM,IAAI,MAAM,sCAAuC,EAAG,GAAG;AAEzF,UAAM,IAAI,IAAI,QAAe,CAAC,SAAS,WAAW;AAChD,YAAM,IAAkC;AAAA,QACtC,WAAW,KAAK,IAAI,IAAI,KAAK;AAAA,QAC7B;AAAA,QACA,KAAK;AAAA,QACL,gBAAgB;AAAA,QAChB,eAAe;AAAA,MACjB;AACA,WAAK,UAAU,IAAI,IAAI,CAAC;AACxB,WAAK,cAAc,MAAM;AAAA,IAE3B,CAAC;AACD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB,SAAmB,UAA8D;AAChG,UAAM,KAAK,KAAK,WAAW,OAAO;AAClC,QAAI,KAAK,UAAU,IAAI,EAAE;AAAG,YAAM,IAAI,MAAM,sCAAuC,EAAG,GAAG;AAEzF,UAAM,IAAkC;AAAA,MACtC,WAAW,KAAK,IAAI,IAAI,KAAK;AAAA,MAC7B;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACF;AACA,SAAK,UAAU,IAAI,IAAI,CAAC;AACxB,SAAK,cAAc,MAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,UAAiB,WAA6B;AACrD,UAAM,KAAK,KAAK,YAAY,QAAQ;AACpC,UAAM,UAAU,KAAK,UAAU,IAAI,EAAE;AACrC,QAAI,CAAC,SAAS;AACZ,UAAI,KAAK,0BAA0B;AAAS,cAAM,IAAI,MAAM,gCAAiC,EAAG,KAAK,EAAE,OAAO,SAAS,CAAC;AAExH,aAAO;AAAA,IACT;AAEA,QAAI,WAAW;AAEb,cAAQ,YAAY,KAAK,IAAI,IAAI,KAAK;AAAA,IACxC,OAAO;AACL,WAAK,UAAU,OAAO,EAAE;AAAA,IAC1B;AACA,QAAI,QAAQ,gBAAgB;AAC1B,cAAQ,eAAe,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,UAAU;AACpB,cAAQ,SAAS,OAAO,QAAQ;AAAA,IAClC;AACA,SAAK,UAAU,SAAS,EAAE,SAAS,QAAQ,KAAK,SAAmB,CAAC;AACpE,QAAI,CAAC,WAAW;AACd,WAAK,UAAU,aAAa,EAAE,SAAS,QAAQ,KAAK,UAAoB,SAAS,KAAK,CAAC;AAAA,IACzF;AACA,WAAO;AAAA,EACT;AACF;;;AC7OO,IAAM,YAAN,MAAM,WAAU;AAAA,EACrB,OAAO,WAAW,IAAI,WAAU;AAAA;AAAA,EAExB,SAAc;AAAA,EACd;AAAA,EACS;AAAA,EACA;AAAA,EAET,YAAY,OAAsB,CAAC,GAAG;AAC5C,SAAK,gBAAgB,KAAK,gBAAgB;AAC1C,SAAK,cAAc,KAAK,cAAc;AACtC,SAAK,SAAS,QAAc;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,IAAI,MAA2B;AAC7B,SAAK,OAAO,QAAQ,IAAI;AACxB,QAAI,KAAK,WAAW;AAAG,WAAK,SAAS,KAAK,aAAa;AAAA,EACzD;AAAA,EAEQ,SAAS,YAAoB;AAEnC,QAAI,KAAK,OAAO,WAAW,GAAG;AAE5B,WAAK,SAAS;AACd;AAAA,IACF;AAEA,QAAI,KAAK,WAAW,GAAG;AAErB;AAAA,IACF;AAIA,SAAK,SAAS,WAAW,MAAM;AAC7B,WAAK,KAAK,aAAa;AAAA,IACzB,GAAG,UAAU;AAAA,EACf;AAAA,EAEA,MAAc,eAAe;AAC3B,UAAM,OAAO,KAAK,OAAO,QAAQ;AAGjC,SAAK,SAAS;AACd,QAAI,SAAS,QAAW;AACtB,UAAI;AACF,cAAM,KAAK;AAEX,aAAK,SAAS;AACd,aAAK,SAAS,KAAK,WAAW;AAAA,MAChC,SAAS,OAAO;AACd,gBAAQ,MAAM,KAAK;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AACF;;;ACtDO,SAAS,YAAe,kBAA4C,IAA4F;AACrK,SAAO,OAAO,qBAAqB,WAAW,mBAAmB,kBAAkB,EAAE,IAAI,mBAAmB,kBAAkB,EAAE;AAClI;AA2CO,SAAS,OAAU,kBAA4C,IAA8E;AAClJ,SAAO,OAAO,qBAAqB,WAAW,YAAY,kBAAkB,EAAE,IAAI,YAAY,kBAAkB,EAAE;AACpH;AASA,gBAAgB,mBAAsB,WAA4B,IAA4F;AAC5J,MAAI,UAAU;AACd,MAAI,iBAAiB;AACrB,SAAO,UAAU,SAAS,cAAc,GAAG;AACzC;AACA,UAAM,IAAI,MAAM,GAAG,SAAS,cAAc;AAC1C,QAAI,MAAM;AAAW;AACrB,UAAM;AACN;AAAA,EACF;AACF;AAOA,UAAU,YAAe,WAA4B,IAA8E;AACjI,MAAI,UAAU;AACd,MAAI,iBAAiB;AACrB,SAAO,UAAU,SAAS,cAAc,GAAG;AACzC;AACA,UAAM,IAAI,GAAG,SAAS,cAAc;AACpC,QAAI,MAAM;AAAW;AACrB,UAAM;AACN;AAAA,EACF;AACF;AAQA,gBAAgB,mBAAsB,OAAe,IAAyF;AAC5I,kBAAgB,OAAO,YAAY,OAAO;AAC1C,MAAI,iBAAiB;AACrB,MAAI,UAAU;AACd,SAAO,UAAU,GAAG;AAClB;AACA,UAAM,IAAI,MAAM,GAAG,SAAS,cAAc;AAC1C,QAAI,MAAM;AAAW;AACrB,UAAM;AACN;AAAA,EACF;AACF;AAOA,UAAU,YAAe,OAAe,IAA8E;AACpH,kBAAgB,OAAO,YAAY,OAAO;AAC1C,MAAI,iBAAiB;AACrB,MAAI,UAAU;AACd,SAAO,UAAU,GAAG;AAClB;AACA,UAAM,IAAI,GAAG,SAAS,cAAc;AACpC,QAAI,MAAM;AAAW;AACrB,UAAM;AACN;AAAA,EACF;AACF;;;AjBtGO,IAAM,UAAU,CACrB,UACA,OACG;AACH,aAAW,KAAK,UAAU;AACxB,UAAM,IAAI,GAAG,CAAC;AACd,QAAI,OAAO,MAAM,aAAa,CAAC;AAAG;AAAA,EACpC;AACF;AA6BO,IAAM,eAAe,eAC1B,UACA,IACA,YACA;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAE3B,eAAW,KAAK,UAAU;AACxB,YAAM,IAAI,MAAM,GAAG,CAAC;AACpB,UAAI;AAAY,cAAM,MAAM,UAAU;AACtC,UAAI,OAAO,MAAM,aAAa,CAAC;AAAG;AAAA,IACpC;AAAA,EACF,OAAO;AAEL,qBAAiB,KAAK,UAAU;AAC9B,YAAM,IAAI,MAAM,GAAG,CAAC;AACpB,UAAI;AAAY,cAAM,MAAM,UAAU;AACtC,UAAI,OAAO,MAAM,aAAa,CAAC;AAAG;AAAA,IACpC;AAAA,EACF;AACF;AAGA,IAAI;AACF,MAAI,OAAO,WAAW,aAAa;AAEjC,IAAC,OAAe,OAAO;AAAA,MACrB,GAAI,OAAe;AAAA,MACnB,MAAM,EAAE,oCAAc,sBAAO,SAAS,cAAc,aAAa,OAAO;AAAA,IAC1E;AAAA,EACF;AACF,QAAQ;AAER;;;AkB/FO,IAAM,yBAAN,cAEG,mBAA4C;AAAA,EACpD;AAAA,EACA;AAAA,EAEA;AAAA,EACA,qBAAqB;AAAA,EACrB,UAAU;AAAA,EACV,aAAa,gBAAQ,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAO9B,YAAY,GAAM,OAAgB,CAAC,GAAG;AACpC,UAAM;AAEN,SAAK,SAAS,KAAK,SAAS;AAC5B,SAAK,MAAmB,KAAK,GAAG,KAAK,OAAO;AAC5C,SAAK,aAA0B,WAAW,KAAK,GAAG;AAAA,EACpD;AAAA,EAEA,WAAW,GAAY;AACrB,QAAI,KAAK,YAAY;AAAG;AACxB,SAAK,UAAU;AACf,QAAI,GAAG;AACL,WAAK,qBAAqB;AAC1B,iBAAW,MAAM;AACf,YAAI,CAAC,KAAK;AAAoB;AAC9B,aAAK,qBAAqB;AAE1B,aAAK,UAAU,QAAQ,EAAE,OAAO,KAAK,IAAI,MAAM,CAAC;AAAA,MAClD,GAAG,CAAC;AAAA,IACN,OAAO;AACL,WAAK,qBAAqB;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,iBAAsD;AACxD,WAAoB,SAAS,KAAK,GAAG;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,gBAA8C;AAChD,WAAO,OAAO,KAAK,KAAK,IAAI,OAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAsB;AACpB,UAAM,IAAiB,SAAS,KAAK,GAAG;AACxC,QAAI,EAAE,WAAW;AAAG,aAAO;AAC3B,SAAK,QAAQ,EAAG,CAAE;AAClB,WAAO,EAAG,CAAE;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,SAAkB;AACpB,WAAoB,KAAK,KAAK,GAAG;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,WAAW,KAAK;AACrB,SAAK,MAAmB,WAAW,KAAK,UAAU;AAGlD,SAAK,aAAa,gBAAQ,MAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,mBAAmB,UAA+B;AAChD,IAAa,mBAAmB,KAAK,KAAK,QAAQ;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,QAAQ,UAAkC;AACxC,WAAoB,kBAAkB,KAAK,KAAK,QAAQ;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,IAAI,MAAM,UAAyB;AACjC,UAAM,aAAa,KAAK,IAAI;AAC5B,QAAI,aAAa,KAAK,IAAI;AAAO;AAGjC,SAAK,MAAmB,GAAG,KAAK,KAAK,QAAQ;AAC7C,QAAI,KAAK,QAAQ;AACf,cAAQ,IAAI,iBAAkB,UAAW,OAAQ,QAAS,EAAE;AAAA,IAC9D;AACA,SAAK,aAAa,gBAAQ,MAAM;AAChC,eAAW,MAAM;AACf,WAAK,UAAU,UAAU,EAAE,UAAoB,WAAuB,CAAC;AAAA,IACzE,GAAG,CAAC;AAEJ,QAAiB,KAAK,KAAK,GAAG;AAAG,WAAK,WAAW,IAAI;AAAA,EACvD;AAAA,EAEA,IAAI,QAAgB;AAClB,WAAO,KAAK,IAAI;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,YAAoB;AACtB,WAAO,KAAK,WAAW;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,UAAkB;AACpB,WAAO,KAAK,WAAW;AAAA,EACzB;AACF;;;ArBxFO,IAAM,aAAa,CACxB,YACoB;AACpB,SAAO,OAAO,OAAO;AAAA,IACnB,OAAO,QAAQ;AAAA,IACf,SAAS,CAAE,GAAG,QAAQ,OAAQ;AAAA,IAC9B,SAAS,QAAQ;AAAA,EACnB,CAAC;AACH;AAuBO,IAAM,OAAO,CAClB,cACA,iBACoB;AACpB,QAAM,CAAE,SAAS,sBAAuB,IAAI,gBAAgB,YAAY;AACxE,MAAI,CAAC;AAAS,UAAM,IAAI,MAAM,sBAAsB;AAEpD,QAAM;AAAA;AAAA,IAEH,gBAAkB,OAAO,KAAK,QAAQ,MAAM,EAAG,CAAE;AAAA;AACpD,MAAI,QAAQ,OAAQ,KAAM,MAAM,QAAW;AACzC,UAAM,IAAI,UAAU,yBAAyB;AAAA,EAC/C;AAGA,QAAM,cAAc,gCAAgC,QAAQ,MAAM;AAClE,MAAI,gBAAgB,QAAW;AAC7B,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AAEA,SAAO,OAAO,OAAO;AAAA,IACnB,OAAO;AAAA,IACP,SAAS,CAAC;AAAA,IACV,SAAS,OAAO,YAAY,WAAW;AAAA,EACzC,CAAC;AACH;AAEO,IAAM,QAAQ,CACnB,OACoB;AAEpB,SAAO,KAAQ,GAAG,OAAO;AAC3B;AAEO,IAAM,kBAAkB,CAC7B,oBACqD;AACrD,MAAI,oBAAoB,QAAW;AACjC,WAAO,CAAE,QAAW,qBAAsB;AAAA,EAC5C;AACA,MAAI,oBAAoB,MAAM;AAC5B,WAAO,CAAE,QAAW,gBAAiB;AAAA,EACvC;AACA,MAAI,YAAY,iBAAiB;AAE/B,WAAO,CAAE,iBAA+B,EAAG;AAAA,EAC7C;AACA,MAAI,OAAO,oBAAoB,UAAU;AACvC,WAAO;AAAA,MACL;AAAA;AAAA,QAEE,QAAQ;AAAA,MACV;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA,oBAAqB,OAAO,eAAgB;AAAA,EAC9C;AACF;AAgCO,IAAM,OAAO,CAAwB,OAAiC;AAC3E,SAAO,SAAS,EAAE,EAAE,WAAW;AACjC;AAQO,IAAM,kBAAkB,CAC7B,OACwC;AAExC,uBAAqB,EAAE;AAEvB,QAAM,QAAQ,GAAG,QAAS,GAAG,KAAM;AAEnC,MAAI,MAAM,WAAW,KAAK,MAAO,CAAE,EAAE,UAAU;AAAM,WAAO,CAAC;AAC7D,SAAO;AACT;AASO,IAAM,WAAW,CACtB,OACgC;AAChC,QAAM,UAAU,gBAAgB,EAAE;AAClC,SAAO,QAAQ,IAAI,CAAC,MAAM,EAAE,KAAK;AACnC;AAEO,IAAM,mBAAmB,CAC9B,YAKmD;AACnD,QAAM,wBAAwB,CAC5B,WACqC;AAErC,QAAI,WAAW;AAAM,aAAO,EAAE,OAAO,KAAK;AAE1C,QAAI,OAAO,WAAW,UAAU;AAC9B,aAAO;AAAA,QACL,OAAO;AAAA,MACT;AAAA,IACF,WAAW,OAAO,WAAW,YAAY,WAAW,QAAQ;AAC1D,YAAM,cAAc,OAAO;AAC3B,UAAI,OAAO,gBAAgB,UAAU;AACnC,cAAM,IAAI;AAAA,UACR,8CAA+C,OAAO,WAAY;AAAA,QACpE;AAAA,MACF;AACA,UAAI,mBAAmB,QAAQ;AAC7B,eAAO;AAAA,UACL,OAAO;AAAA,UACP,eAAe,OAAO;AAAA,QACxB;AAAA,MACF;AACA,aAAO,EAAE,OAAO,YAAY;AAAA,IAC9B,OAAO;AACL,YAAM,IAAI;AAAA,QACR,oBAAqB,OAAO,MAAO;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAGA,MAAI,MAAM,QAAQ,OAAO,GAAG;AAE1B,QAAI,eAAe;AACnB,UAAM,aAAa,QAAQ,IAAI,CAAC,MAAM;AACpC,YAAM,IAAI,sBAAsB,CAAC;AACjC,UAAI,CAAC;AAAG,cAAM,IAAI,MAAM,gBAAgB;AACxC,qBAAe,gBAAgB,EAAE,UAAU;AAC3C,aAAO;AAAA,IACT,CAAC;AACD,QAAI,gBAAgB,WAAW,SAAS,GAAG;AACzC,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AACA,WAAO;AAAA,EACT,OAAO;AACL,UAAM,SAAS,sBAAsB,OAAO;AAC5C,QAAI,CAAC;AAAQ;AACb,WAAO,CAAE,MAAO;AAAA,EAClB;AACF;AAEA,IAAM,kCAAkC,CACtC,MACgE;AAChE,QAAM,YAAY,oBAAI,IAAgD;AAGtE,aAAW,CAAE,eAAe,eAAgB,KAAK,OAAO,QAAQ,CAAC,GAAG;AAClE,QAAI,OAAO,kBAAkB,aAAa;AACxC,YAAM,IAAI,UAAU,2BAA2B;AAAA,IACjD;AACA,QAAI,OAAO,oBAAoB,aAAa;AAC1C,YAAM,IAAI,UAAU,8BAA+B,aAAc,EAAE;AAAA,IACrE;AACA,QAAI,UAAU,IAAI,aAAa,GAAG;AAChC,YAAM,IAAI,MAAM,wBAAyB,aAAc,EAAE;AAAA,IAC3D;AACA,QAAI,cAAc,SAAS,GAAG,GAAG;AAC/B,YAAM,IAAI,MAAM,mCAAmC;AAAA,IACrD;AACA,cAAU,IAAI,eAAe,CAAC,CAAC;AAAA,EACjC;AAGA,aAAW,CAAE,eAAe,eAAgB,KAAK,OAAO,QAAQ,CAAC,GAAG;AAClE,UAAM,UAAU,iBAAiB,eAAe;AAChD,QAAI,YAAY;AAAW,YAAM,IAAI,MAAM,4BAA4B;AACvE,QAAI,YAAY,MAAM;AAEpB,YAAM,aAAa,oBAAI,IAAI;AAC3B,iBAAW,UAAU,SAAS;AAC5B,YAAI,WAAW,IAAI,OAAO,KAAK,GAAG;AAChC,gBAAM,IAAI;AAAA,YACR,iBAAkB,OAAO,KAAM,yBAA0B,aAAc;AAAA,UACzE;AAAA,QACF;AACA,mBAAW,IAAI,OAAO,KAAK;AAC3B,YAAI,OAAO,UAAU;AAAM;AAC3B,YAAI,CAAC,UAAU,IAAI,OAAO,KAAK,GAAG;AAChC,gBAAM,IAAI;AAAA,YACR,iBAAkB,OAAO,KAAM,0DAA2D,aAAc;AAAA,UAC1G;AAAA,QACF;AAAA,MACF;AACA,gBAAU,IAAI,eAAe,OAAO;AAAA,IACtC;AAAA,EACF;AACA,SAAO;AACT;AAQA,IAAM,uBAAuB,CAC3B,UACS;AACT,MAAI,UAAU,QAAW;AACvB,UAAM,IAAI,UAAU,gCAAgC;AAAA,EACtD;AACA,MAAI,OAAO,MAAM,UAAU,UAAU;AACnC,UAAM,IAAI,UAAU,gCAAgC;AAAA,EACtD;AACF;AAUO,IAAM,KAAK,CAChB,IACA,YACoB;AACpB,uBAAqB,EAAE;AACvB,qBAAmB,IAAI,OAAO;AAC9B,SAAO,OAAO,OAAO;AAAA,IACnB,OAAO;AAAA,IACP,SAAS,GAAG;AAAA,IACZ,SAAS,OAAe,CAAE,GAAG,SAA0B,CAAE,GAAG,KAAM,CAAmB,CAAC;AAAA,EACxF,CAAC;AACH;AAEO,IAAM,OAAO,CAClB,OACoB;AAEpB,QAAM,QAAQ,gBAAgB,EAAE,EAAE,GAAG,CAAC;AAEtC,MAAI,CAAC,SAAS,MAAM,UAAU,MAAM;AAClC,UAAM,IAAI;AAAA,MACR,8CAA+C,GAAG,KAAM;AAAA,IAC1D;AAAA,EACF;AACA,SAAO,GAAG,IAAI,MAAM,KAAK;AAC3B;AAQO,IAAM,oBAAoB,CAC/B,IACA,YACY;AACZ,MAAI;AACF,uBAAmB,IAAI,OAAO;AAC9B,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAEO,IAAM,qBAAqB,CAChC,IACA,YACS;AACT,MAAI,YAAY;AAAM,UAAM,IAAI,MAAM,iCAAiC;AACvE,MAAI,YAAY,QAAW;AACzB,UAAM,IAAI,MAAM,sCAAsC;AAAA,EACxD;AACA,MAAI,OAAO,YAAY,UAAU;AAC/B,UAAM,IAAI;AAAA,MACR,gDAAiD,OAAO,OAAQ;AAAA,IAClE;AAAA,EACF;AAKA,QAAM,IAAI,SAAS,EAAE;AACrB,MAAI,EAAE,WAAW;AAAG,UAAM,IAAI,MAAM,8BAA8B;AAClE,MAAI,CAAC,EAAE,SAAS,OAAO,GAAG;AACxB,UAAM,IAAI;AAAA,MACR,iBAAkB,OAAQ,qCAAsC,GAAG,KACnE,uBAAwB,EAAE,KAAK,IAAI,CAAE;AAAA,IACvC;AAAA,EACF;AACF;AAmBO,IAAM,WAAW,IAAI,WAA+C;AACzE,QAAM,IAAI,CAAC;AACX,MAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,UAAM,IAAI,MAAM,2BAA2B;AACvE,MAAI,OAAO,UAAU;AAAG,UAAM,IAAI,MAAM,6BAA6B;AACrE,WAAS,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;AAClD,UAAM,IAAI,OAAQ,KAAM;AACxB,QAAI,OAAO,MAAM,UAAU;AACzB,YAAM,IAAI;AAAA,QACR,wCAAyC,OAAO,CAAE,cAAe,KAAM;AAAA,MACzE;AAAA,IACF;AAEA,MAAG,CAAE,IAAI,UAAU,OAAO,SAAS,IAAI,OAAO,OAAQ,QAAQ,CAAE;AAAA,EAClE;AACA,SAAO;AACT;AAmBO,IAAM,wBAAwB,IAChC,WACa;AAChB,QAAM,IAAI,CAAC;AACX,MAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,UAAM,IAAI,MAAM,2BAA2B;AACvE,MAAI,OAAO,SAAS;AAAG,UAAM,IAAI,MAAM,6BAA6B;AAEpE,aAAW,CAAE,OAAO,CAAE,KAAK,OAAO,QAAQ,GAAG;AAC3C,QAAI,OAAO,MAAM,UAAU;AACzB,YAAM,IAAI;AAAA,QACR,wCAAyC,OAAO,CAAE,cAAe,KAAM;AAAA,MACzE;AAAA,IACF;AAIA,MAAG,CAAE,IAAI,CAAC;AAAA,EACZ;AAEA,WAAS,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;AAElD,UAAM,IAAI,EAAG,OAAQ,KAAM,CAAE;AAC7B,QAAI,UAAU,OAAO,SAAS,GAAG;AAC/B,UAAI,OAAO,SAAS,GAAG;AAErB,UAAE,KAAK,OAAQ,QAAQ,CAAE,CAAC;AAAA,MAC5B,OAAO;AAGL,UAAG,OAAQ,KAAM,CAAE,IAAI;AAAA,MACzB;AAAA,IACF,OAAO;AAEL,QAAE,KAAK,OAAQ,QAAQ,CAAE,CAAC;AAE1B,UAAI,QAAQ;AAAG,UAAE,KAAK,OAAQ,QAAQ,CAAE,CAAC;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;","names":["init","init","run","interval","interval","once","interval","interval","interval","reset","interval","done","timeout","run"]}