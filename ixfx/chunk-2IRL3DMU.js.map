{"version":3,"sources":["../src/collections/queue/QueueFns.ts","../src/collections/queue/QueueMutable.ts"],"sourcesContent":["import type { QueueOpts } from './QueueTypes.js';\n\nexport const debug = (opts: QueueOpts<any>, message: string): void => {\n  opts.debug ? console.log(`queue:${ message }`) : undefined;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`: {\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [ ...queue, ...toAdd.slice(0, toRemove - 1) ];\n      }\n    }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`: {\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return [ ...toAdd.slice(0, capacity - 1), toAdd.at(-1)! ];\n        }\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        //return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [ ...toKeep, ...toAddFinal ];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`: {\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [ ...queue, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown overflow policy ${ policy }`);\n    }\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [ ...queue, ...toAdd ];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${ toReturn.length\n      } capacity: ${ opts.capacity } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${ toReturn.length\n      } expected: ${ potentialLength } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[ 0 ];\n\nexport const isEmpty = <V>(opts: QueueOpts<V>, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import { type IQueueMutable, type IQueueMutableWithEvents, type QueueMutableEvents } from './IQueueMutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './QueueFns.js';\nimport { type QueueOpts } from './QueueTypes.js';\nimport { isEqualDefault, type IsEqual } from '../../util/IsEqual.js';\nimport { SimpleEventEmitter } from '../../Events.js';\n\n/**\n * Mutable queue that fires events when manipulated.\n * \n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n * \n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n * \n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @template V Data type of items\n * @param opts\n * @param startingItems Items are added in array order. So first item will be at the front of the queue.\n */\nexport class QueueMutable<V> extends SimpleEventEmitter<QueueMutableEvents<V>> implements IQueueMutable<V> {\n  readonly opts: QueueOpts<V>;\n  data: ReadonlyArray<V>;\n  eq: IsEqual<V>;\n\n  constructor(opts: QueueOpts<V> = {}, data: ReadonlyArray<V> = []) {\n    super();\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.opts = opts;\n    this.data = data;\n    this.eq = opts.eq ?? isEqualDefault;\n  }\n\n  clear() {\n    const copy = [ ...this.data ];\n    this.data = [];\n    this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n    this.onClear();\n  }\n\n  /**\n   * Called when all data is cleared\n   */\n  protected onClear() { /** no-op */\n  }\n\n  at(index: number): V {\n    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);\n    const v = this.data.at(index);\n    if (v === undefined) throw new Error(`Index appears to be outside range of queue`);\n    return v;\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): number {\n    this.data = enqueue(this.opts, this.data, ...toAdd);\n    const length = this.data.length;\n    this.onEnqueue(this.data, toAdd);\n    return length;\n  }\n\n  protected onEnqueue(result: ReadonlyArray<V>, attemptedToAdd: ReadonlyArray<V>) {\n    this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.opts, this.data);\n    if (v === undefined) return;\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.opts, this.data);\n    this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n    this.onRemoved([ v ], this.data);\n    return v;\n  }\n\n  protected onRemoved(removed: ReadonlyArray<V>, finalData: ReadonlyArray<V>) {\n    this.fireEvent(`removed`, { removed, finalData });\n  }\n\n  /**\n   * Removes values that match `predicate`.\n   * @param predicate \n   * @returns Returns number of items removed.\n   */\n  removeWhere(predicate: (item: V) => boolean): number {\n    const countPre = this.data.length;\n    const toRemove = this.data.filter(v => predicate(v));\n    if (toRemove.length === 0) return 0;\n    this.data = this.data.filter((element) => !predicate(element));\n    this.onRemoved(toRemove, this.data);\n    return countPre - this.data.length;\n  }\n\n  /**\n * Return a copy of the array\n * @returns \n */\n  toArray(): Array<V> {\n    return [ ...this.data ];\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\n/**\n * Creates a new QueueMutable\n * @param opts \n * @param startingItems \n * @returns \n */\nexport function mutable<V>(\n  opts: QueueOpts<V> = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueMutableWithEvents<V> {\n  return new QueueMutable({ ...opts }, [ ...startingItems ]);\n}\n\n"],"mappings":"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","names":[]}