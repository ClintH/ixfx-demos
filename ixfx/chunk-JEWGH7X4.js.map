{"version":3,"sources":["../src/modulation/index.ts","../src/modulation/Envelope.ts","../src/modulation/Forces.ts","../src/modulation/Oscillator.ts","../src/modulation/sources/Ticks.ts","../src/modulation/sources/index.ts","../src/modulation/sources/Time.ts","../src/modulation/sources/PerSecond.ts","../src/modulation/Waveforms.ts"],"sourcesContent":["import * as Easings from './Easing.js';\nimport * as Envelopes from './Envelope.js';\nimport * as Forces from './Forces.js';\nimport * as Oscillators from './Oscillator.js';\nexport * from './PingPong.js';\nexport * from './Waveforms.js';\nexport * as Sources from './sources/index.js';\nexport type * from './Types.js';\n\n/**\n * Easings module\n *\n * [See the guide](https://clinth.github.io/ixfx-docs/modulation/easing/)\n *\n * Overview:\n * * {@link Easings.time}: Ease by time\n * * {@link Easings.tick}: Ease by tick\n * * {@link Easings.get}: Get an easing function by name\n * * {@link Easings.crossfade}: Mix two synchronised easing functions (a slight shortcut over `mix`)\n * * {@link Easings.mix}: Mix two easing functions\n * * {@link Easings.gaussian}: Gaussian distribution (rough bell curve)\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import { Easings } from '../../ixfx/dist/modulation.js';\n * Easings.time(...);\n *\n * // Import from web\n * import { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * Easings.time(...);\n * ```\n */\n\n\n/**\n * Envelopes\n */\nexport * from './Envelope.js';\n\nexport * as Envelopes from './Envelope.js';\n\n/**\n * Forces module can help to compute basic physical forces like gravity, friction, springs etc.\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import { Forces } from '../../ixfx/dist/modulation.js';\n * Forces.attractionForce(...);\n *\n * // Import from web\n * import { Forces } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * Forces.attractionForce(...);\n * ```\n *\n */\n\n\n/**\n * Oscillators module has waveshapes for producing values with a specified frequency.\n *\n * Overview\n * * {@link Oscillators.saw}: 'Sawtooth' wave\n * * {@link Oscillators.sine}: Sine wave\n * * {@link Oscillators.sineBipolar}: Sine wave with range of -1 to 1\n * * {@link Oscillators.square}: Square wave\n * * {@link Oscillators.triangle}: Triangle wave\n * * {@link Oscillators.spring}: Spring oscillator\n *\n * @example On-demand sampling\n * ```js\n * // Saw wave with frequency of 0.10hZ\n * const osc = Oscillators.saw(0.1);\n *\n * // Whever we need to sample from the oscillator...\n * const v = osc.next().value;\n * ```\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import { Oscillators } from '../../ixfx/dist/modulation.js';\n * Oscillators.saw(...);\n *\n * // Import from web\n * import { Oscillators } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * Oscillators.saw(...);\n * ```\n *\n */\n\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Modulation: { Forces, Envelopes, Oscillators, Easings },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\nexport { type Jitterer, type JitterOpts, jitter, jitterAbsolute } from './Jitter.js';\nexport * as Easings from './Easing.js';\nexport * as Forces from './Forces.js';\nexport * as Oscillators from './Oscillator.js';","import { SimpleEventEmitter } from '../Events.js';\nimport { msElapsedTimer, type TimerSource } from '../flow/index.js';\nimport { type Timer } from '../flow/Timer.js';\nimport type { Path } from '../geometry/path/index.js';\nimport * as Bezier from '../geometry/bezier/index.js';\nimport { scale } from '../data/Scale.js';\nimport { interval } from '../flow/Interval.js';\nimport { StateMachineWithEvents } from '../flow/StateMachineWithEvents.js';\n\n/**\n * @returns Returns a full set of default ADSR options\n */\nexport const defaultAdsrOpts = (): EnvelopeOpts => ({\n  attackBend: -1,\n  decayBend: -0.3,\n  releaseBend: -0.3,\n  peakLevel: 1,\n  initialLevel: 0,\n  sustainLevel: 0.6,\n  releaseLevel: 0,\n  attackDuration: 600,\n  decayDuration: 200,\n  releaseDuration: 800,\n  shouldLoop: false,\n});\n\nexport type EnvelopeOpts = AdsrOpts & AdsrTimingOpts;\n/**\n * Options for the ADSR envelope.\n *\n * Use {@link defaultAdsrOpts} to get an initial default:\n * @example\n * ```js\n * let env = adsr({\n *  ...defaultAdsrOpts(),\n *  attackDuration: 2000,\n *  releaseDuration: 5000,\n *  sustainLevel: 1,\n *  retrigger: false\n * });\n * ```\n */\nexport type AdsrOpts = {\n  /**\n   * Attack bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly attackBend?: number;\n  /**\n   * Decay bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly decayBend?: number;\n  /**\n   * Release bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly releaseBend?: number;\n\n  /**\n   * Peak level (maximum of attack stage)\n   */\n  readonly peakLevel?: number;\n\n  /**\n   * Starting level (usually 0)\n   */\n  readonly initialLevel?: number;\n  /**\n   * Sustain level. Only valid if trigger and hold happens\n   */\n  readonly sustainLevel?: number;\n  /**\n   * Release level, when envelope is done (usually 0)\n   */\n  readonly releaseLevel?: number;\n\n  /**\n   * When _false_, envelope starts from it's current level when being triggered.\n   * _True_ by default.\n   */\n  readonly retrigger?: boolean;\n};\n\nexport type AdsrTimingOpts = {\n  /**\n   * If true, envelope indefinately returns to attack stage after release\n   *\n   * @type {boolean}\n   */\n  readonly shouldLoop?: boolean;\n\n  /**\n   * Duration for attack stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly attackDuration?: number;\n  /**\n   * Duration for decay stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly decayDuration?: number;\n  /**\n   * Duration for release stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly releaseDuration?: number;\n};\n\n/**\n * State change event\n */\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface StateChangeEvent {\n  readonly newState: string;\n  readonly priorState: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface CompleteEvent {\n  /* no-op */\n}\n\nexport type Events = {\n  readonly change: StateChangeEvent;\n  readonly complete: CompleteEvent;\n};\n\nconst adsrTransitionsInstance = Object.freeze({\n  attack: [ `decay`, `release` ],\n  decay: [ `sustain`, `release` ],\n  sustain: [ `release` ],\n  release: [ `complete` ],\n  //eslint-disable-next-line unicorn/no-null\n  complete: null,\n});\ntype AdsrStateTransitions = Readonly<typeof adsrTransitionsInstance>;\n\nclass AdsrBase extends SimpleEventEmitter<Events> {\n  readonly #sm: StateMachineWithEvents<AdsrStateTransitions>;\n  readonly #timeSource: TimerSource;\n  #timer: Timer | undefined;\n\n  #holding: boolean;\n  #holdingInitial: boolean;\n\n  attackDuration: number;\n  decayDuration: number;\n  releaseDuration: number;\n  decayDurationTotal: number;\n  shouldLoop: boolean;\n\n  constructor(opts: AdsrTimingOpts) {\n    super();\n\n    this.attackDuration = opts.attackDuration ?? 300;\n    this.decayDuration = opts.decayDuration ?? 500;\n    this.releaseDuration = opts.releaseDuration ?? 1000;\n    this.shouldLoop = opts.shouldLoop ?? false;\n\n    this.#sm = new StateMachineWithEvents<AdsrStateTransitions>(\n      adsrTransitionsInstance,\n      { initial: `attack` }\n    );\n\n    this.#sm.addEventListener(`change`, (event) => {\n      // Reset timer on release\n      if (event.newState === `release` && this.#holdingInitial) {\n        this.#timer?.reset();\n      }\n      super.fireEvent(`change`, event);\n    });\n    this.#sm.addEventListener(`stop`, (event) => {\n      super.fireEvent(`complete`, event);\n    });\n\n    this.#timeSource = msElapsedTimer;\n    this.#holding = this.#holdingInitial = false;\n\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\n  }\n\n  protected switchState(): boolean {\n    if (this.#timer === undefined) return false;\n    // eslint-disable-next-line functional/no-let\n    let elapsed = this.#timer.elapsed;\n    const wasHeld = this.#holdingInitial && !this.#holding;\n\n    // Change through states for as long as needed\n    // eslint-disable-next-line functional/no-let\n    let hasChanged = false;\n    do {\n      hasChanged = false;\n      switch (this.#sm.state) {\n        case `attack`: {\n          if (elapsed > this.attackDuration || wasHeld) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `decay`: {\n          if (elapsed > this.decayDurationTotal || wasHeld) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `sustain`: {\n          if (!this.#holding || wasHeld) {\n            elapsed = 0;\n            this.#sm.next();\n            this.#timer.reset();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `release`: {\n          if (elapsed > this.releaseDuration) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `complete`: {\n          if (this.shouldLoop) {\n            this.trigger(this.#holdingInitial);\n          }\n        }\n      }\n    } while (hasChanged);\n    return hasChanged;\n  }\n\n  /**\n   * Computes a stage progress from 0-1\n   * @param allowStateChange\n   * @returns\n   */\n  protected computeRaw(\n    allowStateChange = true\n  ): [ stage: string | undefined, amount: number, prevStage: string ] {\n    if (this.#timer === undefined) return [ undefined, 0, this.#sm.state ];\n\n    // Change state if necessary based on elapsed time\n    if (allowStateChange) this.switchState();\n\n    const previousStage = this.#sm.state;\n\n    const elapsed = this.#timer.elapsed;\n    // eslint-disable-next-line functional/no-let\n    let relative = 0;\n    const state = this.#sm.state;\n    switch (state) {\n      case `attack`: {\n        relative = elapsed / this.attackDuration;\n        break;\n      }\n      case `decay`: {\n        relative = (elapsed - this.attackDuration) / this.decayDuration;\n        break;\n      }\n      case `sustain`: {\n        relative = 1;\n        break;\n      }\n      case `release`: {\n        relative = Math.min(elapsed / this.releaseDuration, 1);\n        break;\n      }\n      case `complete`: {\n        return [ undefined, 1, previousStage ];\n      }\n      default: {\n        throw new Error(`State machine in unknown state: ${ state }`);\n      }\n    }\n    return [ state, relative, previousStage ];\n  }\n\n  get isDone(): boolean {\n    return this.#sm.isDone;\n  }\n\n  onTrigger(): void {\n    /* no op */\n  }\n\n  trigger(hold = false) {\n    this.onTrigger();\n\n    this.#sm.reset();\n    this.#timer = this.#timeSource();\n    this.#holding = hold;\n    this.#holdingInitial = hold;\n  }\n\n  compute(): void {\n    /* no-op */\n  }\n\n  release() {\n    if (this.isDone || !this.#holdingInitial) return; // Was never holding or done\n\n    // Setting holding flag to false, computeRaw will change state\n    this.#holding = false;\n    this.compute();\n  }\n}\n\n/**\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\n * usually in response to an intial trigger.\n *\n * Created with the {@link adsr} function. [See the ixfx Guide on Envelopes](https://clinth.github.io/ixfx-docs/modulation/envelope/).\n *\n * @example Setup\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * const opts = {\n *  ...Envelopes.defaultAdsrOpts(),\n *  attackDuration: 1000,\n *  decayDuration: 200,\n *  sustainDuration: 100\n * }\n * const env = Envelopes.adsr(opts);\n * ```\n *\n * [Options for envelope](https://clinth.github.io/ixfx/types/Modulation.Envelopes.AdsrOpts.html) are as follows:\n *\n * ```js\n * initialLevel?: number\n * attackBend: number\n * attackDuration: number\n * decayBend: number\n * decayDuration:number\n * sustainLevel: number\n * releaseBend: number\n * releaseDuration: number\n * releaseLevel?: number\n * peakLevel: number\n * retrigger?: boolean\n * shouldLoop: boolean\n * ```\n *\n * If `retrigger` is false, re-triggers will continue at current level\n * rather than resetting to `initialLevel`.\n *\n * If `shouldLoop` is true, envelope loops until `release()` is called.\n *\n * @example Using\n * ```js\n * env.trigger(); // Start envelope\n * ...\n * // Get current value of envelope\n * const [state, scaled, raw] = env.compute();\n * ```\n *\n * * `state` is a string, one of the following: 'attack', 'decay', 'sustain', 'release', 'complete'\n * * `scaled` is a value scaled according to the stage's _levels_\n * * `raw` is the progress from 0 to 1 within a stage. ie. 0.5 means we're halfway through a stage.\n *\n * Instead of `compute()`, most usage of the envelope is just fetching the `value` property, which returns the same scaled value of `compute()`:\n *\n * ```js\n * const value = env.value; // Get scaled number\n * ```\n *\n * @example Hold & release\n * ```js\n * env.trigger(true);   // Pass in true to hold\n * ...envelope will stop at sustain stage...\n * env.release();      // Release into decay\n * ```\n *\n * Check if it's done:\n *\n * ```js\n * env.isDone; // True if envelope is completed\n * ```\n *\n * Envelope has events to track activity: 'change' and 'complete':\n *\n * ```\n * env.addEventListener(`change`, ev => {\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\n * })\n * ```\n */\nexport interface Adsr extends SimpleEventEmitter<Events> {\n  /**\n   * Compute value of envelope at this point in time.\n   *\n   * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\n   * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\n   */\n  compute(\n    allowStateChange?: boolean\n  ): readonly [ stage: string | undefined, scaled: number, raw: number ];\n\n  /**\n   * Returns the scaled value\n   * Same as .compute()[1]\n   */\n  get value(): number;\n  /**\n   * Releases a held envelope. Has no effect if envelope was not held or is complete.\n   */\n  release(): void;\n  /**\n   * Triggers envelope.\n   *\n   * If event is already trigged,\n   * it will be _retriggered_. If`opts.retriggered` is false (default)\n   * envelope starts again at `opts.initialValue`. Otherwise it starts at\n   * the current value.\n   *\n   * @param hold If _true_ envelope will hold at sustain stage\n   */\n  trigger(hold?: boolean): void;\n  /**\n   * _True_ if envelope is completed\n   */\n  get isDone(): boolean;\n}\n\nclass AdsrImpl extends AdsrBase implements Adsr {\n  readonly attackPath: Path;\n  readonly decayPath: Path;\n  readonly releasePath: Path;\n\n  readonly initialLevel;\n  readonly peakLevel;\n  readonly releaseLevel;\n  readonly sustainLevel;\n\n  readonly attackBend;\n  readonly decayBend;\n  readonly releaseBend;\n\n  protected initialLevelOverride: number | undefined;\n  readonly retrigger: boolean;\n  private releasedAt: number | undefined;\n\n  constructor(opts: EnvelopeOpts) {\n    super(opts);\n    this.initialLevel = opts.initialLevel ?? 0;\n    this.peakLevel = opts.peakLevel ?? 1;\n    this.releaseLevel = opts.releaseLevel ?? 0;\n    this.sustainLevel = opts.sustainLevel ?? 0.75;\n    this.retrigger = opts.retrigger ?? true;\n\n    this.attackBend = opts.attackBend ?? 0;\n    this.releaseBend = opts.releaseBend ?? 0;\n    this.decayBend = opts.decayBend ?? 0;\n\n    const max = 1;\n    this.attackPath = Bezier.toPath(\n      Bezier.quadraticSimple(\n        { x: 0, y: this.initialLevel },\n        { x: max, y: this.peakLevel },\n        -this.attackBend\n      )\n    );\n    this.decayPath = Bezier.toPath(\n      Bezier.quadraticSimple(\n        { x: 0, y: this.peakLevel },\n        { x: max, y: this.sustainLevel },\n        -this.decayBend\n      )\n    );\n    this.releasePath = Bezier.toPath(\n      Bezier.quadraticSimple(\n        { x: 0, y: this.sustainLevel },\n        { x: max, y: this.releaseLevel },\n        -this.releaseBend\n      )\n    );\n  }\n\n  onTrigger() {\n    this.initialLevelOverride = undefined;\n    if (!this.retrigger) {\n      const [ _stage, scaled, _raw ] = this.compute();\n      if (!Number.isNaN(scaled) && scaled > 0) {\n        this.initialLevelOverride = scaled;\n      }\n    }\n  }\n\n  get value(): number {\n    return this.compute(true)[ 1 ];\n  }\n\n  compute(\n    allowStateChange = true\n  ): [ stage: string | undefined, scaled: number, raw: number ] {\n    const [ stage, amt ] = super.computeRaw(allowStateChange);\n    if (stage === undefined) return [ undefined, Number.NaN, Number.NaN ];\n    // eslint-disable-next-line functional/no-let\n    let v;\n    switch (stage) {\n      case `attack`: {\n        v = this.attackPath.interpolate(amt).y;\n        if (this.initialLevelOverride !== undefined) {\n          v = scale(v, 0, 1, this.initialLevelOverride, 1);\n        }\n        this.releasedAt = v;\n        break;\n      }\n      case `decay`: {\n        v = this.decayPath.interpolate(amt).y;\n        this.releasedAt = v;\n        break;\n      }\n      case `sustain`: {\n        v = this.sustainLevel;\n        this.releasedAt = v;\n        break;\n      }\n      case `release`: {\n        v = this.releasePath.interpolate(amt).y;\n        // Bound release level to the amp level that we released at.\n        // ie. when release happens before a stage completes\n        if (this.releasedAt !== undefined) {\n          v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\n        }\n        break;\n      }\n      case `complete`: {\n        v = this.releaseLevel;\n        this.releasedAt = undefined;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown state: ${ stage }`);\n      }\n    }\n    return [ stage, v, amt ];\n  }\n}\n\n/**\n * Creates an {@link Adsr} envelope.\n * \n * ```js\n * const opts = {\n *  ...Envelopes.defaultAdsrOpts(),\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * const env = Envelopes.adsr(opts);\n * ```\n * \n * See {@link Adsr} for more.\n * @param opts\n * @returns New {@link Adsr} Envelope\n */\nexport const adsr = (opts: EnvelopeOpts): Adsr => new AdsrImpl(opts);\n\n/**\n * Creates and runs an envelope, sampling its values at `sampleRateMs`.\n * Note that if the envelope loops, iterator never returns.\n *\n * @example Init\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * import { IterableAsync } from  'https://unpkg.com/ixfx/dist/util.js';\n *\n * const opts = {\n *  ...Envelopes.defaultAdsrOpts(),\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * ```\n *\n * ```js\n * //  Add data to array\n * // Sample an envelope every 20ms into an array\n * const data = await IterableAsync.toArray(Envelopes.adsrIterable(opts, 20));\n * ```\n *\n * ```js\n * // Iterate with `for await`\n * // Work with values as sampled\n * for await (const v of Envelopes.adsrIterable(opts, 5)) {\n *  // Work with envelope value `v`...\n * }\n * ```\n * @param opts Envelope options\n * @returns\n */\nexport async function* adsrIterable(\n  opts: AdsrIterableOpts\n): AsyncGenerator<number> {\n  const envelope = adsr(opts.env);\n  const sampleRateMs = opts.sampleRateMs ?? 100;\n  envelope.trigger();\n\n  for await (const v of interval<number>(\n    () => {\n      if (envelope.isDone) return;\n      return envelope.value;\n    },\n    {\n      fixed: sampleRateMs,\n      signal: opts.signal,\n    }\n  )) {\n    yield v;\n  }\n}\n\nexport type AdsrIterableOpts = {\n  readonly signal?: AbortSignal;\n  readonly sampleRateMs?: number;\n  readonly env: EnvelopeOpts;\n};\n\n// const iterableSwap = <V>() => {\n//   let current:AsyncIterableIterator<V>|IterableIterator<V>|undefined;\n\n//   const set = (it:AsyncIterableIterator<V>|IterableIterator<V>) => {\n//     current = it;\n//   }\n\n//   return {\n//     set,\n//     [Symbol.asyncIterator]() {\n//       return {\n//         async next() {\n//           if (!current) return { done: true, value: undefined};\n//           const v = await current.next();\n//           return { value: v.value, done: v.done };\n//         }\n//       };\n//     }}\n// }\n\n// export type IterableDrainOpts =  {\n//   minIntervalMs?:number\n// }\n// const iterableDrain = <V>(opts:IterableDrainOpts = {}) => {\n//   const minIntervalMs = opts.minIntervalMs ?? 0;\n\n//   const swap = iterableSwap<V>();\n//   const timer = continuously(() => {\n\n//   }, )\n//   const set = (it:AsyncIterableIterator<V>|IterableIterator<V>) => {\n//     swap.set(it);\n//   }\n\n// }\n\n// const delayedCount = delayIterable(count(5), { intervalMs: 500, delay: 'both'});\n// const i = interval(delayedCount, { minIntervalMs: 1500, delay: 'after'});\n// for await (const v of i) {\n//   console.log(v);\n// }\n// console.log('x test');\n// const xx = iterableSwap();\n\n// setInterval(async () => {\n//   for await (const v of xx) {\n//     console.log(`v: ${v}`);\n//   }\n//   console.log(`For await done`);\n// }, 1000);\n\n// xx.set(count(10, 1));\n// setTimeout(() => {\n//   xx.set(count(20, 2000));\n// }, 2000);\n","/**\n * Acknowledgements: much of the work here is an adapation from Daniel Shiffman's excellent _The Nature of Code_ website.\n */\nimport { Points, Polar } from '../geometry/index.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport { clamp } from '../data/Clamp.js';\nimport { interpolateAngle } from '../data/Interpolate.js';\nimport { getEdgeX, getEdgeY, type Rect } from '../geometry/rect/index.js';\nimport { divide as PointDivide } from '../geometry/point/Divider.js';\n\n/**\n * Logic for applying mass\n */\nexport type MassApplication = `dampen` | `multiply` | `ignored`;\n\n/**\n * Basic properties of a thing that can be\n * affected by forces\n */\nexport type ForceAffected = {\n  /**\n   * Position. Probably best to use relative coordinates\n   */\n  readonly position?: Point;\n  /**\n   * Velocity vector.\n   * Probably don't want to assign this yourself, but rather have it computed based on acceleration and applied forces\n   */\n  readonly velocity?: Point;\n  /**\n   * Acceleration vector. Most applied forces will alter the acceleration, culminating in a new velocity being set and the\n   * acceleraton value zeroed\n   */\n  readonly acceleration?: Point;\n  /**\n   * Mass. The unit is undefined, again best to think of this being on a 0..1 scale. Mass is particularly important\n   * for the attraction/repulsion force, but other forces can incorporate mass too.\n   */\n  readonly mass?: number;\n\n  readonly angularAcceleration?: number;\n\n  readonly angularVelocity?: number;\n\n  readonly angle?: number;\n};\n\n/**\n * A function that updates values of a thing.\n *\n * These can be created using the xxxForce functions, eg {@link attractionForce}, {@link accelerationForce}, {@link magnitudeForce}, {@link velocityForce}\n */\nexport type ForceFn = (t: ForceAffected) => ForceAffected;\n\n/**\n * A vector to apply to acceleration or a force function\n */\nexport type ForceKind = Point | ForceFn | null;\n\n/**\n * Throws an error if `t` is not of the `ForceAffected` shape.\n * @param t\n * @param name\n */\nexport const guard = (t: ForceAffected, name = `t`) => {\n  if (t === undefined) {\n    throw new Error(`Parameter ${ name } is undefined. Expected ForceAffected`);\n  }\n  if (t === null) {\n    throw new Error(`Parameter ${ name } is null. Expected ForceAffected`);\n  }\n  if (typeof t !== `object`) {\n    throw new TypeError(\n      `Parameter ${ name } is type ${ typeof t }. Expected object of shape ForceAffected`\n    );\n  }\n};\n\n/**\n * `constrainBounce` yields a function that affects `t`'s position and velocity such that it\n * bounces within bounds.\n *\n * ```js\n * // Setup bounce with area constraints\n * // Reduce velocity by 10% with each impact\n * const b = constrainBounce({ width:200, height:500 }, 0.9);\n *\n * // Thing\n * const t = {\n *  position: { x: 50,  y: 50 },\n *  velocity: { x: 0.3, y: 0.01 }\n * };\n *\n * // `b` returns an altereted version of `t`, with the\n * // bounce logic applied.\n * const bounced = b(t);\n * ```\n *\n * `dampen` parameter allows velocity to be dampened with each bounce. A value\n * of 0.9 for example reduces velocity by 10%. A value of 1.1 will increase velocity by\n * 10% with each bounce.\n * @param bounds Constraints of area\n * @params dampen How much to dampen velocity by. Defaults to 1 meaning there is no damping.\n * @returns A function that can perform bounce logic\n */\nexport const constrainBounce = (\n  bounds?: Rect,\n  dampen = 1\n) => {\n  if (!bounds) bounds = { width: 1, height: 1 }\n  const minX = getEdgeX(bounds, `left`);\n  const maxX = getEdgeX(bounds, `right`);\n  const minY = getEdgeY(bounds, `top`);\n  const maxY = getEdgeY(bounds, `bottom`);\n\n  return (t: ForceAffected): ForceAffected => {\n    const position = computePositionFromVelocity(\n      t.position ?? Points.Empty,\n      t.velocity ?? Points.Empty\n    );\n\n    let velocity = t.velocity ?? Points.Empty;\n    let { x, y } = position;\n\n    if (x > maxX) {\n      x = maxX;\n      velocity = Points.invert(Points.multiply(velocity, dampen), `x`);\n    } else if (x < minX) {\n      x = minX;\n      velocity = Points.invert(Points.multiply(velocity, dampen), `x`);\n    }\n\n    if (y > maxY) {\n      y = maxY;\n      velocity = Points.multiply(Points.invert(velocity, `y`), dampen);\n    } else if (position.y < minY) {\n      y = minY;\n      velocity = Points.invert(Points.multiply(velocity, dampen), `y`);\n    }\n\n    return Object.freeze({\n      ...t,\n      position: { x, y },\n      velocity,\n    });\n  };\n};\n\n/**\n * For a given set of attractors, returns a function that a sets acceleration of attractee.\n * Keep note though that this bakes-in the values of the attractor, it won't reflect changes to their state. For dynamic\n * attractors, it might be easier to use `computeAttractionForce`.\n *\n * @example Force\n * ```js\n * const f = Forces.attractionForce(sun, gravity);\n * earth = Forces.apply(earth, f);\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n * @param attractors\n * @param gravity\n * @param distanceRange\n * @returns\n */\nexport const attractionForce =\n  (\n    attractors: ReadonlyArray<ForceAffected>,\n    gravity: number,\n    distanceRange: { readonly min?: number; readonly max?: number } = {}\n  ) =>\n    (attractee: ForceAffected): ForceAffected => {\n      let accel = attractee.acceleration ?? Points.Empty;\n      for (const a of attractors) {\n        if (a === attractee) continue;\n\n        const f = computeAttractionForce(a, attractee, gravity, distanceRange);\n        accel = Points.sum(accel, f);\n      }\n      return {\n        ...attractee,\n        acceleration: accel,\n      };\n    };\n\n/**\n * Computes the attraction force between two things.\n * Value for `gravity` will depend on what range is used for `mass`. It's probably a good idea\n * to keep mass to mean something relative - ie 1 is 'full' mass, and adjust the `gravity`\n * value until it behaves as you like. Keeping mass in 0..1 range makes it easier to apply to\n * visual properties later.\n *\n * @example Attractee and attractor, gravity 0.005\n * ```js\n * const attractor = { position: { x:0.5, y:0.5 }, mass: 1 };\n * const attractee = { position: Points.random(), mass: 0.01 };\n * attractee = Forces.apply(attractee, Forces.computeAttractionForce(attractor, attractee, 0.005));\n * ```\n *\n * @example Many attractees for one attractor, gravity 0.005\n * ```js\n * attractor =  { position: { x:0.5, y:0.5 }, mass: 1 };\n * attractees = attractees.map(a => Forces.apply(a, Forces.computeAttractionForce(attractor, a, 0.005)));\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n *\n * `attractor` thing attracting (eg, earth)\n * `attractee` thing being attracted (eg. satellite)\n *\n *\n * `gravity` will have to be tweaked to taste.\n * `distanceRange` clamps the computed distance. This affects how tightly the particles will orbit and can also determine speed. By default it is 0.001-0.7\n * @param attractor Attractor (eg earth)\n * @param attractee Attractee (eg satellite)\n * @param gravity Gravity constant\n * @param distanceRange Min/max that distance is clamped to.\n * @returns\n */\nexport const computeAttractionForce = (\n  attractor: ForceAffected,\n  attractee: ForceAffected,\n  gravity: number,\n  distanceRange: { readonly min?: number; readonly max?: number } = {}\n): Point => {\n  if (attractor.position === undefined) {\n    throw new Error(`attractor.position not set`);\n  }\n  if (attractee.position === undefined) {\n    throw new Error(`attractee.position not set`);\n  }\n\n  const distributionRangeMin = distanceRange.min ?? 0.01;\n  const distributionRangeMax = distanceRange.max ?? 0.7;\n\n  // Vector between objects\n  const f = Points.normalise(\n    Points.subtract(attractor.position, attractee.position)\n  );\n\n  // Distance\n  const d = clamp(Points.distance(f), distributionRangeMin, distributionRangeMax);\n\n  // Multiply vector by gravity, scaled by mass of things and distance\n  return Points.multiply(\n    f,\n    (gravity * (attractor.mass ?? 1) * (attractee.mass ?? 1)) / (d * d)\n  );\n};\n\nexport type TargetOpts = {\n  /**\n   * Acceleration scaling. Defaults to 0.001\n   */\n  readonly diminishBy?: number;\n  /**\n   * If distance is less than this range, don't move.\n   * If undefined (default), will try to get an exact position\n   */\n  readonly range?: Point;\n};\n/**\n * A force that moves a thing toward `targetPos`.\n *\n * ```js\n * const t = Forces.apply(t, Forces.targetForce(targetPos));\n * ```\n * @param targetPos\n * @param opts\n * @returns\n */\nexport const targetForce = (targetPos: Point, opts: TargetOpts = {}) => {\n  const fn = (t: ForceAffected): ForceAffected => {\n    const accel = computeAccelerationToTarget(\n      targetPos,\n      t.position ?? { x: 0.5, y: 0.5 },\n      opts\n    );\n    return {\n      ...t,\n      acceleration: Points.sum(t.acceleration ?? Points.Empty, accel),\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns `pt` with x and y set to `setpoint` if either's absolute value is below `v`\n * @param pt\n * @param v\n * @returns\n */\n// const roundTo = (pt: Point, v: number, setpoint: number): Point => {\n//   const x = Math.abs(pt.x);\n//   const y = Math.abs(pt.y);\n\n//   if (x < v && y < v) return { x: setpoint, y: setpoint };\n//   if (x < v) return { x: setpoint, y: pt.y };\n//   if (y < v) return { x: pt.x, y: setpoint };\n//   return pt;\n// };\n\n/**\n * Apply a series of force functions or forces to `t`. Null/undefined entries are skipped silently.\n * It also updates the velocity and position of the returned version of `t`.\n *\n * ```js\n * // Wind adds acceleration. Force is dampened by mass\n * const wind = Forces.accelerationForce({ x: 0.00001, y: 0 }, `dampen`);\n *\n * // Gravity adds acceleration. Force is magnified by mass\n * const gravity = Forces.accelerationForce({ x: 0, y: 0.0001 }, `multiply`);\n *\n * // Friction is calculated based on velocity. Force is magnified by mass\n * const friction = Forces.velocityForce(0.00001, `multiply`);\n *\n *  // Flip movement velocity if we hit a wall. And dampen it by 10%\n * const bouncer = Forces.constrainBounce({ width: 1, height: 1 }, 0.9);\n *\n * let t = {\n *  position: Points.random(),\n *  mass: 0.1\n * };\n *\n * // Apply list of forces, returning a new version of the thing\n * t = Forces.apply(t,\n *   gravity,\n *   wind,\n *   friction,\n *   bouncer\n * );\n * ```\n */\nexport const apply = (\n  t: ForceAffected,\n  ...accelForces: ReadonlyArray<ForceKind>\n): ForceAffected => {\n  if (t === undefined) throw new Error(`t parameter is undefined`);\n\n  for (const f of accelForces) {\n    if (f === null || f === undefined) continue;\n    t = typeof f === `function` ? f(t) : {\n      ...t,\n      acceleration: Points.sum(t.acceleration ?? Points.Empty, f),\n    };\n  }\n\n  // Integate velocity from acceleration\n  const velo = computeVelocity(\n    t.acceleration ?? Points.Empty,\n    t.velocity ?? Points.Empty\n  );\n\n  // Compute position\n  const pos = computePositionFromVelocity(t.position ?? Points.Empty, velo);\n\n  const ff: ForceAffected = {\n    ...t,\n    position: pos,\n    velocity: velo,\n    // Clear accel, because it has been integrated into velocity\n    acceleration: Points.Empty,\n  };\n  return ff;\n};\n\n/**\n * Apples `vector` to acceleration, scaling according to mass, based on the `mass` option.\n * It returns a function which can later be applied to a thing.\n *\n * ```js\n * import { Forces } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * // Acceleration vector of (0.1, 0), ie moving straight on horizontal axis\n * const f = Forces.accelerationForce({ x:0.1, y:0 }, `dampen`);\n *\n * // Thing to move\n * let t = { position: ..., acceleration: ... }\n *\n * // Apply force\n * t = f(t);\n * ```\n * @param vector\n * @returns Force function\n */\nexport const accelerationForce =\n  (vector: Point, mass: MassApplication = `ignored`): ForceFn =>\n    (t: ForceAffected) =>\n      Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vector, t, mass), //Points.sum(t.acceleration ?? Points.Empty, op(t.mass ?? 1))\n      });\n\n/**\n * Returns an acceleration vector with mass either dampening or multiplying it.\n * The passed-in `thing` is not modified.\n *\n * ```js\n * // Initial acceleration vector\n * const accel = { x: 0.1, y: 0};\n *\n * // Thing being moved\n * const thing = { mass: 0.5, position: ..., acceleration: ... }\n *\n * // New acceleration vector, affected by mass of `thing`\n * const accelWithMass = massApplyAccel(accel, thing, `dampen`);\n * ```\n * Mass of thing can be factored in, according to `mass` setting. Use `dampen`\n * to reduce acceleration with greater mass of thing. Use `multiply` to increase\n * the effect of acceleration with a greater mass of thing. `ignored` means\n * mass is not taken into account.\n *\n * If `t` has no mass, the `mass` setting is ignored.\n *\n * This function is used internally by the predefined forces.\n *\n * @param vector Vector force\n * @param thing Thing being affected\n * @param mass How to factor in mass of thing (default ignored)\n * @returns Acceleration vector\n */\nconst massApplyAccel = (\n  vector: Point,\n  thing: ForceAffected,\n  mass: MassApplication = `ignored`\n) => {\n\n  let op;\n  switch (mass) {\n    case `dampen`: {\n      op = (mass: number) => PointDivide(vector, mass, mass);\n\n      break;\n    }\n    case `multiply`: {\n      op = (mass: number) => Points.multiply(vector, mass, mass);\n\n      break;\n    }\n    case `ignored`: {\n      op = (_mass: number) => vector;\n\n      break;\n    }\n    default: {\n      throw new Error(\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Unknown 'mass' parameter '${ mass }. Expected 'dampen', 'multiply' or 'ignored'`\n      );\n    }\n  }\n  return Points.sum(thing.acceleration ?? Points.Empty, op(thing.mass ?? 1));\n  // if (t.mass) {\n  //   if (dampen) return Points.sum(t.acceleration ?? Points.Empty, Points.divide(v, t.mass ?? 1));\n  //   else return Points.sum(t.acceleration ?? Points.Empty, Points.multiply(v, t.mass ?? 1));\n  // }\n  // return v;\n};\n\n/**\n * A force based on the square of the thing's velocity.\n * It's like {@link velocityForce}, but here the velocity has a bigger impact.\n *\n * ```js\n * const thing = {\n *  position: { x: 0.5, y:0.5 },\n *  velocity: { x: 0.001, y:0 }\n * };\n * const drag = magnitudeForce(0.1);\n *\n * // Apply drag force to thing, returning result\n * const t = Forces.apply(thing, drag);\n * ```\n * @param force Force value\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const magnitudeForce =\n  (force: number, mass: MassApplication = `ignored`): ForceFn =>\n    (t: ForceAffected): ForceAffected => {\n      if (t.velocity === undefined) return t;\n\n      const mag = Points.distance(Points.normalise(t.velocity));\n      const magSq = force * mag * mag;\n      const vv = Points.multiply(Points.invert(t.velocity), magSq);\n      return Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vv, t, mass),\n      });\n    };\n\n/**\n * Null force does nothing\n * @returns A force that does nothing\n */\nexport const nullForce = (t: ForceAffected): ForceAffected => t;\n\n/**\n * Force calculated from velocity of object. Reads velocity and influences acceleration.\n *\n * ```js\n * let t = { position: Points.random(), mass: 0.1 };\n * const friction = velocityForce(0.1, `dampen`);\n *\n * // Apply force, updating position and velocity\n * t = Forces.apply(t, friction);\n * ```\n * @param force Force\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const velocityForce = (\n  force: number,\n  mass: MassApplication\n): ForceFn => {\n  // Invert velocity and then multiply by force\n  const pipeline = Points.pipeline(\n    // Points.normalise,\n    Points.invert,\n    (v: Point) => Points.multiply(v, force)\n  );\n\n  return (t: ForceAffected): ForceAffected => {\n    if (t.velocity === undefined) return t;\n\n    // Apply pipeline\n    const v = pipeline(t.velocity);\n    return Object.freeze({\n      ...t,\n      acceleration: massApplyAccel(v, t, mass),\n    });\n  };\n};\n\n/**\n * Sets angle, angularVelocity and angularAcceleration based on\n *  angularAcceleration, angularVelocity, angle\n * @returns\n */\nexport const angularForce = () => (t: ForceAffected) => {\n  const accumulator = t.angularAcceleration ?? 0;\n  const vel = t.angularVelocity ?? 0;\n  const angle = t.angle ?? 0;\n\n  const v = vel + accumulator;\n  const a = angle + v;\n\n  return Object.freeze({\n    ...t,\n    angle: a,\n    angularVelocity: v,\n    angularAcceleration: 0,\n  });\n};\n\n// export const positionFromAngleForce = () => (t:ForceAffected) => {\n//   return Object.freeze({\n//     ...t,\n//     position: computePositionFromAngle()\n//   });\n// };\n\n/**\n * Yields a force function that applies the thing's acceleration.x to its angular acceleration.\n * @param scaling Use this to scale the accel.x value. Defaults to 20 (ie accel.x*20). Adjust if rotation is too much or too little\n * @returns\n */\nexport const angleFromAccelerationForce =\n  (scaling = 20) =>\n    (t: ForceAffected) => {\n      const accel = t.acceleration ?? Points.Empty;\n      return Object.freeze({\n        ...t,\n        angularAcceleration: accel.x * scaling,\n      });\n    };\n\n/**\n * Yields a force function that applies the thing's velocity to its angle.\n * This will mean it points in the direction of travel.\n * @param interpolateAmt If provided, the angle will be interpolated toward by this amount. Defaults to 1, no interpolation\n * @returns\n */\nexport const angleFromVelocityForce =\n  (interpolateAmt = 1) =>\n    (t: ForceAffected) => {\n      const a = Points.angle(t.velocity ?? Points.Empty);\n      return Object.freeze({\n        ...t,\n        angle:\n          interpolateAmt < 1\n            ? interpolateAngle(interpolateAmt, t.angle ?? 0, a)\n            : a,\n      });\n    };\n\n/**\n * Spring force\n *\n *  * ```js\n * // End of spring that moves\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Anchored other end of spring\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const springForce = Forces.springForce(pinnedAt, 0.4);\n *\n * continuously(() => {\n *  // Apply force\n *  thing = Forces.apply(thing, springForce);\n * }).start();\n * ```\n * [Read more](https://www.joshwcomeau.com/animation/a-friendly-introduction-to-spring-physics/)\n *\n * @param pinnedAt Anchored end of the spring\n * @param restingLength Length of spring-at-rest (default: 0.5)\n * @param k Spring stiffness (default: 0.0002)\n * @param damping Damping factor to apply, so spring slows over time. (default: 0.995)\n * @returns\n */\nexport const springForce =\n  (\n    pinnedAt: Point,\n    restingLength = 0.5,\n    k = 0.0002,\n    damping = 0.999\n  ) =>\n    (t: ForceAffected): ForceAffected => {\n      const direction = Points.subtract(t.position ?? Points.Empty, pinnedAt);\n      const mag = Points.distance(direction);\n      const stretch = Math.abs(restingLength - mag);\n\n      const f = Points.pipelineApply(direction, Points.normalise, (p) =>\n        Points.multiply(p, -k * stretch)\n      );\n\n      const accel = massApplyAccel(f, t, `dampen`);\n      const velo = computeVelocity(\n        accel ?? Points.Empty,\n        t.velocity ?? Points.Empty\n      );\n      const veloDamped = Points.multiply(velo, damping, damping);\n      return {\n        ...t,\n        velocity: veloDamped,\n        acceleration: Points.Empty,\n      };\n    };\n\n/**\n * Pendulum force options\n */\nexport type PendulumOpts = {\n  /**\n   * Length of 'string' thing is hanging from. If\n   * undefined, the current length between thing and\n   * pinnedAt is used.\n   */\n  readonly length?: number;\n  /**\n   * Max speed of swing. Slower speed can reach equilibrium faster, since it\n   * might not swing past resting point.\n   * Default 0.001.\n   */\n  readonly speed?: number;\n  /**\n   * Damping, how much to reduce velocity. Default 0.995 (ie 0.5% loss)\n   */\n  readonly damping?: number;\n};\n/**\n * The pendulum force swings something back and forth.\n *\n * ```js\n * // Swinger\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Position thing swings from (middle of screen)\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const pendulumForce = Forces.pendulumForce(pinnedAt, { length: 0.4 });\n *\n * continuously(() => {\n *  // Apply force\n *  // Returns a new thing with recalculated angularVelocity, angle and position.\n *  thing = Forces.apply(thing, pendulumForce);\n * }).start();\n * ```\n *\n * [Read more](https://natureofcode.com/book/chapter-3-oscillation/)\n *\n * @param pinnedAt Location to swing from (x:0.5, y:0.5 default)\n * @param opts Options\n * @returns\n */\nexport const pendulumForce =\n  (pinnedAt?: Point, opts: PendulumOpts = {}) =>\n    (t: ForceAffected): ForceAffected => {\n      if (!pinnedAt) pinnedAt = { x: 0, y: 0 };\n      const length =\n        opts.length ?? Points.distance(pinnedAt, t.position ?? Points.Empty);\n      const speed = opts.speed ?? 0.001;\n      const damping = opts.damping ?? 0.995;\n\n      let angle = t.angle;\n      if (angle === undefined) {\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (t.position) {\n          angle = Points.angle(pinnedAt, t.position) - Math.PI / 2;\n        } else {\n          angle = 0; // Position wherever\n        }\n      }\n      const accel = ((-1 * speed) / length) * Math.sin(angle);\n      const v = (t.angularVelocity ?? 0) + accel;\n      angle += v;\n\n      return Object.freeze({\n        angularVelocity: v * damping,\n        angle,\n        position: computePositionFromAngle(length, angle + Math.PI / 2, pinnedAt),\n      });\n    };\n\n/**\n * Compute velocity based on acceleration and current velocity\n * @param acceleration Acceleration\n * @param velocity Velocity\n * @param velocityMax If specified, velocity will be capped at this value\n * @returns\n */\nexport const computeVelocity = (\n  acceleration: Point,\n  velocity: Point,\n  velocityMax?: number\n): Point => {\n  const p = Points.sum(velocity, acceleration);\n  return velocityMax === undefined ? p : Points.clampMagnitude(p, velocityMax);\n};\n\n/**\n * Returns the acceleration to get from `currentPos` to `targetPos`.\n *\n * @example Barebones usage:\n * ```js\n * const accel = Forces.computeAccelerationToTarget(targetPos, currentPos);\n * const vel = Forces.computeVelocity(accel, currentVelocity);\n *\n * // New position:\n * const pos = Points.sum(currentPos, vel);\n * ```\n *\n * @example Implementation:\n * ```js\n * const direction = Points.subtract(targetPos, currentPos);\n * const accel = Points.multiply(direction, diminishBy);\n * ```\n * @param currentPos Current position\n * @param targetPos Target position\n * @param opts Options\n * @returns\n */\nexport const computeAccelerationToTarget = (\n  targetPos: Point,\n  currentPos: Point,\n  opts: TargetOpts = {}\n) => {\n  const diminishBy = opts.diminishBy ?? 0.001;\n\n  // Compare to current position of thing to get vector direction\n  const direction = Points.subtract(targetPos, currentPos);\n\n  if (opts.range && // If direction is less than range, return { x: 0, y: 0}\n    Points.compare(Points.abs(direction), opts.range) === -2) {\n    return Points.Empty;\n  }\n\n  // Diminish vector to make a meaningful acceleration\n  return Points.multiply(direction, diminishBy);\n};\n\n/**\n * Compute a new position based on existing position and velocity vector\n * @param position Position Current position\n * @param velocity Velocity vector\n * @returns Point\n */\nexport const computePositionFromVelocity = (\n  position: Point,\n  velocity: Point\n): Point => Points.sum(position, velocity);\n\n/**\n * Compute a position based on distance and angle from origin\n * @param distance Distance from origin\n * @param angleRadians Angle, in radians from origin\n * @param origin Origin point\n * @returns Point\n */\nexport const computePositionFromAngle = (\n  distance: number,\n  angleRadians: number,\n  origin: Point\n) => Polar.toCartesian(distance, angleRadians, origin);\n\nconst _angularForce = angularForce();\nconst _angleFromAccelerationForce = angleFromAccelerationForce();\n\n/**\n * A force that orients things according to direction of travel.\n *\n * Under the hood, it applies:\n * * angularForce,\n * * angleFromAccelerationForce, and\n * * angleFromVelocityForce\n * @param interpolationAmt\n * @returns\n */\nexport const orientationForce = (interpolationAmt = 0.5): ForceFn => {\n  const angleFromVel = angleFromVelocityForce(interpolationAmt);\n\n  return (t: ForceAffected) => {\n    t = _angularForce(t);\n    t = _angleFromAccelerationForce(t);\n    t = angleFromVel(t);\n    return t;\n  };\n};\n","import * as Timers from '../flow/Timer.js';\n\nconst piPi = Math.PI * 2;\n\nexport type SpringOpts = {\n  /**\n   * Default: 1\n   */\n  readonly mass?: number; // = 1.0\n  /**\n   * Default: 10\n   */\n  readonly damping?: number; // = 10.0\n  /**\n   * Default: 100\n   */\n  readonly stiffness?: number; // = 100.0\n  /**\n   * Default: false\n   */\n  readonly soft?: boolean; // = false\n\n  /**\n   * Default: 0.1\n   */\n  readonly velocity?: number;\n\n  /**\n   * How many iterations to wait for spring settling (default: 10)\n   */\n  readonly countdown?: number;\n};\n\nconst springRaw = (opts: SpringOpts = {}, from = 0, to = 1) => {\n  /** MIT License github.com/pushkine/ */\n  const mass = opts.mass ?? 1;\n  const stiffness = opts.stiffness ?? 100;\n  const soft = opts.soft ?? false;\n  const damping = opts.damping ?? 10;\n  const velocity = opts.velocity ?? 0.1;\n  const delta = to - from;\n  if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n    const angularFrequency = -Math.sqrt(stiffness / mass);\n    const leftover = -angularFrequency * delta - velocity;\n    return (t: number) =>\n      to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n  } else {\n    const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n    const leftover =\n      (damping * delta - 2 * mass * velocity) / dampingFrequency;\n    const dfm = (0.5 * dampingFrequency) / mass;\n    const dm = -(0.5 * damping) / mass;\n    return (t: number) =>\n      to -\n      (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n      Math.E ** (t * dm);\n  }\n};\n\n/**\n * Spring-style oscillation\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const spring = Oscillators.spring();\n *\n * continuously(() => {\n *  const v = spring.next().value;\n *  // Yields values 0...1\n *  //  undefined is yielded when spring is estimated to have stopped\n * });\n * ```\n *\n * Parameters to the spring can be provided.\n * ```js\n * const spring = Oscillators.spring({\n *  mass: 5,\n *  damping: 10\n *  stiffness: 100\n * });\n * ```\n * @param opts Options for spring\n * @param timerOrFreq Timer to use, or frequency\n */\n//eslint-disable-next-line func-style\nexport function* spring(\n  opts: SpringOpts = {},\n  timerOrFreq?: Timers.Timer | number | undefined\n) {\n  if (timerOrFreq === undefined) timerOrFreq = Timers.msElapsedTimer();\n  else if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n\n  const fn = springRaw(opts, 0, 1);\n\n  // Give it some iterations to settle\n  //eslint-disable-next-line functional/no-let\n  let doneCountdown = opts.countdown ?? 10;\n\n  while (doneCountdown > 0) {\n    const s = fn(timerOrFreq.elapsed / 1000);\n    yield s;\n    if (s === 1) {\n      doneCountdown--;\n    } else {\n      doneCountdown = 100;\n    }\n  }\n}\n\n/**\n * Sine oscillator.\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.sine(frequencyTimer(10));\n * const osc = Oscillators.sine(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n *\n * @example Saw/tri pinch\n * ```js\n * const v = Math.pow(osc.value, 2);\n * ```\n *\n * @example Saw/tri bulge\n * ```js\n * const v = Math.pow(osc.value, 0.5);\n * ```\n *\n */\n//eslint-disable-next-line func-style\nexport function* sine(timerOrFreq: Timers.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n\n  while (true) {\n    // Rather than -1 to 1, we want 0 to 1\n    yield (Math.sin(timerOrFreq.elapsed * piPi) + 1) / 2;\n  }\n}\n\n/**\n * Bipolar sine (-1 to 1)\n * @param timerOrFreq\n */\n//eslint-disable-next-line func-style\nexport function* sineBipolar(timerOrFreq: Timers.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield Math.sin(timerOrFreq.elapsed * piPi);\n  }\n}\n\n/**\n * Triangle oscillator\n *\n * ```js\n * // Setup\n * const osc = triangle(Timers.frequencyTimer(0.1));\n * const osc = triangle(0.1);\n *\n * // Call whenver a value is needed\n * const v = osc.next().value;\n * ```\n */\n//eslint-disable-next-line func-style\nexport function* triangle(timerOrFreq: Timers.Timer | number) {\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    // elapsed is repeatedly 0->1\n    //eslint-disable-next-line functional/no-let\n    let v = timerOrFreq.elapsed;\n    // /2 = 0->0.5\n    if (v < 0.5) {\n      // Upward\n      v *= 2;\n    } else {\n      // Downward\n      v = 2 - v * 2;\n    }\n    yield v;\n  }\n}\n\n/**\n * Saw oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.saw(Timers.frequencyTimer(0.1));\n *\n * // Or\n * const osc = Oscillators.saw(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n */\n//eslint-disable-next-line func-style\nexport function* saw(timerOrFreq: Timers.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield timerOrFreq.elapsed;\n  }\n}\n\n/**\n * Square oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n *\n * // Setup\n * const osc = Oscillators.square(Timers.frequencyTimer(0.1));\n * const osc = Oscillators.square(0.1);\n *\n * // Call whenever a value is needed\n * osc.next().value;\n * ```\n */\n//eslint-disable-next-line func-style\nexport function* square(timerOrFreq: Timers.Timer | number) {\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Timers.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield timerOrFreq.elapsed < 0.5 ? 0 : 1;\n  }\n}\n","import { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport type { ModSettable, ModSettableFeedback, ModSettableOptions } from \"../Types.js\";\n\nexport type TicksModSettableOptions = ModSettableOptions & {\n  exclusiveStart: boolean\n  exclusiveEnd: boolean\n}\n/**\n * Returns a function which cycles between 0..1 (inclusive of 0 and 1).\n * `totalTicks` is how many ticks it takes to get to 1. Since we want an inclusive 0 & 1,\n * the total ticks is actually +1.\n *\n * Ie. if totalTicks = 10, we get: 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\n * \n * Use 'exclusiveStart' or 'exclusiveEnd' to shift range. Eg 'exclusiveStart' will begin at 0.1 and\n * include 1.0, while 'exclusiveEnd' will start at 0 and run up to and including 0.9.\n * \n * Other examples:\n * * totalTicks: 20, value goes up by 0.05\n * * totalTicks: 1, value goes up by 1\n * @param totalTicks Positive, integer value. How many ticks to complete a cycle\n * @param options\n * @returns \n */\nexport function ticks(totalTicks: number, options: Partial<TicksModSettableOptions> = {}): ModSettable {\n  throwIntegerTest(totalTicks, `aboveZero`, `totalTicks`);\n  const exclusiveStart = options.exclusiveStart ?? false;\n  const exclusiveEnd = options.exclusiveEnd ?? false;\n  const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n\n  const startPoint = exclusiveStart ? 1 : 0;\n  const endPoint = exclusiveEnd ? totalTicks - 1 : totalTicks;\n\n  let cycleCount = 0;\n  let v = options.startAt ?? startPoint;\n  if (options.startAtRelative) {\n    let totalTicksForReal = totalTicks;\n    if (exclusiveStart) totalTicksForReal--;\n    if (exclusiveEnd) totalTicksForReal--;\n    v = Math.round(options.startAtRelative * totalTicksForReal);\n  }\n\n  return (feedback?: Partial<ModSettableFeedback>) => {\n    if (feedback) {\n      if (feedback.resetAt !== undefined) {\n        v = feedback.resetAt;\n      }\n      if (feedback.resetAtRelative !== undefined) {\n        v = Math.floor(feedback.resetAtRelative * totalTicks);\n      }\n    }\n    if (cycleCount >= cycleLimit) return 1;\n\n    let current = v / totalTicks;\n    v++;\n    if (v > endPoint) {\n      cycleCount++;\n      v = startPoint;\n    }\n    return current;\n  }\n}\n","export * from './Ticks.js'\nexport * from './Time.js';\nexport * from './PerSecond.js';","import { type Interval, intervalToMs } from \"../../flow/IntervalType.js\";\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { ModSettableOptions, ModSettable, ModSettableFeedback } from \"../Types.js\";\n\n/**\n * Returns an elapsed number of milliseconds up to `interval`.\n * If `oneShot` is _false_ (default), it will loop, resetting to 0 when `interval` is reached.\n * If `oneShot` is _true_, once `interval` is reached, this value will be returned.\n * \n * The starting 'position' is `performance.now()`. If `startAt` option is provided, this will be used instead.\n * It probably should be an offset of `performance.now()`, eg: `{ startAt: performance.now() - 500 }` to shift\n * the cycle by 500ms.\n * \n * When using `startAtRelative`, the starting position will be set backward by the relative amount. A value\n * of 0.5, for example, will set the timer back 50% of the interval, meaning the cycle will start half way through.\n * @param interval \n * @param options \n * @returns \n */\nexport function elapsed(interval: Interval, options: Partial<ModSettableOptions> = {}): ModSettable {\n  const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = 1;\n  let start = options.startAt ?? performance.now();\n  let cycleCount = 0;\n  const intervalMs = intervalToMs(interval, 1000);\n  if (options.startAtRelative) {\n    throwNumberTest(options.startAtRelative, `percentage`, `startAtRelative`);\n    start = performance.now() - (intervalMs * options.startAtRelative);\n  }\n  //let stopAt = cycleLimit > 0 ? (intervalMs + start) : Number.MAX_SAFE_INTEGER;\n  return (feedback?: Partial<ModSettableFeedback>) => {\n    if (feedback) {\n      if (feedback.resetAt !== undefined) {\n        start = feedback.resetAt;\n        if (start === 0) start = performance.now();\n      }\n      if (feedback.resetAtRelative !== undefined) {\n        throwNumberTest(feedback.resetAtRelative, `percentage`, `resetAtRelative`);\n        start = performance.now() - (intervalMs * feedback.resetAtRelative);\n      }\n    }\n    if (cycleCount >= cycleLimit) return limitValue;\n    const now = performance.now();\n    const elapsedCycle = now - start;\n    if (elapsedCycle >= intervalMs) {\n      cycleCount += Math.floor(elapsedCycle / intervalMs);\n      start = now;\n      if (cycleCount >= cycleLimit) return limitValue;\n    }\n    return (elapsedCycle % intervalMs) / intervalMs;\n  }\n\n  // } else {\n  //   return () => ((performance.now() - start) % intervalMs) / intervalMs;\n  // }\n}\n\n/**\n * Counts beats based on a BPM\n * @param bpm \n * @param options \n * @returns \n */\nexport function bpm(bpm: number, options: Partial<ModSettableOptions>): ModSettable {\n  const interval = (60 * 1000) / bpm; // milliseconds between beats.\n  return elapsed(interval, options);\n}\n\n/**\n * Counts based on hertz (oscillations per second)\n * @param hz \n * @param options \n * @returns \n */\nexport function hertz(hz: number, options: Partial<ModSettableOptions>): ModSettable {\n  const interval = 1000 / hz;\n  return elapsed(interval, options);\n}\n\n","import type { ModSource } from \"../Types.js\";\n\n/**\n * Returns a proportion of `amount` depending on elapsed time.\n * The idea being that cumulatively, `amount` is yielded every second.\n * \n * ```js\n * // Calculate a proportion of 0.1 every second\n * const x = perSecond(0.1);\n * x();\n * ```\n * \n * The faster `x()` is called, the smaller the chunks of `amount` are returned.\n * Values accumulate. For example, `x()` isn't called for two seconds, 2*amount is returned.\n * \n * @example Usage\n * ```js\n * const settings = {\n *  ageMod: perSecond(0.1);\n* };\n * \n * let state = {\n *  age: 1\n * };\n * \n * // Update\n * setInterval(() => {\n *  let { age } = state;\n *  // Add 0.1 per second, regardless of \n *  // loop speed\n *  age += settings.ageMod(); \n *  state = {\n *    ...state,\n *    age: clamp(age)\n *  }\n * });\n * ```\n * \n * Options:\n * * max: if specified, the max return value\n * * min: if specified, the min return value\n * @param amount\n * @returns \n */\nexport const perSecond = (amount: number, options: Partial<{ max: number, min: number }> = {}): ModSource => {\n  const perMilli = amount / 1000;\n  const min = options.min ?? Number.MIN_SAFE_INTEGER;\n  const max = options.max ?? Number.MAX_SAFE_INTEGER;\n  let called = performance.now();\n\n  return () => {\n    const now = performance.now();\n    const elapsed = now - called;\n    called = now;\n    const x = perMilli * elapsed;\n    if (x > max) return max;\n    if (x < min) return min;\n    return x;\n  }\n}\n\n/**\n * As {@link perSecond}, but per minute.\n * @param amount \n * @param options \n * @returns \n */\nexport const perMinute = (amount: number, options: Partial<{ max: number, min: number }> = {}): ModSource => {\n  return perSecond(amount / 60, options);\n}","import { ticks } from \"./sources/Ticks.js\";\nimport { throwIntegerTest } from \"../util/GuardNumbers.js\";\nimport type { ModSettable, ModSettableFeedback, ModSettableOptions } from \"./Types.js\";\nimport * as Sources from './sources/index.js';\nexport type WaveformShaper = (position: number) => number;\n\nexport type Waveforms = `sine` | `sine-bipolar` | `saw` | `triangle` | `square` | `arc`;\n/**\n * Options for the wave function. Defaults to a sine wave of one cycle per-second.\n */\nexport type WaveOptions = ModSettableOptions & {\n  period: number\n  /**\n   * Clock source. Set this or ticks, hertz, secs or millis\n   * @returns \n   */\n  source: () => number,\n  /**\n   * Waveshape. Default 'sine'\n   */\n  shape: Waveforms\n  /**\n   * Number of ticks per cycle\n   * (Set either ticks, hertz, secs or millis)\n   */\n  ticks: number\n  /**\n   * Number of cycles per second\n   * (Set either ticks, hertz, secs or millis)\n   */\n  hertz: number\n  /**\n   * Number of seconds per cycle. Defaults to one second.\n   * (Set either ticks, hertz, secs or millis)\n   */\n  secs: number\n  /**\n   * Number of milliseconds per cycle\n   * (Set either ticks, hertz, secs or millis)\n   */\n  millis: number\n  /**\n   * If _true_, shape is inverted\n   */\n  invert: boolean\n}\n/**\n * Returns a function that shapes a 0..1 value as a \n * triangle waveform.\n * \n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function triangleShaper(period = 1): WaveformShaper {\n  period = 1 / period;\n  const halfPeriod = period / 2;\n  return (t: number) => {\n    const v = Math.abs((t % period) - halfPeriod);\n    //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n    return v;\n  }\n}\n\n/**\n * Returns a function that shapes a 0..1 value as a square waveform.\n * `period` sets the number of cycles in the 0..1 range.\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function squareShaper(period = 1): WaveformShaper {\n  period = 1 / period;\n  const halfPeriod = period / 2;\n  return (t: number) => {\n    return (t % period) < halfPeriod ? 1 : 0;\n    //console.log(`square: ${ t } v: ${ v }`);\n    //return v;\n  }\n}\n\n/**\n * Returns a function that shapes a 0..1 value as a sine waveform.\n * ```js\n * const s = sineShape();\n * // Calculate value of sine wave at 50%\n * // By default there is one oscillation, thus\n * // it will be the middle of the cycle.\n * s(0.5); \n * ```\n * \n * The `period` determines number of cycles for\n * an input value of 1.\n * ```js\n * // Oscillate twice in 0..1 range\n * const s = sineShape(2);\n * ```\n * \n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function sineShape(period = 1): WaveformShaper {\n  period = period * (Math.PI * 2);\n  return (t: number) => {\n    const v = (Math.sin(t * period) + 1) / 2;\n    //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n    return v;\n  }\n}\n\n/**\n * A series of arcs, sort of like a bouncing ball.\n * @param period \n * @returns \n */\nexport function arcShape(period = 1): WaveformShaper {\n  period = period * (Math.PI * 2);\n  return (t: number) => Math.abs(Math.sin(t * period));\n}\n\nexport function sineBipolarShape(period = 1): WaveformShaper {\n  period = period * (Math.PI * 2);\n  return (t: number) => Math.sin(t * period);\n}\n\n/**\n * Creates a wave modulator. Defaults to 5-second sine wave. \n * ```js\n * // Triangle wave that has a single cycle over two seconds\n * const m = wave({ secs: 2, shape: `triangle`});\n * \n * // Call m() to get current value of wave, eg in\n * // an animation loop\n * const v = m();\n * ```\n * \n * @param options \n * @returns \n */\nexport function wave(options: Partial<WaveOptions>) {\n  const shape = options.shape ?? `sine`;\n  const invert = options.invert ?? false;\n  const period = options.period ?? 1;\n  let sourceFn;\n\n  throwIntegerTest(period, `aboveZero`, `period`);\n\n  const sourceOptions = {\n    ...options\n  }\n  if (options.ticks) {\n    sourceFn = Sources.ticks(options.ticks, sourceOptions);\n  } else if (options.hertz) {\n    sourceFn = Sources.hertz(options.hertz, sourceOptions);\n  } else if (options.millis) {\n    sourceFn = Sources.elapsed(options.millis, sourceOptions);\n  } else if (options.source) {\n    sourceFn = options.source;\n  } else {\n    const secs = options.secs ?? 5;\n    sourceFn = Sources.elapsed(secs * 1000, sourceOptions);\n  }\n\n  let shaperFn;\n  switch (shape) {\n    case `saw`:\n      shaperFn = (v: number) => v;\n      break;\n    case `sine`:\n      shaperFn = sineShape(period);\n      break;\n    case `sine-bipolar`:\n      shaperFn = sineBipolarShape(period);\n      break;\n    case `square`:\n      shaperFn = squareShaper(period);\n      break;\n    case `triangle`:\n      shaperFn = triangleShaper(period);\n      break;\n    case `arc`:\n      shaperFn = arcShape(period);\n      break;\n    default:\n      throw new Error(`Unknown wave shape '${ shape }'. Expected: sine, sine-bipolar, saw, triangle, arc or square`);\n  }\n  return waveFromSource(sourceFn, shaperFn, invert);\n}\n\nexport type WaveShaperFeedback = {\n  /**\n   * Data to feedback to clock source\n   */\n  clock: ModSettableFeedback\n  /**\n   * If set, source function is ignored and this value (0..1) is used instead\n   */\n  override: number\n}\n/**\n * Returns a wave-shaping modulator from a source and shaper\n * @param sourceFn \n * @param shaperFn \n * @returns \n */\nexport function waveFromSource(sourceFn: ModSettable, shaperFn: WaveformShaper, invert = false) {\n  return (feedback?: Partial<WaveShaperFeedback>) => {\n    let v = sourceFn(feedback?.clock);\n    if (feedback?.override) v = feedback.override;\n    v = shaperFn(v);\n    if (invert) v = 1 - v;\n    return v;\n  }\n}"],"mappings":"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","names":["elapsed","mass","interval","bpm","elapsed"]}