{"version":3,"sources":["../src/flow/Timeout.ts","../src/flow/RateMinimum.ts"],"sourcesContent":["import { throwIntegerTest, integerTest } from '../util/GuardNumbers.js';\nimport { type HasCompletion, type HasCompletionRunStates } from './Types.js';\n\nimport { intervalToMs, type Interval } from './IntervalType.js';\n\nexport type TimeoutSyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => void;\nexport type TimeoutAsyncCallback = (\n  elapsedMs?: number,\n  ...args: ReadonlyArray<unknown>\n) => Promise<void>;\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  /**\n   * Starts the timer.\n   * If the timer has already been started and has a scheduled execution, this is cancelled \n   * and re-scheduled.\n   * @param altTimeoutMs Optional override for the interval. Use _undefined_ to use the original interval\n   * @param args \n   */\n  start(altTimeoutMs?: number, args?: ReadonlyArray<unknown>): void;\n  /**\n   * Cancels the timer, aborting any scheduled execution.\n   */\n  cancel(): void;\n};\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * \n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): Timeout => {\n  if (callback === undefined) {\n    throw new Error(`callback parameter is undefined`);\n  }\n  const intervalMs = intervalToMs(interval);\n  throwIntegerTest(intervalMs, `aboveZero`, `interval`);\n\n  let timer: ReturnType<typeof setTimeout>;\n  let startedAt = 0;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let state: HasCompletionRunStates = `idle`;\n\n  const clear = () => {\n    startedAt = 0;\n    globalThis.clearTimeout(timer);\n    state = `idle`;\n  }\n\n  const start = async (\n    altInterval: Interval = interval,\n    args: Array<unknown>\n  ): Promise<void> => {\n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      const altTimeoutMs = intervalToMs(altInterval);\n      const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      if (!it[ 0 ]) {\n        reject(new Error(it[ 1 ]));\n        return;\n      }\n\n      switch (state) {\n        case `scheduled`: {\n          // Cancel other scheduled execution\n          cancel();\n          break;\n        }\n        case `running`: {\n          //console.warn(`Timeout being rescheduled while task is already running`);\n          break;\n        }\n      }\n      state = `scheduled`;\n\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      timer = globalThis.setTimeout(async () => {\n        if (state !== `scheduled`) {\n          console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n          clear();\n          return;\n        }\n        const args_ = args ?? [];\n        startCount++;\n        startCountTotal++;\n        state = `running`;\n        await callback(performance.now() - startedAt, ...args_);\n        state = `idle`\n        clear();\n        resolve();\n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (state === `idle`) return;\n    clear();\n  };\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    start,\n    cancel,\n    get runState() {\n      return state;\n    },\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    }\n  };\n};\n\n\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });","import type { Interval } from \"./IntervalType.js\";\nimport { timeout } from \"./Timeout.js\";\n\n\nexport type RateMinimumOptions<TInput> = Readonly<{\n  whatToCall: (args: TInput) => void\n  fallback: () => TInput\n  interval: Interval\n  abort?: AbortSignal\n}>;\n\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n * \n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n * \n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n * \n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ``` \n * \n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n * \n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n * \n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n * \n * @param options \n * @returns \n */\nexport const rateMinimum = <TInput>(options: RateMinimumOptions<TInput>) => {\n  let disposed = false;\n\n  const t = timeout(() => {\n    if (disposed) return;\n    t.start();\n    options.whatToCall(options.fallback());\n  }, options.interval);\n\n\n  if (options.abort) {\n    options.abort.addEventListener(`abort`, _ => {\n      disposed = true;\n      t.cancel();\n    });\n  }\n  t.start();\n\n  return (args: TInput) => {\n    if (disposed) throw new Error(`AbortSignal has been fired`);\n    t.start();\n    options.whatToCall(args);\n  }\n}"],"mappings":";;;;;;;;;AA+EO,IAAM,UAAU,CACrB,UACA,aACY;AACZ,MAAI,aAAa,QAAW;AAC1B,UAAM,IAAI,MAAM,iCAAiC;AAAA,EACnD;AACA,QAAM,aAAa,aAAa,QAAQ;AACxC,mBAAiB,YAAY,aAAa,UAAU;AAEpD,MAAI;AACJ,MAAI,YAAY;AAChB,MAAI,aAAa;AACjB,MAAI,kBAAkB;AACtB,MAAI,QAAgC;AAEpC,QAAM,QAAQ,MAAM;AAClB,gBAAY;AACZ,eAAW,aAAa,KAAK;AAC7B,YAAQ;AAAA,EACV;AAEA,QAAM,QAAQ,OACZ,cAAwB,UACxB,SACkB;AAClB,UAAM,IAAI,IAAI,QAAc,CAAC,SAAS,WAAW;AAC/C,kBAAY,YAAY,IAAI;AAC5B,YAAM,eAAe,aAAa,WAAW;AAC7C,YAAM,KAAK,YAAY,cAAc,aAAa,cAAc;AAChE,UAAI,CAAC,GAAI,CAAE,GAAG;AACZ,eAAO,IAAI,MAAM,GAAI,CAAE,CAAC,CAAC;AACzB;AAAA,MACF;AAEA,cAAQ,OAAO;AAAA,QACb,KAAK,aAAa;AAEhB,iBAAO;AACP;AAAA,QACF;AAAA,QACA,KAAK,WAAW;AAEd;AAAA,QACF;AAAA,MACF;AACA,cAAQ;AAGR,cAAQ,WAAW,WAAW,YAAY;AACxC,YAAI,UAAU,aAAa;AACzB,kBAAQ,KAAK,2DAA2D;AACxE,gBAAM;AACN;AAAA,QACF;AACA,cAAM,QAAQ,QAAQ,CAAC;AACvB;AACA;AACA,gBAAQ;AACR,cAAM,SAAS,YAAY,IAAI,IAAI,WAAW,GAAG,KAAK;AACtD,gBAAQ;AACR,cAAM;AACN,gBAAQ;AAAA,MACV,GAAG,YAAY;AAAA,IACjB,CAAC;AACD,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,MAAM;AACnB,QAAI,UAAU,OAAQ;AACtB,UAAM;AAAA,EACR;AAEA,SAAO;AAAA;AAAA,IAEL;AAAA,IACA;AAAA,IACA,IAAI,WAAW;AACb,aAAO;AAAA,IACT;AAAA,IACA,IAAI,aAAa;AACf,aAAO;AAAA,IACT;AAAA,IACA,IAAI,kBAAkB;AACpB,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;AC5GO,IAAM,cAAc,CAAS,YAAwC;AAC1E,MAAI,WAAW;AAEf,QAAM,IAAI,QAAQ,MAAM;AACtB,QAAI,SAAU;AACd,MAAE,MAAM;AACR,YAAQ,WAAW,QAAQ,SAAS,CAAC;AAAA,EACvC,GAAG,QAAQ,QAAQ;AAGnB,MAAI,QAAQ,OAAO;AACjB,YAAQ,MAAM,iBAAiB,SAAS,OAAK;AAC3C,iBAAW;AACX,QAAE,OAAO;AAAA,IACX,CAAC;AAAA,EACH;AACA,IAAE,MAAM;AAER,SAAO,CAAC,SAAiB;AACvB,QAAI,SAAU,OAAM,IAAI,MAAM,4BAA4B;AAC1D,MAAE,MAAM;AACR,YAAQ,WAAW,IAAI;AAAA,EACzB;AACF;","names":[]}