{"version":3,"sources":["../src/collections/queue/index.ts","../src/collections/queue/QueueImmutable.ts","../src/collections/queue/PriorityMutable.ts"],"sourcesContent":["\nexport * from './QueueTypes.js';\nexport { type IQueueMutable } from './IQueueMutable.js';\nexport { type IQueueImmutable } from './IQueueImmutable.js';\nexport { type IPriorityQueueMutable } from './IPriorityQueueMutable.js';\nexport { type QueueOpts } from './QueueTypes.js';\nexport { immutable } from './QueueImmutable.js';\nexport { mutable, QueueMutable } from './QueueMutable.js';\nexport { priority } from './PriorityMutable.js';\n","import type { IQueueImmutable } from './IQueueImmutable.js';\nimport { peek, isFull, isEmpty, enqueue, dequeue } from './QueueFns.js';\nimport { type QueueOpts } from './index.js';\n\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable<V> implements IQueueImmutable<V> {\n  readonly opts: QueueOpts<V>;\n  readonly data: ReadonlyArray<V>;\n\n  /**\n   * Creates an instance of Queue.\n   * @param {QueueOpts} opts Options foor queue\n   * @param {V[]} data Initial data. Index 0 is front of queue\n   * @memberof Queue\n   */\n  constructor(opts: QueueOpts<V> = {}, data: ReadonlyArray<V> = []) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n    this.opts = opts;\n    this.data = data;\n  }\n\n  forEach(fn: (v: V) => void) {\n    //eslint-disable-next-line functional/no-let\n    for (let index = this.data.length - 1; index >= 0; index--) {\n      fn(this.data[ index ]);\n    }\n  }\n\n  forEachFromFront(fn: (v: V) => void) {\n    // From front of queue\n    this.data.forEach(fn); //(vv) => fn(vv));\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): QueueImmutable<V> {\n    return new QueueImmutable<V>(\n      this.opts,\n      enqueue(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  dequeue(): QueueImmutable<V> {\n    return new QueueImmutable<V>(this.opts, dequeue(this.opts, this.data));\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = <V>(\n  opts: QueueOpts<V> = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueImmutable<V> => {\n  opts = { ...opts }; // Make a copy of options\n  return new QueueImmutable(opts, [ ...startingItems ]); // Make a copy of array so it can't be modified\n};\n","import { isEqualDefault, type IsEqual } from \"../../IsEqual.js\";\nimport { max as IterablesMax, min as IterablesMin } from \"../Iterables.js\";\nimport type { IPriorityQueueMutable, PriorityItem } from \"./IPriorityQueueMutable.js\";\nimport { QueueMutable } from \"./QueueMutable.js\";\nimport type { QueueOpts } from \"./QueueTypes.js\";\n\nexport class PriorityMutable<V> extends QueueMutable<PriorityItem<V>> implements IPriorityQueueMutable<V> {\n\n  constructor(opts: QueueOpts<PriorityItem<V>> = {}) {\n    if (opts.eq === undefined) {\n      opts = {\n        ...opts,\n        eq: (a, b) => {\n          return isEqualDefault(a.item, b.item);\n        }\n      }\n    }\n    super(opts);\n  }\n\n  enqueueWithPriority(item: V, priority: number) {\n    super.enqueue({ item, priority });\n  }\n\n  changePriority(item: V, priority: number, addIfMissing = false, eq?: IsEqual<V>) {\n    if (item === undefined) throw new Error(`Item cannot be undefined`);\n    let toDelete: PriorityItem<V> | undefined;\n    for (const d of this.data) {\n      if (eq) {\n        if (eq(d.item, item)) {\n          toDelete = d;\n          break;\n        }\n      } else {\n        if (this.eq(d, { item, priority: 0 })) {\n          toDelete = d;\n          break;\n        }\n      }\n    }\n    if (toDelete === undefined && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${ JSON.stringify(item) }`);\n    if (toDelete !== undefined) {\n      this.remove(toDelete);\n    }\n    this.enqueueWithPriority(item, priority);\n  }\n\n  dequeueMax(): V | undefined {\n    const m = IterablesMax(this.data, v => v.priority);\n    if (m === undefined) return;\n    this.remove(m);\n    return m.item;\n  }\n\n  dequeueMin(): V | undefined {\n    const m = IterablesMin(this.data, v => v.priority);\n    if (m === undefined) return;\n    this.remove(m);\n    return m.item;\n  }\n\n  peekMax(): V | undefined {\n    const m = IterablesMax(this.data, v => v.priority);\n    if (m === undefined) return;\n    return m.item;\n  }\n\n  peekMin(): V | undefined {\n    const m = IterablesMin(this.data, v => v.priority);\n    if (m === undefined) return;\n    return m.item;\n  }\n}\n\nexport function priority<V>(\n  opts: QueueOpts<PriorityItem<V>> = {}\n): IPriorityQueueMutable<V> {\n  return new PriorityMutable(opts);\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACOO,IAAM,iBAAN,MAAM,gBAAgD;AAAA,EAClD;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQT,YAAY,OAAqB,CAAC,GAAG,OAAyB,CAAC,GAAG;AAChE,QAAI,SAAS;AAAW,YAAM,IAAI,MAAM,0BAA0B;AAElE,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,QAAQ,IAAoB;AAE1B,aAAS,QAAQ,KAAK,KAAK,SAAS,GAAG,SAAS,GAAG,SAAS;AAC1D,SAAG,KAAK,KAAM,KAAM,CAAC;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,iBAAiB,IAAoB;AAEnC,SAAK,KAAK,QAAQ,EAAE;AAAA,EACtB;AAAA,EAEA,WAAW,OAA4C;AACrD,WAAO,IAAI;AAAA,MACT,KAAK;AAAA,MACL,QAAQ,KAAK,MAAM,KAAK,MAAM,GAAG,KAAK;AAAA,IACxC;AAAA,EACF;AAAA,EAEA,UAA6B;AAC3B,WAAO,IAAI,gBAAkB,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAK,IAAI,CAAC;AAAA,EACvE;AAAA,EAEA,IAAI,UAAmB;AACrB,WAAO,QAAQ,KAAK,MAAM,KAAK,IAAI;AAAA,EACrC;AAAA,EAEA,IAAI,SAAkB;AACpB,WAAO,OAAO,KAAK,MAAM,KAAK,IAAI;AAAA,EACpC;AAAA,EAEA,IAAI,SAAiB;AACnB,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA,EAEA,IAAI,OAAsB;AACxB,WAAO,KAAK,KAAK,MAAM,KAAK,IAAI;AAAA,EAClC;AACF;AAuBO,IAAM,YAAY,CACvB,OAAqB,CAAC,MACnB,kBACoB;AACvB,SAAO,EAAE,GAAG,KAAK;AACjB,SAAO,IAAI,eAAe,MAAM,CAAE,GAAG,aAAc,CAAC;AACtD;;;ACrFO,IAAM,kBAAN,cAAiC,aAAkE;AAAA,EAExG,YAAY,OAAmC,CAAC,GAAG;AACjD,QAAI,KAAK,OAAO,QAAW;AACzB,aAAO;AAAA,QACL,GAAG;AAAA,QACH,IAAI,CAAC,GAAG,MAAM;AACZ,iBAAO,eAAe,EAAE,MAAM,EAAE,IAAI;AAAA,QACtC;AAAA,MACF;AAAA,IACF;AACA,UAAM,IAAI;AAAA,EACZ;AAAA,EAEA,oBAAoB,MAASA,WAAkB;AAC7C,UAAM,QAAQ,EAAE,MAAM,UAAAA,UAAS,CAAC;AAAA,EAClC;AAAA,EAEA,eAAe,MAASA,WAAkB,eAAe,OAAO,IAAiB;AAC/E,QAAI,SAAS;AAAW,YAAM,IAAI,MAAM,0BAA0B;AAClE,QAAI;AACJ,eAAW,KAAK,KAAK,MAAM;AACzB,UAAI,IAAI;AACN,YAAI,GAAG,EAAE,MAAM,IAAI,GAAG;AACpB,qBAAW;AACX;AAAA,QACF;AAAA,MACF,OAAO;AACL,YAAI,KAAK,GAAG,GAAG,EAAE,MAAM,UAAU,EAAE,CAAC,GAAG;AACrC,qBAAW;AACX;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,aAAa,UAAa,CAAC;AAAc,YAAM,IAAI,MAAM,2CAA4C,KAAK,UAAU,IAAI,CAAE,EAAE;AAChI,QAAI,aAAa,QAAW;AAC1B,WAAK,OAAO,QAAQ;AAAA,IACtB;AACA,SAAK,oBAAoB,MAAMA,SAAQ;AAAA,EACzC;AAAA,EAEA,aAA4B;AAC1B,UAAM,IAAI,IAAa,KAAK,MAAM,OAAK,EAAE,QAAQ;AACjD,QAAI,MAAM;AAAW;AACrB,SAAK,OAAO,CAAC;AACb,WAAO,EAAE;AAAA,EACX;AAAA,EAEA,aAA4B;AAC1B,UAAM,IAAI,IAAa,KAAK,MAAM,OAAK,EAAE,QAAQ;AACjD,QAAI,MAAM;AAAW;AACrB,SAAK,OAAO,CAAC;AACb,WAAO,EAAE;AAAA,EACX;AAAA,EAEA,UAAyB;AACvB,UAAM,IAAI,IAAa,KAAK,MAAM,OAAK,EAAE,QAAQ;AACjD,QAAI,MAAM;AAAW;AACrB,WAAO,EAAE;AAAA,EACX;AAAA,EAEA,UAAyB;AACvB,UAAM,IAAI,IAAa,KAAK,MAAM,OAAK,EAAE,QAAQ;AACjD,QAAI,MAAM;AAAW;AACrB,WAAO,EAAE;AAAA,EACX;AACF;AAEO,SAAS,SACd,OAAmC,CAAC,GACV;AAC1B,SAAO,IAAI,gBAAgB,IAAI;AACjC;","names":["priority"]}