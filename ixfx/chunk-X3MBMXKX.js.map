{"version":3,"sources":["../src/collections/index.ts","../src/collections/stack/index.ts","../src/collections/stack/StackImmutable.ts"],"sourcesContent":["export {\n  circularArray,\n  type ICircularArray as CircularArray,\n} from './CircularArray.js';\nexport * as Trees from './tree/index.js';\nexport type * from './Types.js';\n\n/**\n * Stacks store items in order.\n *\n * Stacks and queues can be helpful for processing data in order. They each have slightly different behaviour.\n *\n * Like a stack of plates, the newest item (on top) is removed\n * before the oldest items (at the bottom). {@link Queues} operate differently, with\n * the oldest items (at the front of the queue) removed before the newest items (at the end of the queue).\n *\n * Create stacks with {@link Stacks.immutable} or {@link Stacks.mutable}. These return a {@link IStackImmutable} or {@link IStackMutable} respectively.\n *\n * The ixfx implementation allow you to set a capacity limit with three {@link StackDiscardPolicy |policies} for\n * how items are evicted.\n *\n */\nexport * as Stacks from './stack/index.js';\n\nexport { StackMutable } from './stack/StackMutable.js';\nexport { StackImmutable } from './stack/StackImmutable.js';\n\n/**\n * Sets store unique items.\n *\n * ixfx's {@link ISetImmutable} (or {@link ISetMutable}) compares items by value rather than reference, unlike the default JS implementation.\n *\n * Create using {@link Sets.immutable} or {@link Sets.mutable}\n */\nexport * as Sets from './set/index.js';\n\n\nexport { SetStringMutable } from './set/SetMutable.js';\nexport { SetStringImmutable } from './set/SetImmutable.js';\n\n\n/**\n * Queues store items in the order in which they are added.\n *\n * Stacks and queues can be helpful when it's necessary to process data in order, but each one has slightly different behaviour.\n *\n * Like lining up at a bakery, the oldest items (at the front of the queue) are removed\n * before the newest items (at the end of the queue). This is different to {@link Stacks},\n * where the newest item (on top) is removed before the oldest items (at the bottom).\n *\n * The ixfx implementations allow you to set a capacity limit with three {@link QueueDiscardPolicy | policies} for\n * how items are evicted.\n *\n * Create queues with {@link Queues.immutable} or {@link Queues.mutable}. These return a {@link IQueueImmutable} or {@link IQueueMutable} respectively.\n */\nexport * as Queues from './queue/index.js';\n\nexport { QueueMutable } from './queue/QueueMutable.js';\nexport { QueueImmutable } from './queue/QueueImmutable.js';\n\n/**\n * Maps associate keys with values. Several helper functions are provided\n * for working with the standard JS Map class.\n *\n * Import example\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/collections.js';\n * ```\n * \n * ixfx also includes {@link Maps.IMapMutable}, {@link Maps.IMapImmutable}\n *\n * Overview:\n * * {@link getOrGenerate}: Solves a common scenario of wanting a value by a particular key, or generating it if it doesn't exist\n * * {@link filter}: Yields values in map that match a predicate\n * * {@link find}: Finds the first value that matches a predicate, or _undefined_ if nothing found\n * * {@link hasAnyValue}: Searches through all keys, returning true if any occurence of _value_ was found\n *\n * Transformations:\n * * {@link toArray}: Returns the values of the map as an array\n * * {@link mapToArray}: Applies a function to convert a map's values to an array\n * * {@link toObject}: Coverts a Map to a plain object, useful for JSON serialising.\n * * {@link mapToObjectTransform}: Converts a map to a plain object, but applying a function to values\n * * {@link transformMap}: Like `Array.map`, but for Maps. Useful for generating a map as a transform of an input map.\n * * {@link zipKeyValue}: Given an array of keys and values, combines them together into a map\n */\nexport * as Maps from './map/index.js';\n\n\n","export type { IStack } from './IStack.js';\nexport type { IStackMutable } from './IStackMutable.js';\nexport type { IStackImmutable } from './IStackImmutable.js';\nexport { immutable } from './StackImmutable.js';\nexport { mutable } from './StackMutable.js';\nexport type * from './Types.js';","// -------------------------\n// Immutable\n// -------------------------\nimport type { IStackImmutable } from './IStackImmutable.js';\nimport { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nimport type { StackOpts } from './Types.js';\n\nexport class StackImmutable<V> implements IStackImmutable<V> {\n  private readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  push(...toAdd: ReadonlyArray<V>): StackImmutable<V> {\n    return new StackImmutable<V>(\n      this.opts,\n      push(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  pop(): IStackImmutable<V> {\n    return new StackImmutable<V>(this.opts, pop(this.opts, this.data));\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = <V>(\n  options: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackImmutable<V> => new StackImmutable({ ...options }, [ ...startingItems ]);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;;;ACOO,IAAM,iBAAN,MAAM,gBAAgD;AAAA,EAC1C;AAAA;AAAA,EAER;AAAA,EAET,YAAY,OAAkB,CAAC,GAAG,OAAyB,CAAC,GAAG;AAC7D,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,QAAQ,OAA4C;AAClD,WAAO,IAAI;AAAA,MACT,KAAK;AAAA,MACL,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG,KAAK;AAAA,IACrC;AAAA,EACF;AAAA,EAEA,MAA0B;AACxB,WAAO,IAAI,gBAAkB,KAAK,MAAM,IAAI,KAAK,MAAM,KAAK,IAAI,CAAC;AAAA,EACnE;AAAA,EAEA,QAAQ,IAA0B;AAChC,SAAK,KAAK,QAAQ,EAAE;AAAA,EACtB;AAAA,EAEA,eAAe,IAA0B;AACvC,KAAE,GAAG,KAAK,IAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE;AAAA,EACvC;AAAA,EAEA,IAAI,UAAmB;AACrB,WAAO,QAAQ,KAAK,MAAM,KAAK,IAAI;AAAA,EACrC;AAAA,EAEA,IAAI,SAAkB;AACpB,WAAO,OAAO,KAAK,MAAM,KAAK,IAAI;AAAA,EACpC;AAAA,EAEA,IAAI,OAAsB;AACxB,WAAO,KAAK,KAAK,MAAM,KAAK,IAAI;AAAA,EAClC;AAAA,EAEA,IAAI,SAAiB;AACnB,WAAO,KAAK,KAAK;AAAA,EACnB;AACF;AAyBO,IAAM,YAAY,CACvB,UAAqB,CAAC,MACnB,kBACoB,IAAI,eAAe,EAAE,GAAG,QAAQ,GAAG,CAAE,GAAG,aAAc,CAAC;","names":[]}