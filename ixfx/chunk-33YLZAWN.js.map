{"version":3,"sources":["../src/iterables/sync/Reduce.ts","../src/iterables/IterableSync.ts","../src/collections/stack/StackFns.ts","../src/collections/stack/StackMutable.ts","../src/collections/tree/TreeMutable.ts","../src/collections/tree/Compare.ts","../src/collections/tree/TraverseObject.ts","../src/IsPrimitive.ts"],"sourcesContent":["export function reduce<V>(\n  it: Iterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) start = f(start, v);\n  return start;\n}\n","import { type ToString, toStringDefault } from '../util/index.js';\nimport { type IsEqual } from '../util/IsEqual.js';\nimport { isIterable } from './Iterable.js';\nimport { intervalToMs } from '../flow/IntervalType.js';\nimport type { ToArrayOptions } from './Types.js';\nexport { slice } from './sync/Slice.js';\nexport { reduce } from './sync/Reduce.js';\n\nexport function* uniqueByValue<T>(input: Iterable<T>, toString: ToString<T> = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> {\n  for (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(\n  generator: Generator<number>,\n  defaultValue?: number\n) {\n\n  return (): number | undefined => {\n    const v: number | undefined = generator.next().value as number | undefined;\n    if (v === undefined) return defaultValue;\n    return v;\n  };\n}\n\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first<V>(it: Iterable<V>): V | undefined {\n  for (const value of it) {\n    return value;\n  }\n}\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last<V>(it: Iterable<V>): V | undefined {\n  //eslint-disable-next-line functional/no-let\n  let returnValue: V | undefined;\n  for (const value of it) {\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping<V>(it: Iterable<V>, size: number) {\n  if (size <= 1) throw new Error(`Size should be at least 2`);\n\n  //eslint-disable-next-line functional/no-let\n  let buffer: Array<V> = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      buffer = [ buffer.at(-1)! ];\n    }\n  }\n  if (buffer.length <= 1) return;\n\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport function* chunks<V>(it: Iterable<V>, size: number) {\n  //eslint-disable-next-line functional/no-let\n  let buffer = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\nexport function* concat<V>(...its: ReadonlyArray<Iterable<V>>) {\n  for (const it of its) yield* it;\n}\n\nexport function* dropWhile<V>(\n  it: Iterable<V>,\n  f: (v: V) => boolean\n) {\n  for (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it: Iterable<any>, callback: () => (void | boolean | never)) => {\n  for (const _ of it) {\n    const value = callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\nexport const next = <T>(it: Generator<T>) => {\n  return () => {\n    const r = it.next();\n    if (r.done) return;\n    return r.value;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(\n  it1: IterableIterator<V>,\n  it2: IterableIterator<V>,\n  equality?: IsEqual<V>\n) {\n  //it1 = it1[Symbol.iterator]();\n  //it2 = it2[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const index1 = it1.next(),\n      index2 = it2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport function every<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  for (const v of it) {\n    const result = f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\n\nexport function* fill<V>(it: Iterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n\n  //eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const _ of it) yield v;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach<V>(it: Iterable<V>, f: (v: V) => boolean | void) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    const result = f(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\nexport function find<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return v;\n  }\n}\n\nexport function* flatten<V>(it: Iterable<V>) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport function* map<V, X>(it: Iterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    yield f(v);\n  }\n}\n\nexport function* max<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b): Generator<V> {\n  let max: V | undefined;\n  for (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield max;\n      continue;\n    }\n    if (gt(v, max)) {\n      max = v;\n      yield max;\n    }\n  }\n  return max;\n}\n\nexport function* min<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n    }\n    if (gt(min, v)) {\n      min = v;\n      yield min;\n    }\n  }\n}\n\n\n\nexport function some<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return true;\n  }\n  return false;\n}\n\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\nexport function* repeat<T>(genCreator: () => Iterable<T>, repeatsOrSignal: number | AbortSignal): Generator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n\nexport function* unique<V>(\n  iterable: Iterable<V> | Array<Iterable<V>>\n) {\n  // Adapted from https://surma.github.io/underdash/\n  const buffer: Array<any> = [];\n  let itera: Array<Iterable<V>> = [];\n  itera = Array.isArray(iterable) ? iterable : [ iterable ];\n  for (const it of itera) {\n    for (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function* zip<V>(...its: ReadonlyArray<Iterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.iterator ]());\n\n  while (true) {\n    const vs = iits.map((it) => it.next());\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n\nexport function* fromIterable<T>(iterable: Iterable<T>) {\n  for (const v of iterable) {\n    yield v;\n  }\n}\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function toArray<V>(\n  it: Iterable<V>,\n  options: Partial<ToArrayOptions> = {}\n): Array<V> {\n  const result: Array<V> = [];\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n  for (const v of it) {\n    if (result.length >= maxItems) break;\n    if (Date.now() - started > maxElapsed) break;\n    result.push(v);\n  }\n  return result;\n}\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray<V>(array: Array<V>): Generator<V> {\n  for (const v of array) {\n    yield v;\n  }\n}","import type { StackOpts } from './Types.js';\n\nexport const trimStack = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = stack.length + toAdd.length;\n  const policy = opts.discardPolicy ?? `additions`;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  if (opts.debug) {\n    console.log(\n      `Stack.push: stackLen: ${ stack.length } potentialLen: ${ potentialLength } toRemove: ${ toRemove } policy: ${ policy }`\n    );\n  }\n  switch (policy) {\n    case `additions`: {\n      if (opts.debug) {\n        console.log(\n          `Stack.push:DiscardAdditions: stackLen: ${ stack.length } slice: ${ potentialLength - capacity\n          } toAddLen: ${ toAdd.length }`\n        );\n      }\n\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (stack.length === opts.capacity) {\n        return stack; // Completely full\n      } else {\n        // Only add some from the new array\n        return [ ...stack, ...toAdd.slice(0, toAdd.length - toRemove) ];\n      }\n    }\n    case `newer`: {\n      if (toRemove >= stack.length) {\n        // New items will completely flush out old\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n      } else {\n        // Keep some of the old (from 0)\n        //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n        if (opts.debug) {\n          console.log(` from orig: ${ JSON.stringify(stack.slice(0, stack.length - toRemove)) }`);\n        }\n        return [\n          ...stack.slice(0, stack.length - toRemove),\n          ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n        ];\n      }\n    }\n    case `older`: {\n      // Oldest item in stack is position 0\n      return [ ...stack, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown discard policy ${ policy }`);\n    }\n  }\n};\n\n// Add to top (last index)\nexport const push = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\n  //const mutated = [...stack, ...toAdd];\n  const potentialLength = stack.length + toAdd.length;\n\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n  const toReturn = overSize\n    ? trimStack(opts, stack, toAdd)\n    : [ ...stack, ...toAdd ];\n  return toReturn;\n};\n\n// Remove from top (last index)\nexport const pop = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (stack.length === 0) throw new Error(`Stack is empty`);\n  return stack.slice(0, - 1);\n};\n\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): V | undefined => stack.at(-1);\n\nexport const isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean =>\n  stack.length === 0;\n\nexport const isFull = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return stack.length >= opts.capacity;\n  }\n  return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\n\nimport type { IStackMutable } from './IStackMutable.js';\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\nimport type { StackOpts } from './Types.js';\n\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable<V> implements IStackMutable<V> {\n  readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  /**\n   * Push data onto the stack.\n   * If `toAdd` is empty, nothing happens\n   * @param toAdd Data to add\n   * @returns Length of stack\n   */\n  push(...toAdd: ReadonlyArray<V>): number {\n    if (toAdd.length === 0) return this.data.length;\n    this.data = push(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  pop(): V | undefined {\n    const v = peek(this.opts, this.data);\n    this.data = pop(this.opts, this.data);\n    return v;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = <V>(\n  opts: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackMutable<V> => new StackMutable({ ...opts }, [ ...startingItems ]);\n","import { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\"\nimport { without } from '../../data/arrays/Filter.js';\nimport { containsDuplicateInstances } from \"../../data/arrays/ContainsDuplicateInstances.js\";\nimport { QueueMutable } from \"../queue/QueueMutable.js\"\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { compare as treeCompare } from './Compare.js';\nimport { toStringAbbreviate } from \"../../Text.js\"\nimport type { LabelledSingleValue, TreeNode, SimplifiedNode, TraversableTree } from \"./Types.js\"\n\n/**\n * Compares two nodes.\n * \n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a \n * @param b \n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = <T>(a: TreeNode<T>, b: TreeNode<T>, eq?: IsEqual<T>) => {\n  return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n}\n\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n * \n * Recursive: strips parentage of all children and so on too.\n * @param node \n * @returns \n */\nexport const stripParentage = <T>(node: TreeNode<T>): SimplifiedNode<T> => {\n  const n: SimplifiedNode<T> = {\n    value: node.value,\n    childrenStore: node.childrenStore.map(c => stripParentage(c))\n  }\n  return n;\n}\n/**\n * Wraps a {@link TreeNode} for a more object-oriented means of access.\n */\nexport type WrappedNode<T> = TraversableTree<T> & {\n  /**\n   * Underlying Node\n   */\n  wraps: TreeNode<T>,\n  /**\n   * Gets value, if defined\n   * @returns Value of Node\n   */\n  getValue: () => T | undefined\n  /**\n   * Remove node and its children from tree\n   * @returns \n   */\n  remove: () => void\n  /**\n   * Adds a child node\n   * @param child \n   * @returns \n   */\n  add: (child: WrappedNode<T> | TreeNode<T>) => WrappedNode<T>\n  /**\n   * Adds a new child node, with `value` as its value\n   * @param value \n   * @returns \n   */\n  addValue: (value: T) => WrappedNode<T>\n  /**\n   * Returns _true_ if `child` is an immediate child of this node\n   * @param child \n   * @returns \n   */\n  hasChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  queryValue: (value: T) => IterableIterator<WrappedNode<T>>\n  /**\n   * Returns _true_ if `child` is contained any any descendant\n   * @param child\n   * @returns \n   */\n  hasAnyChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate parent for this node\n   * @param parent \n   * @returns \n   */\n  hasParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate or ancestor parent for this node\n   * @param parent \n   * @returns \n   */\n  hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n}\n\nconst unwrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node : wrap(node);\n\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns \n */\nexport const wrap = <T>(n: TreeNode<T>): WrappedNode<T> => {\n  return {\n    *children() {\n      for (const c of n.childrenStore) {\n        yield wrap(c)\n      }\n    },\n    getValue: () => n.value as T,\n    getIdentity: () => n,\n    *queryValue(value: T): IterableIterator<WrappedNode<T>> {\n      for (const v of queryByValue(value, unwrapped(n))) {\n        yield wrap(v);\n      }\n    },\n    getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n    hasParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasParent(n, unwrapped(parent));\n    },\n    hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyParent(n, unwrapped(parent));\n    },\n    hasChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasChild(unwrapped(child), n);\n    },\n    hasAnyChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyChild(unwrapped(child), n);\n    },\n    remove: () => {\n      remove(n);\n    },\n    addValue: (value: T): WrappedNode<T> => {\n      const nodeValue = addValue(value, n);\n      return wrap(nodeValue);\n    },\n    add: (child: WrappedNode<T> | TreeNode<T>): WrappedNode<T> => {\n      add(unwrapped(child), n);\n      return wrapped(child);\n    },\n    wraps: n\n  }\n}\n\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child \n * @returns \n */\nexport const remove = <T>(child: TreeNode<T>) => {\n  const p = child.parent;\n  if (p === undefined) return;\n  child.parent = undefined;\n  p.childrenStore = without(p.childrenStore, child);\n};\n\n/**\n * Depth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* depthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!root) return;\n  const stack = new StackMutable<TreeNode<T>>();\n  stack.push(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = stack.pop();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      stack.push(...entry.childrenStore);\n    }\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n  }\n}\n\n/**\n * Breadth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* breadthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!node) return;\n  const queue = new QueueMutable<TreeNode<T>>();\n  queue.enqueue(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = queue.dequeue();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      queue.enqueue(...entry.childrenStore);\n    }\n    if (queue.isEmpty) break;\n    entry = queue.dequeue();\n  }\n}\n\n/**\n * Validates the tree from `root` downwards.\n * @param root \n * @param seen \n * @returns \n */\nexport function treeTest<T>(root: TreeNode<T>, seen: Array<TreeNode<T>> = []): [ ok: boolean, msg: string, node: TreeNode<T> ] {\n  if (root.parent === root) return [ false, `Root has itself as parent`, root ];\n  if (seen.includes(root)) return [ false, `Same node instance is appearing further in tree`, root ];\n  seen.push(root);\n  if (containsDuplicateInstances(root.childrenStore)) return [ false, `Children list contains duplicates`, root ];\n\n  for (const c of root.childrenStore) {\n    if (c.parent !== root) return [ false, `Member of childrenStore does not have .parent set`, c ];\n    if (hasAnyChild(root, c)) return [ false, `Child has parent as its own child`, c ];\n    const v = treeTest(c, seen);\n    if (!v[ 0 ]) return v;\n  }\n  return [ true, ``, root ];\n}\n\n/**\n * Throws an exception if `root` fails tree validation\n * @param root \n * @returns \n */\nexport function throwTreeTest<T>(root: TreeNode<T>) {\n  const v = treeTest(root);\n  if (v[ 0 ]) return;\n  throw new Error(`${ v[ 1 ] } Node: ${ toStringAbbreviate(v[ 2 ].value, 30) }`, { cause: v[ 2 ] })\n}\n/**\n * Iterate over direct children of `root`\n * @param root \n */\nexport function* children<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  for (const c of root.childrenStore) {\n    yield c;\n  }\n}\n\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root \n */\nexport function* parents<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  let p = root.parent;\n  while (p) {\n    yield p;\n    p = p.parent;\n  }\n}\n\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node \n * @returns \n */\nexport function nodeDepth(node: TreeNode<any>): number {\n  const p = [ ...parents(node) ];\n  return p.length;\n}\n\nexport const hasChild = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of parent.childrenStore) {\n    if (c === child) return true;\n  }\n  return false;\n}\n\nexport const findChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): TreeNode<T> | undefined => {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) return c;\n  }\n}\n\nexport function* queryByValue<T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): IterableIterator<TreeNode<T>> {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) yield c;\n  }\n}\n\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n * \n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild \n * @param parent \n * @returns \n */\nexport const hasAnyChild = <T>(prospectiveChild: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of breadthFirst(parent)) {\n    if (c === prospectiveChild) return true;\n  }\n  return false;\n}\n\nexport const findAnyChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault) => {\n  for (const c of breadthFirst(parent)) {\n    if (eq(c.value as T, value)) return c;\n  }\n}\n\nexport const getRoot = <T>(node: TreeNode<T>): TreeNode<T> => {\n  if (node.parent) return getRoot(node.parent);\n  return node;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n * \n * Use {@link hasParent} to only check immediate parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasAnyParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  for (const p of parents(child)) {\n    if (p === prospectiveParent) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n * \n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  return child.parent === prospectiveParent;\n}\n\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root); \n * ```\n * @param node \n * @returns \n */\nexport const computeMaxDepth = <T>(node: TreeNode<T>) => {\n  return computeMaxDepthImpl(node, 0);\n}\n\nconst computeMaxDepthImpl = <T>(node: TreeNode<T>, startingDepth = 0) => {\n  let depth = startingDepth;\n  for (const c of node.childrenStore) {\n    depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n  }\n  return depth;\n}\n\nexport const add = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  throwAttemptedChild(child, parent);\n  //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n  //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n  const p = child.parent;\n  parent.childrenStore = [ ...parent.childrenStore, child ];\n  child.parent = parent;\n  if (p) {\n    p.childrenStore = without(p.childrenStore, child);\n  }\n}\n\nexport const addValue = <T>(value: T | undefined, parent: TreeNode<T>) => {\n  return createNode(value, parent);\n}\n\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value \n * @returns \n */\nexport const root = <T>(value?: T | undefined) => {\n  return createNode(value);\n}\n\nexport const fromPlainObject = (value: Record<string, any>, label = ``, parent?: TreeNode<any>, seen: Array<any> = []): TreeNode<LabelledSingleValue<any>> => {\n  const entries = Object.entries(value);\n  parent = parent === undefined ? root() : addValue<LabelledSingleValue<any>>({ label, value }, parent);\n  for (const entry of entries) {\n    const value = entry[ 1 ];\n    // Avoid circular references\n    if (seen.includes(value)) continue;\n    seen.push(value);\n\n    if (typeof entry[ 1 ] === `object`) {\n      fromPlainObject(value, entry[ 0 ], parent, seen);\n    } else {\n      addValue<LabelledSingleValue<any>>({ label: entry[ 0 ], value: value }, parent);\n    }\n  }\n  return parent;\n}\n\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link root} alternatively.\n * @param value \n * @returns \n */\nexport const rootWrapped = <T>(value: T | undefined) => {\n  return wrap(createNode(value));\n}\n\nexport const createNode = <T>(value: T | undefined, parent?: TreeNode<T> | undefined): TreeNode<T> => {\n  const n: TreeNode<T> = {\n    childrenStore: [],\n    parent: parent,\n    value: value\n  }\n  if (parent !== undefined) {\n    parent.childrenStore = [ ...parent.childrenStore, n ];\n  }\n  return n;\n}\n\nexport const childrenLength = <T>(node: TreeNode<T>): number => {\n  return node.childrenStore.length;\n}\n\nexport const value = <T>(node: TreeNode<T>): T | undefined => {\n  return node.value;\n}\n\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node \n * @returns \n */\nexport const asDynamicTraversable = <T>(node: TreeNode<T>): TraversableTree<T> => {\n  const t: TraversableTree<T> = {\n    *children() {\n      for (const c of node.childrenStore) {\n        yield asDynamicTraversable(c);\n      }\n    },\n    getParent() {\n      if (node.parent === undefined) return;\n      return asDynamicTraversable(node.parent);\n    },\n    getValue(): any {\n      return node.value;\n    },\n    getIdentity() {\n      return node;\n    },\n  }\n  return t;\n}\n\nconst throwAttemptedChild = <T>(c: TreeNode<T>, parent: TreeNode<T>) => {\n  if (parent === c) throw new Error(`Cannot add self as child`);\n  if (c.parent === parent) return; // skip if it's already a child\n  if (hasAnyParent(parent, c)) throw new Error(`Child contains parent (1)`, { cause: c });\n  if (hasAnyParent(c, parent)) throw new Error(`Parent already contains child`, { cause: c });\n  if (hasAnyChild(parent, c)) throw new Error(`Child contains parent (2)`, { cause: c });\n}\n\nexport const setChildren = <T>(parent: TreeNode<T>, children: Array<TreeNode<T>>) => {\n  // Verify children are legit\n  for (const c of children) {\n    throwAttemptedChild(c, parent);\n  }\n\n  parent.childrenStore = [ ...children ];\n  for (const c of children) {\n    c.parent = parent;\n  }\n}\n\nexport const toStringDeep = <T>(node: TreeNode<T>, indent = 0): string => {\n  const t = `${ `  `.repeat(indent) } + ${ node.value ? JSON.stringify(node.value) : `-` }`;\n  return node.childrenStore.length > 0 ? (\n    t +\n    `\\n` +\n    node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)\n  ) : t;\n}\n\nexport function* followValue<T>(root: TreeNode<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T | undefined> {\n  for (const c of root.childrenStore) {\n    const value = c.value;\n    if (value === undefined) continue;\n    if (continuePredicate(value, depth)) {\n      yield c.value;\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }","import { type IsEqual, isEqualValueIgnoreOrder } from \"../../util/IsEqual.js\";\nimport * as TreeMutable from './TreeMutable.js';\nimport type { TreeNode, TraversableTree } from './Types.js';\n\nexport type DiffAnnotation<T> = {\n  /**\n   * In the case of changes, this is old value\n   */\n  a: TraversableTree<T>\n  /**\n   * In the case of changes, this is the new value\n   */\n  b: TraversableTree<T>\n  /**\n   * If true, this node's value has been modified\n   */\n  valueChanged: boolean\n  /**\n   * If true, one of the child values has changed\n   */\n  childChanged: boolean\n  /**\n   * List of new children\n   */\n  added: Array<TraversableTree<T>>\n  /**\n   * List of removed children\n   */\n  removed: Array<TraversableTree<T>>\n}\n\nexport type DiffNode<T> = TreeNode<DiffAnnotation<T>> & {\n  toString: () => string\n};\n\nexport const compare = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder, parent?: DiffNode<T> | undefined): DiffNode<T> => {\n  const valueEqual = valueOrIdentityEqual(a, b, eq);\n  // if (!valueEqual) {\n  //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n  // }\n  const childrenCompare = compareChildren(a, b, eq);\n\n  const diff: DiffAnnotation<T> = {\n    valueChanged: !valueEqual, a, b,\n    added: childrenCompare.added,\n    removed: childrenCompare.removed,\n    childChanged: false\n  }\n  const diffNode: DiffNode<T> = {\n    value: diff,\n    childrenStore: [],\n    parent\n  }\n\n  const childrenDiff = childrenCompare.identical.map(c => compare(c[ 0 ], c[ 1 ], eq, diffNode));\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value!));\n  TreeMutable.setChildren(diffNode, childrenDiff);\n  //diffNode.childrenStore = childrenDiff;\n\n  diffNode.toString = () => toString(diffNode, 0);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  diffNode.value!.childChanged = someChildChange;\n  TreeMutable.throwTreeTest(diffNode);\n\n  return diffNode;\n}\n\nconst hasChange = (vv: DiffAnnotation<any>): boolean => {\n  if (vv === undefined) return false;\n  if (vv.valueChanged) return true;\n  if (vv.childChanged) return true;\n  if (vv.added.length > 0) return true;\n  if (vv.removed.length > 0) return true;\n  return false;\n}\n\n\nconst compareChildren = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder) => {\n  const childrenOfA = [ ...a.children() ];\n  const childrenOfB = [ ...b.children() ];\n\n  const identical: Array<[ a: TraversableTree<T>, b: TraversableTree<T> ]> = []\n  const removed: Array<TraversableTree<T>> = [];\n  for (const childA of childrenOfA) {\n    let foundIndex = -1;\n    for (const [ index, childOfB ] of childrenOfB.entries()) {\n      const d = valueOrIdentityEqual(childA, childOfB, eq);\n      if (d) {\n        identical.push([ childA, childOfB ]);\n        foundIndex = index;\n        break;\n      }\n    }\n    if (foundIndex === -1) {\n      // A's child not found in B's children\n      removed.push(childA);\n    } else {\n      // Found, remove it from list of B's children\n      childrenOfB.splice(foundIndex, 1);\n    }\n  }\n  const added = [ ...childrenOfB ];\n  return { added, identical, removed }\n}\n\nconst valueOrIdentityEqual = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T>): boolean => {\n  if (a.getIdentity() === b.getIdentity()) return true;\n  if (eq(a.getValue(), b.getValue())) return true;\n  return false;\n}\n\nconst toStringSingle = <T>(n: TraversableTree<T>) => {\n  return JSON.stringify(n.getValue());\n}\n\nconst toString = <T>(n: DiffNode<T>, indent = 0): string => {\n  if (n === undefined) return `(undefined)`;\n  let t = toStringDiff(n.value, indent);\n  for (const c of n.childrenStore) {\n    t += toString(c, indent + 2);\n  }\n  return t;\n}\n\nconst toStringDiff = <T>(n: DiffAnnotation<T> | undefined, indent: number): string => {\n  const spaces = ` `.repeat(indent);\n  if (n === undefined) return `${ spaces }(undefined)`;\n  const t = [];\n  t.push(`a: ${ toStringSingle(n.a) } b: ${ toStringSingle(n.b) }`);\n  if (n.valueChanged) t.push(`Value changed. Child changed: ${ n.childChanged }`);\n  else t.push(`Value unchanged. Child changed: ${ n.childChanged }`);\n\n  if (n.added.length > 0) {\n    t.push(`Added:`);\n    for (const c of n.added) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  if (n.removed.length > 0) {\n    t.push(`Removed: ${ n.removed.length }`);\n    for (const c of n.removed) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  t.push(`----\\n`)\n  return t.map(line => spaces + line).join(`\\n`);\n}","import { toStringAbbreviate } from '../../Text.js';\n\nimport { last } from '../../iterables/IterableSync.js';\nimport * as TreeArrayBacked from './TreeMutable.js';\nimport { isPrimitive } from '../../IsPrimitive.js';\nimport type { TraversableTree, TreeNode, SimplifiedNode } from './Types.js';\nimport { throwNullUndef } from '../../util/GuardEmpty.js';\nexport type Entry = Readonly<{ name: string, sourceValue: any, nodeValue: any }>;\nexport type EntryWithAncestors = Readonly<{ name: string, sourceValue: any, nodeValue: any, ancestors: Array<string> }>;\nexport type EntryStatic = Readonly<{ name: string, value: any, ancestors?: Array<string> }>\n\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n  /**\n   * Separator for path, eg '.'\n   */\n  readonly separator?: string;\n\n};\n\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link Entry}.\n * @param entries \n * @returns \n */\nexport function prettyPrintEntries(entries: ReadonlyArray<Entry>) {\n  if (entries.length === 0) return `(empty)`;\n  let t = ``;\n  for (const [ index, entry ] of entries.entries()) {\n    t += `  `.repeat(index);\n    t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n  }\n  return t;\n}\n\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const prettyPrint = (\n  node: object,\n  indent = 0,\n  options: Partial<ChildrenOptions> = {}\n): string => {\n  throwNullUndef(node, `node`);\n  const defaultName = options.name ?? `node`;\n  const entry = getNamedEntry(node, defaultName);\n  const t = `${ `  `.repeat(indent) } + name: ${ entry.name } value: ${ JSON.stringify(entry.nodeValue) }`;\n  const childrenAsArray = [ ...children(node, options) ];\n  return childrenAsArray.length > 0 ? (\n    t +\n    `\\n` +\n    childrenAsArray.map((d) => prettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)\n  ) : t;\n};\n\n/**\n * Returns a debug string representation of the node (recursive)\n * @param node \n * @param indent \n * @returns \n */\nexport const toStringDeep = (node: TreeNode<Entry | EntryStatic>, indent = 0) => {\n  let t = ` `.repeat(indent) + ` ${ node.value?.name }`;\n  if (node.value !== undefined) {\n    if (`sourceValue` in node.value && `nodeValue` in node.value) {\n      let sourceValue = toStringAbbreviate(node.value?.sourceValue, 20);\n      const nodeValue = toStringAbbreviate(node.value?.nodeValue, 20);\n      sourceValue = sourceValue === nodeValue ? `` : `source: ` + sourceValue;\n      t += ` = ${ nodeValue } ${ sourceValue }`\n    } else if (`value` in node.value && node.value.value !== undefined) t += ` = ${ node.value.value }`;\n\n    if (`ancestors` in node.value) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      t += ` (ancestors: ${ (node.value.ancestors!).join(`, `) })`;\n    }\n  }\n  t += `\\n`\n  for (const c of node.childrenStore) {\n    t += toStringDeep(c, indent + 1);\n  }\n  return t;\n}\n\nexport type ChildrenOptions = Readonly<{\n  filter: `none` | `leaves` | `branches`\n  name: string\n}>;\n\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays. \n * \n * Sub-children are included as an object blob.\n * \n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n * \n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n * \n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children: \n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n * \n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node \n * @param options  \n */\nexport function* children<T extends object>(\n  node: T,\n  options: Partial<ChildrenOptions> = {}\n): IterableIterator<Entry> {\n  throwNullUndef(node, `node`);\n\n  const filter = options.filter ?? `none`;\n\n  const filterByValue = (v: any): [ filter: boolean, isPrimitive: boolean ] => {\n    if (filter === `none`) return [ true, isPrimitive(v) ];\n    else if (filter === `leaves` && isPrimitive(v)) return [ true, true ];\n    else if (filter === `branches` && !isPrimitive(v)) return [ true, false ];\n    return [ false, isPrimitive(v) ];\n  }\n\n  if (Array.isArray(node)) {\n    //if (options.name === undefined) defaultName = `array`;\n    for (const [ index, element ] of node.entries()) {\n      const f = filterByValue(element);\n      if (f[ 0 ]) {\n        yield { name: index.toString(), sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n        //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n      }\n    }\n  } else if (typeof node === `object`) {\n    const entriesIter = (`entries` in node) ? (node as any as Map<any, any>).entries() : Object.entries(node);\n    for (const [ name, value ] of entriesIter) {\n      //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n      const f = filterByValue(value);\n      if (f[ 0 ]) {\n        yield { name: name, sourceValue: value, nodeValue: f[ 1 ] ? value : undefined };\n      }\n    }\n  }\n}\n\nexport function* depthFirst<T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: Array<string> = []): IterableIterator<EntryWithAncestors> {\n  for (const c of children(node, options)) {\n    //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n    yield { ...c, ancestors: [ ...ancestors ] };\n    yield* depthFirst(c.sourceValue, options, [ ...ancestors, c.name ]);\n  }\n}\n\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName<T extends object>(\n  name: string,\n  node: T\n): Entry | undefined {\n  for (const d of children(node)) {\n    if (d.name === name) return d;\n  }\n}\n\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Entry {\n  // ✔️ Unit tested\n  const v = last(traceByPath(path, node, options));\n  if (!v) throw new Error(`Could not trace path: ${ path } `);\n  return v;\n}\n\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n * \n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n * \n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Iterable<EntryWithAncestors> {\n  // ✔️ Unit tested\n  throwNullUndef(path, `path`);\n  throwNullUndef(node, `node`);\n\n  const separator = options.separator ?? `.`;\n  // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n  const pathSplit = path.split(separator);\n\n  const ancestors: Array<string> = [];\n  for (const p of pathSplit) {\n    const entry = childByName(p, node);\n    //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n    // if (allowArrayIndexes) {\n    //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n    //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n    //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n    //   if (arrayIndex >= 0) {\n    //     // Get array by name without the []\n    //     entry = childByName(withoutBrackets, node);\n    //     //onsole.log(`  entry: ${ entry?.name }`);\n    //     if (entry && Array.isArray(entry.sourceValue)) {\n    //       // Result was array as expected\n    //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], nodeValue: entry.sourceValue[ arrayIndex ] };\n    //     }\n    //   }\n    // }\n\n    if (!entry) {\n      yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n      return;\n    }\n    node = entry.sourceValue;\n    yield { ...entry, ancestors: [ ...ancestors ] };\n    ancestors.push(p);\n  }\n}\n\n/**\n * Returns a projection of `node` as a dynamic traversable.\n * This means that the tree structure is dynamically created as last-minute as possible.\n * \n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n * \n * ```js\n * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n * \n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n * \n * Instead .getIdentity() to get a stable identity:\n * ```js\n * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n * @param node \n * @param options\n * @param ancestors \n * @param parent \n * @returns \n */\nexport const asDynamicTraversable = <T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: Array<string> = [], parent?: TraversableTree<EntryStatic> | undefined): TraversableTree<EntryStatic> => {\n  const name = options.name ?? `object`;\n  const t: TraversableTree<EntryStatic> = {\n    *children() {\n      for (const c of children(node, options)) {\n        yield asDynamicTraversable(c.sourceValue, { ...options, name: c.name }, [ ...ancestors, name ], t);\n      }\n    },\n    getParent() {\n      return parent;\n    },\n    getValue() {\n      return { name, value: node, ancestors };\n    },\n    getIdentity() {\n      return node;\n    }\n  }\n  return t;\n}\n\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node \n * @param options \n * @returns \n */\nexport const createWrapped = <T extends object>(node: T, options: Partial<CreateOptions>): TreeArrayBacked.WrappedNode<any> => {\n  return TreeArrayBacked.wrap(create(node, options));\n};\n\nexport type CreateOptions = {\n  name: string\n  /**\n   * If _true_, only leaf nodes have values. This avoids repetition (important\n   * when comparing trees), with semantics being in the tree itself.\n   * \n   * When _false_ (default) values get decomposed down the tree. This\n   * makes it easy to get all the data for a branch of the tree.\n   * \n   * \n   * Eg if storing { person: { address { state: `qld` } } }\n   * When _true_, the tree would be:\n   * ```\n   * person, value: undefined\n   *  + address, value: undefined\n   *    + state, value: 'qld'\n   * ```\n   * But when _false_, the tree would be:\n   * ```\n   * person, value: { address: { state: `qld } }\n   *  + address, value: { state: `qld` }\n   *    + state, value: `qld`\n   * ```\n   */\n  valuesAtLeaves: boolean\n}\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure.\n * The structure is a snapshot of the object. If the object changes afterwards, the tree will\n * remain the same.\n * \n * Alternatively, consider {@link asDynamicTraversable} which reads the object dynamically.\n * @param node \n * @param options \n * @returns \n */\nexport const create = <T extends object>(node: T, options: Partial<CreateOptions> = {}): TreeNode<EntryStatic> => {\n  const valuesAtLeaves = options.valuesAtLeaves ?? false;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  const valueFor = valuesAtLeaves ? (v: any) => { if (isPrimitive(v)) return v; } : (v: any) => v;\n  return createImpl(node, valueFor(node), options, []);\n}\n\nconst createImpl = <T extends object>(sourceValue: T, nodeValue: T, options: Partial<CreateOptions> = {}, ancestors: Array<string>): TreeNode<EntryStatic> => {\n  const defaultName = options.name ?? `object_ci`;\n  //onsole.log(`createImpl name: ${ defaultName } nodeValue: ${ JSON.stringify(nodeValue) }`);\n  const r = TreeArrayBacked.root<EntryStatic>({ name: defaultName, value: nodeValue, ancestors: [ ...ancestors ] });\n  ancestors = [ ...ancestors, defaultName ];\n  for (const c of children(sourceValue, options)) {\n    const v = options.valuesAtLeaves ? c.nodeValue : c.sourceValue;\n    TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n  }\n  return r;\n}\n\n/**\n * Returns a copy of `node` with its (and all its children's) parent information removed.\n * @param node \n * @param options \n * @returns \n */\nexport const createSimplified = <T extends object>(node: T, options: Partial<CreateOptions> = {}): SimplifiedNode<EntryStatic> => {\n  return TreeArrayBacked.stripParentage(create(node, options));\n}\n\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry<T extends object>(node: T, defaultName = ``): Entry {\n  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node as Entry;\n  if (`name` in node) {\n    return { name: node.name as string, nodeValue: node, sourceValue: node };\n  }\n  return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n\n\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }","import type { Primitive, PrimitiveOrObject } from \"./PrimitiveTypes.js\";\n\n/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value: any): value is Primitive {\n  if (typeof value === `number`) return true;\n  if (typeof value === `string`) return true;\n  if (typeof value === `bigint`) return true;\n  if (typeof value === `boolean`) return true;\n  return false;\n}\n\nexport function isPrimitiveOrObject(value: any): value is PrimitiveOrObject {\n  if (isPrimitive(value)) return true;\n  if (typeof value === `object`) return true;\n  return false;\n}"],"mappings":"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","names":["toString","value","max","min","compare","compare","value","root","children","asDynamicTraversable","children","depthFirst","toStringDeep","value","children","toStringDeep","filter","value","depthFirst","asDynamicTraversable"]}