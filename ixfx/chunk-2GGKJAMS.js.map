{"version":3,"sources":["../src/data/ObjectTracker.ts","../src/data/PointTracker.ts","../src/data/TrackUnique.ts"],"sourcesContent":["import type { TimestampedObject, TrackedValueOpts } from './TrackedValue.js';\nimport { TrackerBase } from './TrackerBase.js';\n\n/**\n * A tracked value of type `V`.\n */\nexport abstract class ObjectTracker<V extends object, SeenResultType> extends TrackerBase<V, SeenResultType> {\n  //abstract onSeen(_p: Array<V>): SeenResultType;\n\n  values: Array<TimestampedObject<V>>;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    super(opts);\n    this.values = [];\n  }\n\n  onTrimmed() {\n    // no-op\n  }\n\n  /**\n   * Reduces size of value store to `limit`. \n   * Returns number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    // Index 0 will be the oldest\n    this.values = this.values.slice(-limit);\n    return this.values.length;\n  }\n\n  /**\n   * Allows sub-classes to be notified when a reset happens\n   * @ignore\n   */\n  onReset() {\n    this.values = [];\n  }\n\n  /**\n   * Tracks a value\n   * @ignore\n   */\n  filterData(p: Array<V> | Array<TimestampedObject<V>>): Array<TimestampedObject<V>> {\n    // Make sure values have a timestamp\n    const ts = p.map((v) =>\n      `at` in v\n        ? v\n        : {\n          ...v,\n          at: Date.now(),\n        }\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const last = ts.at(-1)!;\n\n    if (this.storeIntermediate) this.values.push(...ts);\n    else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last);\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last;\n        break;\n      }\n    }\n    return ts;\n  }\n\n  /**\n   * Last seen value. If no values have been added, it will return the initial value\n   */\n  get last() {\n    if (this.values.length === 1) return this.values[ 0 ];\n    //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.values.at(-1)!;\n  }\n\n  /**\n   * Returns the initial value\n   */\n  get initial() {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (includes the initial value in the count)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the initial value\n   */\n  get elapsed(): number {\n    return Date.now() - this.values[ 0 ].at;\n  }\n\n}\n","import * as Points from '../geometry/point/index.js';\nimport {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from './TrackedValue.js';\nimport { ObjectTracker } from './ObjectTracker.js';\nimport { length as LineLength } from '../geometry/line/Length.js';\nimport { Vectors } from '../geometry/index.js';\nimport { Empty as LinesEmpty } from '../geometry/line/index.js';\nimport type { Coord as PolarCoord } from '../geometry/Polar.js';\nimport type { Line, PolyLine } from '../geometry/line/LineType.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { PointRelation } from '../geometry/point/PointRelationTypes.js';\nimport { joinPointsToLines } from '../geometry/line/JoinPointsToLines.js';\nimport type { PointTrack, PointTrackerResults } from './Types.js';\n\n/**\n * Point tracker. Create via `pointTracker()`.\n *\n */\nexport class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n  /**\n   * Function that yields the relation from initial point\n   */\n  initialRelation: PointRelation | undefined;\n\n  /**\n   * Last result\n   */\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  onTrimmed(): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * Returns the last x coord\n   */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n  }\n\n  seenEvent(p: PointerEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      // @ts-expect-error\n      return this.seen({ x: p.clientX, y: p.clientY });\n    }\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: Array<TimestampedObject<Point>>\n  ): PointTrackerResults {\n    const currentLast = this.last;\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      this.initialRelation = Points.relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? Points.relation(currentLast) : Points.relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return LinesEmpty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length.\n   * @returns Distance\n   */\n  distanceFromStart(): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.distance(initial, this.last) : 0;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x & y.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Point {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.subtract(this.last, initial) : Points.Placeholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return Points.angle(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total length of accumulated points.\n   * Returns 0 if points were not saved, or there's only one\n   */\n  get length(): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return LineLength(l);\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class TrackedPointMap extends TrackedValueMap<\n  Point,\n  PointTracker,\n  PointTrackerResults\n> {\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  /**\n   * Track a PointerEvent\n   * @param event\n   */\n  seenEvent(event: PointerEvent): Promise<Array<PointTrackerResults>> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n      // eslint-disable-next-line unicorn/no-single-promise-in-promise-methods\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}\n\n/**\n * Track several named points over time, eg a TensorFlow body pose point.\n * Call `seen()` to track a point. Mutable. If you want to compare\n * a single coordinate with a reference coordinate,  may be a better choice.\n *\n * See also:\n * * [Geometry.Points.relation](Geometry.Points.relation.html): Compute relation info between two points\n * * [Data.pointTracker](Data.pointTracker-1.html): Track relation between points over time\n * * [Guide to Trackers](https://clinth.github.io/ixfx-docs/data/trackers/)\n * \n * Basic usage\n * ```js\n * import { pointsTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const pt = pointsTracker();\n *\n * // Track a point under a given id\n * document.addEventListener(`pointermove`, e => {\n *  const info = await pt.seen(e.pointerId, { x: e.x, y: e.y });\n *  // Yields some info on relation of the point to initial value\n * });\n * ```\n *\n * Do something with last values for all points\n * ```js\n * const c = Points.centroid(...Array.from(pt.last()));\n * ```\n *\n * More functions...\n * ```js\n * pt.size;       // How many named points are being tracked\n * pt.delete(id); // Delete named point\n * pt.reset();    // Clear data\n * ```\n *\n * Accessing by id:\n *\n * ```js\n * pt.get(id);  // Get named point (or _undefined_)\n * pt.has(id);  // Returns true if id exists\n * ```\n *\n * Iterating over data\n *\n * ```js\n * pt.trackedByAge(); // Iterates over tracked points, sorted by age (oldest first)\n * pt.tracked(); // Tracked values\n * pt.ids();     // Iterator over ids\n *\n * // Last received value for each named point\n * pt.last();\n *\n * pt.initialValues(); // Iterator over initial values for each point\n * ```\n *\n * You can work with 'most recently updated' points:\n *\n * ```js\n * // Iterates over points, sorted by age (oldest first)\n * pt.valuesByAge();\n * ```\n *\n * Options:\n * * `id`: Id of this tracker. Optional\n * * `sampleLimit`: How many samples to store\n * * `storeIntermediate`: If _true_, all points are stored internally\n * * `resetAfterSamples`: If set above 0, it will automatically reset after the given number of samples have been seen\n * @param options\n * @returns\n */\nexport const pointsTracker = (options: TrackOpts = {}) =>\n  new TrackedPointMap(options);\n\n/**\n * A tracked point. Create via {@link pointTracker}. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link pointsTracker}: Track several points, useful for multi-touch.\n * * [Guide to Trackers](https://clinth.github.io/ixfx-docs/data/trackers/)\n * \n * ```js\n * import { pointTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Create a tracker on a pointerdown\n * const t = pointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = pointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = pointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = pointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport const pointTracker = (opts: TrackOpts = {}) => new PointTracker(opts);\n","import { toStringDefault, type ToString } from \"../util/index.js\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link trackUniqueInstances}\n * \n * ```js\n * const t = trackUnique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = trackUnique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * \n * Return function throws an error if `value` is null or undefined.\n * @returns \n */\nexport const trackUnique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}\n\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link trackUnique} to track by value.\n */\nexport const trackUniqueInstances = <T>(): TrackUnique<T> => {\n\n  const set = new Set<T>();\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    if (set.has(value)) return false;\n    set.add(value);\n    return true;\n  }\n}"],"mappings":"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","names":[]}