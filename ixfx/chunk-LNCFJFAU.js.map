{"version":3,"sources":["../src/Immutable.ts"],"sourcesContent":["/** Utilities for working with immutable objects */\nimport JSON5 from 'json5';\nimport { isInteger, isPlainObjectOrPrimitive } from \"./Util.js\";\nimport * as TraversableObject from './collections/tree/TraverseObject.js';\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<any> = (a: any, b: any, _path: string): boolean => {\n  return JSON5.stringify(a) === JSON5.stringify(b);\n}\n\nexport type Change<V> = {\n  path: string\n  previous?: V\n  value: V\n}\n\nexport type CompareDataOptions<V> = {\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n}\n\n/**\n * Scans object, producing a list of changed fields.\n * \n * @param a \n * @param b \n * @param pathPrefix \n * @returns \n */\nexport const compareData = <V extends Record<string, any>>(a: V, b: V, pathPrefix = ``, options: Partial<CompareDataOptions<V>> = {}): Array<Change<any>> => {\n\n  const deepProbe = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const changes: Array<Change<any>> = [];\n\n  let entries: Array<[ key: string, value: any ]> = [];\n  if (deepProbe) {\n    for (const field in a) {\n      const value = (a as any)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n  } else {\n    entries = Object.entries(a);\n  }\n\n  //const isArray = Array.isArray(a);\n  for (const [ key, valueA ] of entries) {\n    if (typeof valueA === `object`) {\n      changes.push(...compareData(valueA, b[ key ], key + `.`, options));\n    } else {\n      const valueB = b[ key ];\n      const sub = pathPrefix + key;// isArray ? untilMatch(pathPrefix, `.`, { fromEnd: true }) + `[${ key }]` : pathPrefix + key;\n      //onsole.log(`sub: ${ sub } isArray: ${ isArray } pathPrefix: ${ pathPrefix } key: ${ key }`)\n      if (!eq(valueA, valueB, sub)) {\n        changes.push({ path: sub, previous: valueA, value: valueB });\n      }\n    }\n  }\n  return changes;\n}\n\n/**\n * Returns a copy of `a` with changes applied.\n * @param a \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(a: V, changes: Array<Change<any>>): V => {\n  for (const change of changes) {\n    a = updateByPath(a, change.path, change.value);\n  }\n  return a;\n}\n\n/**\n * Returns a copy of an object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * const a2 = updateByPath(a, `position.x`, 20);\n * ```\n * \n * If the path cannot be resolved, an exception is thrown\n * @param o \n * @param path \n * @param value \n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(o: V, path: string, value: any, createIfNecessary = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (o === undefined) throw new Error(`Parameter 'o' is undefined`);\n  if (o === null) throw new Error(`Parameter 'o' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(o, split, value, createIfNecessary);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: Array<string>, value: any, createIfNecessary: boolean): any => {\n  if (split.length === 0) return value;\n\n  const start = split.shift();\n  if (!start) return value;\n\n  // const arrayStart = start.indexOf(`[`);\n  // const arrayEnd = start.indexOf(`]`, arrayStart);\n  // if (arrayStart > 0 && arrayEnd > arrayStart) {\n  //   const field = start.slice(0, arrayStart);\n  //   const index = start.slice(arrayStart, arrayEnd + 1);\n  //   split.unshift(index);\n  //   const copy = { ...o };\n  //   copy[ field ] = updateByPathImpl(copy[ field ], split, value, createIfNecessary);\n  //   return copy;\n  // }\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) { //if (start.startsWith(`[`) && start.endsWith(`]`) && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, createIfNecessary);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, createIfNecessary);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): V => {\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' ought to be a string`);\n  if (path.length === 0) throw new Error(`Parameter 'path' is empty`);\n  if (object === undefined) throw new Error(`Parameter 'object' is undefined`);\n  if (object === null) throw new Error(`Parameter 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: Array<string>): V => {\n  if (object === undefined) throw new Error(`Parameter 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return object[ index ] as V;\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (start in object) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return object[ start ] as V;\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Maps the properties of an object through a map function.\n * That is, run each of the values of an object through a function, an return\n * the result.\n *\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObject(rect, (fieldValue) => {\n *  return fieldValue*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObject(rect, (fieldValue, fieldName) => {\n *  if (fieldName === 'width') return fieldValue*3;\n *  else if (typeof fieldValue === 'number') return fieldValue*2;\n *  return fieldValue;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of typesafety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObject(o, (value, key) => {\n *  return movingAverage(10);\n * });\n *\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const map = <\n  SourceType extends Record<string, any>,\n  DestinationFieldType,\n>(\n  // eslint-disable-next-line indent\n  object: SourceType,\n  // eslint-disable-next-line indent\n  mapFunction: (fieldValue: any, field: string, index: number) => DestinationFieldType\n  // eslint-disable-next-line indent\n): RemapObjectPropertyType<SourceType, DestinationFieldType> => {\n  type MapResult = [ field: string, value: DestinationFieldType ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction(sourceFieldValue, sourceField, index),\n  ]) as Array<MapResult>;\n  // @ts-expect-error\n  return Object.fromEntries(mapped);\n};\n\nexport type RemapObjectPropertyType<OriginalType, PropertyType> = {\n  readonly [ Property in keyof OriginalType ]: PropertyType;\n};\n\n/**\n * Returns a list of paths for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *   gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = getFieldPaths(d);\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data by this 'path' string.\n *\n * If object is _null_, and empty array is returned.\n * \n * If `onlyLeaves` is _true_, only leaf nodes are included. _false_ by default.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport const getPaths = (object: object | null, onlyLeaves = false): ReadonlyArray<string> => {\n  if (object === undefined) throw new Error(`Parameter 'object' is undefined`);\n  if (object === null) return []\n\n  const result: Array<string> = [];\n  const iter = TraversableObject.depthFirst(object);\n\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    result.push(path);\n  }\n  return result;\n\n};\n\n/**\n * Returns a representation of the object\n * @param o \n * @returns \n */\nexport const getPathsAndData = (o: object): Array<Change<any>> => {\n  if (o === null) return [];\n  if (o === undefined) return [];\n  const result: Array<Change<any>> = [];\n  getPathsAndDataImpl(o, ``, result);\n  return result;\n}\n\nconst getPathsAndDataImpl = (o: object, prefix: string, result: Array<Change<any>>) => {\n  if (typeof o === `object`) {\n    for (const entries of Object.entries(o)) {\n      const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n      result.push({ path: sub, value: entries[ 1 ] });\n      getPathsAndDataImpl(entries[ 1 ], sub, result);\n    }\n  }\n  return result;\n}"],"mappings":"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","names":["JSON5"]}