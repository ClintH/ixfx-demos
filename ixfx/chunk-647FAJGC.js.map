{"version":3,"sources":["../src/numbers/Quantise.ts","../src/numbers/LinearSpace.ts"],"sourcesContent":["import { throwIntegerTest, throwNumberTest } from \"../util/GuardNumbers.js\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyStr = every.toString();\n  const decimal = everyStr.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    let d = everyStr.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n  throwNumberTest(v, ``, `v`);\n  throwIntegerTest(every, ``, `every`);\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { round } from \"./Round.js\";\n\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(\n  start: number,\n  end: number,\n  steps: number,\n  precision?: number\n): IterableIterator<number> {\n  throwNumberTest(start, ``, `start`);\n  throwNumberTest(end, ``, `end`);\n\n  throwNumberTest(steps, ``, `steps`);\n  const r = precision ? round(precision) : (v: number) => v;\n  const step = (end - start) / (steps - 1);\n\n  throwNumberTest(step, ``, `step`);\n  if (!Number.isFinite(step)) {\n    throw new TypeError(`Calculated step value is infinite`);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < steps; index++) {\n    const v = start + step * index;\n    yield r(v);\n  }\n}\n"],"mappings":";;;;;;;;;AAwBO,IAAM,gBAAgB,CAC3B,GACA,OACA,iBAAiB,SACd;AAEH,QAAM,WAAW,MAAM,SAAS;AAChC,QAAM,UAAU,SAAS,QAAQ,GAAG;AACpC,MAAI,aAAa;AACjB,MAAI,WAAW,GAAG;AAChB,QAAI,IAAI,SAAS,UAAU,UAAU,CAAC,EAAE;AACxC,iBAAa,KAAK;AAClB,YAAQ,KAAK,MAAM,aAAa,KAAK;AACrC,QAAI,IAAI;AAAA,EACV;AACA,kBAAgB,GAAG,IAAI,GAAG;AAC1B,mBAAiB,OAAO,IAAI,OAAO;AAEnC,MAAI,MAAM,IAAI;AACd,QAAM,YAAY,MAAM;AACxB,QAAM,KAAK,MAAM,GAAG;AACpB,MAAK,cAAc,OAAO,kBAAmB,YAAY,IAAK;AAC9D,QAAM,KAAM,QAAQ,MAAO;AAC3B,SAAO;AACT;;;ACzBO,UAAU,YACf,OACA,KACA,OACA,WAC0B;AAC1B,kBAAgB,OAAO,IAAI,OAAO;AAClC,kBAAgB,KAAK,IAAI,KAAK;AAE9B,kBAAgB,OAAO,IAAI,OAAO;AAClC,QAAM,IAAI,YAAY,MAAM,SAAS,IAAI,CAAC,MAAc;AACxD,QAAM,QAAQ,MAAM,UAAU,QAAQ;AAEtC,kBAAgB,MAAM,IAAI,MAAM;AAChC,MAAI,CAAC,OAAO,SAAS,IAAI,GAAG;AAC1B,UAAM,IAAI,UAAU,mCAAmC;AAAA,EACzD;AAGA,WAAS,QAAQ,GAAG,QAAQ,OAAO,SAAS;AAC1C,UAAM,IAAI,QAAQ,OAAO;AACzB,UAAM,EAAE,CAAC;AAAA,EACX;AACF;","names":[]}