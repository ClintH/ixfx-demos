{"version":3,"sources":["../src/rx/index.ts","../src/rx/Util.ts","../src/rx/sources/Function.ts","../src/rx/sources/Iterator.ts","../src/rx/ResolveSource.ts","../src/rx/InitStream.ts","../src/rx/ToReadable.ts","../src/rx/ops/Annotate.ts","../src/rx/ops/Batch.ts","../src/rx/ops/Transform.ts","../src/rx/ops/CloneFromFields.ts","../src/rx/ops/CombineLatestToArray.ts","../src/rx/ops/CombineLatestToObject.ts","../src/rx/ops/Debounce.ts","../src/rx/ops/Field.ts","../src/rx/ops/Filter.ts","../src/rx/ops/Pipe.ts","../src/rx/ops/SingleFromArray.ts","../src/rx/ops/Split.ts","../src/rx/ops/Switcher.ts","../src/rx/ops/SyncToArray.ts","../src/rx/ops/SyncToObject.ts","../src/rx/ops/Throttle.ts","../src/rx/ops/TimeoutTrigger.ts","../src/rx/ops/WithValue.ts","../src/data/graphs/DirectedGraph.ts","../src/data/Table.ts","../src/rx/Graph.ts","../src/rx/Types.ts","../src/rx/ToArray.ts","../src/rx/ToGenerator.ts","../src/rx/Wrap.ts","../src/rx/Count.ts","../src/rx/Dom.ts","../src/text/Segments.ts","../src/data/index.ts","../src/data/Normalise.ts","../src/data/FrequencyMutable.ts","../src/flow/RateMinimum.ts","../src/data/MovingAverage.ts","../src/data/IntervalTracker.ts","../src/data/ObjectTracker.ts","../src/data/PointTracker.ts","../src/data/Flip.ts","../src/data/graphs/index.ts","../src/data/graphs/UndirectedGraph.ts","../src/data/TrackUnique.ts","../src/data/ResolveFields.ts","../src/data/Bipolar.ts","../src/data/Correlate.ts","../src/data/Pool.ts","../src/visual/index.ts","../src/visual/Drawing.ts","../src/visual/Plot2.ts","../src/visual/SceneGraph.ts","../src/visual/ScaleCanvas.ts","../src/dom/DomRx.ts","../src/dom/CanvasSizing.ts","../src/visual/Palette.ts","../src/visual/BipolarView.ts","../src/visual/PlotOld.ts","../src/dom/index.ts","../src/dom/ShadowDom.ts","../src/dom/Log.ts","../src/dom/Util.ts","../src/dom/DataTable.ts","../src/dom/DataDisplay.ts","../src/dom/ElementSizing.ts","../src/dom/PointerVisualise.ts","../src/dom/ErrorHandler.ts","../src/dom/DragDrop.ts","../src/dom/InlineConsole.ts","../src/dom/CssVariables.ts","../src/dom/CanvasHelper.ts","../src/dom/Query.ts","../src/rx/sources/Object.ts","../src/rx/sources/index.ts","../src/rx/sources/Array.ts","../src/rx/sources/ArrayObject.ts","../src/rx/sources/Boolean.ts","../src/rx/sources/Event.ts","../src/rx/sources/FunctionPinged.ts","../src/rx/sources/Number.ts","../src/rx/sources/ObjectProxy.ts","../src/rx/sources/Observable.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/unbound-method */\n//#region imports\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet, ReactiveInitial, ReactiveDisposable } from \"./Types.js\";\n\nimport { isDisposable, messageHasValue, messageIsDoneSignal, opify } from \"./Util.js\";\nimport * as OpFns from './ops/index.js';\nimport { initStream } from \"./InitStream.js\";\nimport { type Interval, intervalToMs } from '../flow/IntervalType.js';\nimport { resolveSource } from './ResolveSource.js';\nimport type { BatchOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/Types.js\";\nimport type { TimeoutTriggerOptions } from \"./sources/Types.js\";\n//#endregion\n\n//#region exports\nexport * from './ops/index.js';\nexport * from './Graph.js';\nexport * from './Types.js';\nexport * from './ToArray.js';\nexport * from './ToGenerator.js';\nexport * from './Util.js';\nexport * from './Wrap.js';\nexport * from './ResolveSource.js';\nexport * from './Count.js';\nexport * as Dom from './Dom.js';\nexport * as From from './sources/index.js';\n//#endregion\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    value: events.value\n  };\n}\n\nexport const Ops = {\n  /**\n * Annotates values.\n * \n * For every value `input` emits, run it through `transformer`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param transformer \n * @returns \n */\n  annotate: <V, TAnnotation>(transformer: (input: V) => V & TAnnotation) => opify(OpFns.annotate, transformer),\n  /**\n   * Annotates all values with the elapsed time since the last value\n   * @returns \n   */\n  annotateElapsed: <V>() => opify<V>(OpFns.annotateElapsed),\n\n  /**\n   * Takes a stream of values and batches them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  batch: <V>(options: Partial<BatchOptions>): ReactiveOp<V, Array<V>> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.batch(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.debounce(source, options);\n    }\n  },\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <V extends object>(fieldName: keyof V, options: FieldOptions<V>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate \n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n\n  pipe: <TInput, TOutput>(...streams: Array<Reactive<any> & ReactiveWritable<any>>) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<Array<V>>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: Array<string>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutTrigger: <V, TTriggerValue>(options: TimeoutTriggerOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutTrigger<V, TTriggerValue>(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out)): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n/**\n * Connects `ops` together, ready for a source.\n * Returns a function that takes a `source`.\n * @param ops \n * @returns \n */\nconst prepareOps = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    for (const op of ops) {\n      // @ts-expect-error\n      source = op(source);\n    }\n    return source as any as Reactive<TOut>;\n  }\n}\n\n\n/**\n * Connects `source` to serially-connected set of ops. Values thus\n * flow from `source` to each op in turn.\n * \n * Returned result is the final reactive.\n * \n * @param source \n * @param ops \n * @returns \n */\nexport function run<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>) {\n  const raw = prepareOps<TIn, TOut>(...ops);\n  return raw(source);\n}\n\nexport function cache<T>(r: Reactive<T>, initialValue: T) {\n  let lastValue: T | undefined = initialValue;\n  r.value(value => {\n    lastValue = value;\n  });\n  return {\n    ...r,\n    last() {\n      return lastValue\n    },\n    reset() {\n      lastValue = undefined;\n    }\n  }\n\n}\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.value(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n/**\n * Connects reactive A to B, passing through a transform function.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      b.set(transform(message.value));\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        if (isDisposable<any>(b)) {\n          b.dispose(`Source closed (${ message.context ?? `` })`);\n        } else {\n          console.warn(`Reactive.to cannot close 'b' reactive since it is not disposable`);\n        }\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      console.warn(`Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}","import { isIterable } from \"../iterables/Iterable.js\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveDisposable, ReactiveInitial, ReactiveOrSource, ReactiveWritable, Wrapped } from \"./Types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./sources/Types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last`) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  return (`on` in rx && `value` in rx)\n}\n\nexport const isDisposable = <V>(v: Reactive<V> | ReactiveWritable<V>): v is ReactiveDisposable<V> => {\n  return (`isDisposed` in v && `dispose` in v);\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotateElapsed` in v)) return false;\n  return true;\n}\n\nexport const opify = <V>(fn: (source: ReactiveOrSource<V>, ...args: Array<any>) => Reactive<V>, ...args: Array<any>) => {\n  return (source: ReactiveOrSource<V>) => {\n    return fn(source, ...args);\n  }\n}\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./Types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * See also {@link Rx.From.pinged} to trigger a function whenever another Reactive emits a value.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}) {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const interval = intervalToMs(options.interval, 1);\n  const loop = options.interval !== undefined;\n  const predelay = intervalToMs(options.predelay, 1);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  if (options.maximumRepeats && !loop) throw new Error(`'maximumRepeats' has no purpose if 'loop' is not set to true`);\n\n\n\n  // const events = initStream<V>({\n  //   onFirstSubscribe() {\n  //     if (run.runState === `idle`) run.start();\n  //   },\n  //   onNoSubscribers() {\n  //     console.log(`Rx.fromFunction onNoSubscribers. lazy: ${ lazy }`);\n  //     if (lazy === `very`) {\n  //       run.cancel();\n  //     }\n  //   },\n  // })\n\n  const done = (reason: string) => {\n    //console.log(`Rx.fromFunction done ${ reason }`);\n    events.dispose(reason);\n    run.cancel();\n  }\n\n  const run = continuously(async () => {\n    if (predelay) await sleep(predelay);\n\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      events.set(value);\n      sentResults++;\n\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n      }\n    }\n    if (!loop) {\n      done(`fromFunction done`);\n      return false; // Stop loop\n    }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false; // Stop loop\n    }\n\n  }, interval);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      run.start();\n    },\n    onStop() {\n      run.cancel();\n    },\n  });\n\n  if (lazy === `never`) run.start();\n  return events;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { nextWithTimeout } from \"../../iterables/IterableAsync.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { isAsyncIterable } from \"../../iterables/Iterable.js\";\nimport type { Reactive, ReactiveDisposable } from \"../Types.js\";\nimport type { GeneratorOptions } from \"./Types.js\";\nimport { StateMachine } from \"../../flow/index.js\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.value(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | Array<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): ReactiveDisposable<V> & Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.Generator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n    // eslint-disable-next-line unicorn/no-null\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      // @ts-expect-error\n      const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc?.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.fromGenerator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isAsyncIterable, isIterable } from \"../iterables/Iterable.js\";\nimport { func } from \"./sources/Function.js\";\nimport { iterator } from \"./sources/Iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./sources/Types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./Types.js\";\nimport { isReactive, isWrapped } from \"./Util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import { type Dispatch, DispatchList } from \"../flow/DispatchList.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport type { InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./Types.js\";\nimport { messageHasValue, messageIsSignal } from \"./Util.js\";\n\n/**\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport const initUpstream = <In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>) => {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n\n  const start = () => {\n    if (unsub !== undefined) return;\n\n    if (options.onStart) options.onStart();\n    unsub = source.on(value => {\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          stop();\n          if (disposeIfSourceDone) events.dispose(`Upstream source has completed (${ value.context ?? `` })`);\n        } else {\n          events.through(value);\n        }\n      } else if (messageHasValue(value)) {\n        onValue(value.value);\n      }\n    });\n  }\n\n  const stop = () => {\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart() {\n      start();\n    },\n    onStop() {\n      stop();\n    }\n  });\n  return events;\n}\n\n\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) onStart();\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) onStop();\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n/**\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    reset: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    through: (pass: Passed<V>) => {\n      if (disposed) throw new Error(`Disposed, cannot through`);\n      dispatcher?.notify(pass)\n    },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    value: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { ReactiveDisposable, ReactiveStream } from \"./Types.js\";\n\nexport const toReadable = <V>(upstream: ReactiveStream<V>): ReactiveDisposable<V> => ({\n  on: upstream.on,\n  dispose: upstream.dispose,\n  isDisposed: upstream.isDisposed,\n  value: upstream.value\n});\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts, AnnotationElapsed } from \"./Types.js\";\n\n/**\n * Annotates values from `source`, appending new fields to values.\n * Output stream will be the type `In & Out`.\n */\nexport function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, transformer: (value: In) => In & TAnnotation, options: Partial<TransformOpts> = {}): Reactive<In & TAnnotation> {\n  const upstream = initUpstream<In, In & TAnnotation>(input, {\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n/**\n * Annotates values from `source`, adding a `elapsedMs` field to values.\n * Elapsed will be the time in milliseconds since the last value. If it is the first value, -1 is used.\n * @param input \n * @param transformer \n * @param options \n * @returns \n */\nexport const annotateElapsed = <In>(input: ReactiveOrSource<In>) => {\n  let last = 0;\n  return annotate<In, AnnotationElapsed>(input, (value) => {\n    const elapsed = last === 0 ? 0 : Date.now() - last;\n    last = Date.now();\n    return { ...value, elapsedMs: elapsed };\n  });\n}","import { QueueMutable } from \"../../collections/index.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { BatchOptions } from \"./Types.js\";\n\n/**\n * Queue from `source`, emitting when thresholds are reached. \n * The resulting Reactive produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in batches of 5 items\n * batch(source, { quantity: 5 });\n * // Emit data every second\n * batch(source, { elapsed: 1000 });\n * ```\n * @param batchSource \n * @param options \n * @returns \n */\nexport function batch<V>(batchSource: ReactiveOrSource<V>, options: Partial<BatchOptions> = {}): Reactive<Array<V>> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  //const logic = options.logic ?? `or`;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  //let lastFire = performance.now();\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      if (timer !== undefined && timer.runState === `idle`) {\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(batchSource, upstreamOpts);\n\n  const send = () => {\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    upstream.set(data);\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      upstream.set(t);\n    },\n  })\n\n  return toReadable(upstream);\n}","import { isPlainObjectOrPrimitive } from \"../../Util.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param input \n * @returns \n */\nexport const cloneFromFields = <In>(source: ReactiveOrSource<In>) => {\n  return transform<In, In>(source, (v): In => {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in v) {\n      const value = (v)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return Object.fromEntries(entries) as In;\n  })\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../Util.js\";\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n * \n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.value(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]  \n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): Reactive<RxValueTypes<T>> {\n  const event = initStream<RxValueTypes<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  const sources = reactiveSources.map(source => resolveSource(source));\n  const noop = () => {/** no-op */ };\n  const sourceOff = sources.map(_ => noop);\n  const doneSources = sources.map(_ => false);\n\n  const unsub = () => {\n    for (const v of sourceOff) { v() }\n  }\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    sourceOff[ index ] = v.on(message => {\n      if (messageIsDoneSignal(message)) {\n        doneSources[ index ] = true;\n        sourceOff[ index ]();\n        sourceOff[ index ] = noop;\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is set`);\n          return;\n        }\n        if (!doneSources.includes(false)) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        data[ index ] = message.value;\n        event.set([ ...data ] as RxValueTypes<T>);\n      }\n    });\n  }\n\n  return {\n    on: event.on,\n    value: event.value\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { Maps } from \"../../collections/index.js\"\nimport { initStream } from \"../InitStream.js\"\nimport { resolveSource } from \"../ResolveSource.js\"\nimport type { ReactiveOrSource, CombineLatestOptions, ReactiveDisposable, Reactive, RxValueTypeObject } from \"../Types.js\"\nimport { messageIsDoneSignal, messageHasValue, isDisposable } from \"../Util.js\"\n\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n * \n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n * \n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.value(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): ReactiveDisposable<RxValueTypeObject<T>> & Reactive<RxValueTypeObject<T>> {\n  type State<V> = {\n    source: Reactive<V>\n    done: boolean\n    data: V | undefined\n    off: () => void\n  }\n  const disposeSources = options.disposeSources ?? true;\n  const event = initStream<RxValueTypeObject<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n\n  const states = new Map<string, State<any>>();\n  for (const [ key, source ] of Object.entries(reactiveSources)) {\n    const s: State<any> = {\n      source: resolveSource(source),\n      done: false,\n      data: undefined,\n      off: () => { /** no-op */ }\n    }\n    states.set(key, s);\n  }\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const someUnfinished = () => Maps.some(states, v => !v.done);\n\n  const unsub = () => {\n    //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n    for (const state of states.values()) state.off();\n  }\n\n  const getData = (): RxValueTypeObject<T> => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      (r as any)[ key ] = state.data;\n    }\n    return r as RxValueTypeObject<T>;\n  }\n\n  for (const state of states.values()) {\n    //console.log(`Rx.MergeToObject loop`);\n    state.off = state.source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        state.done = true;\n        state.off();\n        state.off = () => {/**no-op */ }\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is behaviour`);\n          return;\n        }\n        if (!someUnfinished()) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        state.data = message.value;\n        event.set(getData());\n      }\n    });\n  }\n\n  return {\n    on: event.on,\n    value: event.value,\n    dispose(reason: string) {\n      unsub();\n      event.dispose(reason);\n      if (disposeSources) {\n        for (const v of states.values()) {\n          if (isDisposable(v.source)) {\n            v.source.dispose(`Part of disposed mergeToObject`)\n          }\n        }\n      }\n    },\n    isDisposed() {\n      return event.isDisposed()\n    },\n  }\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { DebounceOptions } from \"./Types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FieldOptions } from \"./Types.js\";\n\n\n\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n * \n * If a source value doesn't have that field, it is skipped.\n *\n * @returns \n */\nexport function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options: Partial<FieldOptions<TFieldType>> = {}): Reactive<TFieldType> {\n  const handleMissing = `missingFieldDefault` in options;\n  const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      if (fieldName in value) {\n        upstream.set(value[ fieldName ] as TFieldType);\n      } else {\n        if (handleMissing) {\n          upstream.set(options.missingFieldDefault as TFieldType);\n        }\n      }\n    },\n  })\n  return toReadable(upstream);\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FilterPredicate } from \"./Types.js\";\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { PipeSet, Reactive, ReactiveDisposable, Passed } from \"../Types.js\";\nimport { isDisposable, messageHasValue, messageIsDoneSignal } from \"../Util.js\";\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> & ReactiveDisposable<TOutput> => {\n  const event = initStream<TOutput>();\n  const unsubs: Array<() => void> = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (isDisposable(s) && !s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    value: event.value,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}","import { shuffle } from \"../../collections/arrays/index.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport type { SingleFromArrayOptions } from \"./Types.js\";\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<Array<V>>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: Array<V>) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<Array<V>, V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, ReactiveStream, Reactive } from \"../Types.js\";\nimport type { SplitOptions } from \"./Types.js\";\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param source \n * @param quantity \n * @returns \n */\nexport const split = <T>(r: ReactiveOrSource<T>, options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  const outputs: Array<ReactiveStream<T>> = [];\n  const source = resolveSource(r);\n  for (let index = 0; index < quantity; index++) {\n    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n  }\n  return outputs;\n}\n\n/**\n * Splits `source` into several duplicated streams. \n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const [a,b,c] = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param source \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(r: ReactiveOrSource<T>, labels: Array<K>): Record<K, Reactive<T>> => {\n  const source = resolveSource(r);\n  const t: Partial<Record<K, Reactive<T>>> = {}\n  for (const label of labels) {\n    t[ label ] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n  }\n  return t as Record<K, Reactive<T>>;\n}","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveStream } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./Types.js\";\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options: Partial<SwitcherOptions> = {}): Record<TLabel, Reactive<TValue>> => {\n  // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n  const match = options.match ?? `first`;\n  const source = resolveSource(reactiveOrSource);\n  let disposed = false;\n  // Setup output streams\n  const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n  for (const label of Object.keys(cases)) {\n    (t as any)[ label ] = initStream<TValue>();\n  }\n\n  const performDispose = () => {\n    if (disposed) return;\n    unsub();\n    disposed = true;\n    for (const stream of Object.values(t)) {\n      (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n    }\n  }\n\n  // Listen to source\n  const unsub = source.on(message => {\n    // Got a value\n    if (messageHasValue(message)) {\n      for (const [ lbl, pred ] of Object.entries(cases)) {\n        if (pred(message.value)) {\n          ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n          if (match === `first`) break;\n        }\n      }\n    } else if (messageIsDoneSignal(message)) {\n      performDispose();\n    }\n  })\n  return t as Record<TLabel, Reactive<TValue>>;\n  // }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsSignal } from \"../Util.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypes<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const maximumWait = intervalToMs(options.maximumWait, 2000);\n\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  type State<V> = {\n    done: boolean,\n    finalData: V | undefined,\n    source: Reactive<V>\n    unsub: () => void\n  }\n\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  //const finalData: Array<RxValueTypes<T> | undefined> = [];\n\n  // Resolve sources\n  //const sources = reactiveSources.map(source => resolveSource(source));\n  //const noop = () => {/*no-op*/ }\n  //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n\n  const states: Array<State<any>> = reactiveSources.map(source => ({\n    finalData: undefined,\n    done: false,\n    source: resolveSource(source),\n    unsub: () => {/**no-op */ }\n  }));\n\n\n  const unsubscribe = () => {\n    for (const s of states) {\n      s.unsub();\n      s.unsub = () => {/**no-op */ }\n    }\n  }\n\n  const isDataSetComplete = () => {\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < data.length; index++) {\n      if (onSourceDone === `allow` && states[ index ].done) continue;\n      if (data[ index ] === undefined) return false;\n    }\n    return true;\n  }\n\n  const hasIncompleteSource = () => states.some(s => !s.done);\n  const resetDataSet = () => {\n    for (let index = 0; index < data.length; index++) {\n      if (finalValue === `last` && states[ index ].done) continue; // Don't overwrite\n      data[ index ] = undefined;\n    }\n  }\n\n  const onWatchdog = () => {\n    done(`Sync timeout exceeded (${ maximumWait.toString() })`);\n  }\n\n  const done = (reason: string) => {\n    if (watchdog) clearTimeout(watchdog);\n    unsubscribe();\n    event.dispose(reason);\n  }\n\n  const init = () => {\n    watchdog = setTimeout(onWatchdog, maximumWait);\n\n    for (const [ index, state ] of states.entries()) {\n      data[ index ] = undefined; // init array positions to be undefined\n\n      state.unsub = state.source.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            state.finalData = data[ index ];\n            state.unsub();\n            state.done = true;\n            state.unsub = () => { /** no-op */ }\n            if (finalValue === `undefined`) data[ index ] = undefined;\n            if (onSourceDone === `break`) {\n              done(`Source '${ index.toString() }' done, and onSourceDone:'break' is set`);\n              return;\n            }\n            if (!hasIncompleteSource()) {\n              done(`All sources done`);\n              return;\n            }\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (isDataSetComplete()) {\n          // All array elements contain values\n          // Emit data and reset\n          event.set([ ...data ] as RxValueTypes<T>);\n          resetDataSet();\n          if (watchdog) clearTimeout(watchdog);\n          watchdog = setTimeout(onWatchdog, maximumWait);\n        }\n      });\n    }\n  }\n\n  const event = initStream<RxValueTypes<T>>({\n    onFirstSubscribe() {\n      unsubscribe();\n      init();\n    },\n    onNoSubscribers() {\n      if (watchdog) clearTimeout(watchdog);\n      unsubscribe();\n\n    },\n  });\n\n  return {\n    on: event.on,\n    value: event.value\n  }\n\n}\n","import { zipKeyValue } from \"../../collections/map/MapFns.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../Types.js\";\nimport { syncToArray } from \"./SyncToArray.js\";\nimport { transform } from \"./Transform.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\nexport function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypeObject<T>> {\n  const keys = Object.keys(reactiveSources)\n  const values = Object.values(reactiveSources);\n\n  const s = syncToArray(values, options);\n  const st = transform(s, (streamValues) => {\n    return zipKeyValue(keys, streamValues);\n  });\n  return st as Reactive<RxValueTypeObject<T>>;\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ThrottleOptions } from \"./Types.js\";\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveDisposable } from \"../Types.js\";\nimport { isTrigger, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutTriggerOptions } from \"../sources/Types.js\";\n\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. For example, this allows you to reset a reactive to some\n * 'zero' state if nothing is going on.\n * \n * If `source` emits faster than the `interval`, it won't get triggered.\n * \n * Default for 'timeout': 1000s.\n * \n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutTrigger(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n * \n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutTrigger(source, { fn: Math.random, interval: 500 });\n * ```\n * \n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source \n * @param options \n */\nexport function timeoutTrigger<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutTriggerOptions<TTriggerValue>): ReactiveDisposable<TSource | TTriggerValue> & Reactive<TSource | TTriggerValue> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const immediate = options.immediate ?? true;\n  const repeat = options.repeat ?? false;\n  const timeoutMs = intervalToMs(options.interval, 1000);\n  if (!isTrigger(options)) {\n    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n  }\n\n  // Send value from trigger\n  const sendFallback = () => {\n    const [ value, done ] = resolveTriggerValue(options);\n    if (done) {\n      events.dispose(`Trigger completed`);\n    } else {\n      if (events.isDisposed()) return;\n      events.set(value);\n      if (repeat) {\n        timer = setTimeout(sendFallback, timeoutMs);\n      }\n    }\n  }\n\n  const events = initUpstream<TSource, TSource | TTriggerValue>(source, {\n    disposeIfSourceDone: true,\n    // Received a value from upstream source\n    onValue(v) {\n      // Reset timeout\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(sendFallback, timeoutMs);\n      // Emit value\n      events.set(v);\n    },\n    onDispose() {\n      console.log(`disposing`);\n      if (timer) clearTimeout(timer);\n    },\n  });\n\n  if (immediate && !timer) {\n    timer = setTimeout(sendFallback, timeoutMs);\n  }\n  return events;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\n\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n * @param input \n * @param options \n * @returns \n */\nexport function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In> {\n  let lastValue: In | undefined = options.initial;\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      upstream.set(value);\n    },\n  })\n\n  const readable = toReadable(upstream);\n  return {\n    ...readable,\n    // @ts-expect-error\n    last() {\n      return lastValue;\n    },\n  }\n}","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { QueueMutable, StackMutable } from \"../../collections/index.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport * as Sync from \"../../iterables/IterableSync.js\"\nimport { Table } from \"../Table.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. By default unidirectional.\n * Returns a new graph with the connection\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n  }\n\n  if (!bidi) return graph;\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n  }\n  return graph;\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","import * as DiGraph from \"../data/graphs/DirectedGraph.js\";\nimport { initStream } from \"./InitStream.js\";\nimport type { Reactive } from \"./Types.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\nfunction isReactive(o: object): o is Reactive<any> {\n  if (typeof o !== `object`) return false;\n  if (`on` in o) {\n    return (typeof o.on === `function`);\n  }\n  return false;\n}\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx \n */\nexport function prepare<V extends Record<string, any>>(_rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Reactive.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Reactive.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    value: events.value\n  }\n  return returnValue;\n}\n\n","import type { Primitive } from 'src/KeyValue.js';\nimport type { ChangeRecord } from '../Compare.js';\nimport type { Interval } from '../flow/IntervalType.js';\nimport * as Immutable from '../Immutable.js';\nimport type { AnnotationElapsed, BatchOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions } from './ops/Types.js';\nimport type { TimeoutTriggerOptions } from './sources/Types.js';\n\nexport type CombineLatestOptions = {\n  /**\n   * If _true_, disposes all the merged sources when the merged reactive closes.\n   * Default: _true_.\n   */\n  disposeSources: boolean\n  /**\n   * How to handle when a source ends.\n   * * 'allow': continue combined stream, last value for done stream will kept\n   * * 'break': stop combined stream\n   * \n   * Default: 'break'\n   */\n  onSourceDone: `allow` | `break`\n}\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: SignalKinds\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: Lazy\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n\n  onDispose: (reason: string) => void\n}\n\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  source: Reactive<TIn>,\n  /**\n   * Annotate values with a timestamp of elapsed time\n   * (uses `annotate`)\n   * @returns \n   */\n  annotateElapsed: () => Wrapped<TIn & AnnotationElapsed>\n  /**\n   * Annotate values with some additional field(s)\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TIn & TAnnotation) => Wrapped<TIn & TAnnotation>\n  /**\n  * Accumulate a batch of values, emitted as an array\n  * @param options \n  * @returns \n  */\n  batch: (options: Partial<BatchOptions>) => Wrapped<Array<TIn>>\n\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name: string } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options: Partial<SplitOptions>) => Array<Wrapped<TIn>>\n  /**\n * Emits values when this stream and any additional streams produce a value. The resulting stream is\n * thus an array of values, each source at a given index.\n * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n * the slowest stream.\n * @returns \n */\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[ TIn, ...RxValueTypes<T> ]>\n\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: { name?: string } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => Record<K, Wrapped<TIn>>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  timeoutTrigger: <TTriggerValue>(options: TimeoutTriggerOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn>>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn | undefined>>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  value: (callback: (value: TIn) => void) => void\n\n}\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n  lazy: Lazy\n  onStart: () => void\n  onStop: () => void\n};\n\nexport type CountOptions = { lazy: Lazy, amount: number, offset: number, interval: Interval, signal: AbortSignal }\n\n\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V> | (() => V)\n\nexport type BindUpdateOpts<V> = {\n  initial: (v: V, el: HTMLElement) => void,\n  binds: Record<string, DomBindValueTarget & {\n    transform?: (value: any) => string\n  }>\n}\n\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `value` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): Unsubscriber\n  value(handler: (value: V) => void): Unsubscriber\n}\n\nexport type Unsubscriber = () => void;\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\nexport type ReactiveWritable<V> = {\n  set(value: V): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveDisposable<V> = Reactive<V> & {\n  dispose(reason: string): void\n  isDisposed(): boolean\n}\n\nexport type ReactiveArray<V> = ReactiveWritable<Array<V>> & {\n  push(value: V): void\n  deleteAt(index: number): void\n  deleteWhere(filter: (value: V) => boolean): number\n  setAt(index: number, value: V): void\n  insertAt(index: number, value: V): void\n  onArray(handler: (changes: Passed<Array<ChangeRecord<number>>>) => void): () => void\n}\n\nexport type ReactiveDiff<V> = ReactiveDisposable<V> & ReactiveWritable<V> & {\n  /**\n   * Diff information\n   * @param handler \n   */\n  onDiff(handler: (changes: Passed<Array<Immutable.Change<any>>>) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   */\n  update(changedPart: Record<string, any>): void\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\nexport type ReactiveStream<V> = Reactive<V> & ReactiveDisposable<V> & ReactiveWritable<V> & {\n  through(message: Passed<V>): void\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  reset(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\nexport type DomBindValueTarget = {\n  /**\n   * If _true_ `innerHTML` is set (a shortcut for elField:`innerHTML`)\n   */\n  htmlContent?: boolean\n  /**\n   * If _true_, 'textContent' is set (a shortcut for elField:'textContext')\n   */\n  textContent?: boolean\n  /**\n   * If set, this DOM element field is set. Eg 'textContent'\n   */\n  elField?: string\n  /**\n   * If set, this DOM attribute is set, Eg 'width'\n   */\n  attribName?: string\n  /**\n   * If set, this CSS variable is set, Eg 'hue' (sets '--hue')\n   */\n  cssVariable?: string\n  /**\n   * If set, this CSS property is set, Eg 'background-color'\n   */\n  cssProperty?: string\n}\n\nexport type ElementBind = {\n  /**\n   * Tag name for this binding.\n   * Overrides `defaultTag`\n   */\n  tagName?: string\n  /**\n   * If _true_, sub-paths are appended to element, rather than `container`\n   */\n  nestChildren?: boolean\n  transform?: (value: any) => string\n}\nexport type ElementsOptions = {\n  container: HTMLElement | string\n  defaultTag: string,\n  binds: Record<string, DomBindValueTarget & ElementBind>\n}\n\nexport type DomBindTargetNode = {\n  query?: string\n  element?: HTMLElement\n}\n\nexport type DomBindTargetNodeResolved = {\n  element: HTMLElement\n}\n\nexport type DomBindUnresolvedSource<V> = DomBindTargetNode & DomBindSourceValue<V> & DomBindValueTarget;\nexport type DomBindResolvedSource<V> = DomBindTargetNodeResolved & DomBindSourceValue<V> & DomBindValueTarget;\n\nexport type DomBindSourceValue<V> = {\n  /**\n   * Field from source value to pluck and use.\n   * This will also be the value passed to the transform\n   */\n  sourceField?: keyof V\n  transform?: (input: V) => string\n  transformValue?: (input: any) => string\n}\n\n// export type PipeSet<In, Out> = [\n//   Reactive<In>,\n//   ...Array<Reactive<any> & ReactiveWritable<any>>,\n//   ReactiveWritable<Out> & Reactive<any>\n// ]\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...Array<Reactive<any> & ReactiveWritable<any>>\n]\n\nexport type InitStreamOptions = {\n  /**\n   * Optional label to associate with this stream. Useful for debugging.\n   */\n  debugLabel: string\n  onFirstSubscribe: () => void\n  onNoSubscribers: () => void\n  onDispose: (reason: string) => void\n}\n\n\n\nexport type DomCreateOptions = {\n  tagName: string\n  parentEl: string | HTMLElement\n}\n\nexport type PipeDomBinding = {\n  /**\n   * Remove binding and optionally delete element(s) (false by default)\n   */\n  remove(deleteElements: boolean): void\n}\n\n\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n  /**\n   * Initial value\n   */\n  initial: V,\n  /**\n   * Laziness\n   */\n  lazy?: Lazy\n}\n\n\n\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n\n  lazy: Lazy\n}\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...Array<ReactiveOp<any, any>>,\n  ReactiveOp<any, Out>\n]\n\nexport type RxValueTypes<T extends ReadonlyArray<ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\n\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    never };\n\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport type { ReactiveOrSource, ToArrayOptions } from \"./Types.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V | undefined>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: Array<V | undefined> = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<Array<V | undefined>>((resolve, reject) => {\n    const done = () => {\n      clearTimeout(maxWait)\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) {\n            //console.log(`Rx.toArray filling at index: ${ index }`);\n            read[ index ] = options.fillValue;\n          }\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as Array<V>;\n\n}","import { resolveSource } from \"./ResolveSource.js\";\nimport type { ReactiveOrSource } from \"./Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n","import * as Ops from \"./ops/index.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { toArray, toArrayOrThrow } from \"./ToArray.js\";\nimport type { ReactiveOrSource, Wrapped, ToArrayOptions, InitStreamOptions, Reactive, RxValueTypes, CombineLatestOptions, } from \"./Types.js\";\nimport type { BatchOptions, FieldOptions, FilterPredicate, DebounceOptions, SwitcherOptions, SplitOptions, ThrottleOptions, TransformOpts, SyncOptions, } from './ops/Types.js'\nimport type { TimeoutTriggerOptions } from './sources/Types.js'\nimport { messageHasValue } from \"./Util.js\";\nimport { map as ImmutableMap } from '../Immutable.js';\n\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n * \n * Example:\n * For every `pointerup` event on the body, batch the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .batch({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .value(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    annotate: <TAnnotation>(transformer: (value: TIn) => TIn & TAnnotation): Wrapped<TIn & TAnnotation> => {\n      const a = Ops.annotate<TIn, TAnnotation>(source, transformer);\n      return wrap(a);\n    },\n    annotateElapsed: () => {\n      return wrap(Ops.annotateElapsed<TIn>(source));\n    },\n    batch: (options: Partial<BatchOptions>): Wrapped<Array<TIn>> => {\n      const w = wrap<Array<TIn>>(Ops.batch(source, options));\n      return w;\n    },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(Ops.debounce<TIn>(source, options));\n    },\n    field: <TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TFieldType>> = {}) => {\n      // Ops.field requires TIn extends object\n      // Would be good if `wrap` returns different versions depending on TIn, so .field\n      // would not be present at all if we had Reactive<number>, for example\n      // @ts-expect-error\n      const f = Ops.field<TIn, TFieldType>(source, fieldName, options);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(Ops.filter(source, predicate, options));\n    },\n    combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}) => {\n      const srcs = [ source, ...sources ] as any as T;\n      return wrap(Ops.combineLatestToArray(srcs, options));\n    },\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<CombineLatestOptions>) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.combineLatestToObject(o, options));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = Ops.split<TIn>(source, options).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => {\n      const l = Ops.splitLabelled<TIn, keyof TIn>(source, labels);\n      const m = ImmutableMap<typeof l, Wrapped<TIn>>(l, v => wrap(v as Reactive<TIn>)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = Ops.switcher<TIn, TRec, TLabel>(source, cases, options);\n      const m = ImmutableMap<typeof s, Wrapped<TIn>>(s, v => wrap(v as Reactive<TIn>));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(additionalSources: T, options: Partial<SyncOptions> = {}) => {\n      const unwrapped = [ source, ...additionalSources ].map(v => resolveSource(v));\n      const x = Ops.syncToArray(unwrapped, options) as Reactive<[ TIn, ...RxValueTypes<T> ]>;\n      return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n    },\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<SyncOptions> = {}) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.syncToObject(o, options));\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(Ops.throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(Ops.transform(source, transformer, options));\n    },\n    timeoutTrigger: <TTrigger>(options: TimeoutTriggerOptions<TTrigger>) => {\n      return wrap(Ops.timeoutTrigger<TIn, TTrigger>(source, options));\n    },\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    value: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    }\n  }\n}\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport { continuously } from \"../flow/Continuously.js\";\nimport type { CountOptions } from \"./Types.js\";\nimport { initLazyStream } from \"./InitStream.js\";\n\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n * \n * ```js\n * const r = Rx.count();\n * r.value(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n * \n * The `limit` is exclusive\n * ```js\n * const r = Rx.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n * \n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n * \n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.count({ start: 10, amount: 2, interval: 500 });\n * ```\n * \n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options \n */\nexport function count(options: Partial<CountOptions> = {}) {\n\n  const lazy = options.lazy ?? `initial`;\n  const interval = intervalToMs(options.interval, 1000);\n  const amount = options.amount ?? 1;\n  const offset = options.offset ?? 0;\n\n  let produced = 0;\n  let value = offset;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n  }\n\n  const timer = continuously(() => {\n    if (options.signal?.aborted) {\n      done(`Aborted (${ options.signal.reason })`);\n      return false;\n    }\n    events.set(value);\n    value += 1;\n    produced++;\n    if (produced >= amount) {\n      done(`Limit reached`);\n      return false;\n    }\n  }, interval);\n\n  const events = initLazyStream<number>({\n    onStart() {\n      timer.start();\n    },\n    onStop() {\n      timer.cancel();\n    },\n    onDispose() {\n      timer.cancel();\n    },\n    lazy\n  });\n  return events;\n}\n","import * as Immutable from \"../Immutable.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport * as Rx from \"./index.js\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind } from './Types.js';\nimport { hasLast, messageHasValue, messageIsSignal } from \"./Util.js\";\nimport type { Change } from \"../Immutable.js\";\nimport { getFromKeys } from \"../collections/map/MapFns.js\";\nimport { afterMatch, beforeMatch } from \"../Text.js\";\nimport { stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"../text/Segments.js\";\nimport { QueueMutable } from \"../collections/index.js\";\nimport { object } from \"./sources/Object.js\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as Array<HTMLElement>;\n\n  return object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes\n * ```js\n * bindText(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'textContent'}` as the options\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<Rx.DomBindSourceValue<V>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<V> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindElement = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement | null, ...binds: Array<DomBindSourceValue<V> & Rx.DomBindValueTarget>): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<V>;\n    return { ...bind, element: el } as DomBindResolvedSource<V>\n  });\n  return bind(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <V>(bind: DomBindSourceValue<V>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: V) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: V) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <V>(source: Rx.Reactive<V>, ...bindsUnresolvedElements: Array<Rx.DomBindUnresolvedSource<V>>): PipeDomBinding => {\n  const binds: Array<DomBindResolvedSource<V>> = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<V>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: V) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      update(message.value);\n    } else if (messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Array<Change<any>>, el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  const binds = opts.binds;\n  const update = (value: Array<Change<any>>) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(message => {\n    if (Rx.messageHasValue(message)) {\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = getFromKeys(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: Array<Immutable.Change<any>>) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = Immutable.getPathsAndData(d.value, Number.MAX_SAFE_INTEGER, path);\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(message => {\n    if (message.value) {\n      console.log(`Rx.Dom.elements diff ${ JSON.stringify(message.value) } `);\n      changes(message.value);\n    }\n  });\n\n  // Source has an initial value, use that\n  if (hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes(Immutable.getPathsAndData(last as object, 1));\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = Rx.From.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = Rx.From.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n","\n\n/**\n * Normalise module\n * * {@link array}: Normalises the contents of an array of known values.\n * * {@link stream}: Normalises a stream of unknown values.\n */\nexport * as Normalise from './Normalise.js';\n\nexport * from './FrequencyMutable.js';\nexport * from './MovingAverage.js';\nexport * from './NumberTracker.js';\nexport * from './IntervalTracker.js';\nexport * from './PointTracker.js';\nexport * from './TrackedValue.js';\nexport * from './TrackerBase.js';\nexport * from './PrimitiveTracker.js';\nexport * from './Clamp.js';\nexport * from './Scale.js';\nexport * from './Flip.js';\nexport * as Graphs from './graphs/index.js'\nexport * from './TrackUnique.js';\nexport * from './Table.js';\nexport * from './ResolveFields.js';\n\n/**\n * Work with bipolar values (-1...1)\n * \n * Import:\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Overview:\n * * {@link immutable}: Immutable wrapper around a value\n * * {@link clamp}: Clamp on -1..1 scale\n * * {@link scale}: Scale a value to -1..1\n * * {@link toScalar}: Convert -1..1 to 0..1\n * * {@link fromScalar}: Convert from 0..1 to -1..1\n * * {@link towardZero}: Nudge a bipolar value towards zero\n */\nexport * as Bipolar from './Bipolar.js';\nexport * from './Interpolate.js';\nexport * from './Wrap.js';\nexport * as Correlate from './Correlate.js';\nexport * as Pool from './Pool.js';\nexport * from './Types.js';\nexport const piPi = Math.PI * 2;\n","import { minMaxAvg } from '../collections/arrays/NumericArrays.js';\nimport { clamp } from './Clamp.js';\nimport { scale } from './Scale.js';\nimport { throwNumberTest } from '../Guards.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passingin `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * Note that if a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  //eslint-disable-next-line functional/no-let\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  //eslint-disable-next-line functional/no-let\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  throwNumberTest(minDefault);\n  throwNumberTest(maxDefault);\n\n  return (v: number): number => {\n    throwNumberTest(v);\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [Read more in the docs](https://clinth.github.io/ixfx-docs/data/normalising/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/data.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (\n  values: readonly number[],\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new Error(`values param should be an array`);\n  }\n  const mma = minMaxAvg(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","///  Unit tested!\n\nimport { type ToString } from '../Util.js';\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as KeyValueUtil from '../KeyValue.js';\nimport { KeyValues } from '../index.js';\n\nexport type FrequencyEventMap = {\n  readonly change: { context: any };\n};\n\nexport class FrequencyMutable<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString?: ToString<V> | undefined) {\n    super();\n    this.#store = new Map();\n\n    if (keyString === undefined) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        return typeof a === `string` ? a : JSON.stringify(a);\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, { context: this });\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): Array<[ key: string, count: number ]> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    //eslint-disable-next-line functional/no-let\n    let t = ``;\n    for (const [ key, count ] of this.#store.entries()) {\n      t += `${ key }: ${ count }, `;\n    }\n    if (t.endsWith(`, `)) return t.slice(0, Math.max(0, t.length - 2));\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    //eslint-disable-next-line functional/no-let\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.minMaxAvg();\n    return freq / mma.total;\n  }\n\n  /**\n   * @returns Copy of entries as an array\n   */\n  entries(): Array<KeyValueUtil.KeyValue> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   *\n   * @returns Returns `{min,max,avg,total}`\n   */\n  minMaxAvg() {\n    return KeyValues.minMaxAvg(this.entries());\n  }\n\n  /**\n   *\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: KeyValues.SortSyles = `value`\n  ): ReadonlyArray<KeyValues.KeyValue> {\n    const s = KeyValueUtil.getSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   *\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  add(...values: Array<V>) {\n    if (values === undefined) throw new Error(`value parameter is undefined`);\n\n    const keys = values.map(v => this.#keyString(v));\n\n    //const key = this.#keyString(value);\n    for (const key of keys) {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    }\n    this.fireEvent(`change`, { context: this });\n  }\n}\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link frequencyMutable}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = frequencyMutable();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = frequencyMutable();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequencyMutable( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @template V Type of items\n */\nexport const frequencyMutable = <V>(keyString?: ToString<V> | undefined) =>\n  new FrequencyMutable<V>(keyString);\n","import type { Interval } from \"./IntervalType.js\";\nimport { timeout } from \"./Timeout.js\";\n\n\nexport type RateMinimumOptions<TInput> = Readonly<{\n  whatToCall: (args: TInput) => void\n  fallback: () => TInput\n  interval: Interval\n  abort?: AbortSignal\n}>;\n\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n * \n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n * \n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n * \n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ``` \n * \n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n * \n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n * \n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n * \n * @param options \n * @returns \n */\nexport const rateMinimum = <TInput>(options: RateMinimumOptions<TInput>) => {\n  let disposed = false;\n\n  const t = timeout(() => {\n    if (disposed) return;\n    t.start();\n    options.whatToCall(options.fallback());\n  }, options.interval);\n\n\n  if (options.abort) {\n    options.abort.addEventListener(`abort`, _ => {\n      disposed = true;\n      t.cancel();\n    });\n  }\n  t.start();\n\n  return (args: TInput) => {\n    if (disposed) throw new Error(`AbortSignal has been fired`);\n    t.start();\n    options.whatToCall(args);\n  }\n}","import type { Interval } from '../flow/IntervalType.js';\nimport { averageWeighted } from '../collections/arrays/AverageWeighted.js';\nimport { average } from '../collections/arrays/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { numberTest, throwNumberTest } from '../Guards.js';\nimport { rateMinimum } from '../flow/RateMinimum.js';\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * `add()` adds a new value and returns the calculated average.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma.add(50);  // 50\n * ma.add(100); // 75\n * ma.add(75);  // 75\n * ma.add(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * Use `clear()` to reset the moving average, or `compute()` to get the current value without adding.\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r[ 0 ] && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n\n  // let disposed = false;\n  // const ma: MovingAverage = {\n  //   dispose() {\n  //     disposed = true;\n  //   },\n  //   get isDisposed() {\n  //     return disposed;\n  //   },\n  //   add(v: number) {\n  //     if (disposed) throw new Error(`MovingAverage disposed, cannot add`);\n  //     count++;\n  //     average = average + (v - average) / Math.min(count, scaling);\n  //     return average;\n  //   },\n  //   clear() {\n  //     if (disposed) throw new Error(`MovingAverage disposed, cannot clear`);\n  //     average = 0;\n  //     count = 0;\n  //   },\n  //   compute() {\n  //     return average;\n  //   },\n  // };\n  // return ma;\n};\n\nexport type MovingAverageTimedOptions = Readonly<{\n  interval: Interval\n  default?: number\n  abort?: AbortSignal\n}>\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n * \n * mat(); // Get current average\n * ```\n * \n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * \n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param updateRateMs\n * @param value\n * @param scaling\n * @returns\n */\nexport const movingAverageTimed = (options: MovingAverageTimedOptions) => {\n  const average = movingAverageLight();\n  const rm = rateMinimum({\n    ...options,\n    whatToCall: (distance: number) => {\n      average(distance);\n    },\n    fallback() {\n      return options.default ?? 0;\n    }\n  })\n\n  return (v: number) => {\n    rm(v);\n    return average();\n  }\n};\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n/**\n * Creates a moving average for a set number of `samples`.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n * `add` adds a number and returns the computed average. Call `compute` to\n * get the average without adding a new value.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma.add(10); // 10\n * ma.add(5);  // 7.5\n * ```\n *\n * `clear` clears the average.\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, Easings.gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  //let disposed = false;\n\n  const q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  return (v?: number | undefined) => {\n    const r = numberTest(v);\n    if (r[ 0 ] && v !== undefined) {\n      q.enqueue(v);\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n\n  // const clear = () => {\n  //   q = new QueueMutable<number>({\n  //     capacity: samples,\n  //     discardPolicy: `older`,\n  //   });\n  // };\n\n  // const compute = () => {\n  //   return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  // };\n\n  // const add = (v: number) => {\n  //   q.enqueue(v);\n  //   return compute();\n  // };\n\n  // const dispose = () => {\n  //   disposed = true;\n  // };\n\n  // return { add, compute, clear, dispose, isDisposed: disposed };\n};\n\n/**\n * Moving average.\n * Create via {@link movingAverage} or {@link movingAverageLight}.\n */\n// export type MovingAverage = {\n//   /**\n//    * Clear data\n//    */\n//   clear(): void;\n//   /**\n//    * Returns current average\n//    */\n//   compute(): number;\n//   /**\n//    * Adds a value, returning new average\n//    * @param v Value to add\n//    */\n//   add(v: number): number;\n\n//   dispose(): void;\n//   get isDisposed(): boolean;\n// };\n\nconst PiPi = Math.PI * 2;\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { NumberTracker } from './NumberTracker.js';\nimport { type TrackedValueOpts as TrackOpts } from './TrackedValue.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n *\n * @export\n * @class IntervalTracker\n * @extends {ValueTracker}\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(performance.now() - this.lastMark);\n    }\n    this.lastMark = performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { intervalTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const t = intervalTracker();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = intervalTracker({ resetAfterSamples: 100} );\n * ```\n * @param opts Options for tracker\n * @returns New interval tracker\n */\nexport const intervalTracker = (opts?: TrackOpts) => new IntervalTracker(opts);\n","import type { TimestampedObject, TrackedValueOpts } from './TrackedValue.js';\nimport { TrackerBase } from './TrackerBase.js';\n\n/**\n * A tracked value of type `V`.\n */\nexport abstract class ObjectTracker<V extends object, SeenResultType> extends TrackerBase<V, SeenResultType> {\n  //abstract onSeen(_p: Array<V>): SeenResultType;\n\n  values: Array<TimestampedObject<V>>;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    super(opts);\n    this.values = [];\n  }\n\n  onTrimmed() {\n    // no-op\n  }\n\n  /**\n   * Reduces size of value store to `limit`. \n   * Returns number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    // Index 0 will be the oldest\n    this.values = this.values.slice(-limit);\n    return this.values.length;\n  }\n\n  /**\n   * Allows sub-classes to be notified when a reset happens\n   * @ignore\n   */\n  onReset() {\n    this.values = [];\n  }\n\n  /**\n   * Tracks a value\n   * @ignore\n   */\n  filterData(p: Array<V> | Array<TimestampedObject<V>>): Array<TimestampedObject<V>> {\n    // Make sure values have a timestamp\n    const ts = p.map((v) =>\n      `at` in v\n        ? v\n        : {\n          ...v,\n          at: Date.now(),\n        }\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const last = ts.at(-1)!;\n\n    if (this.storeIntermediate) this.values.push(...ts);\n    else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last);\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last;\n        break;\n      }\n    }\n    return ts;\n  }\n\n  /**\n   * Last seen value. If no values have been added, it will return the initial value\n   */\n  get last() {\n    if (this.values.length === 1) return this.values[ 0 ];\n    //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.values.at(-1)!;\n  }\n\n  /**\n   * Returns the initial value\n   */\n  get initial() {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (includes the initial value in the count)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the initial value\n   */\n  get elapsed(): number {\n    return Date.now() - this.values[ 0 ].at;\n  }\n\n}\n","import * as Points from '../geometry/point/index.js';\nimport {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from './TrackedValue.js';\nimport { ObjectTracker } from './ObjectTracker.js';\nimport { Lines, Vectors } from '../geometry/index.js';\nimport type { Coord as PolarCoord } from '../geometry/Polar.js';\nimport type { Line, PolyLine } from '../geometry/line/index.js';\n\n/**\n * Information about seen points\n */\nexport type PointTrack = Points.PointRelationResult & {\n  // readonly speedFromInitial:number\n};\n\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = {\n  /**\n   * Relation of last point to previous point\n   */\n  readonly fromLast: PointTrack;\n  /**\n   * Relation of last point to initial point.\n   * \n   * When the tracker is reset or resizes (eg. if it reaches its capacity), the\n   * initial point will be the first new point. Thus, the initial point\n   * always maintains some time horizon\n   */\n  readonly fromInitial: PointTrack;\n  readonly values: ReadonlyArray<Points.Point>;\n};\n\n/**\n * Point tracker. Create via `pointTracker()`.\n *\n */\nexport class PointTracker extends ObjectTracker<Points.Point, PointTrackerResults> {\n  /**\n   * Function that yields the relation from initial point\n   */\n  initialRelation: Points.PointRelation | undefined;\n\n  /**\n   * Last result\n   */\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  onTrimmed(): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * Returns the last x coord\n   */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n  }\n\n  seenEvent(p: PointerEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      // @ts-expect-error\n      return this.seen({ x: p.clientX, y: p.clientY });\n    }\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: Array<TimestampedObject<Points.Point>>\n  ): PointTrackerResults {\n    const currentLast = this.last;\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      this.initialRelation = Points.relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? Points.relation(currentLast) : Points.relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const speed = previousLast === undefined ? 0 : Lines.length(previousLast, currentLast) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return Lines.joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Points.Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return Lines.Empty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length.\n   * @returns Distance\n   */\n  distanceFromStart(): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.distance(initial, this.last) : 0;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x & y.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Points.Point {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? Points.subtract(this.last, initial) : Points.Placeholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return Points.angle(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total length of accumulated points.\n   * Returns 0 if points were not saved, or there's only one\n   */\n  get length(): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return Lines.length(l);\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class TrackedPointMap extends TrackedValueMap<\n  Points.Point,\n  PointTracker,\n  PointTrackerResults\n> {\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  /**\n   * Track a PointerEvent\n   * @param event\n   */\n  seenEvent(event: PointerEvent): Promise<Array<PointTrackerResults>> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}\n\n/**\n * Track several named points over time, eg a TensorFlow body pose point.\n * Call `seen()` to track a point. Mutable. If you want to compare\n * a single coordinate with a reference coordinate,  may be a better choice.\n *\n * See also:\n * * [Geometry.Points.relation](Geometry.Points.relation.html): Compute relation info between two points\n * * [Data.pointTracker](Data.pointTracker-1.html): Track relation between points over time\n * * [Guide to Trackers](https://clinth.github.io/ixfx-docs/data/trackers/)\n * \n * Basic usage\n * ```js\n * import { pointsTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const pt = pointsTracker();\n *\n * // Track a point under a given id\n * document.addEventListener(`pointermove`, e => {\n *  const info = await pt.seen(e.pointerId, { x: e.x, y: e.y });\n *  // Yields some info on relation of the point to initial value\n * });\n * ```\n *\n * Do something with last values for all points\n * ```js\n * const c = Points.centroid(...Array.from(pt.last()));\n * ```\n *\n * More functions...\n * ```js\n * pt.size;       // How many named points are being tracked\n * pt.delete(id); // Delete named point\n * pt.reset();    // Clear data\n * ```\n *\n * Accessing by id:\n *\n * ```js\n * pt.get(id);  // Get named point (or _undefined_)\n * pt.has(id);  // Returns true if id exists\n * ```\n *\n * Iterating over data\n *\n * ```js\n * pt.trackedByAge(); // Iterates over tracked points, sorted by age (oldest first)\n * pt.tracked(); // Tracked values\n * pt.ids();     // Iterator over ids\n *\n * // Last received value for each named point\n * pt.last();\n *\n * pt.initialValues(); // Iterator over initial values for each point\n * ```\n *\n * You can work with 'most recently updated' points:\n *\n * ```js\n * // Iterates over points, sorted by age (oldest first)\n * pt.valuesByAge();\n * ```\n *\n * Options:\n * * `id`: Id of this tracker. Optional\n * * `sampleLimit`: How many samples to store\n * * `storeIntermediate`: If _true_, all points are stored internally\n * * `resetAfterSamples`: If set above 0, it will automatically reset after the given number of samples have been seen\n * @param opts\n * @returns\n */\nexport const pointsTracker = (opts: TrackOpts = {}) =>\n  new TrackedPointMap(opts);\n\n/**\n * A tracked point. Create via {@link pointTracker}. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link pointsTracker}: Track several points, useful for multi-touch.\n * * [Guide to Trackers](https://clinth.github.io/ixfx-docs/data/trackers/)\n * \n * ```js\n * import { pointTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Create a tracker on a pointerdown\n * const t = pointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = pointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = pointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = pointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport const pointTracker = (opts: TrackOpts = {}) => new PointTracker(opts);\n","import { throwNumberTest } from '../Guards.js';\nimport type { NumberFunction } from './Types.js';\n\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v: number | NumberFunction) => {\n  if (typeof v === `function`) v = v();\n  throwNumberTest(v, `percentage`, `v`);\n  return 1 - v;\n};\n","export * as Directed from './DirectedGraph.js';\nexport * as Undirected from './UndirectedGraph.js';","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { Table } from \"../Table.js\"\n\n\nexport type Vertex = Readonly<{\n  id: string\n}>\n\nexport type Edge = Readonly<{\n  a: string,\n  b: string,\n  weight?: number\n}>\n\nexport type Graph = Readonly<{\n  edges: ReadonlyArray<Edge>,\n  vertices: IMapImmutable<string, Vertex>\n}>\n\nexport type ConnectOptions = Readonly<{\n  a: string\n  b: string | Array<string>\n  weight?: number\n}>\n\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id\n  }\n}\n\nexport const updateGraphVertex = (graph: Graph, vertex: Vertex): Graph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\nexport const getOrCreate = (graph: Graph, id: string): Readonly<{ graph: Graph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\nfunction resolveVertex(graph: Graph, idOrVertex: string | Vertex): Vertex {\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\nexport const hasConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): boolean => {\n  const edge = getConnection(graph, a, b);\n  return edge !== undefined;\n}\n\nexport const getConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): Edge | undefined => {\n  const aa = resolveVertex(graph, a);\n  const bb = resolveVertex(graph, b);\n  for (const edge of graph.edges) {\n    if (edge.a == aa.id && edge.b === bb.id) return edge;\n    if (edge.a == bb.id && edge.b === aa.id) return edge;\n  }\n  return;\n}\n\n/**\n * Connect A <-> B\n * @param graph \n * @param a \n * @param b \n * @param weight \n * @returns \n */\nexport function connectTo(graph: Graph, a: string, b: string, weight?: number): { graph: Graph, edge: Edge } {\n  const aResult = getOrCreate(graph, a);\n  graph = aResult.graph;\n  const bResult = getOrCreate(graph, b);\n  graph = bResult.graph;\n\n  let edge = getConnection(graph, a, b);\n  if (edge !== undefined) return { graph, edge };\n  edge = {\n    a,\n    b,\n    weight\n  }\n\n  const graphChanged: Graph = {\n    ...graph,\n    edges: [ ...graph.edges, edge ]\n  }\n  return { graph: graphChanged, edge }\n}\n\nexport function connect(graph: Graph, options: ConnectOptions): Graph {\n  const { a, weight, b } = options;\n  const destinations = Array.isArray(b) ? b : [ b ];\n\n  for (const destination of destinations) {\n    const result = connectTo(graph, a, destination, weight);\n    graph = result.graph;\n  }\n\n  return graph;\n}\n\nexport const graph = (...initialConnections: Array<ConnectOptions>): Graph => {\n  let g: Graph = {\n    vertices: immutableMap(),\n    edges: []\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\nexport function toAdjacencyMatrix(graph: Graph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    table.setRow(i, v.length, false);\n\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      const connected = hasConnection(graph, ii, jj);\n      if (connected) {\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: Graph): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: Graph): Array<string> => {\n  const r: Array<string> = [];\n\n  r.push(`Vertices: ${ [ ...graph.vertices.values() ].map(v => v.id).join(`, `) }`);\n  // eslint-disable-next-line unicorn/no-array-push-push\n  r.push(`Edges:`);\n  for (const edge of graph.edges) {\n    r.push(stringForEdge(edge));\n  }\n  return r;\n}\n\nconst stringForEdge = (edge: Edge) => {\n  const weight = edge.weight ? ` (${ edge.weight })` : ``;\n  return `${ edge.a } <-> ${ edge.b }${ weight }`\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield resolveVertex(graph, edge.b);\n    else if (edge.b === context) yield resolveVertex(graph, edge.a);\n  }\n}\n\nexport function* edgesForVertex(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield edge;\n    else if (edge.b === context) yield edge;\n  }\n}","import { toStringDefault, type ToString } from \"../Util.js\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link trackUniqueInstances}\n * \n * ```js\n * const t = trackUnique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = trackUnique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * \n * Return function throws an error if `value` is null or undefined.\n * @returns \n */\nexport const trackUnique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}\n\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link trackUnique} to track by value.\n */\nexport const trackUniqueInstances = <T>(): TrackUnique<T> => {\n\n  const set = new Set<T>();\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    if (set.has(value)) return false;\n    set.add(value);\n    return true;\n  }\n}","import * as Rx from '../rx/index.js';\nimport { isPrimitive, type PrimitiveOrObject } from \"../KeyValue.js\";\n\ntype ValueType = string | number | boolean | object\n\ntype FunctionType<V> = (() => V) | (() => Promise<V>);\ntype ValueOrFunction<V> = ValueType | FunctionType<V> | Iterator<V> | AsyncIterator<V>;\n\nexport type PullRecord<T extends Record<string, PrimitiveOrObject | (() => any) | Rx.Reactive<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends Rx.Reactive<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    T[ K ] extends object ? T[ K ] :\n    never };\n\n// export type PullRecord2<T extends Record<string, PrimitiveOrObject | ReactiveOrSource<any>>> =\n//   { [ K in keyof T ]:\n//     T[ K ] extends number ? number | undefined :\n\n//     T[ K ] extends string ? string | undefined :\n//     T[ K ] extends boolean ? boolean | undefined :\n//     T[ K ] extends bigint ? bigint | undefined :\n//     T[ K ] extends Reactive<infer V> ? V | undefined :\n//     T[ K ] extends Wrapped<infer V> ? V | undefined :\n//     T[ K ] extends Generator<infer V> ? V | undefined :\n//     T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n//     T[ K ] extends IterableIterator<infer V> ? V | undefined :\n//     T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n//     T[ K ] extends Array<infer V> ? V | undefined :\n//     T[ K ] extends object ? T[ K ] :\n//     never };\n\nexport type ResolveValue<V> =\n  V extends () => Promise<any> ? Awaited<ReturnType<V>> :\n  V extends () => any ? ReturnType<V> :\n  V extends Iterator<object> ? object :\n  V extends Iterator<number> ? number :\n  V extends Iterator<string> ? string :\n  V extends Iterator<boolean> ? boolean :\n  V extends AsyncIterator<object> ? object :\n  V extends AsyncIterator<number> ? number :\n  V extends AsyncIterator<string> ? string :\n  V extends AsyncIterator<boolean> ? boolean :\n  V extends ValueType ? V : never;\n\nexport type ResolvedObject<V> = Readonly<{\n  [ key in keyof V ]: ResolveValue<V[ key ]>\n}>\n\nasync function resolveValue<V extends ValueType>(valueOrFunction: ValueOrFunction<V>): Promise<V> {\n  if (typeof valueOrFunction === `object` && `next` in valueOrFunction) {\n    const v = await valueOrFunction.next();\n    return v.value as V;\n  }\n  if (typeof valueOrFunction === `function`) {\n    const v = await valueOrFunction() as V;\n    return v;\n  }\n  return valueOrFunction as V;\n}\n\n// const object = {\n//   name: `blah`,\n//   gen: count(5)\n// }\n// const c = resolveValue(count(5));\n// const cc = resolveFields(object);\n// cc.gen\n\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n * \n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n * \n * It also works with generators\n * ```js\n * import { count } from './numbers.js';\n * \n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object \n * @returns \n */\nexport async function fieldResolve<V extends object>(object: V): Promise<ResolvedObject<V>> {\n  const output = [];\n  for (const entry of Object.entries(object)) {\n    const key = entry[ 0 ];\n    const valueOrFunction = entry[ 1 ] as ValueOrFunction<typeof entry[ 1 ]>;\n    const value = await resolveValue(valueOrFunction);\n    output.push([ key, value ]);\n  }\n  return Object.fromEntries(output) as ResolvedObject<V>;\n}\n\n/**\n * Returns a function that resolves `object`.\n * \n * Use {@link fieldResolve} to resolve an object directly.\n * @param object \n * @returns \n */\nexport function fieldResolver<V extends object>(object: V) {\n  return () => fieldResolve(object);\n}\n\nexport function pull<T extends Record<string, PrimitiveOrObject | (() => any)>>(value: T): { compute: () => Promise<PullRecord<T>>, dispose: () => void } {\n  const sources: Record<string, Rx.Reactive<any>> = {};\n  const fixedValues: Record<string, Array<any> | PrimitiveOrObject> = {};\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const callers: Record<string, Function | (() => any)> = {};\n\n  for (const [ key, v ] of Object.entries(value)) {\n    if (Array.isArray(v) || isPrimitive(v)) {\n      fixedValues[ key ] = v;\n      // } else if (isIterable(v) || isAsyncIterable(v)) {\n      //   generators[ key ] = ChainFromIterable(v)();\n    } else if (typeof v === `function`) {\n      callers[ key ] = v;\n    } else {\n      try {\n        console.log(`pull: ${ key }`);\n        const s = Rx.resolveSource(v as any);\n        (sources as any)[ key ] = s;\n      } catch {\n        fixedValues[ key ] = v;\n      }\n    }\n  }\n\n  // Merge sources to one Rx\n  const latestToObjectRx = Rx.combineLatestToObject(sources, { onSourceDone: `allow` });\n  let lastRxValue: Record<string, any> | undefined;\n  const latestToObjectOff = latestToObjectRx.value(v => {\n    lastRxValue = v;\n  });\n\n  //let computeCallersCount = 0;\n  const computeCallers = async () => {\n    const r = {};\n    //computeCallersCount++;\n    for (const [ key, value ] of Object.entries(callers)) {\n      (r as any)[ key ] = await value();\n    }\n    //console.log(`computeCallers: ${ computeCallersCount }`, r);\n    return r;\n  }\n\n  const compute = async () => ({ ...fixedValues, ...lastRxValue, ...(await computeCallers()) } as PullRecord<T>);\n  const dispose = () => {\n    latestToObjectOff();\n    latestToObjectRx.dispose(`ResolveFields.dispose`);\n  }\n  return { compute, dispose };\n}\n\n// export function push<T extends Record<string, Primitive | Rx.ReactiveOrSource<any>>>(value: T): { compute: () => Rx.RxPrimitiveValueTypeObject<T>, dispose: () => void } {\n//   const sources: Record<string, Rx.Reactive<any>> = {};\n//   //const interval = intervalToMs(options.interval, 100);\n//   const fixedValues: Record<string, Array<any> | Primitive> = {};\n\n//   // Convert dynamic things to a Reactive and stash under 'sources'\n//   // Stash fixed values to 'fixedValues'\n//   for (const [ key, v ] of Object.entries(value)) {\n//     if (Array.isArray(v) || isPrimitive(v)) {\n//       fixedValues[ key ] = v;\n//       continue;\n//     }\n//     const s = Rx.resolveSource(v);\n//     (sources as any)[ key ] = s;\n//   }\n\n//   // Merge sources to one Rx\n//   const r = Rx.mergeToObject(sources, { onSourceDone: `allow` });\n\n//   // Throttle data if necessary\n//   // if (interval > 0) {\n//   //   r = Rx.throttle(r, { elapsed: interval });\n//   // }\n\n//   let lastRxValue: Record<string, any> | undefined;\n//   const off = r.value(v => {\n//     lastRxValue = v;\n//   });\n\n//   const compute = () => ({ ...fixedValues, ...lastRxValue } as Rx.RxPrimitiveValueTypeObject<T>);\n//   const dispose = () => {\n//     off();\n//     if (Rx.isDisposable(r)) {\n//       r.dispose(`ResolveFields.dispose`);\n//     }\n//   }\n//   return { compute, dispose };\n// }\n","\nimport { type RandomOptions, type RandomSource } from '../random/Types.js';\nimport { throwNumberTest } from '../Guards.js';\nimport { interpolate } from './Interpolate.js';\nimport { scaler as numberScaler } from './Scale.js';\nimport { floatSource } from '../random/FloatSource.js';\n\n/**\n * Wrapper around a bipolar value. Immutable.\n * \n * ```js\n * let b = Bipolar.immutable();\n * let b = Bipolar.immutable(0.5);\n * b = b.add(0.1);\n * ```\n */\nexport type BipolarWrapper = {\n  value: number\n  towardZero: (amt: number) => BipolarWrapper\n  add: (amt: number) => BipolarWrapper\n  multiply: (amt: number) => BipolarWrapper\n  inverse: () => BipolarWrapper\n  asScalar: () => number\n  interpolate: (amt: number, b: number) => BipolarWrapper\n  [ Symbol.toPrimitive ]: (hint: string) => number | string | boolean\n}\n\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n * \n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n * \n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n * \n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValue \n * @returns \n */\nexport const immutable = (startingValueOrBipolar: number | BipolarWrapper = 0): BipolarWrapper => {\n  const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n\n  if (startingValue > 1) throw new Error(`Cannot be larger than 1`);\n  if (startingValue < -1) throw new Error(`Cannot be smaller than -1`);\n  if (Number.isNaN(startingValue)) throw new Error(`startingValue is NaN`);\n\n  const v = startingValue;\n  return {\n    [ Symbol.toPrimitive ](hint: string) {\n      if (hint === `number`) return v;\n      else if (hint === `string`) return v.toString();\n      return true;\n    },\n    value: v,\n    towardZero: (amt: number) => {\n      return immutable(towardZero(v, amt));\n    },\n    add: (amt: number) => {\n      return immutable(clamp(v + amt));\n    },\n    multiply: (amt: number) => {\n      return immutable(clamp(v * amt));\n    },\n    inverse: () => {\n      return immutable(-v);\n    },\n    interpolate: (amt: number, b: number) => {\n      return immutable(clamp(interpolate(amt, v, b)));\n    },\n    asScalar: () => {\n      return toScalar(v);\n    }\n  }\n}\n\n/**\n * Converts bipolar value to a scalar\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue: number) => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);\n  return (bipolarValue + 1) / 2;\n}\n\n/**\n * Makes a scalar into a bipolar value.\n * \n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n * \n * Throws an error if `scalarValue` is not on 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue: number) => {\n  throwNumberTest(scalarValue, `percentage`, `v`);\n  return (scalarValue * 2) - 1;\n};\n\n/**\n * Scale a number to -1..1 range\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * \n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue: number, inMin: number, inMax: number) => {\n  return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n}\n\n/**\n * Scale a number, clamped to -1..1 range\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * \n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleClamped = (inputValue: number, inMin: number, inMax: number) => {\n  return numberScaler(inMin, inMax, -1, 1)(inputValue);\n}\n\n/**\n * Source for random bipolar values\n * ```js\n * const r = Bipolar.randomSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n * \n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * Bipolar.randomSource({ max: 0.5 });\n * ```\n * \n * Consider using {@link random} if you just want a one-off random\n * value.\n * @param source \n * @returns \n */\nexport const randomSource = (maxOrOptions?: number | RandomOptions): RandomSource => {\n  const source = floatSource(maxOrOptions);\n  return () => (source() * 2) - 1;\n}\n\n/**\n * Returns a random bipolar value\n * ```js\n * const r = Bipolar.random(); // -1...1 random\n * ```\n * \n * Options can be provided, eg.\n * ```js\n * Bipolar.random({ max: 0.5 }); // -0.5..0.5 random\n * ```\n * \n * Use {@link randomSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions \n * @returns \n */\nexport const random = (maxOrOptions?: number | RandomOptions): number => {\n  const source = randomSource(maxOrOptions);\n  return source();\n}\n/**\n * Clamp a bipolar value\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter must be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`v parameter is NaN`);\n  if (bipolarValue > 1) return 1;\n  if (bipolarValue < -1) return -1;\n  return bipolarValue;\n}\n\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n * \n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n * \n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue: number, amount: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${ typeof bipolarValue }`);\n  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${ typeof amount }`);\n  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);\n  if (bipolarValue < 0) {\n    bipolarValue += amount;\n    if (bipolarValue > 0) bipolarValue = 0;\n  } else if (bipolarValue > 0) {\n    bipolarValue -= amount;\n    if (bipolarValue < 0) bipolarValue = 0;\n  }\n  return bipolarValue;\n}","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn\n * @param lastData\n * @param newData\n * @param opts\n * @returns\n */\n//eslint-disable-next-line functional/immutable-data\nexport const align = <V>(\n  similarityFn: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  opts: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = opts.matchThreshold ?? 0;\n  const debug = opts.debug ?? false;\n  const results = new Map();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map();\n  lastData?.forEach((d, index) => {\n    if (d === undefined) {\n      throw new Error(`'lastData' contains undefined (index: ${index})`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < newData.length; i++) {\n    const newD = newData[i];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${newD.id}`);\n\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: last.id,\n      score: last === null ? -1 : similarityFn(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n    //eslint-disable-next-line functional/immutable-data\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[0];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${top.score} id: ${newD.id}`\n        );\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score})`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    //eslint-disable-next-line functional/immutable-data\n    lastMap.delete(top.id);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn\n * @param opts\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, opts: AlignOpts = {}) => {\n  //eslint-disable-next-line functional/no-let\n  let lastData: readonly DataWithId<V>[] = [];\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, opts);\n    return [...lastData];\n  };\n  return compute;\n};\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as Debug from '../debug/index.js';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type Opts<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string, data: V) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    //const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`, data);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: Array<PoolUser<V>>;\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`, data);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n */\nexport class Pool<V> {\n  private _resources: Array<Resource<V>>;\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet;\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param opts Pool options\n   */\n  constructor(opts: Opts<V> = {}) {\n    this.capacity = opts.capacity ?? -1;\n    this.fullPolicy = opts.fullPolicy ?? `error`;\n    this.capacityPerResource = opts.capacityPerResource ?? 1;\n    this.userExpireAfterMs = opts.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      opts.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = opts.generate;\n    this.freeResource = opts.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, opts.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    //eslint-disable-next-line functional/no-let\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a resource to the pool.\n   * Throws an error if the capacity limit is reached.\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new Error(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    //eslint-disable-next-line functional/no-let\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Array<Resource<V>> = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: Array<string> = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`, user.data);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  private _findUser(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    //eslint-disable-next-line functional/no-let\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a user key.\n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * @param userKey\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this._findUser(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      //console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this._findUser(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param opts\n * @returns\n */\nexport const create = <V>(opts: Opts<V> = {}): Pool<V> => new Pool<V>(opts);\n","import * as Drawing from './Drawing.js';\nimport * as Svg from './Svg.js';\n//import * as Plot from './Plot.js';\n\nimport * as Plot2 from './Plot2.js';\n\nimport * as Palette from './Palette.js';\nimport * as Colour from './Colour.js';\nimport * as SceneGraph from './SceneGraph.js';\nimport * as Video from './Video.js';\n\nexport * as ImageDataGrid from './ImageDataGrid.js';\nexport * as BipolarView from './BipolarView.js';\nexport * as Palette from './Palette.js';\nexport * as Drawing from './Drawing.js';\nexport * as Svg from './Svg.js';\n//export * as Plot from './Plot.js';\n\n\nexport * as Plot2 from './Plot2.js';\nexport * as PlotOld from './PlotOld.js';\nexport * as SceneGraph from './SceneGraph.js';\nexport * from './ScaleCanvas.js';\n\n/**\n * Colour interpolation, scale generation and parsing\n *\n * Overview\n * * {@link interpolate}: Blend colours\n * * {@link scale}: Produce colour scale\n * * {@link opacity}: Give a colour opacity\n * * {@link randomHue}: Generate a random hue\n * * {@link goldenAngleColour}: Pick perceptually different shades\n *\n * CSS\n * * {@link getCssVariable}: Parse a CSS-defined colour\n *\n * Conversions: convert from 'blue', 'rgb(255,0,0)',  'hsl(0, 100%, 50%)' etc:\n * * {@link toHex}: to a hex format string\n * * {@link toHsl}: to a `{h, s, l}` object\n * * {@link toRgb}: to a `{r, g, b}` object\n */\nexport * as Colour from './Colour.js';\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n * ```\n */\nexport * as Video from './Video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        SceneGraph,\n        Plot2,\n        Drawing,\n        Svg,\n        Palette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n","import * as Points from '../geometry/point/index.js';\nimport * as Lines from '../geometry/line/index.js';\nimport * as Triangles from '../geometry/triangle/index.js';\nimport { throwArrayTest } from '../Guards.js';\nimport * as Arcs from '../geometry/arc/index.js';\nimport * as Beziers from '../geometry/Bezier.js';\nimport * as Ellipses from '../geometry/Ellipse.js';\nimport * as Colours from '../visual/Colour.js';\nimport { resolveEl } from '../dom/ResolveEl.js';\nimport { roundUpToMultiple } from '../Util.js';\nimport type { IStackImmutable } from '../collections/stack/IStackImmutable.js';\nimport { StackImmutable } from '../collections/stack/StackImmutable.js';\n//import type { Point, CirclePositioned, Rect, RectPositioned } from '../geometry/Types.js';\n//import type { Line, Path, Triangle } from '../geometry/Types.js';\nimport type { Point } from '../geometry/point/index.js';\nimport type { Line } from '../geometry/line/index.js';\nimport type { CirclePositioned } from '../geometry/circle/index.js';\nimport type { Rect, RectPositioned } from '../geometry/rect/index.js';\nimport type { Path } from '../geometry/path/index.js';\nimport type { Triangle } from '../geometry/triangle/index.js';\n\nimport { empty as RectsEmpty } from '../geometry/rect/index.js';\nimport { corners as RectsCorners } from '../geometry/rect/Corners.js';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElCtxOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rect\n) => {\n  // TODO: Is there a way of automagically defining makeHelper to avoid repetition and keep typesafety and JSDoc?\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    paths(pathsToDraw: Array<Path>, opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Line | Array<Line>, opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: RectPositioned | Array<RectPositioned>,\n      opts?: DrawingOpts & { filled?: boolean }\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Array<Point>,\n      opts?: DrawingOpts & { loop?: boolean }\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Array<Point>, opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Point | Array<Point>,\n      opts?: DrawingOpts & {\n        radius: number;\n        outlined?: boolean;\n        filled?: boolean;\n      }\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: CirclePositioned | Array<\n        CirclePositioned>,\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Array<Arcs.ArcPositioned>,\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: Array<string>,\n      opts: DrawingOpts & {\n        anchor: Point;\n        anchorPadding?: number;\n        bounds?: RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: ReadonlyArray<StackOp>\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  //eslint-disable-next-line functional/immutable-data\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | ReadonlyArray<Arcs.ArcPositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: ReadonlyArray<StackOp>): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    // eslint-disable-next-line functional/immutable-data\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  if (stk === undefined) stk = new StackImmutable<StackOp>();\n\n  const push = (...ops: Array<StackOp>): DrawingStack => {\n    if (stk === undefined) stk = new StackImmutable<StackOp>();\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: ReadonlyArray<Point>,\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: CirclePositioned | ReadonlyArray<CirclePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c);\n  } else {\n    draw(circlesToDraw as CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | ReadonlyArray<Ellipses.EllipsePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: ReadonlyArray<Path> | Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (Lines.isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Path);\n  }\n};\n\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: {\n    readonly lineWidth?: number\n    readonly loop?: boolean\n    readonly fillStyle?: string\n    readonly strokeStyle?: string\n  } = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n\n  throwArrayTest(pts);\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    //eslint-disable-next-line functional/immutable-data\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: { readonly fillStyle?: string } = {},\n  labels?: ReadonlyArray<string>\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Point\n): Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  //eslint-disable-next-line functional/immutable-data\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Point | ReadonlyArray<Point>,\n  opts?: DrawingOpts & {\n    readonly radius?: number;\n    readonly outlined?: boolean;\n    readonly filled?: boolean;\n  }\n) => {\n  if (opts === undefined) opts = {};\n  const radius = opts.radius ?? 10;\n\n  applyOpts(ctx, opts);\n\n  ctx.beginPath();\n\n  // x&y for arc is the center of circle\n  if (Array.isArray(pos)) {\n    for (const p of pos) {\n      ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n    }\n  } else {\n    const p = pos as Point;\n    ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  if (opts.filled || !opts.outlined) ctx.fill();\n  if (opts.outlined) ctx.stroke();\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.opacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.opacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Line | ReadonlyArray<Line>,\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t);\n  } else {\n    draw(toDraw as Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangle | ReadonlyArray<Triangle>,\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rect | RectPositioned | ReadonlyArray<RectPositioned>,\n  opts: DrawingOpts & {\n    readonly filled?: boolean;\n    readonly stroked?: boolean;\n  } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroked = opts.stroked ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: RectPositioned | Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroked ?? true) ctx.strokeRect(x, y, d.width, d.height);\n\n    if (opts.debug) {\n      pointLabels(ctx, RectsCorners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // if (widthMultiple) return roundUpToMultiple(m.width, widthMultiple) + padding;\n  // return m.width + padding;\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rect => {\n  if (text === undefined || text === null || text.length === 0) return RectsEmpty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? roundUpToMultiple(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: ReadonlyArray<string>,\n  opts: DrawingOpts & {\n    readonly anchor: Point;\n    readonly anchorPadding?: number;\n    readonly bounds?: RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  //eslint-disable-next-line functional/prefer-tacit\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  // eslint-disable-next-line functional/no-let\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: ReadonlyArray<string> | string,\n  opts: DrawingOpts & {\n    readonly bounds: RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import { minIndex } from '../collections/arrays/NumericArrays.js';\nimport * as Arrays from '../collections/arrays/index.js';\nimport * as Points from '../geometry/point/index.js';\nimport { clamp } from '../data/Clamp.js';\nimport { flip } from '../data/Flip.js';\nimport { scale } from '../data/Scale.js';\nimport * as Sg from './SceneGraph.js';\n\nimport { textRect, textWidth } from './Drawing.js';\nimport { ifNaN } from '../Util.js'\nimport { getPaths, getField } from '../Immutable.js';\nimport { throwNumberTest } from '../Guards.js';\nimport type { Rect, RectPositioned, PointCalculableShape } from '../geometry/Types.js';\nimport { subtract as RectsSubtract } from '../geometry/rect/Subtract.js';\nimport { scaleCanvas } from './ScaleCanvas.js';\nimport { parentSizeCanvas } from '../dom/CanvasSizing.js';\n\n/**\n * \n *  const dataStream = new DataStream();\n *  dataStream.in({ key: `x`, value: 0.5 }); \n *  const label = (obj:any) => {\n *    if (`key` in obj) return obj;\n *    return { key: randomKey(), ...obj }\n *  }\n *  const stream = pipeline(dataStream, label);\n *  // Actively compute size of window based on window width\n *  const windowSize = ops.divide(rxWindow.innerWidth, pointSize);\n *  const dataWindow = window(stream, windowSize);\n *  const dataToPoints = (value);\n * \n *  const drawPlot = (dataWindow) => {\n *    for (const dataPoint in dataWindow) {\n *    }\n *  }\n */\n\n/**\n * A data source\n */\nexport type DataSource = {\n  dirty: boolean;\n  type: string;\n  get range(): DataRange;\n  add(value: number): void;\n  clear(): void;\n}\n\n/**\n * Plot options\n */\nexport type Opts = {\n  /**\n   * If true, Canvas will be resized to fit parent\n   */\n  autoSize?: boolean;\n  /**\n   * Colour for axis lines & labels\n   */\n  axisStrokeColour?: string;\n\n  axisTextColour?: string\n\n  legendTextColour?: string\n  /**\n   * Width for axis lines\n   */\n  axisStrokeWidth?: number;\n};\n\n/**\n * Series options\n */\nexport type SeriesOpts = {\n  /**\n   * Colour for series\n   */\n  colour: string;\n  /**\n   * Visual width/height (depends on drawingStyle)\n   */\n  width?: number;\n  /**\n   * How series should be rendered\n   */\n  drawingStyle?: `line` | `dotted` | `bar`;\n  /**\n   * Preferred data range\n   */\n  axisRange?: DataRange;\n  /**\n   * If true, range will stay at min/max, rather than continuously adapting\n   * to the current data range.\n   */\n  visualRangeStretch?: boolean;\n};\n\nexport type DataPoint = {\n  value: number;\n  index: number;\n  title?: string;\n};\n\nexport type DataHitPoint = (\n  pt: Points.Point\n) => [ point: DataPoint | undefined, distance: number ];\n\nclass ArrayDataSource implements DataSource {\n  data: Array<number>;\n  series: Series;\n  dirty = false;\n  type = `array`;\n\n  private _range: Arrays.MinMaxAvgTotal | undefined;\n\n  constructor(series: Series) {\n    this.series = series;\n    this.data = [];\n    this.dirty = true;\n  }\n\n  clear() {\n    this.set([]);\n    this._range = undefined;\n  }\n\n  set(data: Array<number>) {\n    this.data = data;\n    this.dirty = true;\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get range(): DataRange {\n    if (!this.dirty && this._range !== undefined) return this._range;\n    this.dirty = false;\n    const updatedRange = Arrays.minMaxAvg(this.data);\n    if (this._range === undefined || updatedRange.max !== this._range.max || updatedRange.min !== this._range.min) {\n      this._range = updatedRange;\n      return { ...this._range, changed: true };\n    } else {\n      return { ...this._range, changed: false };\n\n    }\n  }\n\n  add(value: number) {\n    this.data = [ ...this.data, value ];\n    this.dirty = true;\n  }\n}\n\nclass StreamingDataSource extends ArrayDataSource {\n  desiredDataPointMinWidth = 5;\n\n  add(value: number) {\n    const lastWidth = this.series.lastPxPerPt;\n    if (lastWidth > -1 && lastWidth < this.desiredDataPointMinWidth) {\n      // Remove older data\n      const pts = Math.floor(this.desiredDataPointMinWidth / lastWidth);\n      const d = [ ...this.data.slice(pts), value ];\n      super.set(d);\n    } else super.add(value);\n  }\n}\n\nexport type DataRange = {\n  min: number;\n  max: number;\n  changed?: boolean;\n};\n\nexport class Series {\n  name: string;\n  colour: string;\n  source: DataSource;\n  drawingStyle: `line` | `dotted` | `bar`;\n  width = 3;\n  dataHitPoint: DataHitPoint | undefined;\n  tooltip?: string;\n  precision = 2;\n\n  readonly axisRange: DataRange;\n\n  // How many pixels wide per data point on last draw\n  lastPxPerPt = -1;\n\n  protected _visualRange: DataRange;\n  protected _visualRangeStretch: boolean;\n\n  constructor(\n    name: string,\n    sourceType: `array` | `stream`,\n    private plot: Plot,\n    opts: SeriesOpts\n  ) {\n    this.name = name;\n\n    this.drawingStyle = opts.drawingStyle ?? `line`;\n    this.colour = opts.colour;\n    this.width = opts.width ?? 3;\n    this.axisRange = opts.axisRange ?? { min: Number.NaN, max: Number.NaN };\n    this._visualRange = { ...this.axisRange };\n    this._visualRangeStretch = opts.visualRangeStretch ?? true;\n\n    if (sourceType === `array`) {\n      this.source = new ArrayDataSource(this);\n    } else if (sourceType === `stream`) {\n      this.source = new StreamingDataSource(this);\n    } else throw new Error(`Unknown sourceType. Expected array|stream`);\n  }\n\n  formatValue(v: number) {\n    return v.toFixed(this.precision);\n  }\n\n  get visualRange(): DataRange {\n    let vr = this._visualRange;\n    const sourceRange = this.source.range;\n    let changed = false;\n\n    if (sourceRange.changed) {\n      if (this._visualRangeStretch) {\n        // Stretch range to lowest/highest-seen min/max\n        const rmin = Math.min(ifNaN(vr.min, sourceRange.min), sourceRange.min);\n        const rmax = Math.max(ifNaN(vr.max, sourceRange.max), sourceRange.max);\n        if (rmin !== vr.min || rmax !== vr.max) {\n          // Changed\n          vr = { min: rmin, max: rmax };\n          changed = true;\n        }\n      } else {\n        // Use actual range of data\n        if (!isRangeEqual(sourceRange, vr)) {\n          vr = sourceRange;\n          changed = true;\n        }\n      }\n    }\n    this._visualRange = vr;\n    return { ...vr, changed };\n  }\n\n  scaleValue(value: number): number {\n    if (this.source === undefined) return value;\n    const r = this.visualRange;\n    if (r.changed) {\n      this.plot.notify(`range-change`, this.plot.plotArea);\n    }\n    if (r.min == r.max) {\n      // No real scale - only received the same value for this series\n      return 0.5;\n    }\n    return scale(value, r.min, r.max);\n  }\n\n  add(value: number) {\n    throwNumberTest(value, ``, `value`);\n    this.source.add(value);\n    //this.plot.plotArea.layoutInvalidated(`Series.add`);\n    this.plot.plotArea.drawingInvalidated(`Series.add`);\n  }\n\n  /**\n   * Clears the underlying source\n   * and sets a flag that the plot area needs redrawing\n   */\n  clear() {\n    this.source.clear();\n    this._visualRange = { ...this.axisRange };\n    this.plot.plotArea.layoutInvalidated(`Series.clear`);\n  }\n}\n\nexport class PlotArea extends Sg.CanvasBox {\n  paddingPx = 5;\n  piPi = Math.PI * 2;\n  // If pointer is more than this distance away from a data point, it's ignored\n  pointerDistanceThreshold = 20;\n  lastRangeChange = 0;\n  pointer: Points.Point | undefined;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `PlotArea`, region);\n\n  }\n\n  clear() {\n    this.lastRangeChange = 0;\n    this.pointer = undefined;\n  }\n\n  protected measureSelf(\n    opts: Sg.MeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | string {\n\n    const axisY = opts.getActualSize(`AxisY`);\n    const padding = this.paddingPx;\n    const legend = opts.getActualSize(`Legend`);\n    const legendHeight = legend?.height ?? 0;\n\n    const axisX = opts.getActualSize(`AxisX`);\n    const axisXHeight = axisX?.height ?? 0;\n\n    if (!axisY) return `No AxisY. Measured: ${ opts.whatIsMeasured().join(`, `) }`;\n    if (!legend) return `No Legend`;\n    if (!axisX) return `No AxisX`;\n\n    return {\n      width: opts.bounds.width - axisY.width - this.paddingPx,\n      height: opts.bounds.height - legendHeight - axisXHeight - padding,\n    };\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent: Sg.Layout) {\n    const axisY = measureState.getActualSize(`AxisY`);\n    //const axisX = measureState.getActualSize(`AxisX`);\n    const padding = this.paddingPx;\n\n    //const legend = measureState.getActualSize(`Legend`);\n    //const legendHeight = legend?.height ?? 0;\n\n    //const axisXHeight = axisX?.height ?? 0;\n    const axisYWidth = axisY?.width ?? 0;\n\n    //const height = this._measuredSize?.height ?? 0;\n\n    return {\n      x: axisYWidth,\n      y: padding // layoutState.bounds.height - height - axisXHeight - legendHeight\n    }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(`onNotify message: ${ message } source: ${ source.id }`);\n    if (message === `measureApplied` && source === this.plot.axisY)\n      this.layoutInvalidated(`PlotArea.onNotify measureApplied to axisY`);\n    if (message === `laidout` && source === this.plot.legend)\n      this.layoutInvalidated(`PlotArea.onNotify laidout to legend`);\n  }\n\n  // protected onClick(p: Point): void {\n  //   this.plot.frozen = !this.plot.frozen;\n  // }\n\n  protected onPointerLeave(): void {\n    for (const series of this.plot.series.values()) {\n      series.tooltip = undefined;\n    }\n    this.pointer = undefined;\n    (this.plot.legend as Sg.CanvasBox).drawingInvalidated(`PlotArea.onPointerLeave`);\n  }\n\n  protected onPointerMove(p: Points.Point): void {\n    this.pointer = p;\n    this.plot.legend.drawingInvalidated(`PlotArea.onPointerMove`);\n  }\n\n  protected measurePreflight(): void {\n    this.updateTooltip();\n  }\n\n  updateTooltip() {\n    const p = this.pointer;\n    if (p === undefined) return;\n\n    for (const series of this.plot.series.values()) {\n      if (p === undefined) {\n        series.tooltip = undefined;\n        return;\n      }\n      if (series.dataHitPoint === undefined) return;\n      const v = series.dataHitPoint(p);\n      if (v[ 0 ] === undefined) return;\n      if (v[ 1 ] > this.pointerDistanceThreshold) return; // too far away\n      series.tooltip = series.formatValue(v[ 0 ].value);\n      //this.plot.legend.onLayoutNeeded();\n    }\n    this.plot.legend.drawingInvalidated(`PlotArea.updateTooltip`);\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    if (this.plot.frozen) return;\n    const seriesCopy = this.plot.seriesArray(); // [...this.plot.series.values()];\n    //ctx.fillStyle = `hsla(10,50%,50%,0.5)`;\n    //ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n\n    // Using -1 for y to catch a few random peaks from sharp lines\n    ctx.clearRect(0, -1, this.canvasRegion.width, this.canvasRegion.height);\n\n    for (const series of seriesCopy) {\n      if (series.source.type === `array` || series.source.type === `stream`) {\n        const arraySeries = series.source as ArrayDataSource;\n        if (arraySeries.data === undefined) return;\n        const d = [ ...arraySeries.data ];\n        this.drawDataSet(series, d, ctx);\n      } else console.warn(`Unknown data source type ${ series.source.type }`);\n    }\n  }\n\n  computeY(series: Series, rawValue: number) {\n    const s = series.scaleValue(rawValue);\n    return flip(s) * this.canvasRegion.height + this.paddingPx;\n  }\n\n  drawDataSet(\n    series: Series,\n    d: Array<number>,\n    ctx: CanvasRenderingContext2D\n  ): void {\n    const padding = this.paddingPx + series.width;\n    const v = RectsSubtract(this.canvasRegion, padding * 2, padding * 3.5);\n    const pxPerPt = v.width / d.length;\n\n    series.lastPxPerPt = pxPerPt;\n    let x = padding;\n\n    ctx.strokeStyle = series.colour;\n    ctx.lineWidth = series.width;\n    const shapes: Array<DataPoint & PointCalculableShape> = [];\n\n    series.dataHitPoint = (pt: Points.Point): [ DataPoint, number ] => {\n      const distances = shapes.map((v) => Points.distanceToExterior(pt, v));\n      const index = minIndex(...distances);\n      const closest = shapes[ index ];\n      if (closest === undefined) [ undefined, 0 ];\n      return [ closest, distances[ index ] ];\n    };\n\n    // eslint-disable-next-line unicorn/prefer-switch\n    if (series.drawingStyle === `line`) {\n      let y = 0;\n      ctx.beginPath();\n\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = clamp(series.scaleValue(d[ index ]));\n        y = padding + this.paddingPx + v.height * flip(scaled);\n        shapes.push({ x, y, index: index, value: d[ index ] });\n\n        if (index == 0) ctx.moveTo(x + pxPerPt / 2, y);\n        else ctx.lineTo(x + pxPerPt / 2, y);\n\n        if (y > this.canvasRegion.height)\n          console.warn(`${ y } h: ${ this.canvasRegion.height }`);\n        x += pxPerPt;\n      }\n      ctx.strokeStyle = series.colour;\n      ctx.stroke();\n    } else if (series.drawingStyle === `dotted`) {\n      let y = 0;\n      ctx.fillStyle = series.colour;\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = series.scaleValue(d[ index ]);\n        y = padding + v.height * flip(scaled);\n        ctx.beginPath();\n        ctx.arc(x + pxPerPt / 2, y, series.width, 0, this.piPi);\n        ctx.fill();\n        shapes.push({ radius: series.width, x, y, index: index, value: d[ index ] });\n        x += pxPerPt;\n      }\n    } else if (series.drawingStyle === `bar`) {\n      ctx.fillStyle = series.colour;\n      const interBarPadding = Math.ceil(pxPerPt * 0.1);\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let index = 0; index < d.length; index++) {\n        const scaled = series.scaleValue(d[ index ]);\n        const h = v.height * scaled;\n        const r = {\n          x: x + interBarPadding,\n          y: v.height - h + padding,\n          width: pxPerPt - interBarPadding,\n          height: h,\n          index: index,\n          value: d[ index ],\n        };\n        ctx.fillRect(r.x, r.y, r.width, r.height);\n        shapes.push(r);\n        x += pxPerPt;\n      }\n    }\n  }\n}\n\nexport class Legend extends Sg.CanvasBox {\n  sampleSize = { width: 10, height: 10 };\n  padding = 3;\n  widthSnapping = 20;\n\n  labelMeasurements = new Map<string, RectPositioned>();\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `Legend`, region);\n  }\n\n  clear() {\n    /** no-op */\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, layoutState: Sg.LayoutState, _parent: Sg.Layout) {\n    const axisY = measureState.getActualSize(`AxisY`);\n    const axisYWidth = axisY?.width ?? 0;\n\n    const height = this._measuredSize?.height ?? 0;\n    return {\n      x: axisYWidth,\n      y: layoutState.bounds.height - height\n    }\n  }\n\n  protected measureSelf(\n    opts: Sg.CanvasMeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | RectPositioned | string {\n    const series = this.plot.seriesArray();\n    const sample = this.sampleSize;\n    const padding = this.padding;\n    const widthSnapping = this.widthSnapping;\n    const ctx = opts.ctx;\n\n    const yAxis = opts.measurements.get(`AxisY`);\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    let x = padding;\n    let y = padding;\n    const availableWidth = opts.bounds.width - yAxisWidth - padding;\n\n    //let rows = 1;\n    let rowHeight = 0;\n    for (const s of series) {\n      const startX = x;\n      x += sample.width + padding;\n      ctx.textBaseline = `middle`;\n\n      const text = textRect(ctx, s.name, padding, widthSnapping);\n\n      x += textWidth(ctx, s.name, padding, widthSnapping);\n\n      if (s.tooltip) {\n        x += textWidth(ctx, s.tooltip, padding, widthSnapping);\n      }\n      const r = { width: 10, height: 10, x: startX, y };\n\n      this.labelMeasurements.set(s.name, r)\n      rowHeight = Math.min(sample.height + padding + padding, text.height + padding + padding);\n      x += padding;\n      if (x > availableWidth) {\n        x = padding;\n        y += rowHeight;\n        //rows++;\n\n      }\n    }\n\n    return {\n      width: availableWidth,\n      height: y + rowHeight\n    }\n    // const ctx = (opts as Sg.CanvasMeasureState).ctx;\n\n    // const usableWidth = opts.bounds.width - yAxisWidth;\n\n    // let width = padding;\n    // for (const s of series) {\n    //   width += sample.width + padding;\n    //   width += textWidth(ctx, s.name, padding, widthSnapping);\n    //   width += textWidth(ctx, s.tooltip, padding, widthSnapping);\n    // }\n\n    // const rows = Math.max(1, Math.ceil(width / usableWidth));\n    // console.log(`rows: ${ rows }`);\n    // const h = rows * (this.sampleSize.height + this.padding + this.padding);\n    // return {\n    //   x: yAxisWidth,\n    //   y: opts.bounds.height - h,\n    //   width: usableWidth,\n    //   height: h,\n    // };\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const series = this.plot.seriesArray();\n    const sample = this.sampleSize;\n    const padding = this.padding;\n    this.debugLog(`drawSelf`);\n\n    ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n    for (const s of series) {\n      const r = this.labelMeasurements.get(s.name);\n      if (r === undefined) continue;\n      let x = r.x;\n\n      // Draw colour chip\n      ctx.fillStyle = s.colour;\n      ctx.fillRect(x, r.y, sample.width, sample.height);\n      x += sample.width + padding;\n\n      // Label\n      ctx.textBaseline = `middle`;\n      ctx.fillStyle = this.plot.legendTextColour;\n      ctx.fillText(s.name, x, r.y + sample.height / 2);\n\n      if (s.tooltip) {\n        ctx.fillStyle = this.plot.legendTextColour;\n        ctx.fillText(s.tooltip, r.x, r.y + sample.height / 2);\n      }\n    }\n    // const series = this.plot.seriesArray();\n    // const sample = this.sampleSize;\n    // const padding = this.padding;\n    // const widthSnapping = this.widthSnapping;\n\n    // let x = padding;\n    // let y = padding;\n\n    // ctx.clearRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n    // let rows = 1;\n    // for (const s of series) {\n    //   ctx.fillStyle = s.colour;\n    //   ctx.fillRect(x, y, sample.width, sample.height);\n    //   x += sample.width + padding;\n    //   ctx.textBaseline = `middle`;\n    //   ctx.fillStyle = this.plot.legendTextColour;\n    //   ctx.fillText(s.name, x, y + sample.height / 2);\n    //   x += textWidth(ctx, s.name, padding, widthSnapping);\n\n    //   if (s.tooltip) {\n    //     ctx.fillStyle = this.plot.legendTextColour;\n    //     ctx.fillText(s.tooltip, x, y + sample.height / 2);\n    //     x += textWidth(ctx, s.tooltip, padding, widthSnapping);\n    //   }\n    //   x += padding;\n    //   if (x > this.canvasRegion.width - 100) {\n    //     x = padding;\n    //     y += sample.height + padding + padding;\n    //     rows++;\n    //     this.debugLog(`drawSelf rows: ${ rows }`);\n    //   }\n    // }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    this.debugLog(`onNotify ${ message } source: ${ source.id }`);\n    if (message === `measureApplied` && source === (this._parent as Plot).axisY) {\n      this.layoutInvalidated(`Legend.onNotify measureApplied to axisY`);\n\n    } else if (message == `range-change`) {\n      //this.layoutInvalidated(`Legend.onNotify range-change`);\n    }\n  }\n}\n\nexport class AxisX extends Sg.CanvasBox {\n  paddingPx = 2;\n  colour?: string;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `AxisX`, region);\n  }\n\n  clear() {\n    /** no-op */\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(message);\n    if (message === `measureApplied` && source === this.plot.axisY) {\n      this.layoutInvalidated(`AxisX.onNotify measureApplied to axisY`);\n    }\n    // if (message === `measureApplied` && source === this.plot.legend) {\n    //   this.layoutInvalidated(`AxisX.onNotify measureApplied to legend`);\n    // }\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const plot = this.plot;\n    const v = this.canvasRegion;\n    const strokeWidth = plot.axisStrokeWidth;\n\n    const colour = this.colour ?? plot.axisStrokeColour;\n    ctx.strokeStyle = colour;\n\n    ctx.clearRect(0, 0, v.width, v.height);\n    //ctx.fillStyle = `hsla(200,50%,50%,0.5)`;\n    //ctx.fillRect(0, 0, v.width, v.height);\n    //this.debugLog(`drawSelf: ${ v.width } x ${ v.height } padding: ${ this.paddingPx }`);\n    ctx.beginPath();\n    ctx.lineWidth = strokeWidth;\n    ctx.moveTo(0, strokeWidth / 2);\n    ctx.lineTo(v.width, strokeWidth / 2);\n    ctx.stroke();\n  }\n\n  protected measureSelf(\n    opts: Sg.CanvasMeasureState,\n    _parent?: Sg.Measurement\n  ): Rect | RectPositioned | string {\n    const plot = this.plot;\n    const padding = this.paddingPx;\n    const yAxis = opts.measurements.get(`AxisY`);\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    // TODO: If we start using x-axis labels\n    const heightOfText = 0;//textHeight(opts.ctx, `100`, padding);\n    const h = plot.axisStrokeWidth + heightOfText + padding + padding;\n\n    return {\n      width: opts.bounds.width - yAxisWidth - padding,\n      height: h,\n    };\n  }\n\n  protected layoutSelf(measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent?: Sg.Layout | undefined): Points.Point | undefined {\n    const yAxis = measureState.measurements.get(`AxisY`);\n    const legend = measureState.getActualSize(`Legend`);\n    const legendHeight = legend?.height ?? 0;\n\n    const yAxisWidth = yAxis?.actual.width ?? 0;\n\n    const height = this._measuredSize?.height ?? 0;\n    return {\n      x: yAxisWidth,\n      y: measureState.bounds.height - height - legendHeight\n    }\n  }\n}\n\nconst isRangeEqual = (a: DataRange, b: DataRange) =>\n  a.max === b.max && a.min === b.min;\nconst isRangeSinglePoint = (a: DataRange) => a.max === a.min;\n\nexport class AxisY extends Sg.CanvasBox {\n  // Number of digits axis will be expected to show as a data legend\n  private _maxDigits = 1;\n\n  seriesToShow: string | undefined;\n  paddingPx = 2;\n  colour?: string;\n\n  lastRange: DataRange;\n  lastPlotAreaHeight = 0;\n\n  constructor(private plot: Plot, region: RectPositioned) {\n    super(plot, `AxisY`, region);\n    this.lastRange = { min: 0, max: 0 };\n  }\n\n  clear() {\n    this.lastRange = { min: 0, max: 0 };\n    this.lastPlotAreaHeight = 0;\n  }\n\n  protected measurePreflight(): void {\n    //this.debugLog(`measurePreflight`);\n    // const series = this.getSeries();\n    // if (\n    //   series !== undefined &&\n    //   !isRangeEqual(series.visualRange, this.lastRange)\n    // ) {\n    //   this.layoutInvalidated(`AxisY.measurePreflight`);\n    // }\n  }\n\n  protected onNotify(message: string, source: Sg.Box): void {\n    //this.debugLog(message);\n    const pa = this.plot.plotArea;\n    if (message === `range-change`) {\n      // Notification that series range has changed\n      this.drawingInvalidated(`range-change`);\n      return;\n    }\n\n    if (message === `measureApplied` && source === pa && (pa.canvasRegion.height !== this.lastPlotAreaHeight)) {\n      this.lastPlotAreaHeight = pa.canvasRegion.height;\n      this.drawingInvalidated(`AxisY.onNotify height change`);\n    }\n  }\n\n  protected measureSelf(copts: Sg.CanvasMeasureState): Rect {\n    //this.debugLog(`measureSelf. needsLayout: ${ this._needsLayoutX } needsDrawing: ${ this._needsDrawing }`);\n\n    if (copts.ctx === undefined) throw new Error(`opts.ctx is undefined`);\n\n    const paddingPx = this.paddingPx;\n    let width = this.plot.axisStrokeWidth + paddingPx;\n\n    const series = this.getSeries();\n    if (series !== undefined) {\n      const r = series.visualRange;\n      this._maxDigits =\n        Math.ceil(r.max).toString().length + series.precision + 1;\n\n      const textToMeasure = `9`.repeat(this._maxDigits);\n      width += textWidth(copts.ctx, textToMeasure, paddingPx * 2);\n    }\n    const w = copts.resolveToPx(this.desiredRegion?.width, width, width);\n    return {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      width: w!,\n      height: copts.bounds.height,\n    };\n  }\n\n  protected layoutSelf(_measureState: Sg.MeasureState, _layoutState: Sg.LayoutState, _parent?: Sg.Layout | undefined): Points.Point {\n    return { x: 0, y: 0 }\n  }\n\n  protected drawSelf(ctx: CanvasRenderingContext2D): void {\n    const s = this.getSeries();\n    if (s === undefined) {\n      if (this.seriesToShow === undefined) return;\n      console.warn(`Plot AxisY series '${ this.seriesToShow }' is missing.`);\n    } else {\n      this.seriesAxis(s, ctx);\n    }\n  }\n\n  getSeries(): Series | undefined {\n    return this.seriesToShow === undefined ?\n      // Pick first series\n      this.plot.seriesArray()[ 0 ] :\n      // Try designated series name\n      this.plot.series.get(this.seriesToShow);\n  }\n\n  seriesAxis(series: Series, ctx: CanvasRenderingContext2D) {\n    const plot = this.plot;\n    const plotArea = plot.plotArea;\n    const v = this.canvasRegion;\n    const paddingPx = this.paddingPx;\n    const r = series.visualRange;\n    const strokeWidth = plot.axisStrokeWidth;\n\n    const colour = this.colour ?? plot.axisStrokeColour;\n    ctx.strokeStyle = colour;\n    ctx.fillStyle = colour;\n\n    if (Number.isNaN(r.min) && Number.isNaN(r.max)) return; // Empty\n    this.lastRange = r;\n    ctx.clearRect(0, 0, v.width, v.height);\n\n    // ctx.fillStyle = `yellow`;\n    // ctx.fillRect(0, 0, this.canvasRegion.width, this.canvasRegion.height);\n\n    ctx.beginPath();\n    ctx.lineWidth = strokeWidth;\n    const lineX = v.width - strokeWidth / 2;\n    ctx.moveTo(lineX, plotArea.paddingPx + strokeWidth);\n    ctx.lineTo(lineX, plotArea.canvasRegion.height + paddingPx + strokeWidth + strokeWidth);\n    ctx.stroke();\n\n    ctx.textBaseline = `top`;\n    const fromRight = v.width - paddingPx * 4;\n\n    ctx.fillStyle = plot.axisTextColour;\n    if (isRangeSinglePoint(r)) {\n      this.debugLog(`rangeSinglePoint`);\n      drawText(ctx, series.formatValue(r.max), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.max) - paddingPx * 4,\n      ]);\n    } else {\n      // Draw min/max data labels\n      drawText(ctx, series.formatValue(r.max), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.max) + strokeWidth / 2,\n      ]);\n      drawText(ctx, series.formatValue(r.min), (size) => [\n        fromRight - size.width,\n        plotArea.computeY(series, r.min) - 5,\n      ]);\n    }\n  }\n}\n\nconst drawText = (\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  position: (size: TextMetrics) => [ x: number, y: number ]\n) => {\n  if (ctx === undefined) throw new Error(`ctx is undefined`);\n  const size = ctx.measureText(text);\n  const xy = position(size);\n  ctx.fillText(text, xy[ 0 ], xy[ 1 ]);\n};\n\n/**\n * Canvas-based data plotter.\n *\n * ```\n * const p = new Plot(document.getElementById(`myCanvas`), opts);\n *\n * // Plot 1-5 as series  test'\n * p.createSeries(`test`, `array`, [1,2,3,4,5]);\n *\n * // Create a streaming series, add a random number\n * const s = p.createSeries(`test2`, `stream`);\n * s.add(Math.random());\n * ```\n * `createSeries` returns the {@link Series} instance with properties for fine-tuning\n *\n * For simple usage, use `plot(someData)` which automatically creates\n * series for the properties of an object.\n */\nexport class Plot extends Sg.CanvasBox {\n  plotArea: PlotArea;\n  legend: Legend;\n  axisX: AxisX;\n  axisY: AxisY;\n  axisStrokeColour: string;\n  axisTextColour: string;\n  legendTextColour: string;\n\n  axisStrokeWidth: number;\n  series: Map<string, Series>;\n  private _frozen = false;\n  private _canvasEl: HTMLCanvasElement;\n  private _ctx: CanvasRenderingContext2D;\n\n  defaultSeriesOpts?: SeriesOpts;\n  constructor(canvasElementOrQuery: HTMLCanvasElement | string, opts: Opts = {}) {\n    const { ctx, element, bounds } = scaleCanvas(canvasElementOrQuery);\n    super(undefined, `Plot`);//bounds);\n    this._canvasEl = element;\n    this._ctx = ctx;\n\n    if (opts.autoSize) {\n      parentSizeCanvas(element, (event) => {\n        this.drawingInvalidated(`resize`);\n        this.layoutInvalidated(`resize`);\n        this.update(event.ctx, true);\n      });\n    }\n\n    this.axisStrokeColour = opts.axisStrokeColour ?? `black`;\n    this.axisTextColour = opts.axisTextColour ?? `black`;\n    this.legendTextColour = opts.legendTextColour ?? `black`;\n\n    this.axisStrokeWidth = opts.axisStrokeWidth ?? 3;\n    this.series = new Map();\n    this.plotArea = new PlotArea(this, bounds);\n    this.legend = new Legend(this, bounds);\n    this.axisX = new AxisX(this, bounds);\n    this.axisY = new AxisY(this, bounds);\n\n    // this.plotArea.debugLayout = true;\n    // this.axisX.debugLayout = true;\n    // this.axisY.debugLayout = true;\n    // this.legend.debugLayout = true;\n    // this.debugLayout = true;\n  }\n\n  update(ctx?: CanvasRenderingContext2D, force = false) {\n    if (ctx === undefined) ctx = this._ctx;\n    super.update(ctx, force);\n    // this.plotArea.update(ctx, force);\n    // this.axisX.update(ctx, force);\n    // this.axisY.update(ctx, force);\n    // this.legend.update(ctx, force);\n  }\n\n  /**\n   * Calls 'clear()' on each of the series\n   */\n  clearSeries() {\n    for (const series of this.series.values()) {\n      series.clear();\n    }\n    this.update();\n  }\n\n  /**\n   * Removes all series, plot, legend\n   * and axis data.\n   */\n  clear() {\n    this.series = new Map();\n    this.plotArea.clear();\n    this.legend.clear();\n    this.axisX.clear();\n    this.axisY.clear();\n    this.layoutInvalidated(`Plot.clear`);\n    this.drawingInvalidated(`Plot.clear`);\n    this.update();\n  }\n\n  get frozen(): boolean {\n    return this._frozen;\n  }\n\n  set frozen(v: boolean) {\n    this._frozen = v;\n    if (v) {\n      this._canvasEl.classList.add(`frozen`);\n      this._canvasEl.title = `Plot frozen. Tap to unfreeze`;\n    } else {\n      this._canvasEl.title = ``;\n      this._canvasEl.classList.remove(`frozen`);\n    }\n  }\n\n  seriesArray(): Array<Series> {\n    return [ ...this.series.values() ];\n  }\n\n  get seriesLength(): number {\n    return this.series.size;\n  }\n\n  /**\n   * Plots a simple object, eg `{ x: 10, y: 20, z: 300 }`\n   * Series are automatically created for each property of `o`\n   *\n   * Be sure to call `update()` to visually refresh.\n   * @param o\n   */\n  plot(o: any) {\n    const paths = getPaths(o, true);\n    let seriesCreated = false;\n    for (const p of paths) {\n      let s = this.series.get(p);\n      if (s === undefined) {\n        s = this.createSeries(p, `stream`);\n        s.drawingStyle = `line`;\n        seriesCreated = true;\n      }\n      s.add(getField(o, p));\n    }\n    if (seriesCreated) this.legend.layoutInvalidated(`new series`);\n    this.update();\n  }\n\n  createSeriesFromObject(o: any, prefix = ``): Array<Series> {\n    const keys = Object.keys(o);\n    const create = (key: string): Array<Series> => {\n      const v = o[ key ];\n      if (typeof v === `object`) {\n        return this.createSeriesFromObject(v, `${ prefix }${ key }.`);\n      } else if (typeof v === `number`) {\n        return [ this.createSeries(key, `stream`) ];\n      } else {\n        return [];\n      }\n    };\n    return keys.flatMap(k => create(k));\n  }\n\n  createSeries(\n    name?: string,\n    type: `stream` | `array` = `array`,\n    seriesOpts?: SeriesOpts\n  ): Series {\n    const seriesLength = this.seriesLength;\n\n    if (name === undefined) name = `series-${ seriesLength }`;\n    if (this.series.has(name))\n      throw new Error(`Series name '${ name }' already in use`);\n\n    let opts: SeriesOpts = {\n      colour: `hsl(${ (seriesLength * 25) % 360 }, 70%,50%)`,\n      ...seriesOpts,\n    };\n    if (this.defaultSeriesOpts) opts = { ...this.defaultSeriesOpts, ...opts };\n\n    const s = new Series(name, type, this, opts);\n    // if (type === `array` && initialData !== undefined) {\n    //   (s.source as ArrayDataSource).set(initialData);\n    // }\n\n    this.series.set(name, s);\n    this.setReady(true, true);\n    this.plotArea.drawingInvalidated(`Plot.createSeries`);\n    return s;\n  }\n}\n","import { Arrays } from '../collections/index.js';\nimport { Points } from '../geometry/index.js';\nimport * as Rects from '../geometry/rect/index.js';\nimport { intersectsPoint as RectsIntersectsPoint } from '../geometry/rect/Intersects.js';\nimport { isPlaceholder as RectsIsPlaceholder } from '../geometry/rect/Guard.js';\nimport { placeholderPositioned as RectsPlaceholderPositioned, placeholder as RectsPlaceholder, emptyPositioned as RectsEmptyPositioned } from '../geometry/rect/index.js';\nimport { hue as randomHue } from '../random/index.js';\nimport type { Point } from '../geometry/point/index.js';\nimport type { Rect, RectPositioned } from '../geometry/rect/index.js';\n\nexport type Measurement = {\n  actual: Rect;\n  ref: Box;\n  children: Array<Measurement | undefined>;\n};\n\nexport type Layout = {\n  actual: Point;\n  ref: Box;\n  children: Array<Layout | undefined>;\n};\n\nexport type PxUnit = {\n  value: number;\n  type: `px`;\n};\n\nexport type PcUnit = {\n  value: number;\n  type: `pc`;\n};\n\nexport type BoxUnit = PxUnit | PcUnit;\n\nexport type BoxRect = {\n  x?: BoxUnit;\n  y?: BoxUnit;\n  width?: BoxUnit;\n  height?: BoxUnit;\n};\n\nexport const boxUnitFromPx = (v: number): PxUnit => {\n  return { type: `px`, value: v };\n}\nexport const boxRectFromPx = (x: number, y: number, width: number, height: number): BoxRect => {\n  return {\n    x: boxUnitFromPx(x),\n    y: boxUnitFromPx(y),\n    width: boxUnitFromPx(width),\n    height: boxUnitFromPx(height)\n  }\n}\nexport const boxRectFromRectPx = (r: RectPositioned): BoxRect => {\n  return {\n    x: boxUnitFromPx(r.x),\n    y: boxUnitFromPx(r.y),\n    width: boxUnitFromPx(r.width),\n    height: boxUnitFromPx(r.height)\n  }\n}\n\nconst unitIsEqual = (a: BoxUnit, b: BoxUnit): boolean => {\n  if (a.type === `px` && b.type === `px`) {\n    return a.value === b.value;\n  }\n  return false;\n};\n\nconst boxRectIsEqual = (\n  a: BoxRect | undefined,\n  b: BoxRect | undefined\n): boolean => {\n  if (a === undefined && b === undefined) return true;\n  if (a === undefined) return false;\n  if (b === undefined) return false;\n  if (a.x && b.x && !unitIsEqual(a.x, b.x)) return false;\n  if (a.y && b.y && !unitIsEqual(a.y, b.y)) return false;\n  if (a.width && b.width && !unitIsEqual(a.width, b.width)) return false;\n  if (a.height && b.height && !unitIsEqual(a.height, b.height)) return false;\n  return true;\n};\n\nclass BaseState {\n  bounds: RectPositioned;\n  pass: number;\n  constructor(bounds: RectPositioned) {\n    this.bounds = bounds;\n    this.pass = 0;\n  }\n\n  resolveToPx(u: BoxUnit | undefined, maxValue: number, defaultValue?: number): number | undefined {\n    if (u === undefined && defaultValue !== undefined) return defaultValue;\n    if (u === undefined) return; //throw new Error(`unit undefined`);\n    if (u.type === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Type is missing`);\n    if (u.value === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Value is missing`);\n\n\n    if (u.type === `px`) return u.value;\n    if (u.type === `pc`) return u.value * maxValue;\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    // @ts-expect-error\n    throw new Error(`Unknown unit type: ${ u.type }`);\n  }\n\n  resolveBox(box: BoxRect | undefined): Rect | RectPositioned | undefined {\n    if (box === undefined) return undefined;\n    const x = this.resolveToPx(box.x, this.bounds.width);\n    const y = this.resolveToPx(box.y, this.bounds.height);\n    const width = this.resolveToPx(box.width, this.bounds.width);\n    const height = this.resolveToPx(box.height, this.bounds.height);\n    if (!width || !height) throw new TypeError(`Expected width and height`);\n    if (x === undefined && y === undefined) {\n      return Object.freeze({ width, height });\n    } else {\n      if (!x || !y) throw new TypeError(`Expected x and y`);\n      return Object.freeze({\n        x, y, width, height\n      });\n    }\n  }\n}\n\nexport class MeasureState extends BaseState {\n  measurements: Map<string, Measurement>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.measurements = new Map<string, Measurement>();\n  }\n\n  getActualSize(id: string): Rect | undefined {\n    const s = this.measurements.get(id);\n    if (s === undefined) return;\n    if (RectsIsPlaceholder(s.actual)) return;\n    return s.actual;\n  }\n\n  whatIsMeasured(): Array<string> {\n    return [ ...this.measurements.keys() ]\n  }\n}\n\nexport class LayoutState extends BaseState {\n  layouts: Map<string, Layout>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.layouts = new Map<string, Layout>();\n  }\n}\n/**\n * Box\n */\nexport abstract class Box {\n\n  /** Rectangle Box occupies in canvas/etc */\n  canvasRegion: RectPositioned = RectsPlaceholderPositioned;\n\n  private _desiredRect: BoxRect | undefined;\n\n  protected _measuredSize: Rect | undefined;\n  protected _layoutPosition: Point | undefined;\n\n  protected children: Array<Box> = [];\n  protected readonly _parent: Box | undefined;\n  private _idMap = new Map<string, Box>();\n\n  debugLayout = false;\n\n  private _visible = true;\n  protected _ready = true;\n\n  takesSpaceWhenInvisible = false;\n\n  protected _needsMeasuring = true;\n  protected _needsLayoutX = true;\n  protected _needsDrawing = true;\n\n  debugHue = randomHue();\n  readonly id: string;\n\n  /**\n   * Constructor.\n   * \n   * If `parent` is provided, `parent.onChildAdded(this)` is called.\n   * @param parent parent box \n   * @param id id of this box\n   */\n  constructor(parent: Box | undefined, id: string) {\n    this.id = id;\n    this._parent = parent;\n\n    parent?.onChildAdded(this);\n  }\n\n  /**\n   * Returns _true_ if `box` is a child\n   * @param box \n   * @returns \n   */\n  hasChild(box: Box): boolean {\n    const byReference = this.children.find((c) => c === box);\n    const byId = this.children.find((c) => c.id === box.id);\n    return byReference !== undefined || byId !== undefined;\n  }\n\n  /**\n   * Sends a message to all child boxes.\n   * \n   * This first calls `onNotify` on this instance,\n   * before calling `notify()` on each child.\n   * @param message \n   * @param source \n   */\n  notify(message: string, source: Box) {\n    this.onNotify(message, source);\n    for (const c of this.children) c.notify(message, source);\n  }\n\n  *getChildren() {\n    return this.children.entries();\n  }\n\n  /**\n   * Handles a received message\n   * @param _message \n   * @param _source \n   */\n  protected onNotify(_message: string, _source: Box) {\n    /** no-op */\n  }\n\n  /**\n   * Notification a child box has been added\n   * \n   * Throws if\n   * - child has parent as its own child\n   * - child is same as this\n   * - child is already child of this\n   * @param child \n   */\n  protected onChildAdded(child: Box) {\n    if (child.hasChild(this)) throw new Error(`Recursive`);\n    if (child === this) throw new Error(`Cannot add self as child`);\n    if (this.hasChild(child)) throw new Error(`Child already present`);\n\n    this.children.push(child);\n    this._idMap.set(child.id, child);\n\n    this.layoutInvalidated(`Box.onChildAdded`);\n  }\n\n  /**\n   * Sets `_ready` to `ready`. If `includeChildren` is _true_,\n   * `setReady` is called on each child\n   * @param ready \n   * @param includeChildren \n   */\n  setReady(ready: boolean, includeChildren = false) {\n    this._ready = ready;\n    if (includeChildren) {\n      for (const c of this.children) c.setReady(ready, includeChildren);\n    }\n  }\n\n  /**\n   * Gets visible state\n   */\n  get visible(): boolean {\n    return this._visible;\n  }\n\n  /**\n   * Sets visible state\n   */\n  set visible(v: boolean) {\n    if (this._visible === v) return;\n    this._visible = v;\n\n    // Invalidated because we skip measuring when it is invisible\n    this.layoutInvalidated(`Box.set visible`);\n  }\n\n  /**\n   * Gets the box's desired region, or _undefined_\n   */\n  get desiredRegion(): BoxRect | undefined {\n    return this._desiredRect;\n  }\n\n  /**\n   * Sets the box's desired region.\n   * Calls `onLayoutNeeded()`\n   */\n  set desiredRegion(v: BoxRect | undefined) {\n    if (boxRectIsEqual(v, this._desiredRect)) return;\n    this._desiredRect = v;\n    this.layoutInvalidated(`set desiredRegion`);\n  }\n\n  /**\n   * Calls `notifyChildLayoutNeeded`\n   */\n  layoutInvalidated(reason: string) {\n    if (reason === undefined) debugger;\n    this.debugLog(`layoutInvalidated ${ reason }`);\n    this._needsMeasuring = true;\n    this._needsLayoutX = true;\n    // TODO: Only set to true during measuring if it actually changes\n    this._needsDrawing = true;\n    this.notifyChildLayoutNeeded();\n  }\n\n  drawingInvalidated(_reason: string): void {\n    this._needsDrawing = true;\n    //this.debugLog(`drawingInvalidated ${ reason }`);\n  }\n\n  /**\n   * Called from a child, notifying us that\n   * its layout has changed\n   * @returns \n   */\n  private notifyChildLayoutNeeded() {\n    // TODO: Not all layout changes require re-layout higher up\n    this._needsDrawing = true;\n    this._needsLayoutX = true;\n    this._needsMeasuring = true;\n    if (this._parent === undefined) return;\n    this._parent.notifyChildLayoutNeeded();\n  }\n\n  /**\n   * Returns the root box\n   */\n  get root(): Box {\n    if (this._parent === undefined) return this;\n    return this._parent.root;\n  }\n\n  /**\n   * Prepare for measuring\n   */\n  protected measurePreflight() {\n    /** no-up */\n  }\n\n  /**\n   * Applies actual size, returning _true_ if size is different than before\n   * \n   * 1. Sets `_needsLayout` to _false_.\n   * 2. Sets `visual` to `m`\n   * 3. Calls `measureApply` on each child\n   * 4. If there's a change or `force`, sets `needsDrawing` to _true_, and notifies root of `measureApplied`\n   * @param m Measurement for box\n   * @returns \n   */\n  protected measureApply(m: Measurement) {\n    this._needsMeasuring = false;\n\n    const different = this._measuredSize === undefined ? true : !Rects.isEqualSize(m.actual, this._measuredSize);\n    if (different) {\n      //this.debugLog(`measureApply: Size is different than previous. Actual: ${ JSON.stringify(m.actual) } current: ${ JSON.stringify(this._measuredSize) }`);\n      this._needsLayoutX = true;\n    }\n\n    this._measuredSize = { width: m.actual.width, height: m.actual.height };\n\n    for (const c of m.children) {\n      if (c !== undefined) c.ref.measureApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`measureApplied`, this);\n    }\n    return different;\n  }\n\n  protected layoutApply(l: Layout) {\n    this._needsLayoutX = false;\n\n    const different = this._layoutPosition === undefined ? true : !Points.isEqual(l.actual, this._layoutPosition);\n    // if (different) {\n    //   this.debugLog(`layoutApply. Position different than previous. ${ JSON.stringify(l.actual) }`);\n    // }\n    this._layoutPosition = { x: l.actual.x, y: l.actual.y };\n\n    for (const c of l.children) {\n      if (c !== undefined) c.ref.layoutApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`layoutApplied`, this);\n    }\n    return different;\n  }\n\n  /**\n   * Debug log from this box context\n   * @param m \n   */\n  debugLog(m: any) {\n    if (!this.debugLayout) return;\n    console.log(this.id, m);\n\n  }\n\n  layoutStart(measureState: MeasureState, layoutState: LayoutState, force: boolean, parent?: Layout): Layout | undefined {\n    const m: Layout = {\n      ref: this,\n      actual: Points.Empty,\n      children: [],\n    };\n    // Stash away measurement by id\n    layoutState.layouts.set(this.id, m);\n\n    const currentPosition = this.layoutSelf(measureState, layoutState, parent);\n    this.root.notify(`laidout`, this);\n\n    // For some reason we can't measure\n    if (currentPosition === undefined) return;\n\n    // Assign\n    m.actual = currentPosition;\n\n    m.children = this.children.map((c) => c.layoutStart(measureState, layoutState, force, m));\n    if (Arrays.withoutUndefined(m.children).length < this.children.length) {\n      return undefined; // One of the children did not resolve\n    }\n    return m;\n  }\n\n  protected layoutSelf(\n    measureState: MeasureState,\n    layoutState: LayoutState,\n    _parent?: Layout\n  ): Point | undefined {\n    // TODO: Proper layout\n    const box = layoutState.resolveBox(this._desiredRect);\n    const x = box === undefined ? 0 : (`x` in box ? box.x : 0);\n    const y = box === undefined ? 0 : (`y` in box ? box.y : 0);\n    if (x === undefined) debugger;\n    if (y === undefined) debugger;\n    return { x, y }\n  }\n\n  /**\n   * Start of measuring\n   * 1. Keeps track of measurements in `opts.measurements`\n   * 2. If this box takes space\n   * 2.1. Measure itself if needed\n   * 2.2. Use size\n   * 2. Calls `measureStart` on each child\n   * @param opts Options\n   * @param force Force measurement\n   * @param parent Parent's measurement \n   * @returns Measurement\n   */\n  measureStart(\n    opts: MeasureState,\n    force: boolean,\n    parent?: Measurement\n  ): Measurement | undefined {\n    this.measurePreflight();\n\n    const m: Measurement = {\n      ref: this,\n      // So far no known measurement\n      actual: RectsPlaceholder,\n      children: [],\n    };\n    // Stash away measurement by id\n    opts.measurements.set(this.id, m);\n\n    if (!this._visible && !this.takesSpaceWhenInvisible) {\n      // If we're not visible, there's no actual size\n      m.actual = RectsEmptyPositioned;\n    } else {\n      let currentMeasurement: Rect | string | undefined = this._measuredSize;\n\n      // If we need to, measure how big it actually is\n      if (this._needsMeasuring || this._measuredSize === undefined) {\n        currentMeasurement = this.measureSelf(opts, parent);\n        this.root.notify(`measured`, this);\n      }\n\n      // For some reason we can't measure\n      if (typeof currentMeasurement === `string`) {\n        //this.debugLog(`measureStart: measureSelf failed: ${ currentMeasurement }`);\n        return;\n      } else if (currentMeasurement === undefined) {\n        //this.debugLog(`measureStart: measureSelf failed for some other reason`);\n        return;\n      }\n\n      // Assign\n      m.actual = currentMeasurement;\n    }\n\n    m.children = this.children.map((c) => c.measureStart(opts, force, m));\n    if (Arrays.withoutUndefined(m.children).length < this.children.length) {\n      //this.debugLog(`measureStart: Child failed measureStart`);\n      return undefined; // One of the children did not resolve\n    }\n\n    return m;\n  }\n\n  /**\n   * Measure the box\n   * 1. Uses desired rectangle, if possible\n   * 2. Otherwise uses parent's size\n   * @param opts Measure state\n   * @param parent Parent size\n   * @returns \n   */\n  protected measureSelf(\n    opts: MeasureState,\n    parent?: Measurement\n  ): Rect | string {\n    let size = RectsPlaceholder;\n\n    const context = parent ? parent.actual : opts.bounds;\n    const desired = opts.resolveBox(this._desiredRect);\n\n    size = desired ? Rects.clamp(desired, context) : context;\n\n    if (RectsIsPlaceholder(size)) {\n      return `Box.measureSelf - No size for box?`;\n    }\n    return size;\n  }\n\n\n  /**\n   * Gets initial state for a run of measurements & layout.\n   * \n   * Called when update() is called\n   * @param context\n   */\n  protected abstract updateBegin(context: any): [ MeasureState, LayoutState ];\n\n  protected abstract updateComplete(measureChanged: boolean, layoutChanged: boolean): void;\n\n  // protected updateDone(state: MeasureState, force: boolean): void {\n  //   this.onUpdateDone(state, force);\n  //   for (const c of this.children) c.updateDone(state, force);\n  // }\n\n  /**\n   * Update has completed\n   * @param state \n   * @param force \n   */\n  //abstract onUpdateDone(state: MeasureState, force: boolean): void;\n\n  /**\n   * Update\n   * 1. Calls `this.updateBegin()` to initialise measurement state\n   * 2. In a loop, run `measureStart()` and then `measureApply` if possible\n   * 3. Call `updateDone` when finished\n   * @param force Force update\n   * @returns \n   */\n  update(context: object, force = false) {\n    if (context === undefined) throw new Error(`context is undefined`);\n\n    if (!this._needsMeasuring && !this._needsLayoutX && !force) return;\n    const [ measureState, layoutState ] = this.updateBegin(context);\n    let attempts = 5;\n    let measureApplied = false;\n    let layoutApplied = false;\n\n    // Measure everything\n    if (this._needsMeasuring || force) {\n      //this.debugLog(`update: needs measuring (force: ${ force }) bounds: ${ JSON.stringify(measureState.bounds) }`);\n      while (attempts--) {\n        const m = this.measureStart(measureState, force);\n        if (m !== undefined) {\n          // Apply measurements\n          this.measureApply(m);\n          if (!this._ready) return;\n          measureApplied = true;\n        }\n      }\n      //this.updateDone(state, force);\n      if (!measureApplied) this.debugLog(`Ran out of measurement attempts`);\n    }\n\n    // Lay it out\n    if (this._needsLayoutX || force) {\n      const p = this.layoutStart(measureState, layoutState, force);\n      if (p === undefined) {\n        this.debugLog(`Warning: could not layout`);\n      } else {\n        this.layoutApply(p);\n        layoutApplied = true;\n      }\n    }\n    this.updateComplete(measureApplied, layoutApplied);\n  }\n}\n\n/**\n * Canvas measure state\n */\nexport class CanvasMeasureState extends MeasureState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n  }\n}\n\nexport class CanvasLayoutState extends LayoutState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n\n  }\n}\n\n/**\n * A Box that exists on a HTMLCanvasElement\n */\nexport class CanvasBox extends Box {\n  readonly bounds: RectPositioned | undefined;\n  constructor(\n    parent: CanvasBox | undefined,\n    //canvasElement: HTMLCanvasElement,\n    id: string,\n    bounds?: RectPositioned\n  ) {\n    super(parent, id);\n    this.bounds = bounds;\n    this.debugLog(`CanvasBox ctor bounds: ${ JSON.stringify(bounds) }`);\n  }\n\n  static fromCanvas(canvasElement: HTMLCanvasElement): CanvasBox {\n    const box = new CanvasBox(undefined, `canvas-box`, canvasElement.getBoundingClientRect());\n    return box;\n  }\n\n  /**\n   * Called if this is the parent Box\n   */\n  public addEventHandlers(element: HTMLElement) {\n    element.addEventListener(`pointermove`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyPointerMove(p);\n    });\n\n    element.addEventListener(`pointerleave`, (_event) => {\n      this.notifyPointerLeave();\n    });\n\n    element.addEventListener(`click`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyClick(p);\n    });\n  }\n\n  protected onClick(_p: Point) {\n    /** no-up */\n  }\n\n  /**\n   * Click event has happened on canvas\n   * 1. If it's within our range, call `onClick` and pass to all children via `notifyClick`\n   * @param p \n   * @returns \n   */\n  private notifyClick(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = Points.subtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onClick(pp);\n      // TODO: Only call `notifyClick` if child is within range?\n      for (const c of this.children) (c as CanvasBox).notifyClick(pp);\n    }\n  }\n\n  /**\n   * Pointer has left\n   * 1. Pass notification to all children via `notifyPointerLeave`\n   */\n  private notifyPointerLeave() {\n    this.onPointerLeave();\n    for (const c of this.children) (c as CanvasBox).notifyPointerLeave();\n  }\n\n  /**\n   * Pointer has moved\n   * 1. If it's within range `onPointerMove` is called, and pass on to all children via `notifyPointerMove`\n   * @param p \n   * @returns \n   */\n  private notifyPointerMove(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = Points.subtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onPointerMove(pp);\n      for (const c of this.children) (c as CanvasBox).notifyPointerMove(pp);\n    }\n  }\n\n  /**\n   * Handler when pointer has left\n   */\n  protected onPointerLeave() {\n    /** no-up */\n  }\n\n  /**\n   * Handler when pointer moves within our region\n   * @param _p \n   */\n  protected onPointerMove(_p: Point) {\n    /** no-up */\n\n  }\n\n  /**\n   * Performs recalculations and drawing as necessary\n   * If nothing needs to happen, function returns.\n   * @param context \n   * @param force Force update\n   */\n  update(context: CanvasRenderingContext2D, force = false) {\n    super.update(context, force);\n    this.draw(context, force);\n  }\n\n  getBounds(): RectPositioned | undefined {\n    return this.bounds === undefined && this._parent ? (this._parent as CanvasBox).bounds : this.bounds;\n  }\n\n  /**\n   * Update begins.\n   * @returns MeasureState\n   */\n  protected updateBegin(context: CanvasRenderingContext2D): [ MeasureState, LayoutState ] {\n    if (context === undefined) throw new Error(`Context is undefined`);\n    let bounds = this.getBounds();\n    //this.debugLog(`updateBegin bounds: ${ JSON.stringify(bounds) } measured: ${ JSON.stringify(this._measuredSize) }`);\n\n    if (bounds === undefined) {\n      this.debugLog(`No bounds for element or parent, using canvas bounds`);\n      bounds = { x: 0, y: 0, width: context.canvas.width, height: context.canvas.height }\n    }\n    return [\n      new CanvasMeasureState(bounds, context),\n      new CanvasLayoutState(bounds, context)\n    ]\n    // if (this.region) {\n    //   return new CanvasMeasureState(this.region);\n    // } else {\n    //   const s = this.canvasEl.getBoundingClientRect();\n\n    //   return new CanvasMeasureState(\n    //     {\n    //       x: 0,\n    //       y: 0,\n    //       width: s.width,\n    //       height: s.height,\n    //     },\n    //     ctx\n    //   );\n    // }\n  }\n\n  protected updateComplete(_measureChanged: boolean, _layoutChanged: boolean): void {\n    //this.debugLog(`updateComplete. measureChanged: ${ _measureChanged } layoutChanged: ${ _layoutChanged } pos: ${ JSON.stringify(this._layoutPosition) }`);\n    this.canvasRegion = RectsPlaceholderPositioned;\n  }\n\n  protected measureApply(m: Measurement): boolean {\n    const different = super.measureApply(m);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  protected layoutApply(l: Layout): boolean {\n    const different = super.layoutApply(l);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  public draw(ctx: CanvasRenderingContext2D, force = false) {\n    //this.debugLog(`draw. needs drawing: ${ this._needsDrawing } force: ${ force } pos: ${ JSON.stringify(this._layoutPosition) } size: ${ JSON.stringify(this._measuredSize) }`);\n\n    // if (!this._needsDrawing && !force) return;\n\n    if (this._needsDrawing || force) {\n      if (RectsIsPlaceholder(this.canvasRegion)) {\n        if (this._layoutPosition === undefined) return;\n        if (this._measuredSize === undefined) return;\n        this.canvasRegion = {\n          x: this._layoutPosition.x,\n          y: this._layoutPosition.y,\n          width: this._measuredSize.width,\n          height: this._measuredSize.height\n        }\n      }\n\n      //this.debugLog(`draw: canvasRegion: ${ JSON.stringify(this.canvasRegion) }`);\n      if (this._needsLayoutX || this._needsMeasuring) {\n        //this.debugLog(`draw: warning: drawing with outdated layout / measurements`);\n      }\n      ctx.save();\n      const v = this.canvasRegion;\n      ctx.translate(v.x, v.y);\n\n      if (this.debugLayout) {\n        //ctx.clearRect(0,0,v.width,v.height);\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = `hsl(${ this.debugHue }, 100%, 50%)`;\n\n        //ctx.fillStyle = ctx.strokeStyle;\n        //ctx.fillRect(0,0,v.width,v.height);\n\n        ctx.strokeRect(0, 0, v.width, v.height);\n\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fillText(this.id, 10, 10, v.width);\n\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(v.width, v.height);\n        ctx.stroke();\n      }\n\n      this.drawSelf(ctx);\n\n      this._needsDrawing = false;\n      ctx.restore();\n    }\n    for (const c of this.children) {\n      (c as CanvasBox).draw(ctx, force)\n    }\n  }\n\n  /**\n   * Draw this object\n   * @param _ctx \n   */\n  protected drawSelf(_ctx: CanvasRenderingContext2D): void {\n    /** no-up */\n  }\n}\n","import { resolveEl } from \"../dom/ResolveEl.js\";\n\n/**\n * Scales a canvas to account for retina displays.\n * \n * ```js\n * const r = scaleCanvas(`#my-canvas`);\n * r.ctx;      // CanvasRendering2D\n * r.element;  // HTMLCanvasElement\n * r.bounds;   // {x:number,y:number,width:number,height:number}\n * ```\n * \n * Eg:\n * ```js\n * const { ctx } = scaleCanvas(`#my-canvas`);\n * ctx.fillStyle = `red`;\n * ctx.fillRect(0,0,100,100);\n * ```\n * \n * Throws an error if `domQueryOrElement` does not resolve.w\n * @param domQueryOrElement \n * @returns \n */\nexport const scaleCanvas = (domQueryOrElement: HTMLCanvasElement | string) => {\n  const canvasElement = resolveEl<HTMLCanvasElement>(domQueryOrElement);\n  const ratio = window.devicePixelRatio;\n  canvasElement.style.width = canvasElement.width + `px`;\n  canvasElement.style.height = canvasElement.height + `px`;\n  canvasElement.width *= devicePixelRatio;\n  canvasElement.height *= devicePixelRatio;\n\n  const getContext = () => {\n    const ctx = canvasElement.getContext(`2d`);\n\n    if (ctx === null) throw new Error(`Could not get drawing context`);\n    ctx.save();\n    ctx.scale(ratio, ratio);\n    return ctx;\n  }\n  return { ctx: getContext(), element: canvasElement, bounds: canvasElement.getBoundingClientRect() };\n}","import type { Interval } from 'src/flow/IntervalType.js';\nimport * as Rx from '../rx/index.js';\n\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param timeoutMs\n * @returns\n */\nexport const windowResize = (elapsed?: Interval) => Rx.Ops.debounce<UIEvent>({ elapsed: elapsed ?? 100 })(Rx.From.event(window, `resize`));\n\n/**\n * Observe when document's class changes\n *\n * ```js\n * const c = themeChangeObservable();\n * c.on(msg => {\n *  // do something...\n * });\n * ```\n * @returns\n */\nexport const themeChange = () => {\n  const m = Rx.From.observable<Array<MutationRecord>>(stream => {\n    const ro = new MutationObserver((entries) => {\n      stream.set(entries);\n    });\n    const opts: MutationObserverInit = {\n      attributeFilter: [ `class` ],\n      attributes: true,\n    };\n    ro.observe(document.documentElement, opts);\n\n    return () => {\n      ro.disconnect();\n    }\n  });\n  return m;\n}\n\n/**\n * Observe when element resizes. Specify `timeoutMs` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param timeoutMs Tiemout before event gets triggered\n * @returns\n */\nexport const resizeObservable = (\n  elem: Readonly<Element>,\n  timeout?: Interval\n) => {\n  if (elem === null) {\n    throw new Error(`elem parameter is null. Expected element to observe`);\n  }\n  if (elem === undefined) {\n    throw new Error(`elem parameter is undefined. Expected element to observe`);\n  }\n\n  const m = Rx.From.observable<Array<ResizeObserverEntry>>(stream => {\n    const ro = new ResizeObserver((entries) => {\n      stream.set(entries);\n    });\n    ro.observe(elem);\n\n    return () => {\n      ro.unobserve(elem);\n    };\n  });\n  return Rx.Ops.debounce<Array<ResizeObserverEntry>>({ elapsed: timeout ?? 100 })(m);\n}","import { resizeObservable, windowResize } from \"./DomRx.js\";\nimport type { ElementResizeArgs as ElementResizeArguments } from \"./ElementSizing.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\n\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport type CanvasResizeArgs = ElementResizeArguments<HTMLCanvasElement> & {\n  readonly ctx: CanvasRenderingContext2D;\n};\n\n\n/**\n * Resizes given canvas to its parent element.\n * To resize canvas to match the viewport, use {@link fullSizeCanvas}.\n *\n * Provide a callback for when resize happens.\n * @param domQueryOrEl Query string or reference to canvas element\n * @param onResized Callback for when resize happens, eg for redrawing canvas\n * @returns Observable\n */\nexport const parentSizeCanvas = (\n  domQueryOrEl: Readonly<string | HTMLCanvasElement>,\n  onResized?: (args: CanvasResizeArgs) => void,\n  timeoutMs = 100\n) => {\n  const el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n  if (el.nodeName !== `CANVAS`) {\n    throw new Error(\n      `Expected HTML element with node name CANVAS, not ${ el.nodeName }`\n    );\n  }\n  const parent = el.parentElement;\n  if (parent === null) throw new Error(`Element has no parent`);\n\n  const ctx = (el).getContext(`2d`);\n  if (ctx === null) throw new Error(`Could not create drawing context`);\n\n  //const safetyMargin = 4;\n\n  el.style.width = `100%`;\n  el.style.height = `100%`;\n\n\n  const ro = resizeObservable(parent, timeoutMs).value(\n    entries => {\n      const entry = entries.find((v) => v.target === parent);\n      if (entry === undefined) return;\n\n      const width = entry.contentRect.width;\n      const height = entry.contentRect.height;\n      //console.log(`contentH: ${e.contentRect.height} current: ${el.getBoundingClientRect().height}`);\n\n      // el.setAttribute(`width`, width-safetyMargin + `px`);\n      // el.setAttribute(`height`, height-safetyMargin + `px`);\n      el.setAttribute(`width`, el.offsetWidth + `px`);\n      el.setAttribute(`height`, el.offsetHeight + `px`);\n\n      if (onResized !== undefined) {\n        const bounds = {\n          min: Math.min(width, height),\n          max: Math.max(width, height),\n          width,\n          height,\n          center: { x: width / 2, y: height / 2 },\n        };\n        onResized({ ctx, el, bounds });\n      }\n    }\n  );\n\n  return ro;\n};\n\n\n/**\n * Resizes given canvas element to match window size.\n * To resize canvas to match its parent, use {@link parentSizeCanvas}.\n *\n * To make the canvas appear propery, it sets the following CSS:\n * ```css\n * {\n *  top: 0;\n *  left: 0;\n *  zIndex: -1;\n *  position: fixed;\n * }\n * ```\n * Pass _true_ for `skipCss` to avoid this.\n *\n * Provide a callback for when resize happens.\n * @param domQueryOrEl Query string or reference to canvas element\n * @param onResized Callback for when resize happens, eg for redrawing canvas\n * @param skipCss if true, style are not added\n * @returns Observable\n */\nexport const fullSizeCanvas = (\n  domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>,\n  onResized?: (args: CanvasResizeArgs) => void,\n  skipCss = false\n) => {\n  if (domQueryOrEl === null || domQueryOrEl === undefined) {\n    throw new Error(`domQueryOrEl is null or undefined`);\n  }\n  const el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n  if (el.nodeName !== `CANVAS`) {\n    throw new Error(\n      `Expected HTML element with node name CANVAS, not ${ el.nodeName }`\n    );\n  }\n  const ctx = el.getContext(`2d`);\n  if (ctx === null) throw new Error(`Could not create drawing context`);\n\n  const update = () => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    el.width = width;\n    el.height = height;\n\n    if (onResized !== undefined) {\n      const bounds = {\n        min: Math.min(width, height),\n        max: Math.max(width, height),\n        width,\n        height,\n        center: { x: width / 2, y: height / 2 },\n      };\n      onResized({ ctx, el, bounds });\n    }\n  };\n\n  // Setup\n  if (!skipCss) {\n    el.style.top = `0`;\n    el.style.left = `0`;\n    el.style.zIndex = `-100`;\n    el.style.position = `fixed`;\n  }\n\n  const r = windowResize();\n  r.value(update);\n\n  update();\n  return r;\n};\n","/**\n * Manage a set of colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type Palette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: readonly string[]): Palette =>\n  new PaletteImpl(fallbacks);\n\nclass PaletteImpl {\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #store: Map<string, string> = new Map();\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: readonly string[];\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: readonly string[]) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const varName = `--` + key;\n    // eslint-disable-next-line functional/no-let\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(varName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import * as Drawing from \"./Drawing.js\";\nimport * as Bipolar from \"../data/Bipolar.js\";\n\n/**\n * Options\n */\nexport type BipolarViewOptions = Readonly<{\n  width?: number,\n  height?: number,\n  labelPrecision?: number\n  labels?: [ string, string ],\n  axisColour?: string,\n  bgColour?: string,\n  whiskerColour?: string,\n  whiskerSize?: number,\n  dotColour?: string,\n  dotRadius?: number,\n  showWhiskers?: boolean,\n  showDot?: boolean,\n  showLabels?: boolean,\n  padding?: number,\n  labelColour?: string,\n  axisWidth?: number,\n  asPercentages?: boolean,\n  /**\n   * Custom rendering for background\n   */\n  renderBackground?: Render\n}>\n\nfunction getNumericAttribute(el: HTMLElement, name: string, defaultValue: number) {\n  const a = el.getAttribute(name);\n  if (a === null) return defaultValue;\n  return Number.parseInt(a);\n}\n\nexport type Render = (ctx: CanvasRenderingContext2D, width: number, height: number) => void;\n/**\n * A function that plots a point on the graph\n */\nexport type BipolarView = (x: number, y: number) => void;\n\n/**\n * Initialises a plotter for bipolar values (-1...1)\n * \n * ```js\n * const p = BipolarView.init(`#my-canvas`);\n * // Shows the dot at 1, 0.5\n * p(1, 0.5);\n * ```\n * @param elementQuery \n * @param opts \n * @returns \n */\nexport const init = (elementQuery: string, opts: BipolarViewOptions = {}): BipolarView => {\n  const element = document.querySelector<HTMLCanvasElement>(elementQuery);\n  if (!element) throw new Error(`Element query could not be found (${ elementQuery })`);\n  const labels = opts.labels ?? [ `x`, `y` ];\n  const labelPrecision = opts.labelPrecision ?? 2;\n  const asPercentages = opts.asPercentages ?? false;\n  // Flags\n  const showWhiskers = opts.showWhiskers ?? true;\n  const showDot = opts.showDot ?? true;\n  const showLabels = opts.showLabels ?? true;\n  // Colours\n  const axisColour = opts.axisColour ?? `silver`;\n  const bgColour = opts.bgColour ?? `white`;\n  const whiskerColour = opts.whiskerColour ?? `black`;\n  const dotColour = opts.dotColour ?? whiskerColour;\n  const labelColour = opts.labelColour ?? axisColour;\n  // Sizes\n  const axisWidth = (opts.axisWidth ?? 1 * window.devicePixelRatio);\n  const dotRadius = (opts.dotRadius ?? 5 * window.devicePixelRatio);\n  const pad = (opts.padding ?? 10 * window.devicePixelRatio);\n  const whiskerSize = (opts.whiskerSize ?? 5 * window.devicePixelRatio);\n  const width = (opts.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio);\n  const height = (opts.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio);\n\n  element.width = width;// * window.devicePixelRatio;\n  element.height = height;// * window.devicePixelRatio;\n  element.style.width = width / window.devicePixelRatio + `px`;\n  element.style.height = height / window.devicePixelRatio + `px`;\n\n  const midY = height / 2;\n  const midX = width / 2;\n  const ctx = element.getContext(`2d`);\n  if (!ctx) throw new Error(`Could not create drawing context`);\n\n  if (window.devicePixelRatio >= 2) {\n    ctx.font = `20px sans-serif`;\n  }\n  const percentageFormat = (v: number) => Math.round(v * 100) + `%`;\n  const fixedFormat = (v: number) => v.toFixed(labelPrecision);\n\n  const valueFormat = asPercentages ? percentageFormat : fixedFormat;\n  if (showLabels) {\n    labels[ 0 ] = labels[ 0 ] + `:`;\n    labels[ 1 ] = labels[ 1 ] + `:`;\n  } else {\n    labels[ 0 ] = ``;\n    labels[ 1 ] = ``;\n  }\n\n  const renderBackground: Render = opts.renderBackground ?? ((ctx, width, height): void => {\n    ctx.fillStyle = bgColour;\n    ctx.fillRect(0, 0, width, height);\n  });\n\n  return (x: number, y: number) => {\n    x = Bipolar.clamp(x);\n    y = Bipolar.clamp(y);\n\n    renderBackground(ctx, width, height);\n\n    // Labels\n    ctx.fillStyle = labelColour;\n    ctx.textBaseline = `top`;\n    ctx.save();\n    ctx.translate(midX, midY);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText((labels[ 1 ] + ` ` + valueFormat(y)).trim(), -midX + pad, 1);\n    ctx.restore();\n    ctx.fillText((labels[ 0 ] + ` ` + valueFormat(x)).trim(), pad, midX + 2);\n\n    // Axes\n    ctx.strokeStyle = axisColour;\n    ctx.lineWidth = axisWidth;\n    ctx.beginPath();\n    ctx.moveTo(pad, midY);\n    ctx.lineTo(width - pad, midY);\n    ctx.moveTo(midX, pad);\n    ctx.lineTo(midX, height - pad);\n    ctx.stroke();\n    ctx.closePath();\n\n    const yy = (height - pad - pad) / 2 * -y;\n    const xx = (width - pad - pad) / 2 * x;\n\n    ctx.save();\n    ctx.translate(midX, midY);\n\n    // Dot\n    if (showDot) {\n      Drawing.circle(ctx, { radius: dotRadius, x: xx, y: yy }, { fillStyle: dotColour });\n    }\n\n    // Whiskers\n    if (showWhiskers) {\n      ctx.strokeStyle = whiskerColour;\n\n      // y line\n      ctx.beginPath();\n      ctx.moveTo(0, yy - whiskerSize);\n      ctx.lineTo(0, yy + whiskerSize);\n\n      // x line\n      ctx.moveTo(xx - whiskerSize, 0);\n      ctx.lineTo(xx + whiskerSize, 0);\n      ctx.stroke();\n      ctx.closePath();\n\n\n    }\n\n    // Restore transform\n    ctx.restore();\n  }\n}\n","import { minMaxAvg } from '../collections/arrays/NumericArrays.js';\nimport { type ICircularArray } from '../collections/CircularArray.js';\nimport { resolveEl } from '../dom/ResolveEl.js';\nimport { Colour, Drawing } from './index.js';\nimport {\n  ofArrayMutable,\n  ofCircularMutable,\n  type IMapOfMutableExtended,\n} from '../collections/map/index.js';\nimport type { Rect, Point } from '../geometry/Types.js';\nimport { parentSizeCanvas } from '../dom/CanvasSizing.js';\n\nexport type Plotter = {\n  add(value: number, series?: string, skipDrawing?: boolean): void;\n  drawValue(index: number): void;\n  /**\n   * Draws current data. Useful if skipDrawing was true for earlier add() calls.\n   */\n  draw(): void;\n  clear(): void;\n  dispose(): void;\n};\n\n/**\n * Series\n */\nexport type Series = {\n  min: number;\n  max: number;\n  range: number;\n  name: string;\n  colour: string;\n  lastValue?: number;\n  hoverValue?: number;\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = PlotOpts & {\n  x: Axis;\n  y: Axis;\n  ctx: CanvasRenderingContext2D;\n  textHeight: number;\n  capacity: number;\n  coalesce: boolean;\n  margin: number;\n  canvasSize: Rect;\n  clearCanvas: boolean;\n  translucentPlot?: boolean;\n  highlightIndex?: number;\n  leadingEdgeDot: boolean;\n  debug: boolean;\n  digitsPrecision: number;\n  lineWidth: number;\n  defaultSeriesColour: string;\n  defaultSeriesVariable?: string;\n  showLegend: boolean;\n  pointer: { x: number; y: number };\n};\n\n/**\n * Properties for an axis\n */\nexport type Axis = {\n  allowedSeries?: Array<string>;\n  /**\n   * Name of axis, eg `x`\n   */\n  name: string;\n  /**\n   * Colour to use for axis labels\n   */\n  colour?: string;\n  /**\n   * Forced scale for values\n   */\n  scaleRange?: [ number, number ];\n  /**\n   * Forced range for labelling, by default\n   * uses scaleRange\n   */\n  labelRange?: [ number, number ];\n  /**\n   * Width of axis line\n   */\n  lineWidth: number;\n  /**\n   * How line ends\n   */\n  endWith: `none` | `arrow`;\n  /**\n   * Where to place the name of the axis\n   */\n  namePosition: `none` | `end` | `side`;\n  /**\n   * Width for y axis, height for x axis\n   */\n  textSize: number;\n  /**\n   * If true, axis labels (ie numeric scale) are shown. Default: true\n   */\n  showLabels: boolean;\n  /**\n   * If true, a line is drawn to represent axis. Default: true\n   */\n  showLine: boolean;\n};\n\nexport type SeriesColours = Record<string, string | undefined>;\n\n/**\n * Plotter options\n */\nexport type PlotOpts = {\n  debug?: boolean;\n  seriesColours?: SeriesColours;\n  /**\n   * Default: 2\n   */\n  digitsPrecision?: number;\n  x?: Axis;\n  y?: Axis;\n  plotSize?: Rect;\n  autoSizeCanvas?: boolean;\n  style?: `connected` | `dots` | `none`;\n  //palette?: Palette.Palette\n  /**\n   * Number of items to keep in the circular array\n   * Default: 10\n   */\n  capacity?: number;\n  //showYAxis?:boolean\n  //showXAxis?:boolean\n  //yAxes?: string[]|string\n  textHeight?: number;\n  /**\n   * Width of plotted line\n   */\n  lineWidth?: number;\n  /**\n   * If true, sub-pixel data points are ignored\n   */\n  coalesce?: boolean;\n  /**\n   * Fixed range to scale Y values. By default normalises values\n   * as they come in. This will also determine the y-axis labels and drawing\n   */\n  //fixedRange?:[number,number]\n  /**\n   * How many horizontal pixels per data point. If unspecified,\n   * it will scale based on width of canvas and capacity.\n   */\n  //dataXScale?:number\n  defaultSeriesColour?: string;\n  defaultSeriesVariable?: string;\n  showLegend?: boolean;\n};\n\nconst piPi = Math.PI * 2;\n\nexport const defaultAxis = (name: string): Axis => ({\n  endWith: `none`,\n  lineWidth: 1,\n  namePosition: `none`,\n  name: name,\n  showLabels: name === `y`,\n  showLine: true,\n  // For y axis, it's the width, for x axis it's the text height\n  textSize: name === `y` ? 20 : 10,\n});\n\nexport const calcScale = (\n  buffer: BufferType,\n  drawingOpts: DrawingOpts,\n  seriesColours?: SeriesColours\n) => {\n  //const seriesNames = buffer.keys();\n  const scales: Array<Series> = [];\n\n  for (const s of buffer.keys()) {\n    //seriesNames.forEach(s => {\n\n    const series = [ ...buffer.get(s) ];\n    if (series.length === 0) break;\n\n    let { min, max } = minMaxAvg(series);\n    let range = max - min;\n\n    let colour;\n    if (seriesColours !== undefined) {\n      colour = seriesColours[ s ];\n    }\n    if (colour == undefined) {\n      colour = drawingOpts.defaultSeriesVariable ? Colour.getCssVariable(\n        `accent`,\n        drawingOpts.defaultSeriesColour\n      ) : drawingOpts.defaultSeriesColour;\n    }\n\n    if (range === 0) {\n      range = min;\n      min = min - range / 2;\n      max = max + range / 2;\n    }\n    scales.push({\n      min,\n      max,\n      range,\n      name: s,\n      colour: colour,\n    });\n  }\n  return scales;\n};\n\nexport const add = (buffer: BufferType, value: number, series = ``) => {\n  buffer.addKeyedValues(series, value);\n};\n\nexport type BufferType =\n  | IMapOfMutableExtended<number, ICircularArray<number>>\n  | IMapOfMutableExtended<number, ReadonlyArray<number>>;\n\nexport const drawValue = (\n  index: number,\n  buffer: BufferType,\n  drawing: DrawingOpts\n) => {\n  const c = {\n    ...drawing,\n    translucentPlot: true,\n    leadingEdgeDot: false,\n  };\n  draw(buffer, c);\n\n  drawing = {\n    ...drawing,\n    highlightIndex: index,\n    leadingEdgeDot: true,\n    translucentPlot: false,\n    style: `none`,\n    clearCanvas: false,\n  };\n  draw(buffer, drawing);\n};\n\nconst scaleWithFixedRange = (\n  buffer: BufferType,\n  range: [ number, number ],\n  drawing: DrawingOpts\n) =>\n  calcScale(buffer, drawing, drawing.seriesColours).map((s) => ({\n    ...s,\n    range: range[ 1 ] - range[ 0 ],\n    min: range[ 0 ],\n    max: range[ 1 ],\n  }));\n\n/**\n * Draws a `buffer` of data with `drawing` options.\n *\n * @param buffer\n * @param drawing\n */\nexport const draw = (buffer: BufferType, drawing: DrawingOpts) => {\n  const { x: xAxis, y: yAxis, ctx, canvasSize } = drawing;\n  const margin = drawing.margin;\n  // const cap = drawing.capacity === 0 ? buffer.lengthMax : drawing.capacity;\n  const series = drawing.y.scaleRange\n    ? scaleWithFixedRange(buffer, drawing.y.scaleRange, drawing)\n    : calcScale(buffer, drawing, drawing.seriesColours);\n\n  if (drawing.clearCanvas)\n    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `orange`;\n    ctx.strokeRect(0, 0, canvasSize.width, canvasSize.height);\n  }\n\n  // Move in for margin\n  ctx.translate(margin, margin);\n\n  // Calculate/use plot area\n  const plotSize = drawing.plotSize ?? plotSizeFromBounds(canvasSize, drawing);\n\n  // Draw vertical axes\n  const axisSize = {\n    height: plotSize.height + margin + margin,\n    width: plotSize.width,\n  };\n\n  if (yAxis.showLabels || yAxis.showLine) {\n    // Draw the labels for each series\n    for (const s of series) {\n      if (yAxis.allowedSeries !== undefined && !yAxis.allowedSeries.includes(s.name)) continue;\n      drawYSeriesScale(s, axisSize, drawing);\n    }\n\n    // Draw vertical line\n    if (series.length > 0 && yAxis.showLine)\n      drawYLine(axisSize, series[ 0 ], drawing);\n  }\n\n  // Draw x/horizontal axis if needed\n  if ((xAxis.showLabels || xAxis.showLine) && series.length > 0) {\n    const yPos = yAxis.labelRange ? yAxis.labelRange[ 0 ] : series[ 0 ].min;\n    drawXAxis(\n      plotSize.width,\n      calcYForValue(yPos, series[ 0 ], plotSize.height) +\n      margin +\n      xAxis.lineWidth,\n      drawing\n    );\n  }\n\n  const plotDrawing = {\n    ...drawing,\n    plotSize,\n  };\n\n  const ptr = Drawing.translatePoint(ctx, drawing.pointer);\n  // Draw data for each series\n  for (const s of series) {\n    const data = buffer.getSource(s.name);\n    if (data === undefined) continue;\n\n    let leadingEdgeIndex =\n      buffer.typeName === `circular`\n        ? (data as ICircularArray<number>).pointer - 1\n        : data.length - 1;\n    if (drawing.highlightIndex !== undefined)\n      leadingEdgeIndex = drawing.highlightIndex;\n    ctx.save();\n    ctx.translate(0, margin + margin);\n\n    drawSeriesData(s, data, plotSize, plotDrawing, leadingEdgeIndex);\n    ctx.restore();\n  }\n\n  if (drawing.showLegend) {\n    ctx.save();\n    ctx.translate(0, plotSize.height + margin + margin + margin);\n    const legendSize = {\n      width: plotSize.width,\n      height: drawing.x.textSize + margin + margin,\n    };\n    drawLegend(series, drawing, legendSize);\n    ctx.restore();\n  }\n  ctx.resetTransform();\n};\n\n/**\n * Draw vertical axis\n * @param series\n * @param height\n * @param drawing\n */\nconst drawYSeriesScale = (\n  series: Series,\n  plotSize: Rect,\n  drawing: DrawingOpts\n) => {\n  const { ctx, y, digitsPrecision, margin } = drawing;\n  const { height } = plotSize;\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `purple`;\n    ctx.strokeRect(0, 0, y.textSize, height + margin);\n  }\n\n  ctx.fillStyle = series.colour.length > 0 ? series.colour : `white`;\n\n  // Override colour with axis-defined colour\n  if (y.colour) ctx.fillStyle = y.colour;\n\n  // Draw labels\n  const min = y.labelRange ? y.labelRange[ 0 ] : series.min;\n  const max = y.labelRange ? y.labelRange[ 1 ] : series.max;\n  const range = y.labelRange ? max - min : series.range;\n  const mid = min + range / 2;\n  const halfHeight = drawing.textHeight / 2;\n\n  ctx.textBaseline = `top`;\n  ctx.fillText(\n    min.toFixed(digitsPrecision),\n    0,\n    calcYForValue(min, series, height) - halfHeight\n  );\n  ctx.fillText(\n    mid.toFixed(digitsPrecision),\n    0,\n    calcYForValue(mid, series, height) - halfHeight\n  );\n  ctx.fillText(\n    max.toFixed(digitsPrecision),\n    0,\n    calcYForValue(max, series, height) - margin\n  );\n\n  ctx.translate(y.textSize + margin, 0);\n};\n\nconst drawYLine = (plotSize: Rect, series: Series, drawing: DrawingOpts) => {\n  if (series === undefined) throw new Error(`series undefined`);\n  const { ctx, y } = drawing;\n  const { height } = plotSize;\n\n  const min = y.labelRange ? y.labelRange[ 0 ] : series.min;\n  const max = y.labelRange ? y.labelRange[ 1 ] : series.max;\n\n  const minPos = calcYForValue(min, series, height);\n  const maxPos = calcYForValue(max, series, height);\n\n  // Draw line\n  ctx.translate(y.lineWidth, 0);\n  ctx.lineWidth = y.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(0, minPos);\n  ctx.lineTo(0, maxPos);\n  ctx.strokeStyle = series.colour;\n  if (y.colour) ctx.strokeStyle = y.colour;\n  ctx.stroke();\n  ctx.translate(y.lineWidth, 0);\n};\n\nconst drawLegend = (\n  series: Array<Series>,\n  drawing: DrawingOpts,\n  size: { width: number; height: number }\n) => {\n  const { ctx } = drawing;\n  const lineSampleWidth = 10;\n\n  let x = 0;\n  const lineY = drawing.margin * 3;\n  const textY = drawing.margin;\n\n  ctx.lineWidth = drawing.lineWidth;\n\n  for (const s of series) {\n    ctx.moveTo(x, lineY);\n    ctx.strokeStyle = s.colour;\n    ctx.lineTo(x + lineSampleWidth, lineY);\n    ctx.stroke();\n    x += lineSampleWidth + drawing.margin;\n\n    let label = s.name;\n    if (s.lastValue)\n      label += ` ` + s.lastValue.toFixed(drawing.digitsPrecision);\n    const labelSize = ctx.measureText(label);\n\n    ctx.fillStyle = s.colour;\n    ctx.fillText(label, x, textY);\n    x += labelSize.width;\n  }\n};\n\nconst drawXAxis = (width: number, yPos: number, drawing: DrawingOpts) => {\n  const { ctx, x, y } = drawing;\n\n  if (!x.showLine) return;\n\n  if (x.colour) ctx.strokeStyle = x.colour;\n  ctx.lineWidth = x.lineWidth;\n  ctx.beginPath();\n\n  // Assumes ctx is translated after drawing Y axis\n  ctx.moveTo(0, yPos);\n  ctx.lineTo(width, yPos);\n  ctx.stroke();\n};\n\n/**\n * Draw series data\n * @param series\n * @param values\n * @param plotSize\n * @param drawing\n */\nconst drawSeriesData = (\n  series: Series,\n  values: ArrayLike<number>,\n  plotSize: Rect,\n  drawing: DrawingOpts,\n  leadingEdgeIndex: number\n) => {\n  const { ctx, lineWidth, translucentPlot = false, margin, x: xAxis } = drawing;\n  const style = drawing.style ?? `connected`;\n  const height = plotSize.height - margin;\n\n  let dataXScale = 1;\n  if (xAxis.scaleRange) {\n    const xAxisRange = xAxis.scaleRange[ 1 ] - xAxis.scaleRange[ 0 ];\n    dataXScale = plotSize.width / xAxisRange;\n  } else {\n    dataXScale = drawing.capacity === 0 ? plotSize.width / values.length : plotSize.width / drawing.capacity;\n  }\n\n  // Step through data faster if per-pixel density is above one\n  const incrementBy = drawing.coalesce\n    ? (dataXScale < 0\n      ? Math.floor(1 / dataXScale)\n      : 1)\n    : 1;\n\n  let x = 0;\n  let leadingEdge: Point | undefined;\n\n  if (drawing.debug) {\n    ctx.strokeStyle = `green`;\n    ctx.strokeRect(0, 0, plotSize.width, plotSize.height);\n  }\n\n  const colourTransform = (c: string) => {\n    if (translucentPlot) return Colour.opacity(c, 0.2);\n    return c;\n  };\n\n  if (style === `dots`) {\n    ctx.fillStyle = colourTransform(series.colour);\n  } else if (style === `none`) {} else {\n    ctx.beginPath();\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = colourTransform(series.colour);\n  }\n\n  for (let index = 0; index < values.length; index += incrementBy) {\n    const y = calcYForValue(values[ index ], series, height) - 1;\n\n    if (style === `dots`) {\n      ctx.beginPath();\n      ctx.arc(x, y, lineWidth, 0, piPi);\n      ctx.fill();\n    } else if (style === `none`) {} else {\n      if (index == 0) ctx.moveTo(x, y);\n      ctx.lineTo(x, y);\n    }\n\n    if (index === leadingEdgeIndex) {\n      leadingEdge = { x, y };\n      series.lastValue = values[ index ];\n    }\n    x += dataXScale;\n  }\n\n  if (style === `connected`) {\n    ctx.stroke();\n  }\n\n  // Draw a circle at latest data point\n  if (leadingEdge !== undefined && drawing.leadingEdgeDot) {\n    ctx.beginPath();\n    ctx.fillStyle = colourTransform(series.colour); // drawing.palette.getOrAdd(`series${series.name}`));\n    ctx.arc(leadingEdge.x, leadingEdge.y, 3, 0, 2 * Math.PI);\n    ctx.fill();\n  }\n};\n\nconst calcYForValue = (v: number, series: Series, height: number) =>\n  (1 - (v - series.min) / series.range) * height;\n\n/**\n * Calculates lost area, given a margin value, axis settings.\n * @param margin\n * @param x\n * @param y\n * @param showLegend\n * @returns\n */\nconst calcSizing = (margin: number, x: Axis, y: Axis, showLegend: boolean) => {\n  let fromLeft = margin;\n  if (y.showLabels) fromLeft += y.textSize;\n  if (y.showLine) fromLeft += y.lineWidth;\n  if (y.showLabels || y.showLine) fromLeft += margin + margin;\n  const fromRight = margin;\n\n  const fromTop = margin + margin;\n  let fromBottom = margin + margin;\n  fromBottom += x.showLabels ? x.textSize : margin;\n  if (x.showLine) fromBottom += x.lineWidth;\n  if (x.showLabels || x.showLine) fromBottom += margin;\n\n  if (showLegend) fromBottom += x.textSize;\n\n  return {\n    left: fromLeft,\n    right: fromRight,\n    top: fromTop,\n    bottom: fromBottom,\n  };\n};\n\nconst plotSizeFromBounds = (\n  bounds: Rect,\n  opts: { margin: number; y: Axis; x: Axis; showLegend: boolean }\n): Rect => {\n  const { width, height } = bounds;\n  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);\n  return {\n    width: width - sizing.left - sizing.right,\n    height: height - sizing.top - sizing.bottom,\n  };\n};\n\nconst canvasSizeFromPlot = (\n  plot: Rect,\n  opts: { margin: number; y: Axis; x: Axis; showLegend: boolean }\n): Rect => {\n  const { width, height } = plot;\n  const sizing = calcSizing(opts.margin, opts.x, opts.y, opts.showLegend);\n  return {\n    width: width + sizing.left + sizing.right,\n    height: height + sizing.top + sizing.bottom,\n  };\n};\n\n/**\n * Creates a simple horizontal data plot within a DIV.\n *\n * ```\n * const p = plot(`#parentDiv`);\n * p.add(10);\n * p.clear();\n *\n * // Plot data using series\n * p.add(-1, `temp`);\n * p.add(0.4, `humidty`);\n * ```\n *\n * Options can be specified to customise plot\n * ```\n * const p = plot(`#parentDiv`, {\n *  capacity: 100,     // How many data points to store (default: 10)\n *  showYAxis: false,  // Toggle whether y axis is shown (default: true)\n *  lineWidth: 2,      // Width of plot line (default: 2)\n *  yAxes:  [`temp`],  // Only show these y axes (by default all are shown)\n *  coalesce: true,    // If true, sub-pixel data points are skipped, improving performance for dense plots at the expense of plot precision\n * });\n * ```\n *\n * For all `capacity` values other than `0`, a circular array is used to track data. Otherwise an array is used that will\n * grow infinitely.\n *\n * By default, will attempt to use CSS variable `--series[seriesName]` for axis colours.\n *  `--series[name]-axis` for titles. Eg `--seriesX`. For data added without a named series,\n * it will use `--series` and `--series-axis`.\n * @param parentElOrQuery\n * @param opts\n * @return Plotter instance\n */\nexport const plot = (\n  parentElementOrQuery: string | HTMLElement,\n  opts: PlotOpts\n): Plotter => {\n  if (parentElementOrQuery === null)\n    throw new Error(`parentElOrQuery is null. Expected string or element`);\n\n  const parentEl = resolveEl(parentElementOrQuery);\n  let canvasEl: HTMLCanvasElement;\n  let destroyCanvasEl = true;\n  let plotSize: Rect | undefined = opts.plotSize;\n  let canvasSize: Rect;\n  if (parentEl.nodeName === `CANVAS`) {\n    // Use provided canvas\n    canvasEl = parentEl as HTMLCanvasElement;\n    destroyCanvasEl = false;\n    canvasSize = { width: canvasEl.width, height: canvasEl.height };\n  } else {\n    // Create a CANVAS that fills parent\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    parentEl.append(canvasEl);\n    plotSize = opts.plotSize;\n    canvasSize = { width: canvasEl.width, height: canvasEl.height };\n  }\n\n  const pointer = { x: 0, y: 0 };\n\n  const onPointerMove = (event: PointerEvent) => {\n    pointer.x = event.offsetX;\n    pointer.y = event.offsetY;\n  };\n\n  canvasEl.addEventListener(`pointermove`, onPointerMove);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const ctx = canvasEl.getContext(`2d`)!;\n\n  const capacity = opts.capacity ?? 10;\n  const buffer =\n    capacity > 0\n      ? ofCircularMutable<number>({ capacity })\n      : ofArrayMutable<number>();\n  const metrics = ctx.measureText(`Xy`);\n  const coalesce = opts.coalesce ?? true;\n\n  // Sanity-check\n  if (ctx === null) throw new Error(`Drawing context not available`);\n\n  let xAxis = defaultAxis(`x`);\n  if (opts.x) xAxis = { ...xAxis, ...opts.x };\n  let yAxis = defaultAxis(`y`);\n  if (opts.y) yAxis = { ...yAxis, ...opts.y };\n\n  let drawingOpts: DrawingOpts = {\n    ...opts,\n    y: yAxis,\n    x: xAxis,\n    pointer: pointer,\n    capacity,\n    coalesce,\n    plotSize,\n    canvasSize,\n    ctx,\n    textHeight:\n      opts.textHeight ??\n      metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\n    style: opts.style ?? `connected`,\n    defaultSeriesColour: opts.defaultSeriesColour ?? `yellow`,\n    margin: 3,\n    clearCanvas: true,\n    leadingEdgeDot: true,\n    debug: opts.debug ?? false,\n    digitsPrecision: opts.digitsPrecision ?? 2,\n    lineWidth: opts.lineWidth ?? 2,\n    showLegend: opts.showLegend ?? false,\n  };\n\n  if (plotSize) {\n    // Size canvas based on given plot size\n    const canvasSize = canvasSizeFromPlot(plotSize, drawingOpts);\n    canvasEl.width = canvasSize.width;\n    canvasEl.height = canvasSize.height;\n\n    drawingOpts.canvasSize = canvasSize;\n  }\n\n  if (opts.autoSizeCanvas) {\n    parentSizeCanvas(canvasEl, (args) => {\n      const bounds = args.bounds;\n      drawingOpts = {\n        ...drawingOpts,\n        plotSize: plotSizeFromBounds(bounds, drawingOpts),\n        canvasSize: bounds,\n      };\n      draw(buffer, drawingOpts);\n    });\n  }\n\n  return {\n    drawValue: (index: number) => {\n      drawValue(index, buffer, drawingOpts);\n    },\n    dispose: () => {\n      canvasEl.removeEventListener(`pointermove`, onPointerMove);\n      if (destroyCanvasEl) canvasEl.remove();\n    },\n    add: (value: number, series = ``, skipDrawing = false) => {\n      add(buffer, value, series);\n      if (skipDrawing) return;\n      draw(buffer, drawingOpts);\n    },\n    draw: () => {\n      draw(buffer, drawingOpts);\n    },\n    clear: () => {\n      buffer.clear();\n    },\n  };\n};\n","export * from './Log.js';\nexport * from './Util.js';\nexport * as DataTable from './DataTable.js';\nexport * from './DataDisplay.js';\n\n/**\n * Functions for working with DOM elements\n */\nexport * as Forms from './Forms.js';\nexport * from './PointerVisualise.js';\nexport * from './ErrorHandler.js';\nexport * as DragDrop from './DragDrop.js';\nexport * from './InlineConsole.js';\nexport * as Variables from './CssVariables.js';\nexport * from './CanvasHelper.js';\nexport * from './CanvasSizing.js';\nexport * from './ElementSizing.js';\nexport * from './ResolveEl.js';\nexport * as Rx from './DomRx.js';\nexport * from './Query.js';","export const addShadowCss = (\n  parentEl: Readonly<HTMLElement>,\n  styles: string\n): ShadowRoot => {\n  const styleEl = document.createElement(`style`);\n\n  //eslint-disable-next-line functional/immutable-data\n  styleEl.textContent = styles;\n  //eslint-disable-next-line functional/no-let\n  let shadowRoot;\n  if (parentEl.shadowRoot) {\n    shadowRoot = parentEl.shadowRoot;\n    //eslint-disable-next-line functional/immutable-data\n    shadowRoot.innerHTML = ``;\n  } else {\n    shadowRoot = parentEl.attachShadow({ mode: `open` });\n  }\n  shadowRoot.append(styleEl);\n  return shadowRoot;\n};\n","import { resolveEl } from './ResolveEl.js';\nimport { addShadowCss } from './ShadowDom.js';\n\nexport type LogOpts = {\n  readonly reverse?: boolean;\n  readonly capacity?: number;\n  readonly timestamp?: boolean;\n  readonly collapseDuplicates?: boolean;\n  readonly monospaced?: boolean;\n  readonly minIntervalMs?: number;\n  readonly css?: string;\n};\n\n//eslint-disable-next-line functional/no-mixed-types\nexport type Log = {\n  clear(): void;\n  error(messageOrError: unknown): void;\n  log(message?: string | object | number): HTMLElement | undefined;\n  warn(message?: string | object | number): HTMLElement | undefined;\n  //eslint-disable-next-line functional/prefer-immutable-types\n  append(el: HTMLElement): void;\n  dispose(): void;\n  readonly isEmpty: boolean;\n};\n\n/**\n * Allows writing to a DOM element in console.log style. Element grows in size, so use\n * something like `overflow-y: scroll` on its parent\n *\n * ```\n * const l = log(`#dataStream`); // Assumes HTML element with id `dataStream` exists\n * l.log(`Hi`);\n * l.log(); // Displays a horizontal rule\n *\n * const l = log(document.getElementById(`dataStream`), {\n *  timestamp: true,\n *  truncateEntries: 20\n * });\n * l.log(`Hi`);\n * l.error(`Some error`); // Adds class `error` to line\n * ```\n *\n * For logging high-throughput streams:\n * ```\n * // Silently drop log if it was less than 5ms since the last\n * const l = log(`#dataStream`, { minIntervalMs: 5 });\n *\n * // Only the last 100 entries are kept\n * const l = log(`#dataStream`, { capacity: 100 });\n * ```\n *\n * @param {(HTMLElement | string | undefined)} elOrId Element or id of element\n * @param {LogOpts} opts\n * @returns {Log}\n */\nexport const log = (\n  //eslint-disable-next-line functional/prefer-immutable-types\n  domQueryOrElement: HTMLElement | string,\n  opts: LogOpts = {}\n): Log => {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const {\n    capacity = 0,\n    monospaced = true,\n    timestamp = false,\n    collapseDuplicates = true,\n    css = ``,\n  } = opts;\n\n  // eslint-disable-next-line functional/no-let\n  let added = 0;\n  // eslint-disable-next-line functional/no-let\n  let lastLog: string | undefined;\n  // eslint-disable-next-line functional/no-let\n  let lastLogRepeats = 0;\n\n  const parentElement = resolveEl<HTMLElement>(domQueryOrElement);\n  const fontFamily = monospaced\n    ? `Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", Monaco, \"Courier New\", Courier, monospace`\n    : `normal`;\n  const shadowRoot = addShadowCss(\n    parentElement,\n    `\n  .log {\n    font-family: ${ fontFamily };\n    background-color: var(--code-background-color);\n    padding: var(--padding1, 0.2em);\n    overflow-y: auto;\n    height:100%;\n  }\n  .timestamp {\n    margin-right: 0.5em;\n    opacity: 0.5;\n    font-size: 70%;\n    align-self: center;\n  }\n  .line {\n    display: flex;\n    padding-bottom: 0.1em;\n    padding-top: 0.1em;\n  }\n  .line:hover {\n  \n  }\n  .error {\n    color: red;\n  }\n  .badge {\n    border: 1px solid currentColor;\n    align-self: center;\n    font-size: 70%;\n    padding-left: 0.2em;\n    padding-right: 0.2em;\n    border-radius: 1em;\n    margin-left: 0.5em;\n    margin-right: 0.5em;\n  }\n  .msg {\n    flex: 1;\n    word-break: break-word;\n  }\n  ${ css }\n  `\n  );\n\n  const el = document.createElement(`div`);\n  // eslint-disable-next-line functional/immutable-data,unicorn/no-keyword-prefix\n  el.className = `log`;\n  shadowRoot.append(el);\n\n  const error = (messageOrError: string | Error) => {\n    const line = document.createElement(`div`);\n\n    if (typeof messageOrError === `string`) {\n      // eslint-disable-next-line functional/immutable-data\n      line.innerHTML = messageOrError;\n    } else if (messageOrError instanceof Error) {\n      const stack = messageOrError.stack;\n      line.innerHTML = stack === undefined ? messageOrError.toString() : stack.toString();\n    } else {\n      // eslint-disable-next-line functional/immutable-data\n      line.innerHTML = messageOrError as string;\n    }\n    line.classList.add(`error`);\n    append(line);\n    lastLog = undefined;\n    lastLogRepeats = 0;\n  };\n\n  //eslint-disable-next-line functional/no-let\n  let lastLogTime = 0;\n\n  const warn = (whatToLog: unknown = ``): HTMLElement | undefined => {\n    const element = log(whatToLog);\n    if (!element) return element;\n    element.classList.add(`warning`);\n    return element;\n  }\n  const log = (whatToLog: unknown = ``): HTMLElement | undefined => {\n    // eslint-disable-next-line functional/no-let\n    let message: string | undefined;\n    const interval = window.performance.now() - lastLogTime;\n    if (opts.minIntervalMs && interval < opts.minIntervalMs) return;\n    lastLogTime = window.performance.now();\n\n    if (typeof whatToLog === `object`) {\n      message = JSON.stringify(whatToLog);\n    } else if (whatToLog === undefined) {\n      message = `(undefined)`;\n    } else if (whatToLog === null) {\n      message = `(null)`;\n    } else if (typeof whatToLog === `number`) {\n      if (Number.isNaN(message)) message = `(NaN)`;\n      message = whatToLog.toString();\n    } else {\n      message = whatToLog as string;\n    }\n\n    if (message.length === 0) {\n      const rule = document.createElement(`hr`);\n      lastLog = undefined;\n      append(rule);\n    } else if (message === lastLog && collapseDuplicates) {\n      const lastElement = el.firstElementChild as HTMLElement;\n      // eslint-disable-next-line functional/no-let\n      let lastBadge = lastElement.querySelector(`.badge`);\n      if (lastBadge === null) {\n        lastBadge = document.createElement(`div`);\n        // eslint-disable-next-line functional/immutable-data,unicorn/no-keyword-prefix\n        lastBadge.className = `badge`;\n        lastElement.insertAdjacentElement(`beforeend`, lastBadge);\n      }\n      if (lastElement !== null) {\n        // eslint-disable-next-line functional/immutable-data\n        lastBadge.textContent = (++lastLogRepeats).toString();\n      }\n      return lastElement;\n    } else {\n      const line = document.createElement(`div`);\n      // eslint-disable-next-line functional/immutable-data\n      line.textContent = message;\n      append(line);\n      lastLog = message;\n      return line;\n    }\n  };\n\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const append = (line: HTMLElement) => {\n    if (timestamp) {\n      const wrapper = document.createElement(`div`);\n      const timestamp = document.createElement(`div`);\n      // eslint-disable-next-line functional/immutable-data,unicorn/no-keyword-prefix\n      timestamp.className = `timestamp`;\n      // eslint-disable-next-line functional/immutable-data\n      timestamp.textContent = new Date().toLocaleTimeString();\n      wrapper.append(timestamp, line);\n      line.classList.add(`msg`);\n      wrapper.classList.add(`line`);\n      line = wrapper;\n    } else {\n      line.classList.add(`line`, `msg`);\n    }\n\n    if (opts.reverse) {\n      el.append(line);\n    } else {\n      el.insertBefore(line, el.firstChild);\n    }\n\n    if (capacity > 0 && ++added > capacity * 2) {\n      while (added > capacity) {\n        el.lastChild?.remove();\n        added--;\n      }\n    }\n\n    if (opts.reverse) {\n      // Scroll to bottom\n      //eslint-disable-next-line functional/immutable-data\n      el.scrollTop = el.scrollHeight;\n    }\n    lastLogRepeats = 0;\n  };\n\n  const clear = () => {\n    // eslint-disable-next-line functional/immutable-data\n    el.innerHTML = ``;\n    lastLog = undefined;\n    lastLogRepeats = 0;\n    added = 0;\n  };\n\n  const dispose = () => {\n    el.remove();\n  };\n\n  return {\n    error,\n    log,\n    warn,\n    append,\n    clear,\n    dispose,\n    get isEmpty() {\n      return added === 0;\n    },\n  };\n};\n","//import { Observable, debounceTime, fromEvent } from 'rxjs';\nimport * as Points from '../geometry/point/index.js';\nimport JSON5 from 'json5';\nimport type { CardinalDirection } from '../geometry/Grid.js';\nimport { cardinal } from '../geometry/rect/index.js';\nimport type { Point } from '../geometry/point/index.js';\nimport { resolveEl, resolveEls, type QueryOrElements } from './ResolveEl.js';\n\nexport type PointSpaces = `viewport` | `screen` | `document`;\n\n/**\n * Convert an absolute point to relative, in different coordinate spaces.\n *\n * When calling the returned function, the input value must be in the same\n * scale as the intended output scale.\n *\n * Viewport-relative is used by default.\n *\n * @example Get relative position of click in screen coordinates\n * ```js\n * const f = pointScaler({ to: 'screen' });\n * document.addEventListener('click', evt => {\n *  const screenRelative = f(evt.screenX, evt.screenY);\n *  // Yields {x,y} on 0..1 scale\n * });\n * ```\n *\n * @example Get relative position of click in viewport coordinates\n * ```js\n * const f = pointScaler({ to: 'viewport' });\n * document.addEventListener('click', evt => {\n *  const viewportRelative = f(evt.clientX, evt.clientY);\n *  // Yields {x,y} on 0..1 scale\n * });\n * ```\n *\n * @example Get relative position of click in document coordinates\n * ```js\n * const f = pointScaler({ to: 'document' });\n * document.addEventListener('click', evt => {\n *  const documentRelative = f(evt.pageX, evt.pageY);\n *  // Yields {x,y} on 0..1 scale\n * });\n * ```\n *\n * @param opts\n * @returns\n */\nexport const pointScaler = (reference: PointSpaces = `viewport`) => {\n  switch (reference) {\n    case `viewport`: {\n      return (a: Readonly<Point | number | Array<number>>, b?: number) => {\n        const pt = Points.getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x / window.innerWidth,\n          y: pt.y / window.innerHeight,\n        });\n      };\n    }\n    case `screen`: {\n      return (a: Readonly<Point | number | Array<number>>, b?: number) => {\n        const pt = Points.getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x / screen.width,\n          y: pt.y / screen.height,\n        });\n      };\n    }\n    case `document`: {\n      return (a: Readonly<Point | number | Array<number>>, b?: number) => {\n        const pt = Points.getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x / document.body.scrollWidth,\n          y: pt.y / document.body.scrollHeight,\n        });\n      };\n    }\n    default: {\n      throw new Error(\n        `Unknown 'reference' parameter: ${ JSON.stringify(reference) }`\n      );\n    }\n  }\n};\n\nexport type ElPositionOpts = {\n  readonly target?: PointSpaces;\n  readonly relative?: boolean;\n  readonly anchor?: CardinalDirection | `center`;\n};\n\n/**\n * Returns a function which yields element position in target coordinate space with optional scaling.\n * Live position is calculated when the function is invoked.\n * Use {@link positionRelative} to simply get relative position of element in given coordinate space.\n *\n * @example Absolute position of #blah in viewport coordinate space\n * ```js\n * const f = positionFn('#blah');\n * f(); // Yields: {x,y}\n * // Or:\n * positionFn('#blah')(); // Immediately invoke\n * ```\n *\n * @example Relative position of element in viewport-space\n * ```js\n * const f = positionFn(evt.target, { relative: true });\n * f(); // Yields: {x,y}\n * ```\n *\n * @example Relative position of #blah in screen-space\n * ```js\n * const f = positionFn('#blah', { target: 'screen', relative: true });\n * f(); // Yields: {x,y}\n * ```\n *\n * By default, top-left corner (north west) is used. Other cardinal points or 'center' can be specified:\n * ```js\n * // Relative position by center\n * positionFn('#blah', { relative: true, anchor: 'center' });\n *\n * // ...by bottom-right corner\n * positionFn('#blah', { relative: true, anchor: 'se' });\n * ```\n *\n * This function is useful if you have a stable DOM element and conversion target.\n * If the DOM element is changing continually, consider using {@link viewportToSpace} to\n * convert from viewport coordinates to target coordinates:\n *\n * ```js\n * // Eg.1 Absolute coords in screen space\n * const vpToScreen = viewportToSpace('screen');\n * vpToScreen(el.getBoundingClientRect());\n *\n * // Eg.2 Relative coords in viewport space\n * const vpRelative = pointScaler(); // Re-usable scaler. Default uses viewport\n * vpRelative(el.getBoundingClientRect()); // Yields: { x,y }\n *\n * // Eg.3 Relative coords in screen space\n * const vpToScreen = viewportToSpace('screen'); // Map viewport->screen\n * const screenRelative = pointScaler('screen'); // Scale screen units\n *\n * // Combine into a resuable function that takes an element\n * const mapAndScale = (el) => screenRelative(vpToScreen(el.getBoundingClientRect()));\n *\n * // Call\n * mapAndScale(document.getElementById('blah')); // Yields: { x,y }\n * ```\n * @param domQueryOrEl\n * @param coordinateSpace\n * @param scaled\n * @returns\n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const positionFn = (\n  domQueryOrEl: Readonly<string | HTMLElement>,\n  opts: ElPositionOpts = {}\n): (() => Point) => {\n  const targetSpace = opts.target ?? `viewport`;\n  const relative = opts.relative ?? false;\n  const anchor = opts.anchor ?? `nw`;\n\n  const el = resolveEl(domQueryOrEl);\n  const vpToSpace = viewportToSpace(targetSpace);\n\n  if (relative) {\n    const s = pointScaler(targetSpace);\n    return () => s(vpToSpace(cardinal(el.getBoundingClientRect(), anchor)));\n  } else {\n    return () => vpToSpace(cardinal(el.getBoundingClientRect(), anchor));\n  }\n};\n\n/**\n * Returns a {x,y} Point on a cardinal position of element.\n * ```\n * // Top edge, middle horizontal position\n * const pos = cardinalPosition(`#blah`, `n`);\n * ```\n * @param domQueryOrEl \n * @param anchor \n * @returns \n */\nexport const cardinalPosition = (\n  domQueryOrEl: Readonly<string | HTMLElement>,\n  anchor: CardinalDirection | `center` = `nw`\n): Point => {\n  const el = resolveEl(domQueryOrEl);\n  return cardinal(el.getBoundingClientRect(), anchor);\n};\n/**\n * Returns relative position of element in target coordinate space, or viewport by default.\n * Relative means that { x:0.5, y: 0.5 } is the middle of the target space. Eg for viewport, that means its the middle of the browser window.\n * ```js\n * // These all yield { x, y }\n * elPositionRelative('#blah');\n * elPositionRelative(evt.target, 'screen');\n * ```\n * @param domQueryOrEl DOM query or element\n * @param target Target coordinate space, or viewport by default\n * @returns Point\n */\nexport const positionRelative = (\n  domQueryOrEl: Readonly<string | HTMLElement>,\n  target: PointSpaces = `viewport`\n): Point => {\n  const f = positionFn(domQueryOrEl, { relative: true, target });\n  return f();\n};\n\n/**\n * Returns a function that converts input viewport coordinate space\n * to an output coordinate space.\n *\n * ```js\n * // f() will convert from viewport to document coordinate space\n * const f = viewportToSpace('document');\n *\n * // {x:100,y:100} is viewport coordinate space\n * f(100,100); // Yields: { x, y } converted to document space\n * ```\n *\n * Or immediately invoke for one-off use:\n * ```js\n * viewportToSpace('document')(100,100); // Yields: { x, y }\n * ```\n * @param targetSpace\n * @returns\n */\nexport const viewportToSpace = (targetSpace: PointSpaces = `viewport`) => {\n  switch (targetSpace) {\n    case `screen`: {\n      return (a: Readonly<Point | Array<number> | number>, b?: number) => {\n        const pt = Points.getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x + window.screenX,\n          y: pt.y + window.screenY,\n        });\n      };\n    }\n    case `document`: {\n      return (a: Readonly<Point | Array<number> | number>, b?: number) => {\n        const pt = Points.getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x + window.scrollX,\n          y: pt.y + window.scrollY,\n        });\n      };\n    }\n    case `viewport`: {\n      return (a: Readonly<Point | Array<number> | number>, b?: number) => {\n        const pt = Points.getPointParameter(a, b);\n        return Object.freeze({\n          x: pt.x,\n          y: pt.y,\n        });\n      };\n    }\n    default: {\n      throw new Error(\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        `Unexpected target coordinate space: ${ targetSpace }. Expected: viewport, document or screen`\n      );\n    }\n  }\n};\n\n/**\n * Position element by relative coordinate. Relative to window dimensions by default\n * @param element DOM element to position, or query\n * @param relativePos Window-relative coordinate. 0.5/0.5 is middle of window.\n */\nexport const positionFromMiddle = (\n  domQueryOrEl: string | HTMLElement,\n  relativePos: Point,\n  relativeTo: `window` | `screen` = `window`\n) => {\n  if (!domQueryOrEl) throw new Error(`domQueryOrEl is null or undefined`);\n  const el = resolveEl<HTMLElement>(domQueryOrEl);\n\n  // Convert relative to absolute units\n  const absPosition = Points.multiply(\n    relativePos,\n    window.innerWidth,\n    window.innerHeight\n  );\n\n  const thingRect = el.getBoundingClientRect();\n  const offsetPos = Points.subtract(\n    absPosition,\n    thingRect.width / 2,\n    thingRect.height / 2\n  );\n\n  // Apply via CSS\n  el.style.transform = `translate(${ offsetPos.x }px, ${ offsetPos.y }px)`;\n};\n\n\n\n\n\n\n\n/**\n * Given an array of class class names, this will cycle between them each time\n * it is called.\n *\n * Eg, assume `list` is: [ `a`, `b`, `c` ]\n *\n * If `el` already has the class `a`, the first time it is called, class `a`\n * is removed, and `b` added. The next time `b` is swapped for `c`. Once again,\n * `c` will swap with `a` and so on.\n *\n * If `el` is undefined or null, function silently returns.\n * @param el Element\n * @param list List of class names\n * @returns\n */\nexport const cycleCssClass = (\n  el: Readonly<HTMLElement>,\n  list: ReadonlyArray<string>\n) => {\n  if (el === null || !el) return;\n  if (!Array.isArray(list)) {\n    throw new TypeError(`List should be an array of strings`);\n  }\n\n  for (let index = 0; index < list.length; index++) {\n    if (el.classList.contains(list[ index ])) {\n      el.classList.remove(list[ index ]);\n      if (index + 1 < list.length) {\n        el.classList.add(list[ index + 1 ]);\n      } else {\n        el.classList.add(list[ 0 ]);\n      }\n      return;\n    }\n  }\n  el.classList.add(list[ 0 ]);\n};\n\n\n\n/**\n * Source: https://zellwk.com/blog/translate-in-javascript\n * @param domQueryOrEl\n */\nexport const getTranslation = (\n  domQueryOrEl: Readonly<string | HTMLElement>\n): Point => {\n  // Source:\n  // https://raw.githubusercontent.com/zellwk/javascript/master/src/browser/dom/translate-values.js\n\n  const el = resolveEl<HTMLElement>(domQueryOrEl);\n  const style = window.getComputedStyle(el);\n  const matrix = style.transform;\n\n  // No transform property. Simply return 0 values.\n  if (matrix === `none` || typeof matrix === `undefined`) {\n    return {\n      x: 0,\n      y: 0,\n      z: 0,\n    };\n  }\n\n  // Can either be 2d or 3d transform\n  const matrixType = matrix.includes(`3d`) ? `3d` : `2d`;\n  // @ts-expect-error\n  const matrixValues = matrix.match(/matrix.*\\((.+)\\)/)[ 1 ].split(`, `);\n\n  // 2d Matrixes have 6 values\n  // Last 2 values are X and Y.\n  // 2d Matrixes does not have Z value.\n  if (matrixType === `2d`) {\n    return {\n      x: Number.parseFloat(matrixValues[ 4 ]),\n      y: Number.parseFloat(matrixValues[ 5 ]),\n      z: 0,\n    };\n  }\n\n  // 3d Matrixes have 16 values\n  // The 13th, 14th, and 15th values are X, Y, and Z\n  if (matrixType === `3d`) {\n    return {\n      x: Number.parseFloat(matrixValues[ 12 ]),\n      y: Number.parseFloat(matrixValues[ 13 ]),\n      z: Number.parseFloat(matrixValues[ 14 ]),\n    };\n  }\n\n  return { x: 0, y: 0, z: 0 };\n};\n\n\n/**\n * Creates an element after `sibling`\n * ```\n * const el = createAfter(siblingEl, `DIV`);\n * ```\n * @param sibling Element\n * @param tagName Element to create\n * @returns New element\n */\nexport const createAfter = (\n  sibling: Readonly<HTMLElement>,\n  tagName: string\n): HTMLElement => {\n  const el = document.createElement(tagName);\n  sibling.parentElement?.insertBefore(el, sibling.nextSibling);\n  return el;\n};\n\n/**\n * Creates an element inside of `parent`\n * ```\n * const newEl = createIn(parentEl, `DIV`);\n * ```\n * @param parent Parent element\n * @param tagName Tag to create\n * @returns New element\n */\nexport const createIn = (\n  parent: Readonly<HTMLElement>,\n  tagName: string\n): HTMLElement => {\n  const el = document.createElement(tagName);\n  parent.append(el);\n  return el;\n};\n\n/**\n * Remove all child nodes from `parent`\n * @param parent\n */\nexport const clear = (parent: Readonly<HTMLElement>) => {\n  let c = parent.lastElementChild;\n\n  while (c) {\n    c.remove();\n    c = parent.lastElementChild;\n  }\n};\n\n\n/**\n * Copies string representation of object to clipboard\n * @param obj\n * @returns Promise\n */\nexport const copyToClipboard = (object: object) => {\n  const p = new Promise((resolve, reject) => {\n    //const json = JSON.stringify(obj, null, 2);\n    const string_ = JSON5.stringify(object);\n    navigator.clipboard.writeText(JSON.stringify(string_)).then(\n      () => {\n        resolve(true);\n      },\n      (error) => {\n        console.warn(`Could not copy to clipboard`);\n        console.log(string_);\n        reject(new Error(error));\n      }\n    );\n  });\n  return p;\n};\n\n/**\n * Inserts `element` into `parent` sorted according to its HTML attribute `data-sort`.\n * \n * Assumes:\n * * Every child of `parent` and `element`, has a `data-sort` attribute. This is the basis for sorting.\n * * `parent` starts off empty or pre-sorted.\n * * Order of `parent`'s children is not changed (ie it always remains sorted)\n * @param parent \n * @param element \n */\nexport const insertSorted = (parent: HTMLElement, element: HTMLElement) => {\n  const elSort = element.getAttribute(`data-sort`) ?? ``;\n  let elAfter;\n  let elBefore;\n  for (const c of parent.children) {\n    const sort = c.getAttribute(`data-sort`) ?? ``;\n    if (elSort >= sort) elAfter = c;\n    if (elSort <= sort) elBefore = c;\n    if (elAfter !== undefined && elBefore !== undefined) break;\n  }\n  if (elAfter !== undefined) {\n    elAfter.insertAdjacentElement(`afterend`, element);\n  } else if (elBefore === undefined) {\n    parent.append(element);\n  } else {\n    elBefore.insertAdjacentElement(`beforebegin`, element);\n  }\n}\n\nexport type CreateUpdateElement<V> = (\n  item: V,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  el: HTMLElement | null\n) => HTMLElement;\n\nexport const reconcileChildren = <V>(\n  parentEl: HTMLElement,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  list: Map<string, V>,\n  createUpdate: CreateUpdateElement<V>\n) => {\n  if (parentEl === null) throw new Error(`parentEl is null`);\n  if (parentEl === undefined) throw new Error(`parentEl is undefined`);\n\n  const seen = new Set<string>();\n\n  for (const [ key, value ] of list) {\n    const id = `c-${ key }`;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const el = parentEl.querySelector(`#${ id }`);\n    const finalEl = createUpdate(value, el as HTMLElement);\n    if (el !== finalEl) {\n      finalEl.id = id;\n      parentEl.append(finalEl);\n    }\n    seen.add(id);\n  }\n\n  const prune: Array<HTMLElement> = [];\n  for (const child of parentEl.children) {\n    if (!seen.has(child.id)) {\n      prune.push(child as HTMLElement);\n    }\n  }\n\n  // for (let index = 0; index < parentEl.children.length; index++) {\n  //   const c = parentEl.children[ index ] as HTMLElement;\n  //   if (!seen.has(c.id)) {\n  //     prune.push(c);\n  //   }\n  // }\n\n  for (const p of prune) p.remove();\n};\n\n/**\n * Adds `cssClass` to element(s) if `value` is true.\n * ```js\n * setClass(`#someId`, true, `activated`);\n * ```\n * @param query \n * @param value \n * @param cssClass \n * @returns \n */\nexport const setCssClass = (selectors: QueryOrElements, value: boolean, cssClass: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n\n  for (const element of elements) {\n    if (value) element.classList.add(cssClass);\n    else element.classList.remove(cssClass);\n  }\n};\n\n/**\n * Toggles a CSS class on all elements that match selector\n * @param selectors \n * @param cssClass \n * @returns \n */\nexport const setCssToggle = (selectors: QueryOrElements, cssClass: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  for (const element of elements) {\n    element.classList.toggle(cssClass);\n  }\n}\n\nexport const setCssDisplay = (selectors: QueryOrElements, value: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  for (const element of elements) {\n    (element).style.display = value;\n  }\n};\n\n/**\n * Gets a HTML element by id, throwing an error if not found\n * @param id \n * @returns \n */\nexport const byId = <V extends HTMLElement>(id: string): HTMLElement => {\n  // eslint-disable-next-line unicorn/prefer-query-selector\n  const element = document.getElementById(id);\n  if (element === null) throw new Error(`HTML element with id '${ id }' not found`);\n  return element as V;\n}\n\n\n\nexport const setHtml = (selectors: QueryOrElements, value: string | number) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  if (typeof value === `number`) {\n    value = value.toString();\n  }\n  for (const element of elements) {\n    element.innerHTML = value;\n  }\n};\n\nexport const setText = (selectors: QueryOrElements, value: string | number) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  if (typeof value === `number`) {\n    value = value.toString();\n  }\n  for (const element of elements) {\n    element.textContent = value;\n  }\n};\n\nexport const elRequery = (selectors: string) => {\n  ({\n    text: (value: string | number) => { setText(selectors, value); },\n    html: (value: string | number) => { setHtml(selectors, value); },\n    cssDisplay: (value: string) => { setCssDisplay(selectors, value); },\n    cssClass: (value: boolean, cssClass: string) => { setCssClass(selectors, value, cssClass); },\n    cssToggle: (cssClass: string) => { setCssToggle(selectors, cssClass); },\n    el: () => resolveEl(selectors),\n    els: () => resolveEls(selectors)\n  });\n}\n\nexport const el = (selectors: QueryOrElements) => {\n  const elements = resolveEls(selectors);\n  return {\n    text: (value: string | number) => { setText(elements, value); },\n    html: (value: string | number) => { setHtml(elements, value); },\n    cssDisplay: (value: string) => { setCssDisplay(elements, value); },\n    cssClass: (value: boolean, cssClass: string) => { setCssClass(elements, value, cssClass); },\n    cssToggle: (cssClass: string) => { setCssToggle(elements, cssClass); },\n    el: () => elements[ 0 ],\n    els: () => elements\n  }\n}","import { round } from '../numbers/Round.js';\nimport { resolveEl as resolveElement } from './ResolveEl.js';\nimport JSON5 from 'json5';\n\nexport type FormattingOptions = {\n  readonly precision?: number\n  readonly roundNumbers?: number\n}\nexport type DataTableOpts = FormattingOptions & {\n  readonly formatter?: DataFormatter\n  readonly objectsAsTables?: boolean\n  readonly idPrefix?: string\n};\n\nexport type DataTable<V> = {\n  update(data: V): void;\n  remove(): boolean;\n};\n\nconst toHtmlSimple = (v: any, options: FormattingOptions): string => {\n  if (v === null) return `(null)`;\n  if (v === undefined) return `(undefined)`;\n  if (typeof v === `boolean`) return v ? `true` : `false`;\n  if (typeof v === `string`) return `\"${ v }\"`;\n  if (typeof v === `number`) {\n    let vAsNumber = v;\n    if (options.roundNumbers !== undefined) vAsNumber = round(options.roundNumbers, v)\n    if (options.precision !== undefined) return vAsNumber.toFixed(options.precision);\n    return vAsNumber.toString();\n  }\n  if (typeof v === `object`) return toTableSimple(v, options);\n  return JSON5.stringify(v);\n}\n\nconst toTableSimple = (v: object, options: FormattingOptions): string => {\n  let html = `<div style=\"display:grid; grid-template-columns: repeat(2, 1fr)\">`;\n  for (const entry of Object.entries(v)) {\n    const value = toHtmlSimple(entry[ 1 ], options);\n    html += `<div class=\"label\" style=\"display:table-cell\">${ entry[ 0 ] }</div>\n      <div class=\"data\" style=\"display:table-cell\">${ value }</div>`\n  }\n  html += `</div>`;\n  return html;\n}\n\n/**\n * Creates a table of data points for each object in the map\n * ```\n * const t = DataTable.fromList(parentEl, map);\n * t.update(newMap);\n * ```\n */\nexport const fromList = (\n  parentOrQuery: HTMLElement | string,\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: Map<string, object>\n): DataTable<Map<string, object>> => {\n  const parent = resolveElement(parentOrQuery);\n  let container: HTMLDivElement | undefined = document.createElement(\n    `DIV`\n  ) as HTMLDivElement;\n  parent.append(container);\n\n  const remove = () => {\n    if (!container) return false;\n    container.remove();\n    container = undefined;\n    return true;\n  };\n\n  const update = (data: ReadonlyMap<string, object>) => {\n    const seenTables = new Set();\n\n    for (const [ key, value ] of data) {\n      const tKey = `table-${ key }`;\n      seenTables.add(tKey);\n      let t: HTMLElement | null = parent.querySelector(`#${ tKey }`);\n      if (t === null) {\n        t = document.createElement(`table`);\n        if (!t) throw new Error(`Could not create table element`);\n        //eslint-disable-next-line functional/immutable-data\n        t.id = tKey;\n        parent.append(t);\n      }\n\n      updateElement(t as HTMLTableElement, value);\n    }\n\n    // Remove tables that aren't present in map\n    // eslint-disable-next-line unicorn/prefer-spread\n    const tables = Array.from(parent.querySelectorAll(`table`));\n    for (const t of tables) {\n      if (!seenTables.has(t.id)) {\n        t.remove();\n      }\n    }\n  };\n\n  if (data) update(data);\n  return { update, remove };\n  // return (d: ReadonlyMap<string, object>) => {\n  //   update(d);\n  // };\n};\n\n/**\n * Format data. Return _undefined_ to signal that\n * data was not handled.\n */\nexport type DataFormatter = (data: object, path: string) => string | undefined;\n\n/**\n * Updates the given table element so each entry in the map is a\n * row in the table.\n *\n * Rows are keyed by the map key. Rows with keys not found in the map are deleted.\n * @param t Table\n * @param data Map of data\n * @param opts Options\n * @returns\n */\nconst updateElement = (\n  //eslint-disable-next-line functional/prefer-immutable-types\n  t: HTMLTableElement,\n  data: object,\n  opts: DataTableOpts = {}\n) => {\n  const precision = opts.precision ?? 2;\n  const idPrefix = opts.idPrefix ?? ``;\n  const objectsAsTables = opts.objectsAsTables ?? false;\n\n  if (data === undefined) {\n    //eslint-disable-next-line functional/immutable-data\n    t.innerHTML = ``;\n    return;\n  }\n  const seenRows = new Set();\n\n  for (const [ key, value ] of Object.entries(data)) {\n    const domKey = `${ idPrefix }-row-${ key }`;\n    // Keep track of keys currently in object\n    seenRows.add(domKey);\n\n    // Is there already a row for this key?\n    let rowEl = t.querySelector(`tr[data-key='${ domKey }']`);\n    if (rowEl === null) {\n      // No row, add it\n      rowEl = document.createElement(`tr`);\n      t.append(rowEl);\n      rowEl.setAttribute(`data-key`, domKey);\n\n      const keyEl = document.createElement(`td`);\n      keyEl.textContent = key;\n      keyEl.classList.add(`label`);\n      rowEl.append(keyEl);\n    }\n\n    // Is there already a cell for the value?\n    let valEl = rowEl.querySelector(`td[data-key='${ domKey }-val']`);\n\n    if (valEl === null) {\n      // No, create the cell\n      valEl = document.createElement(`td`);\n      valEl.classList.add(`data`);\n      valEl.setAttribute(`data-key`, `${ domKey }-val`);\n      rowEl.append(valEl);\n    }\n\n    // Format the value as HTML\n    let valueHTML: string | undefined;\n    if (opts.formatter) {\n      valueHTML = opts.formatter(value, key);\n    }\n\n    // If there's no formatter, or not handled...\n    if (valueHTML === undefined) {\n      if (typeof value === `object`) {\n        valueHTML = objectsAsTables ? toTableSimple(value, opts) : JSON5.stringify(value);\n      } else if (typeof value === `number`) {\n        valueHTML = opts.roundNumbers ? Math.round(value).toString() : value.toFixed(precision);\n      } else if (typeof value === `boolean`) {\n        valueHTML = value ? `true` : `false`;\n      } else if (typeof value === `string`) {\n        valueHTML = `\"${ value }\"`;\n      } else {\n        valueHTML = JSON.stringify(value);\n      }\n    }\n\n    // Set the cell value\n    (valEl as HTMLElement).innerHTML = valueHTML;\n  }\n\n  // Remove rows that aren't present in data\n  // eslint-disable-next-line unicorn/prefer-spread\n  const rows = Array.from(t.querySelectorAll(`tr`));\n  for (const r of rows) {\n    const key = r.getAttribute(`data-key`);\n    if (!seenRows.has(key)) {\n      r.remove();\n    }\n  }\n};\n\n/**\n * Creates a HTML table where each row is a key-value pair from `data`.\n * First column is the key, second column data.\n *\n * ```js\n * const dt = fromObject(`#hostDiv`);\n * ```\n *\n * `dt` is a function to call when you want to update data:\n *\n * ```js\n * dt({\n *  name: `Blerg`,\n *  height: 120\n * });\n * ```\n */\nexport const fromObject = (\n  parentOrQuery: HTMLElement | string,\n  data?: object,\n  opts?: DataTableOpts\n): DataTable<object> => {\n  const parent = resolveElement(parentOrQuery);\n  const idPrefix = opts?.idPrefix ?? Math.floor(Math.random() * 1000).toString();\n\n  let t: HTMLTableElement | undefined = document.createElement(`table`);\n  parent.append(t);\n\n  const remove = () => {\n    if (!t) return false;\n    t.remove();\n    t = undefined;\n    return true;\n  };\n\n  // Update already if there's initial data\n  if (data) updateElement(t, data, opts);\n\n  const update = (d: object) => {\n    if (!t) throw new Error(`Table disposed`);\n    updateElement(t, d, { ...opts, idPrefix });\n  };\n\n  return { remove, update };\n};\n","import { fromObject } from \"./DataTable.js\";\n\nexport type DataDisplayOptions = {\n  theme?: `dark` | `light`\n}\n\n// TODO Visually show data which has changed since last update\n// TODO Click on a field to show a sparkline for it\n/**\n * Creates a simple display for data. Designed to show ixfx state data\n * \n * ```js\n * // Create once\n * const display = new DataDisplay();\n * \n * // Call .update to show state\n * display.update(state);\n * ```\n */\nexport class DataDisplay {\n\n  dataTable;\n\n  /**\n   * Constructor\n   * @param options Options\n   */\n  constructor(options: DataDisplayOptions = {}) {\n    const theme = options.theme ?? `dark`;\n\n    const existing = document.querySelector(`#ixfx-data-display`);\n    if (existing !== null) throw new Error(`DataDisplay already loaded on this page`);\n\n    const container = document.createElement(`div`);\n    container.id = `ixfx-data-display`;\n    container.classList.add(`theme-${ theme }`);\n\n    const css = document.createElement(`style`);\n    css.textContent = `\n    #ixfx-data-display {\n      background: white;\n      color: black;\n      border: 2px solid hsl(0deg 0.61% 90%);\n      border-radius: 4px;\n      z-index: 1000;\n      opacity: 40%;\n      padding: 1em;\n      font-family: monospace;\n      position: fixed;\n      right: 1em;\n      top: 1em;\n    }\n    #ixfx-data-display.theme-dark {\n      background: black;\n      color: white;\n      border: 2px solid hsl(0deg 0.61% 10%);\n    }\n    #ixfx-data-display:hover {\n      opacity: 100%;\n    }\n    #ixfx-data-display table {\n      border-collapse: collapse;\n    }\n    #ixfx-data-display tr:not(:last-child) {\n      border-bottom: 2px solid hsl(0deg 0.61% 90%);\n    }\n    #ixfx-data-display.dark tr:not(:last-child) {\n      border-bottom: 2px solid hsl(0deg 0.61% 10%);\n    }\n    #ixfx-data-display td {\n      padding-bottom: 0.4em;\n      padding-top: 0.4em;\n    }\n    #ixfx-data-display .label {\n      color: hsl(0deg 0.61% 60%);\n      text-align: right;\n      padding-right: 0.5em;\n    }\n    #ixfx-data-display.theme-dark .label {\n      color: gray;\n    }\n    `\n\n    container.style.display = `inline-block`;\n    document.body.append(css);\n    document.body.append(container);\n\n    this.dataTable = fromObject(container, undefined, {\n      objectsAsTables: true,\n      roundNumbers: 2\n    });\n  }\n\n  update(data: object) {\n    this.dataTable.update(data);\n  }\n}","import type { Point } from \"src/geometry/point/index.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\nimport { resizeObservable, windowResize } from \"./DomRx.js\";\n\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport type ElementResizeArgs<V extends HTMLElement | SVGSVGElement> = {\n  readonly el: V;\n  readonly bounds: {\n    readonly width: number;\n    readonly height: number;\n    readonly center: Point;\n    readonly min: number;\n    readonly max: number;\n  };\n};\n\n\nexport const fullSizeElement = <V extends HTMLElement>(\n  domQueryOrEl: string | V,\n  onResized?: (args: ElementResizeArgs<V>) => void\n) => {\n  const el = resolveEl<V>(domQueryOrEl);\n\n  const r = windowResize();\n  const update = () => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    el.setAttribute(`width`, width.toString());\n    el.setAttribute(`height`, height.toString());\n\n    if (onResized !== undefined) {\n      const bounds = {\n        min: Math.min(width, height),\n        max: Math.max(width, height),\n        width,\n        height,\n        center: {\n          x: width / 2,\n          y: height / 2,\n        },\n      };\n      onResized({ el, bounds });\n    }\n  };\n  r.value(update);\n\n  update();\n  return r;\n};\n\n/**\n * Sets width/height atributes on the given element according to the size of its parent.\n * @param domQueryOrEl Elememnt to resize\n * @param onResized Callback when resize happens\n * @param timeoutMs Timeout for debouncing events\n * @returns\n */\nexport const parentSize = <V extends HTMLElement | SVGSVGElement>(\n  domQueryOrEl: string | V,\n  onResized?: (args: ElementResizeArgs<V>) => void,\n  timeoutMs = 100\n) => {\n  const el = resolveEl<V>(domQueryOrEl);\n  const parent = el.parentElement;\n  if (parent === null) throw new Error(`Element has no parent`);\n\n  const ro = resizeObservable(parent, timeoutMs).value(\n    (entries: ReadonlyArray<ResizeObserverEntry>) => {\n      const entry = entries.find((v) => v.target === parent);\n      if (entry === undefined) return;\n\n      const width = entry.contentRect.width;\n      const height = entry.contentRect.height;\n\n      el.setAttribute(`width`, width + `px`);\n      el.setAttribute(`height`, height + `px`);\n      if (onResized !== undefined) {\n        const bounds = {\n          min: Math.min(width, height),\n          max: Math.max(width, height),\n          width,\n          height,\n          center: { x: width / 2, y: height / 2 },\n        };\n        onResized({ el, bounds });\n      }\n    }\n  );\n\n  return ro;\n};","import {\n  pointsTracker,\n} from '../data/PointTracker.js';\nimport { resolveEl as resolveElement } from './ResolveEl.js';\nimport * as Svg from '../visual/Svg.js';\nimport { fullSizeElement } from './ElementSizing.js';\n\nexport type Opts = {\n  readonly touchRadius?: number;\n  readonly mouseRadius?: number;\n  readonly trace?: boolean;\n  readonly hue?: number;\n};\n\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery\n * @param opts\n */\nexport const pointerVisualise = (\n  //eslint-disable-next-line functional/prefer-immutable-types\n  elOrQuery: HTMLElement | string,\n  opts: Opts = {}\n) => {\n  const touchRadius = opts.touchRadius ?? 45;\n  const mouseRadius = opts.touchRadius ?? 20;\n  const trace = opts.trace ?? false;\n  const hue = opts.hue ?? 100;\n\n  const startFillStyle = `hsla(${ hue }, 100%, 10%, 10%)`;\n\n  //eslint-disable-next-line functional/no-let\n  let currentHue = hue;\n\n  const el = resolveElement(elOrQuery);\n  const tracker = pointsTracker({\n    storeIntermediate: trace,\n  });\n\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const svg = document.createElementNS(\n    `http://www.w3.org/2000/svg`,\n    `svg`\n  ) as any as SVGElement & HTMLElement;\n  //eslint-disable-next-line functional/immutable-data\n  svg.id = `pointerVis`;\n  svg.style.zIndex = `-1000`;\n  svg.style.position = `fixed`;\n  svg.style.top = `0`;\n  svg.style.left = `0`;\n  svg.style.width = `100%`;\n  svg.style.height = `100%`;\n  svg.style.boxSizing = `border-box`;\n  svg.style.border = `3px solid red`;\n  svg.style.pointerEvents = `none`;\n  svg.style.touchAction = `none`;\n\n  fullSizeElement(svg);\n  let pointerCount = 0;\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const lostPointer = (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    tracker.delete(id);\n    currentHue = hue;\n    svg.querySelector(`#pv-start-${ id }`)?.remove();\n\n    for (let index = 0; index < pointerCount + 10; index++) {\n      svg.querySelector(`#pv-progress-${ id }-${ index }`)?.remove();\n    }\n    pointerCount = 0;\n  };\n\n  const trackPointer = async (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    const pt = { x: event.x, y: event.y };\n    const type = event.pointerType;\n    if (event.type === `pointermove` && !tracker.has(id)) {\n      return;\n    }\n    const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n\n    if (info.values.length === 1) {\n      const el = Svg.Elements.circle(\n        {\n          ...info.values[ 0 ],\n          radius: type === `touch` ? touchRadius : mouseRadius,\n        },\n        svg,\n        {\n          fillStyle: startFillStyle,\n        },\n        `#pv-start-${ id }`\n      );\n      el.style.pointerEvents = `none`;\n      el.style.touchAction = `none`;\n    }\n\n    const fillStyle = `hsla(${ currentHue }, 100%, 50%, 50%)`;\n\n    const el2 = Svg.Elements.circle(\n      { ...pt, radius: type === `touch` ? touchRadius : mouseRadius },\n      svg,\n      {\n        fillStyle,\n      },\n      `#pv-progress-${ id }-${ info.values.length }`\n    );\n    el2.style.pointerEvents = `none`;\n    el2.style.touchAction = `none`;\n    currentHue += 1;\n    pointerCount = info.values.length;\n  };\n\n  document.body.append(svg);\n\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  el.addEventListener(`pointerdown`, trackPointer);\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\n  el.addEventListener(`pointermove`, trackPointer);\n  el.addEventListener(`pointerup`, lostPointer);\n  el.addEventListener(`pointerleave`, lostPointer);\n  el.addEventListener(`contextmenu`, (event) => {\n    event.preventDefault();\n  });\n};\n","import { getErrorMessage } from \"../debug/GetErrorMessage.js\";\n\n/**\n * Creates an error handler to show errors on-screen.\n * This is useful when testing on mobile devices that lack access to the console.\n *\n * ```js\n * const e = defaultErrorHandler();\n * ```\n *\n * Manual control:\n * ```js\n * const e = defaultErrorHandler();\n * e.show(someError);\n * e.hide();\n * ```\n * @returns\n */\nexport const defaultErrorHandler = () => {\n  //eslint-disable-next-line functional/no-let\n  let enabled = true;\n  const container = document.createElement(`div`);\n  container.style.color = `black`;\n  container.style.border = `2px solid red`;\n  container.style.backgroundColor = `hsl(0, 80%, 90%)`;\n  container.style.padding = `1em`;\n  container.style.display = `none`;\n  container.style.top = `1em`;\n  container.style.left = `1em`;\n  container.style.position = `absolute`;\n\n  container.style.fontFamily = `monospace`;\n\n  const messageElement = document.createElement(`div`);\n  messageElement.style.maxWidth = `50vw`;\n  messageElement.style.maxHeight = `50vh`;\n  messageElement.style.overflowY = `scroll`;\n\n  container.innerHTML = `<h1>Error</h1>`;\n  container.append(messageElement);\n\n  const styleButton = (b: HTMLButtonElement) => {\n    b.style.padding = `0.3em`;\n    b.style.marginTop = `1em`;\n  };\n\n  const buttonClose = document.createElement(`button`);\n  buttonClose.textContent = `Close`;\n  buttonClose.addEventListener(`click`, () => {\n    hide();\n  });\n\n  const buttonStop = document.createElement(`button`);\n  buttonStop.textContent = `Stop displaying errors`;\n  buttonStop.addEventListener(`click`, () => {\n    enabled = false;\n    hide();\n  });\n\n  styleButton(buttonClose);\n  styleButton(buttonStop);\n\n  container.append(buttonClose);\n  container.append(buttonStop);\n  document.body.append(container);\n\n  const show = (ex: Error | string | Event) => {\n    container.style.display = `inline`;\n    messageElement.innerHTML += (ex as any).stack ? `<pre>${ (ex as any).stack }</pre>` : `<p>${ getErrorMessage(ex) }</p>`;\n  };\n\n  const hide = () => {\n    container.style.display = `none`;\n  };\n\n  // eslint-disable-next-line unicorn/prefer-add-event-listener\n  window.onerror = (message, url, lineNo, colNo, error) => {\n    if (enabled) {\n      if (error) {\n        console.log(error);\n        show(error);\n      } else {\n        console.log(message);\n        show(message);\n      }\n    }\n  };\n\n  window.addEventListener(`unhandledrejection`, (event) => {\n    console.log(event.reason);\n    if (enabled) {\n      show(event.reason);\n    }\n  });\n  return { show, hide };\n};\n","import { Points } from '../geometry/index.js';\n\nexport type DragState = {\n  readonly token?: object;\n  readonly initial: Points.Point;\n  readonly delta: Points.Point;\n};\n\nexport type DragStart = {\n  readonly allow: boolean;\n  readonly token: object;\n};\nexport type DragListener = {\n  readonly start?: () => DragStart;\n  readonly progress?: (state: DragState) => boolean;\n  readonly abort?: (reason: string, state: DragState) => void;\n  readonly success?: (state: DragState) => void;\n};\n\n//eslint-disable-next-line functional/prefer-immutable-types\nexport const draggable = (elem: SVGElement, listener: DragListener) => {\n  //eslint-disable-next-line functional/no-let\n  let initial = Points.Placeholder;\n  //eslint-disable-next-line functional/no-let\n  let token: object;\n\n  // De-select if there's a click elsewhere\n  const onParentClick = () => {\n    const selected = elem.classList.contains(`drag-sel`);\n    if (selected) {\n      elem.classList.remove(`drag-sel`);\n    }\n  };\n\n  // Click to select\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const onElementClick = (event: MouseEvent) => {\n    const selected = elem.classList.contains(`drag-sel`);\n    if (selected) {\n      elem.classList.remove(`drag-sel`);\n    } else {\n      elem.classList.add(`drag-sel`);\n    }\n    event.stopPropagation();\n  };\n\n  elem.ownerDocument.addEventListener(`click`, onParentClick);\n  elem.addEventListener(`click`, onElementClick);\n\n  // Remove event handlers\n  const dragCleanup = () => {\n    elem.classList.remove(`drag-progress`);\n\n    elem.ownerDocument.removeEventListener(`pointermove`, onPointerMove);\n    elem.ownerDocument.removeEventListener(`pointerup`, onPointerUp);\n    elem.ownerDocument.removeEventListener(`pointercancel`, onDragCancel);\n  };\n\n  const dispose = () => {\n    console.log(`drag dispose`);\n    if (elem.classList.contains(`drag-progress`)) {\n      onDragCancel(undefined, `dispose`);\n    } else {\n      dragCleanup();\n    }\n    elem.ownerDocument.removeEventListener(`click`, onParentClick);\n    elem.removeEventListener(`click`, onElementClick);\n  };\n\n  // Dragging\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const onPointerMove = (moveEvent: PointerEvent) => {\n    moveEvent.preventDefault();\n    moveEvent.stopPropagation();\n\n    const offset = Points.isPlaceholder(initial)\n      ? { x: moveEvent.offsetX, y: moveEvent.offsetY }\n      : {\n        x: moveEvent.x - initial.x,\n        y: moveEvent.y - initial.y,\n      };\n    const state: DragState = {\n      delta: offset,\n      initial: initial,\n      token,\n    };\n    if (typeof listener.progress !== `undefined` && !listener.progress(state)) {\n      onDragCancel(undefined, `discontinued`);\n    }\n  };\n\n  // Done dragging\n  //eslint-disable-next-line functional/prefer-immutable-types\n  const onPointerUp = (upEvent: PointerEvent) => {\n    dragCleanup();\n    const offset = {\n      x: upEvent.x - initial.x,\n      y: upEvent.y - initial.y,\n    };\n    const state: DragState = {\n      initial: initial,\n      token,\n      delta: offset,\n    };\n    if (typeof listener.success !== `undefined`) {\n      listener.success(state);\n    }\n  };\n\n  // Drag is cancelled\n  const onDragCancel = (\n    //eslint-disable-next-line functional/prefer-immutable-types\n    event: PointerEvent | MouseEvent | undefined,\n    reason = `pointercancel`\n  ) => {\n    dragCleanup();\n    const state: DragState = {\n      token,\n      initial: initial,\n      delta: { x: -1, y: -1 },\n    };\n    if (typeof listener.abort !== `undefined`) {\n      listener.abort(reason, state);\n    }\n  };\n\n  elem.addEventListener(`pointerdown`, (event) => {\n    const selected = elem.classList.contains(`drag-sel`);\n    if (!selected) return;\n\n    initial = { x: event.x, y: event.y };\n    const s =\n      typeof listener.start === `undefined`\n        ? { allow: true, token }\n        : listener.start();\n    if (!s.allow) return;\n\n    token = s.token;\n\n    elem.classList.add(`drag-progress`);\n    elem.ownerDocument.addEventListener(`pointermove`, onPointerMove);\n    elem.ownerDocument.addEventListener(`pointerup`, onPointerUp);\n    elem.ownerDocument.addEventListener(`pointercancel`, onDragCancel);\n  });\n\n  return dispose;\n};\n","import { getErrorMessage } from '../debug/GetErrorMessage.js';\nimport { afterMatch } from '../Text.js';\nimport { log, type LogOpts } from './Log.js';\n\nexport type InlineConsoleOptions = LogOpts;\n\n/**\n * Adds an inline console to the page. A DIV is added to display log messages.\n * \n * Captures all console.log, console.warn and console.error calls, as well as unhandled exceptions.\n * \n * ```js\n * // Adds the DIV and intercepts console logs\n * inlineConsole();\n * \n * console.log(`Hello`); // message is displayed in the inline console\n * ```\n * @param opts \n */\nexport const inlineConsole = (opts: InlineConsoleOptions = {}) => {\n  const original = {\n    log: console.log,\n    error: console.error,\n    warn: console.warn\n  };\n\n  const logElement = document.createElement(`DIV`);\n  logElement.id = `ixfx-log`;\n  logElement.style.position = `fixed`;\n  logElement.style.left = `0px`;\n  logElement.style.top = `0px`;\n  logElement.style.pointerEvents = `none`;\n  logElement.style.display = `none`;\n\n  document.body.prepend(logElement);\n\n  const logger = log(logElement, opts);\n\n  const visibility = (show: boolean) => {\n    logElement.style.display = show ? `block` : `none`;\n  }\n\n  console.error = (message?: any, ...optionalParameters: Array<any>) => {\n    logger.error(message);\n    if (optionalParameters.length > 0) {\n      logger.error(optionalParameters);\n    }\n    original.error(message, ...optionalParameters);\n    visibility(true);\n  }\n\n  console.warn = (message?: any, ...optionalParameters: Array<any>) => {\n    logger.warn(message);\n    if (optionalParameters.length > 0) {\n      logger.warn(optionalParameters);\n    }\n    visibility(true);\n  }\n\n  console.log = (message?: any, ...optionalParameters: Array<any>) => {\n    logger.log(message);\n    if (optionalParameters.length > 0) {\n      logger.log(optionalParameters);\n    }\n    original.log(message, ...optionalParameters);\n    visibility(true);\n  }\n\n  //eslint-disable-next-line unicorn/prefer-add-event-listener\n  window.onerror = (event, source, lineno, _colno, error) => {\n    const abbreviatedSource = source === undefined ? `` : afterMatch(source, `/`, { fromEnd: true });\n    //const eventString = typeof event === `string` ? event : JSON.stringify(event).toString();\n    const eventString = getErrorMessage(error);\n    //const errorString = error === undefined ? `` : error.message;\n\n    logger.error(eventString + ` (${ abbreviatedSource }:${ lineno })`);\n    visibility(true);\n  }\n}","import * as Text from \"../Text.js\"\nimport { resolveEl } from \"./ResolveEl.js\"\n\n/**\n * CSS Variable\n */\nexport type CssVariable = {\n  /**\n   * CSS variable to read for the value. `--` prefix is not needed\n   */\n  variable: string\n  /**\n   * Attribute name, eg 'width' for a Canvas element.\n   */\n  attribute?: string\n  field?: string\n  /**\n   * Optional default value\n   */\n  defaultValue: string | undefined\n}\n\n/**\n * CSS Variable by id\n */\nexport type CssVariableByIdOption = CssVariable & {\n  id: string\n}\n\n/**\n * CSS variable by query\n */\nexport type CssVariableByQueryOption = CssVariable & {\n  query: string\n}\n\n/**\n * CSS variable by element reference\n */\nexport type CssVariableByElementOption = CssVariable & {\n  element: (HTMLElement | SVGElement) | Array<Element>\n}\n\n/**\n * CSS variable option\n */\nexport type CssVariableOption = CssVariable & (CssVariableByElementOption | CssVariableByIdOption | CssVariableByQueryOption);\n\n/**\n * Parse data as attributes.\n * \n * This is a first step of going from a relatively human-friendly simple array format\n * into setting HTML attributes based on a CSS variable. The second step is to call `setFromVariables`\n * \n * ```js\n * // Array of arrays is treated as a set of key-value pairs\n * const options = [ [`indicator-fill`, `gray`], [`backdrop-fill`, `whitesmoke`] ]\n * const attrs = parseAsAttributes(options);\n * Yields:\n * [\n *  { variable: `indicator-fill`, attribute: `fill`, id: `indicator`, defaultValue: `gray` }\n *  { variable: `backdrop-fill`, attribute: `fill`, id: `backdrop`, defaultValue: `whitesmoke` }\n * ]\n * \n * // Assign\n * setFromCssVariables(document.body, attrs);\n * ```\n * @param options \n * @returns \n */\nexport const parseAsAttributes = (options: Array<string | Array<string>>): Array<CssVariable & CssVariableByIdOption> => {\n  return options.map(opt => {\n    let defaultValue;\n    // Nested array, treat second element as default value, name as first\n    if (Array.isArray(opt)) {\n      defaultValue = opt[ 1 ];\n      opt = opt[ 0 ];\n    }\n    const dash = opt.indexOf(`-`);\n    if (dash < 0) throw new Error(`Simple expression expects form of: 'elementid-attribute'`);\n    return {\n      variable: opt,\n      attribute: opt.slice(dash + 1),\n      id: opt.slice(0, dash),\n      defaultValue\n    }\n  })\n}\n\n/**\n * Reads the value of a CSS variable and assign it to HTML attributes or object field.\n * \n * ```js\n * const options = [\n *  // Set the 'width' attribute to the value of --some-css-variable to all elements with class 'blah'\n *  { query: `.blah`, variable: `some-css-variable`, attribute: `width` }\n *  // Set #blah's 'size' attribute to the value of css variable '--size'\n *  { id: 'blah', variable: 'size', attribute: 'size' }\n *  // Sets someEL.blah = css variable '--hue'\n *  { element: someEl, variable: `hue`, field: `blah` }\n * ]\n * \n * setFromVariables(document.body, ...options);\n * ```\n * \n * The first parameter is the context for which CSS variable values are fetched\n * as well as for resolving query selectors. This can usually be `document.body`.\n * @param context Context element which is needed for relative querying. Otherwise use document.body\n * @param options Details of what to do\n */\nexport const setFromVariables = (context: HTMLElement | string, ...options: Array<CssVariableOption>) => {\n  const contextEl = resolveEl(context);\n  const style = window.getComputedStyle(contextEl);\n\n  for (const opt of options) {\n    const variable = Text.afterMatch(opt.variable, `--`);\n    let v = style.getPropertyValue(`--${ variable }`);\n    if (v === null || v.length === 0) {\n      if (opt.defaultValue === undefined) { continue; }\n      else { v = opt.defaultValue; }\n    }\n\n    let query: string | undefined;\n    let els;//: SVGElement | HTMLElement | null | undefined;\n    if (`query` in opt && opt.query !== undefined) {\n      query = opt.query;\n    } else if (`id` in opt && opt.id !== undefined) {\n      query = `#${ opt.id }`;\n    } else if (`element` in opt && opt.element !== undefined) {\n      els = Array.isArray(opt.element) ? opt.element : [ opt.element ];\n    }\n    if (query === undefined) {\n      if (els === undefined) {\n        throw new Error(`Missing query, id or element`);\n      }\n    } else {\n      els = [ ...contextEl.querySelectorAll(query) ] as Array<Element>;// as SVGElement | HTMLElement | null | undefined;\n    }\n    if (els === null) continue;\n    if (els === undefined) continue;\n    if (opt.attribute) {\n      for (const el of els) {\n        (el as HTMLElement).setAttribute(opt.attribute, v);\n      }\n    } else if (opt.field) {\n      for (const el of els) {\n        (el as any)[ opt.field ] = v;\n      }\n    } else {\n      throw new Error(`Neither 'attribute' or 'field' to set is defined in option (${ JSON.stringify(opt) })`);\n    }\n  }\n}","import { resolveEl } from \"./ResolveEl.js\";\nimport { Rects, Scaler } from '../geometry/index.js';\nimport { type Rect } from '../geometry/rect/index.js';\nimport { multiply as RectsMultiply } from \"../geometry/rect/index.js\";\nimport { windowResize } from \"./DomRx.js\";\nimport type { ScaleBy } from \"../geometry/Scaler.js\";\nimport { SimpleEventEmitter } from \"../Events.js\";\n\n/**\n * Options\n */\nexport type CanvasOpts = {\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  readonly clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  readonly skipCss: boolean;\n  readonly scaleBy: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  readonly onResize?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Automatically set canvas to fill. Default: 'none'\n   * * 'viewport': size of screen\n   * * 'parent': size of parent element\n   * * 'none': no resizing. Use 'width' and 'height' options to set the logical size of the canvas\n   * \n   */\n  readonly fill: `viewport` | `parent` | `none`\n  /**\n   * Logical width of canvas.\n   * Ignored if `fill` is set to 'viewport' or 'parent'\n   */\n  readonly width: number\n  /**\n   * Logical height of canvas.\n   * Ignored if `fill` is set to 'viewport' or 'parent'\n   */\n  readonly height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  readonly zIndex: number\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx \n   * @param size \n   * @returns \n   */\n  readonly draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n};\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n}\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { fill: `viewport` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { fill: `viewport`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { fill: `viewport`, draw });\n * ```\n * @param domQueryOrEl Canvas element to wrap\n * @param opts Options\n * @returns \n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasOpts\n\n  #scaler: Scaler.ScalerCombined;\n  #currentSize: Rect = Rects.empty;\n  #ctx: CanvasRenderingContext2D | undefined;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasOpts> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n\n\n    this.opts = {\n      fill: opts.fill ?? `none`,\n      height: opts.height ?? -1,\n      width: opts.width ?? -1,\n      zIndex: opts.zIndex ?? -1,\n      scaleBy: opts.scaleBy ?? `both`,\n      onResize: opts.onResize,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false\n    }\n\n    this.#scaler = Scaler.scaler(`both`);\n\n    this.#init();\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  #setLogicalSize(logicalSize: Rect) {\n    Rects.guard(logicalSize, `logicalSize`);\n\n    const ratio = window.devicePixelRatio || 1;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = Scaler.scaler(this.opts.scaleBy, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = RectsMultiply(logicalSize, ratio, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSize.width.toString() + `px`;\n    this.el.style.height = logicalSize.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#currentSize = logicalSize;\n\n    // Notify listeners of resize\n    const r = this.opts.onResize;\n    if (r) {\n      setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#currentSize, helper: this });\n  }\n\n  /**\n   * Notified that parent has changed size\n   * @returns \n   */\n  #onParentResize() {\n    const parentEl = this.el.parentElement;\n    if (!parentEl) return;\n    const bounds = parentEl.getBoundingClientRect();\n    this.#setLogicalSize({ width: bounds.width, height: bounds.height });\n  }\n\n  /**\n   * Notified that window has changed size\n   */\n  #onWindowResize() {\n    this.#setLogicalSize({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  #init() {\n    switch (this.opts.fill) {\n      case `viewport`: {\n        if (!this.opts.skipCss) {\n          this.el.style.position = `absolute`;\n          this.el.style.left = `0px`;\n          this.el.style.top = `0px`;\n          this.el.style.zIndex = this.opts.zIndex.toString();\n        }\n        const r = windowResize();\n        r.value(() => { this.#onWindowResize() });\n\n        this.#onWindowResize();\n        break;\n      }\n      case `parent`: {\n        const parentEl = this.el.parentElement;\n        if (!parentEl) throw new Error(`Canvas element has no parent?!`);\n        if (!this.opts.skipCss) {\n          this.el.style.position = `relative`;\n          this.el.style.left = `0px`;\n          this.el.style.top = `0px`;\n        }\n        // const r = resizeObservable(parentEl);\n        // r.value(onParentResize);\n        const r = windowResize();\n        r.value(() => { this.#onParentResize() });\n        this.#onParentResize();\n        break;\n      }\n      case `none`: {\n        // Use current size\n        let { width, height } = this.el.getBoundingClientRect();\n        if (this.opts.width > 0) width = this.opts.width;\n        if (this.opts.height > 0) height = this.opts.height;\n        const desiredSize = { width, height };\n        this.#setLogicalSize(desiredSize);\n        break;\n      }\n      default: {\n        throw new Error(`Unknown 'fill' value. Expecting: 'none', 'viewport' or 'fill'`);\n      }\n    }\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#currentSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `this.ctx.clearRect( 0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (this.#ctx) {\n      this.#ctx.clearRect(0, 0, this.width, this.height);\n    }\n  }\n\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#currentSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#currentSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#currentSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n  /**\n   * Returns a {@link Scaler} that converts from relative to absolute\n   * coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n   * // Assuming a canvas of 800x600\n   * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n   * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n   * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n   * ```\n   */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Returns a {@link Scaler} that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n   * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y:600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0,   y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n}","import { trackUniqueInstances } from \"../data/TrackUnique.js\";\nexport type ElementQueryOptions = {\n  /**\n   * If true, elements are only returned once, even if that match several queries\n   */\n  ensureUnique: boolean\n}\n\n/**\n * Async iterator over DOM query strings\n * ```js\n * query(`div`); // all DIVs\n * query([`.class`, `.and-other-class`]); // All things with these two classes\n * ```\n * @param queryOrElement \n * @returns \n */\nexport async function* query(queryOrElement: string | HTMLElement | Array<string | HTMLElement> | AsyncGenerator<string | HTMLElement>, options: Partial<ElementQueryOptions> = {}): AsyncGenerator<HTMLElement> {\n\n  if (typeof queryOrElement === `string`) {\n    return query([ queryOrElement ], options);\n  } else if (typeof queryOrElement === `object` && `nodeName` in queryOrElement) {\n    return query([ queryOrElement ], options);\n  }\n\n  const ensureUnique = options ?? false;\n  const isUnique = ensureUnique ? trackUniqueInstances<HTMLElement>() : (_: HTMLElement) => true;\n\n  if (Array.isArray(queryOrElement)) {\n    for (const item of queryOrElement) {\n      if (typeof item === `string`) {\n        for (const element of document.querySelectorAll(item)) {\n          const elementProper = element as HTMLElement;\n          if (isUnique(elementProper)) {\n            yield elementProper;\n          }\n        }\n      } else {\n        if (isUnique(item)) {\n          yield item;\n        }\n      }\n    }\n  } else {\n    for await (const item of queryOrElement) {\n      if (typeof item === `string`) {\n        for (const element of document.querySelectorAll(item)) {\n          if (isUnique(element as HTMLElement)) {\n            yield element as HTMLElement;\n          }\n        }\n      } else {\n        if (isUnique(item)) {\n          yield item;\n        }\n      }\n    }\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { Immutable } from \"../../index.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveDiff, ReactiveInitial, ReactiveNonInitial, ReactiveDisposable } from \"../Types.js\";\nimport type { ObjectOptions } from \"./Types.js\";\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.on(value => {\n *  const changed = value.value;\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `on` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDisposable<V> & ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? Immutable.isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Array<Immutable.Change<any>>>();\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    if (value !== undefined) {\n      const diff = Immutable.compareData(value, v, { ...options, includeMissingFromA: true });\n      //console.log(`Rx.fromObject.set diff`, diff);\n      if (diff.length === 0) return;\n      diffEvent.set(diff);\n    }\n\n    value = v;\n    setEvent.set(v);\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (value === undefined) {\n      value = toMerge as V;\n    } else {\n      const diff = Immutable.compareData(toMerge, value);\n      // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n      // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n      if (diff.length === 0) return; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      diffEvent.set(diff);\n    }\n    setEvent.set(value);\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.fromObject.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Immutable.getField<any>(value, path);\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = Immutable.compareData(existing, valueForField, { ...options, includeMissingFromA: true });\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Immutable.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    diffEvent.set(diff);\n    setEvent.set(o);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    value: setEvent.value,\n    onDiff: diffEvent.on,\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","export * from './Array.js';\nexport * from './ArrayObject.js';\nexport * from './Boolean.js';\nexport * from './Event.js';\nexport * from './Function.js';\nexport * from './FunctionPinged.js';\nexport * from './Iterator.js';\nexport * from './Number.js';\nexport * from './Object.js';\nexport * from './ObjectProxy.js';\nexport * from './Observable.js';\n//export * from './Resolve.js';\nexport * from './Types.js';","\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveFinite, ReactiveInitial } from \"../Types.js\";\nimport type { ArrayOptions } from \"./Types.js\";\n\nexport const of = <V>(source: Array<V> | Iterable<V>, options: Partial<ArrayOptions> = {}) => {\n  if (Array.isArray(source)) {\n    return array(source, options);\n  } else {}\n}\n\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n * \n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n * @param array \n * @param options \n * @returns \n */\nexport const array = <V>(sourceArray: Array<V>, options: Partial<ArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const whenStopped = options.whenStopped ?? `continue`;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const array = [ ...sourceArray ];\n\n  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${ lazy }'. Use lazy:'very' instead.`);\n\n  const intervalMs = intervalToMs(options.interval, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);\n      c.start();\n    },\n    onStop() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${ whenStopped } index: ${ index }`);\n\n      c.cancel();\n      if (whenStopped === `reset`) index = 0;\n    },\n    // onFirstSubscribe() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n    //   // Start if in lazy mode and not running\n    //   if (lazy !== `never` && c.runState === `idle`) c.start();\n    // },\n    // onNoSubscribers() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n    //   if (lazy === `very`) {\n    //     c.cancel();\n    //     if (whenStopped === `reset`) {\n    //       index = 0;\n    //     }\n    //   }\n    // }\n  });\n\n  const c = continuously(() => {\n    if (signal?.aborted) {\n      s.dispose(`Signalled (${ signal.reason })`);\n      return false; // stop looping\n    }\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      s.dispose(`Source array complete`);\n      return false; // stop loop\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: s.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    value: s.value\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { compareArrays, type ChangeRecord } from \"../../Compare.js\";\nimport { isEqualValueDefault } from \"../../IsEqual.js\";\nimport * as Arrays from '../../collections/arrays/index.js';\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveInitial, ReactiveDisposable, ReactiveNonInitial, ReactiveArray } from \"../Types.js\";\nimport type { ArrayObjectOptions } from \"./Types.js\";\n\n/**\n * Wraps an array object\n * @param initialValue \n * @param options \n * @returns \n */\nexport function arrayObject<V>(initialValue: ReadonlyArray<V> = [], options: Partial<ArrayObjectOptions<V>> = {}): ReactiveDisposable<ReadonlyArray<V>> & ReactiveArray<V> & (ReactiveInitial<ReadonlyArray<V>> | ReactiveNonInitial<ReadonlyArray<V>>) {\n  const eq = options.eq ?? isEqualValueDefault;\n  const setEvent = initStream<Array<V>>();\n  //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n  const arrayEvent = initStream<Array<ChangeRecord<number>>>();\n  let value: ReadonlyArray<V> = initialValue;\n  let disposed = false;\n\n  const set = (replacement: Array<V> | ReadonlyArray<V>) => {\n    const diff = compareArrays<V>(value as Array<V>, replacement as Array<V>, eq);\n    //console.log(`Rx.fromArray.set diff`, diff);\n    //if (diff.length === 0) return;\n    //diffEvent.set(diff);\n    value = replacement;\n    setEvent.set([ ...replacement ]);\n  }\n\n  const setAt = (index: number, v: V) => {\n    (value as Array<V>)[ index ] = v;\n    setEvent.set([ ...value ]);\n  }\n\n  const push = (v: V) => {\n    value = [ ...value, v ];\n    setEvent.set([ ...value ]);\n    const cr: ChangeRecord<number> = [ `add`, value.length - 1, v ];\n    arrayEvent.set([ cr ]);\n  }\n\n  const deleteAt = (index: number) => {\n    const valueChanged = Arrays.remove(value, index);\n    if (valueChanged.length === value.length) return; // no change\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    //console.log(diff.summary);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  const deleteWhere = (filter: (value: V) => boolean) => {\n    const valueChanged = value.filter(v => !filter(v));\n    const count = value.length - valueChanged.length;\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n    return count;\n  }\n\n  const insertAt = (index: number, v: V) => {\n    const valueChanged = Arrays.insertAt(value, index, v);\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  // const update = (toMerge: Partial<V>) => {\n  //   // eslint-disable-next-line unicorn/prefer-ternary\n  //   if (value === undefined) {\n  //     value = toMerge as V;\n  //   } else {\n  //     const diff = Immutable.compareData(toMerge, value);\n  //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n  //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n  //     if (diff.length === 0) return; // No changes\n  //     value = {\n  //       ...value,\n  //       ...toMerge\n  //     }\n  //     diffEvent.set(diff);\n  //   }\n  //   setEvent.set(value);\n  // }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    //diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  const r = {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    last: () => value,\n    on: setEvent.on,\n    onArray: arrayEvent.on,\n    value: setEvent.value,\n    setAt,\n    push,\n    deleteAt,\n    deleteWhere,\n    insertAt,\n    /**\n     * Set the whole object\n     */\n    set\n  }\n  return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveDisposable, ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function boolean(initialValue: boolean): ReactiveDisposable<boolean> & ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport function boolean(): ReactiveDisposable<boolean> & ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\nexport function boolean(initialValue?: boolean): ReactiveDisposable<boolean> & ReactiveWritable<boolean> & (ReactiveNonInitial<boolean> | ReactiveInitial<boolean>) {\n  let value = initialValue;\n  const events = initStream<boolean>();\n\n  const set = (v: boolean) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    value: events.value,\n    set\n  }\n}","import type { Optional, Passed, ReactiveDisposable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\nimport { object } from \"./Object.js\";\nimport type { EventOptions } from \"./Types.js\";\n\nexport function event<V extends Record<string, any>>(target: EventTarget | null, name: string, options: EventOptions<V>): ReactiveInitial<V> & ReactiveDisposable<V>;\nexport function event<V extends Record<string, any>>(target: EventTarget | null, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.value(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * As a convienence, there is an in-built transform option, via `options.transform`. Event data\n * passes through this function before emitting. \n * ```js\n * // Emit relative pixel values rather than absolute\n * Rx.From.event(document,`pointermove`, { \n *  transform: (event) => ({ x: event.x/window.innerWidth, y:event.y/window.innerHeight })\n * })\n * ```\n * Providing the transform function also properly types the stream.\n * \n * To create an initial value for an event stream, provide `options.transform`, and have it\n * return the default value if there is undefined input.\n * \n * ```js\n * // Makes an initial value of {x:0.5,y:0.5},\n * // but later yields relative pixel values\n * Rx.From.event(document,`pointermove`, { \n *  transform: (event) => {\n *    if (!event) return { x: 0.5, y: 0.5 }\n *    return { x: event.x / window.innerWidth, y: event.y / window.innerHeight }\n *  }\n * })\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param target Event emitter\n * @param name Event name\n * @param options Options\n * @returns \n */\nexport function event<V extends Record<string, any>>(target: EventTarget | null, name: string, options: Partial<EventOptions<V>> = {}): (ReactiveInitial<V> | ReactiveNonInitial<V>) & ReactiveDisposable<V> {\n  // TODO could this have better typing to pick up on the proper eventargs?\n  if (target === null) throw new Error(`Param 'target' is null`);\n  const transform = options.transform;\n  const initialValue = transform ? transform() : undefined;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const rxObject = initialValue ? object<V>(initialValue, { deepEntries: true }) : object<V>(undefined, { deepEntries: true });\n  const lazy = options.lazy ?? false;\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(transform ? transform(args) : args);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Reactive.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Reactive.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<V>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    value: (handler: (v: V) => void) => {\n      if (lazy) add();\n      return rxObject.value(handler);\n    }\n  }\n}\n","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { initLazyStream, initStream } from \"../InitStream.js\";\nimport type { Reactive, Unsubscriber } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../Util.js\";\nimport type { PingedFunctionOptions, PingedFunctionFunction } from \"./Types.js\";\n\n\n/**\n * Creates a reactive with `callback` as a value source. This gets called whenever `source` emits a value.\n *\n * @param callback \n * @param source \n * @param options \n * @returns \n */\nexport function pinged<T, TSource>(source: Reactive<TSource>, callback: PingedFunctionFunction<T, TSource>, options: Partial<PingedFunctionOptions> = {}) {\n  const closeOnError = options.closeOnError ?? true;\n  const lazy = options.lazy ?? `initial`;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n\n  let upstreamOff: Unsubscriber | undefined;\n\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, (_) => {\n      done(`Signal received (${ options.signal?.reason })`);\n    })\n  }\n\n  const events = initStream<T>({\n    onFirstSubscribe() {\n      if (lazy !== `never` && upstreamOff === undefined) start();\n    },\n    onNoSubscribers() {\n      // Unsubscribe from source if we're very lazy\n      // Stay subscribed if we're only initially lazy or not lazy at all\n      if (lazy === `very` && upstreamOff !== undefined) {\n        upstreamOff();\n        upstreamOff = undefined;\n      }\n    },\n  })\n\n  const start = () => {\n    upstreamOff = source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Upstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal);\n      } else if (messageHasValue(message)) {\n        void trigger(message.value);\n      }\n    });\n  }\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    if (upstreamOff) upstreamOff();\n  }\n\n  const trigger = async (value: TSource) => {\n    try {\n      const v = await callback(value, internalAbortCallback);\n      events.set(v);\n      // Feedback from callback\n      if (internalAbort.signal.aborted) {\n        done(`callback function aborted (${ internalAbort.signal.reason })`);\n        return false\n      }\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n      }\n    }\n  }\n\n  if (lazy === `never`) start();\n  return events;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveDisposable, ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function number(initialValue: number): ReactiveDisposable<number> & ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveDisposable<number> & ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveDisposable<number> & ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    value: events.value,\n    set\n  }\n}\n","import { object } from \"./Object.js\";\nimport { symbol, type ReactiveDiff, type ReactiveInitial } from \"../Types.js\";\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target`, so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.value(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n * \n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * @param target \n * @returns \n */\nexport const objectProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n  const rx = object(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      const isArray = Array.isArray(target);\n      //console.log(`Rx.fromProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (isArray && p === `length`) return true;\n\n      if (typeof p === `string`) {\n        rx.updateField(p, newValue);\n      }\n\n      // If target is array and field looks like an array index...\n      if (isArray && typeof p === `string`) {\n        const pAsNumber = Number.parseInt(p);\n        if (!Number.isNaN(pAsNumber)) {\n          target[ pAsNumber ] = newValue;\n          return true;\n        }\n      }\n      (target as any)[ p ] = newValue;\n      return true;\n    }\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const objectProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = objectProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../Types.js\";\nimport { messageHasValue } from \"../Util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.value(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined) {\n  const ow = observableWritable(init);\n  return {\n    on: ow.on,\n    value: ow.value\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined) {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    value: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n"],"mappings":"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","names":["wrap","run","log","iterator","field","event","event","event","stream","event","init","distance","object","graph","vertices","line","distance","to","stringForEdge","isReactive","wrap","map","count","average","count","distance","smoothingFactor","event","subtract","adjacentVertices","connect","connectTo","createVertex","dumpGraph","getOrCreate","graph","toAdjacencyMatrix","updateGraphVertex","createVertex","updateGraphVertex","graph","getOrCreate","resolveVertex","connectTo","connect","toAdjacencyMatrix","dumpGraph","debugGraphToArray","adjacentVertices","object","value","clamp","immutable","scale","scaleClamped","immutable","clamp","scale","scaleClamped","r","draw","arc","ellipse","corners","rect","line","byId","clamp","event","getContext","stream","timeout","el","plot","v","event","paths","create","create","el","to","el","ctx","width","height","clamp","piPi","plot","event","canvasSize","el","line","log","timestamp","clear","el","multiply","subtract","object","JSON5","elements","import_json5","JSON5","remove","data","el","el","event","el2","event","event","event","query","el","query","elements","el","bind","field","init","create","changes","array","array","filter","count","insertAt","transform","remove","add","target","init","transform"]}