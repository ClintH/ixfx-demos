{"version":3,"sources":["../src/geometry/index.ts","../src/geometry/Waypoint.ts","../src/geometry/line/JoinPointsToLines.ts","../src/geometry/line/Guard.ts","../src/geometry/line/GetPointsParameter.ts","../src/geometry/line/Length.ts","../src/geometry/line/Interpolate.ts","../src/geometry/line/Angles.ts","../src/geometry/line/Midpoint.ts","../src/geometry/line/index.ts","../src/geometry/rect/Guard.ts","../src/geometry/point/NormaliseByRect.ts","../src/geometry/point/GetPointParameter.ts","../src/geometry/point/Distance.ts","../src/geometry/line/Nearest.ts","../src/geometry/line/DistanceSingleLine.ts","../src/geometry/point/FindMinimum.ts","../src/geometry/rect/Max.ts","../src/geometry/point/Bbox.ts","../src/geometry/line/Bbox.ts","../src/geometry/point/Divider.ts","../src/geometry/line/Divide.ts","../src/geometry/line/FromFlatArray.ts","../src/geometry/Polar.ts","../src/geometry/Angles.ts","../src/geometry/point/Subtract.ts","../src/geometry/point/Empty.ts","../src/geometry/line/FromPivot.ts","../src/geometry/line/FromPointsToPath.ts","../src/geometry/point/IsEqual.ts","../src/geometry/line/IsEqual.ts","../src/geometry/point/index.ts","../src/geometry/point/Abs.ts","../src/geometry/point/Angle.ts","../src/geometry/point/Apply.ts","../src/geometry/point/Centroid.ts","../src/geometry/point/Clamp.ts","../src/geometry/point/Compare.ts","../src/geometry/point/ConvexHull.ts","../src/geometry/circle/Guard.ts","../src/geometry/circle/DistanceCenter.ts","../src/geometry/circle/DistanceFromExterior.ts","../src/geometry/circle/IsEqual.ts","../src/geometry/point/Sum.ts","../src/geometry/circle/Intersections.ts","../src/geometry/Intersects.ts","../src/geometry/rect/Intersects.ts","../src/geometry/rect/Center.ts","../src/geometry/point/PointType.ts","../src/geometry/rect/Distance.ts","../src/geometry/point/DistanceToCenter.ts","../src/geometry/point/DistanceToExterior.ts","../src/geometry/point/ToArray.ts","../src/geometry/point/DotProduct.ts","../src/geometry/point/From.ts","../src/geometry/point/Interpolate.ts","../src/geometry/point/Invert.ts","../src/geometry/point/Multiply.ts","../src/geometry/point/Magnitude.ts","../src/geometry/point/Most.ts","../src/geometry/point/Normalise.ts","../src/geometry/point/Pipeline.ts","../src/geometry/point/ProgressBetween.ts","../src/geometry/point/Project.ts","../src/geometry/point/Quantise.ts","../src/geometry/point/Random.ts","../src/geometry/point/Reduce.ts","../src/geometry/point/Relation.ts","../src/geometry/point/Rotate.ts","../src/geometry/point/RotatePointArray.ts","../src/geometry/point/Round.ts","../src/geometry/point/To.ts","../src/geometry/point/WithinRange.ts","../src/geometry/point/Wrap.ts","../src/geometry/line/Multiply.ts","../src/geometry/line/RelativePosition.ts","../src/geometry/line/Rotate.ts","../src/geometry/line/Subtract.ts","../src/geometry/line/Sum.ts","../src/geometry/line/ToString.ts","../src/geometry/line/ToPath.ts","../src/geometry/Layout.ts","../src/geometry/CirclePacking.ts","../src/geometry/shape/index.ts","../src/geometry/rect/Corners.ts","../src/geometry/rect/FromTopLeft.ts","../src/geometry/circle/IsContainedBy.ts","../src/geometry/circle/Intersecting.ts","../src/geometry/circle/Random.ts","../src/geometry/circle/Center.ts","../src/geometry/rect/Random.ts","../src/geometry/circle/index.ts","../src/geometry/circle/Area.ts","../src/geometry/rect/FromCenter.ts","../src/geometry/circle/Bbox.ts","../src/geometry/circle/ExteriorPoints.ts","../src/geometry/circle/InteriorPoints.ts","../src/geometry/circle/Perimeter.ts","../src/geometry/circle/Interpolate.ts","../src/geometry/circle/Multiply.ts","../src/geometry/circle/Svg.ts","../src/geometry/circle/ToPath.ts","../src/geometry/circle/ToPositioned.ts","../src/geometry/rect/index.ts","../src/geometry/rect/Area.ts","../src/geometry/rect/Cardinal.ts","../src/geometry/rect/Edges.ts","../src/geometry/rect/Empty.ts","../src/geometry/rect/FromElement.ts","../src/geometry/rect/FromNumbers.ts","../src/geometry/rect/GetRectPositionedParameter.ts","../src/geometry/rect/IsEqual.ts","../src/geometry/rect/Lengths.ts","../src/geometry/rect/Multiply.ts","../src/geometry/rect/NormaliseByRect.ts","../src/geometry/rect/Subtract.ts","../src/geometry/rect/Sum.ts","../src/geometry/rect/ToArray.ts","../src/geometry/path/index.ts","../src/geometry/bezier/Guard.ts","../src/geometry/Grid.ts","../src/geometry/bezier/index.ts","../node_modules/bezier-js/src/utils.js","../node_modules/bezier-js/src/poly-bezier.js","../node_modules/bezier-js/src/bezier.js","../src/geometry/path/CompoundPath.ts","../src/geometry/Ellipse.ts","../src/geometry/CurveSimplification.ts","../src/geometry/QuadTree.ts","../src/geometry/Scaler.ts","../src/geometry/rect/Placeholder.ts","../src/geometry/Convolve2d.ts","../src/visual/ImageDataGrid.ts","../src/geometry/arc/index.ts","../src/geometry/Vector.ts","../src/geometry/SurfacePoints.ts","../src/geometry/triangle/index.ts","../src/geometry/triangle/Guard.ts","../src/geometry/triangle/Edges.ts","../src/geometry/triangle/Area.ts","../src/geometry/triangle/Centroid.ts","../src/geometry/triangle/Perimeter.ts","../src/geometry/triangle/InnerCircle.ts","../src/geometry/triangle/OuterCircle.ts","../src/geometry/triangle/Rotate.ts","../src/geometry/triangle/Equilateral.ts","../src/geometry/triangle/Right.ts","../src/geometry/triangle/Isosceles.ts"],"sourcesContent":["export * as Waypoints from './Waypoint.js';\nexport * as Layouts from './Layout.js';\nexport * as Circles from './circle/index.js';\nexport * as Lines from './line/index.js';\nexport * as Rects from './rect/index.js';\nexport * as Points from './point/index.js';\nexport * as Paths from './path/index.js';\nexport * as Grids from './Grid.js';\nexport * as Beziers from './bezier/index.js';\nexport * as Compound from './path/CompoundPath.js';\nexport * as Ellipses from './Ellipse.js';\nexport type * from './Types.js';\n\nexport * from './Angles.js';\nexport * as CurveSimplification from './CurveSimplification.js';\n\n/**\n * Quad tree is a datastructure for efficiently determining whether\n * a point/shape is at a location\n * - {@link quadTree}: Create a quad tree\n */\nexport * as QuadTree from './QuadTree.js';\n\nexport * as Scaler from './Scaler.js';\nexport * as Convolve2d from './Convolve2d.js';\n\n/**\n * Work with arcs. Arcs are a angle-limited circle, describing a wedge.\n * \n * {@link ArcPositioned} has a origin x,y.\n * \n * Conversions:\n * - {@link fromDegrees}\n * - {@link toLine}: A line from start/end position of arc\n * - {@link toSvg}: Returns an SVG representation of arc\n * \n * Calculations:\n * - {@link bbox}: Bounding box\n * - {@link interpolate}: Interplate two arcs\n * - {@link point}: Find a point on the arc, given an angle\n * - {@link length}: Circumference of arc\n * \n * Comparisons:\n * - {@link isArc}: Returns true if object is Arc-ish\n * - {@link isEqual}: Returns true if two objects have identical arc properties\n */\nexport * as Arcs from './arc/index.js';\n\n/**\n * Generate a few basic geometric shapes\n * Overview:\n * * {@link arrow}\n * * {@link starburst}\n */\nexport * as Shapes from './shape/index.js';\n\n/**\n * Helper functions for working with vectors, which can either be a {@link Point} or Polar {@link Polar.Coord}.\n * While most of the functionality is provided in either of those modules, the Vector module lets you cleanly\n * interoperate between these two coordinates.\n */\nexport * as Vectors from './Vector.js';\n\n\n/**\n * Work with Polar coordinates.\n * A {@link Polar.Coord} is just `{ angleRadians:number, distance: number }`.\n * \n * Conversion: {@link toCartesian}, {@link fromCartesian}, {@link toString}\n * \n * Math: {@link divide}, {@link invert}, {@link multiply}, {@link dotProduct}\n * \n * Geometric manipulations: {@link rotate}, {@link rotateDegrees}\n * \n * Cleaning: {@link clampMagnitude}, {@link normalise}\n * \n * Debugging: {@link toString}\n * \n * Comparisons: {@link isAntiParallel}, {@link isOpposite}, {@link isParallel}, {@link isPolarCoord}\n */\nexport * as Polar from './Polar.js';\n\n/**\n * Functions for producing points within a shape.\n * Useful for creating patterns.\n * \n * Overview:\n * * {@link sphereFibonacci}: Generate points on a sphere\n * * {@link circleVogelSpiral}: Generate a sunflower-esque pattern of points in a circle \n */\nexport * as SurfacePoints from './SurfacePoints.js';\n\n/**\n * Triangle processing.\n * \n * Helpers for creating:\n * - {@link Triangles.fromFlatArray}: Create from `[ x1, y1, x2, y2, x3, y3 ]`\n * - {@link Triangles.fromPoints}: Create from three `{ x, y }` sets\n * - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n * \n * There are sub-modules for dealing with particular triangles:\n * - {@link Triangles.Equilateral}: Equilateral triangls\n * - {@link Triangles.Right}: Right-angled triangles\n * - {@link Triangles.Isosceles}: Iscosceles triangles\n * \n * Calculations\n * - {@link angles}: Internal angles in radians. {@link anglesDegrees} for degrees. \n * - {@link area}: Area of triangle\n * - {@link bbox}: Bounding box\n * - {@link centroid}: Centroid of triangle\n * - {@link perimeter}: Calculate perimeter\n * - {@link lengths}: Return array lengths of triangle's edges\n * - {@link rotate}, {@link rotateByVertex}\n * \n * Conversions\n * - {@link edges}: Edges of triangle as {@link Line}\n * - {@link corners}: Corner positions\n * - {@link innerCircle}: Largest circle to fit within triangle\n * - {@link outerCircle}: Largest circle to enclose triangle\n * - {@link toFlatArray}\n * \n * Comparisons\n * - {@link intersectsPoint}: Whether a point intersects triangle\n * - {@link isEqual}: Check whether two triangles have equal values\n * - {@link isAcute}, {@link isEquilateral}, {@link isIsosceles}, {@link isRightAngle}\n * - {@link isTriangle}: Returns true if object has expected properties of a triangle\n */\nexport * as Triangles from './triangle/index.js';\n\n// try {\n//   if (typeof window !== `undefined`) {\n//     //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n//     (window as any).ixfx = { ...(window as any).ixfx, Geometry: { Circles, Arcs, Lines, Rects, Points, Paths, Grids, Beziers, Compound, Ellipses, Polar, Shapes, radiansFromAxisX, radianToDegree, degreeToRadian } };\n//   }\n// } catch { /* no-op */ }\n","import type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { Path } from \"./path/PathType.js\";\nimport type { Point } from \"./point/PointType.js\";\nimport { joinPointsToLines } from './line/JoinPointsToLines.js';\nimport { toPath } from './line/ToPath.js';\nimport { distance as PointsDistance } from \"./point/Distance.js\";\nimport { sortByNumericProperty } from \"../data/arrays/Sort.js\";\n\nexport type Waypoint = CirclePositioned;\n\nexport type WaypointOpts = {\n  readonly maxDistanceFromLine: number;\n  readonly enforceOrder: boolean;\n};\n\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints \n * @param opts \n * @returns \n */\nexport const fromPoints = (\n  waypoints: ReadonlyArray<Point>,\n  opts: Partial<WaypointOpts> = {}\n) => {\n  const lines = joinPointsToLines(...waypoints);\n  return init(\n    lines.map((l) => toPath(l)),\n    opts\n  );\n};\n\n/**\n * Result \n */\nexport type WaypointResult = {\n  /**\n   * Path being compared against\n   */\n  path: Path\n  /**\n   * Index of this path in original `paths` array\n   */\n  index: number\n  /**\n   * Nearest point on path. See also {@link distance}\n   */\n  nearest: Point\n  /**\n   * Closest distance to path. See also {@link nearest}\n   */\n  distance: number\n  /**\n   * Rank of this result, 0 being highest.\n   */\n  rank: number\n  /**\n   * Relative position on this path segment\n   * 0 being start, 0.5 middle and so on.\n   */\n  positionRelative: number\n}\n\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => Array<WaypointResult>\n\n/**\n * Initialise\n * \n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths \n * @param opts \n * @returns \n */\nexport const init = (paths: ReadonlyArray<Path>, opts: Partial<WaypointOpts> = {}): Waypoints => {\n  //const enforceOrder = opts.enforceOrder ?? true;\n  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n\n  const checkUnordered = (pt: Point): Array<WaypointResult> => {\n    const results = paths.map((p, index) => {\n      const nearest = p.nearest(pt);\n      const distance = PointsDistance(pt, nearest);\n\n      // Relative position of nearest point on this path segment\n      const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);;\n      return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n    });\n\n    const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n    const sorted = sortByNumericProperty(filtered, `distance`);\n\n    // Assign ranks\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let rank = 0; rank < sorted.length; rank++) {\n      sorted[ rank ].rank = rank;\n    }\n    return sorted;\n  };\n\n  // const checkUnordered = (p:Point) => {\n  //   // Calculate progress of pointer between all the waypoint lines\n  //   const progresses = lines.map((line, index) => (\n  //     {\n  //       index,\n  //       score: Points.progressBetween(p, line.a, line.b)\n  //     }));\n  //   // Sort by closest\n  //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n  // };\n  return checkUnordered;\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { fromPoints } from \"./FromPoints.js\";\nimport type { PolyLine } from \"./LineType.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { isPoint } from \"../point/Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/PointType.js\";\nimport { isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard as guardPoint } from '../point/Guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/PointType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { isPolyLine } from \"./Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { throwNumberTest, throwPercentTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { length } from \"./Length.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n  // eslint-disable-next-line unicorn/no-negated-condition\n  if (!allowOverflow) throwPercentTest(amount, `amount`);\n  else throwNumberTest(amount, ``, `amount`);\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n","import { interpolate } from \"./Interpolate.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport type { Point } from \"../point/PointType.js\";\n\nconst directionVector = (line: Line): Point => ({\n  x: line.b.x - line.a.x,\n  y: line.b.y - line.a.y\n});\n\n\n\nconst directionVectorNormalised = (line: Line): Point => {\n  const l = length(line);\n  const v = directionVector(line);\n  return {\n    x: v.x / l,\n    y: v.y / l\n  };\n};\n\n/**\n * Returns a parallel line to `line` at `distance`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance \n */\nexport const parallel = (line: Line, distance: number): Line => {\n  const dv = directionVector(line);\n  const dvn = directionVectorNormalised(line);\n  const a = {\n    x: line.a.x - dvn.y * distance,\n    y: line.a.y + dvn.x * distance\n  };\n  return {\n    a,\n    b: {\n      x: a.x + dv.x,\n      y: a.y + dv.y\n    }\n  };\n};\n\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line: Line, distance: number, amount = 0) => {\n  const origin = interpolate(amount, line);\n  const dvn = directionVectorNormalised(line);\n  return {\n    x: origin.x - dvn.y * distance,\n    y: origin.y + dvn.x * distance\n  };\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\n\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine \n * @param pointB \n * @returns \n */\nexport const midpoint = (aOrLine: Point | Line, pointB?: Point): Point => {\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  return interpolate(0.5, a, b);\n};","import type { Point } from '../point/PointType.js';\nimport type { Line } from './LineType.js';\n//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/NormaliseByRect.js';\nimport { minFast } from '../../numbers/NumericArrays.js';\nimport { distanceSingleLine } from './DistanceSingleLine.js';\nimport { isLine } from './Guard.js';\nimport { length } from './Length.js';\nimport { interpolate } from './Interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/Guard.js';\nexport * from './Angles.js';\nexport * from './Bbox.js';\nexport * from './DistanceSingleLine.js';\nexport * from './Divide.js';\nexport * from './FromFlatArray.js';\nexport * from './FromNumbers.js';\nexport * from './FromPoints.js';\nexport * from './FromPivot.js';\nexport * from './FromPointsToPath.js';\nexport * from './GetPointsParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './IsEqual.js';\nexport * from './JoinPointsToLines.js';\nexport * from './Length.js';\nexport type * from './LinePathType.js';\nexport type * from './LineType.js';\nexport * from './Midpoint.js';\nexport * from './Multiply.js';\nexport * from './Nearest.js';\nexport * from './RelativePosition.js';\nexport * from './Rotate.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './ToPath.js';\nexport * from './ToString.js';\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Empty = Object.freeze({\n  a: Object.freeze({ x: 0, y: 0 }),\n  b: Object.freeze({ x: 0, y: 0 })\n});\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({\n  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n  b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l \n * @returns \n */\nexport const isEmpty = (l: Line): boolean => PointIsEmpty(l.a) && PointIsEmpty(l.b);\n\nexport const isPlaceholder = (l: Line): boolean => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n\n\n\n\n/**\n * Applies `fn` to both start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n * \n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n * \n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns \n */\nexport const apply = (line: Line, fn: (p: Point) => Point) => Object.freeze<Line>(\n  {\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n  }\n);\n\n\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint \n * @param b \n * @returns \n */\nexport const angleRadian = (lineOrPoint: Line | Point, b?: Point): number => {\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b point must be provided`);\n  }\n  return Math.atan2(b.y - a.y, b.x - a.x);\n};\n\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line \n * @param width\n * @param height \n * @returns \n */\nexport const normaliseByRect = (line: Line, width: number, height: number): Line => Object.freeze({\n  ...line,\n  a: PointsNormaliseByRect(line.a, width, height),\n  b: PointsNormaliseByRect(line.b, width, height)\n});\n\n\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange \n * @returns True if point is within range\n */\nexport const withinRange = (line: Line, point: Point, maxRange: number): boolean => {\n  const calculatedDistance = distance(line, point);\n  return calculatedDistance <= maxRange;\n};\n\n\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n * \n * @example\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns \n */\nexport const slope = (lineOrPoint: Line | Point, b?: Point): number => {\n\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b parameter required`);\n  }\n  if (b === undefined) {\n    throw new TypeError(`Second point missing`)\n  } else {\n    return (b.y - a.y) / (b.x - a.x);\n  }\n};\n\n\n/**\n * Scales a line from its midpoint\n * \n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor \n */\nexport const scaleFromMidpoint = (line: Line, factor: number): Line => {\n  const a = interpolate(factor / 2, line);\n  const b = interpolate(0.5 + factor / 2, line);\n  return { a, b };\n};\n\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line: Line, x: number): Point => {\n  const y = line.a.y + (x - line.a.x) * slope(line);\n  return Object.freeze({ x: x, y });\n};\n\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line: Line, distance: number): Line => {\n  const calculatedLength = length(line);\n  return Object.freeze({\n    ...line,\n    a: line.a,\n    b: Object.freeze({\n      x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n      y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n    })\n  });\n};\n\n/**\n * Yields every integer point along `line`. \n * \n * @example Basic usage\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n * \n * Some precision is lost as start and end\n * point is also returned as an integer.\n * \n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\n//eslint-disable-next-line func-style\nexport function* pointsOf(line: Line): Generator<Point> {\n  // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n  const { a, b } = line;\n  let x0 = Math.floor(a.x);\n  let y0 = Math.floor(a.y);\n  const x1 = Math.floor(b.x);\n  const y1 = Math.floor(b.y);\n  const dx = Math.abs(x1 - x0);\n  const dy = -Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1;\n  const sy = y0 < y1 ? 1 : -1;\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  let err = dx + dy;\n\n  while (true) {\n    yield { x: x0, y: y0 };\n    if (x0 === x1 && y0 === y1) break;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const e2 = 2 * err;\n    if (e2 >= dy) {\n      err += dy;\n      x0 += sx;\n    }\n    if (e2 <= dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n}\n\n/**\n * Returns the distance of `point` to the \n * nearest point on `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line: Line | ReadonlyArray<Line>, point: Point): number => {\n  if (Array.isArray(line)) {\n    const distances = line.map(l => distanceSingleLine(l, point));\n    return minFast(distances);\n  } else {\n    return distanceSingleLine(line as Line, point);\n  }\n};\n\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n * \n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @export\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a: Point | Line, b: Point): ReadonlyArray<number> => {\n  if (isLine(a)) {\n    return [ a.a.x, a.a.y, a.b.x, a.b.y ];\n  } else if (isPoint(a) && isPoint(b)) {\n    return [ a.x, a.y, b.x, b.y ];\n  } else {\n    throw new Error(`Expected single line parameter, or a and b points`);\n  }\n};\n\n/**\n * Yields all the points of all the lines.\n * \n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines \n */\n//eslint-disable-next-line func-style\nexport function* asPoints(lines: Iterable<Line>) {\n  for (const l of lines) {\n    yield l.a;\n    yield l.b;\n  }\n}\n\n/**\n * Returns an SVG description of line\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const toSvgString = (a: Point, b: Point): ReadonlyArray<string> => [ `M${ a.x } ${ a.y } L ${ b.x } ${ b.y }` ];\n","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\n\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({x:1,y:2,width:10,height:20});\n * // Returns {x:1,y:2,width:10,height:20}\n * getRectPositioned({width:10,height:20}, {x:1, y:2 }); \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `p` has a position (x,y)\n * @param p Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  p: Point | Rect | RectPositioned\n): p is Point =>\n  (p as Point).x !== undefined && (p as Point).y !== undefined;\n\n/**\n * Returns _true_ if `p` has width and height.\n * @param p\n * @returns\n */\nexport const isRect = (p: unknown): p is Rect => {\n  if (p === undefined) return false;\n  if ((p as Rect).width === undefined) return false;\n  if ((p as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `p` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param p\n * @returns\n */\nexport const isRectPositioned = (\n  p: any\n): p is RectPositioned => isRect(p) && isPositioned(p);\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Rect } from \"../rect/RectTypes.js\";\nimport { isRect } from \"../rect/Guard.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Normalises a point by a given width and height\n * @param pt Point\n * @param width Width\n * @param height Height\n */\nexport function normaliseByRect(\n  pt: Point,\n  width: number,\n  height: number\n): Point;\n\nexport function normaliseByRect(pt: Point, rect: Rect): Point;\n\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function normaliseByRect(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point so it is on a 0..1 scale\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(\n  a: Point | number,\n  b: number | Rect,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n  if (isPoint(a)) {\n    if (typeof b === `number` && c !== undefined) {\n      throwNumberTest(b, `positive`, `width`);\n      throwNumberTest(c, `positive`, `height`);\n    } else {\n      if (!isRect(b)) {\n        throw new Error(`Expected second parameter to be a rect`);\n      }\n      c = b.height;\n      b = b.width;\n    }\n    return Object.freeze({\n      x: a.x / b,\n      y: a.y / c,\n    });\n  } else {\n    throwNumberTest(a, `positive`, `x`);\n    if (typeof b !== `number`) {\n      throw new TypeError(`Expecting second parameter to be a number (width)`);\n    }\n    if (typeof c !== `number`) {\n      throw new TypeError(`Expecting third parameter to be a number (height)`);\n    }\n\n    throwNumberTest(b, `positive`, `y`);\n    throwNumberTest(c, `positive`, `width`);\n    if (d === undefined) throw new Error(`Expected height parameter`);\n    throwNumberTest(d, `positive`, `height`);\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}","import { isPoint } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from './PointType.js';\nimport { getPointParameter } from \"./GetPointParameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n *\n * ```js`\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ``\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { minIndex } from \"../../numbers/NumericArrays.js\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line: Line | ReadonlyArray<Line>, point: Point): Point => {\n\n  const n = (line: Line): Point => {\n    const { a, b } = line;\n    const atob = { x: b.x - a.x, y: b.y - a.y };\n    const atop = { x: point.x - a.x, y: point.y - a.y };\n    const length = atob.x * atob.x + atob.y * atob.y;\n\n\n    let dot = atop.x * atob.x + atop.y * atob.y;\n    const t = Math.min(1, Math.max(0, dot / length));\n    dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n    return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n  };\n\n  if (Array.isArray(line)) {\n    const pts = line.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(line as Line));\n  }\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard } from './Guard.js';\nimport { guard as guardPoint } from '../point/Guard.js';\nimport { length } from \"./Length.js\";\nimport { nearest } from \"./Nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns \n */\nexport const distanceSingleLine = (line: Line, point: Point): number => {\n  guard(line, `line`);\n  guardPoint(point, `point`);\n\n  if (length(line) === 0) {\n    // Line is really a point\n    return length(line.a, point);\n  }\n\n  const near = nearest(line, point);\n  return length(near, point);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport const findMinimum = (\n  comparer: (a: Point, b: Point) => Point,\n  ...points: ReadonlyArray<Point>\n): Point => {\n  if (points.length === 0) throw new Error(`No points provided`);\n  let min = points[ 0 ];\n  for (const p of points) {\n    min = comparer(min, p);\n  }\n  return min;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Geometry.Points.bbox | Geometry.Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (\n  topLeft: Point,\n  topRight: Point,\n  bottomRight: Point,\n  bottomLeft: Point\n): RectPositioned => {\n  if (topLeft.y > bottomRight.y) {\n    throw new Error(`topLeft.y greater than bottomRight.y`);\n  }\n  if (topLeft.y > bottomLeft.y) {\n    throw new Error(`topLeft.y greater than bottomLeft.y`);\n  }\n\n  const w1 = topRight.x - topLeft.x;\n  const w2 = bottomRight.x - bottomLeft.x;\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\n  const h2 = Math.abs(bottomRight.y - topRight.y);\n  return {\n    x: Math.min(topLeft.x, bottomLeft.x),\n    y: Math.min(topRight.y, topLeft.y),\n    width: Math.max(w1, w2),\n    height: Math.max(h1, h2),\n  };\n};\n","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/Max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points: ReadonlyArray<Point>): RectPositioned => {\n  const leftMost = findMinimum((a, b) => {\n    return a.x < b.x ? a : b;\n  }, ...points);\n  const rightMost = findMinimum((a, b) => {\n    return a.x > b.x ? a : b;\n  }, ...points);\n  const topMost = findMinimum((a, b) => {\n    return a.y < b.y ? a : b;\n  }, ...points);\n  const bottomMost = findMinimum((a, b) => {\n    return a.y > b.y ? a : b;\n  }, ...points);\n\n  const topLeft = { x: leftMost.x, y: topMost.y };\n  const topRight = { x: rightMost.x, y: topMost.y };\n  const bottomRight = { x: rightMost.x, y: bottomMost.y };\n  const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n  return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\n","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport type { Line } from \"./LineType.js\";\nimport { bbox as PointsBbox } from \"../point/Bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line: Line): RectPositioned => PointsBbox(line.a, line.b);\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport { guard, guardNonZeroPoint, isPoint } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport { guard as RectsGuard, isRect } from '../rect/Guard.js'\nimport type { Rect } from \"../rect/RectTypes.js\";\n/**\n * Divides point a by rectangle:\n * ```js\n * return {\n *  x: a.x / rect.width,\n *  y: a.y / rect.hight\n * };\n * ```\n * \n * Or point:\n * ```js\n * return {\n *  x: a.x / b.x,\n *  y: a.y / b.y\n * }\n * ```\n * \n * \n * Dividing by zero will give Infinity for that dimension.\n * @param a\n * @param rectOrPoint\n */\nexport function divide(a: Point, rectOrPoint: Rect | Point): Point;\n\n/**\n * Divides a point by x,y.\n * ```js\n * return {\n *  x: a.x / x,\n *  y: b.y / y\n * };\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param a Point\n * @param x X divisor\n * @param y Y divisor. If unspecified, x divisor is used.\n */\nexport function divide(a: Point, x: number, y?: number): Point;\n\n/**\n * Divides two sets of points:\n * ```js\n * return {\n *  x: x1 / x2,\n *  y: y1 / y2\n * };\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function divide(x1: number, y1: number, x2?: number, y2?: number): Point;\n\n/**\n * Divides a from b. If a contains a zero, that axis will be returned as zero\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport function divide(\n  a: Point | number,\n  b: Rect | Point | number,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n\n  if (isPoint(a)) {\n    guard(a, `a`);\n    if (isPoint(b)) {\n      //guardNonZeroPoint(b);\n      return Object.freeze({\n        x: a.x / b.x,\n        y: a.y / b.y,\n      });\n    } else if (isRect(b)) {\n      RectsGuard(b, `rect`);\n      return Object.freeze({\n        x: a.x / b.width,\n        y: a.y / b.height,\n      });\n    } else {\n      if (c === undefined) c = b;\n      guard(a);\n      throwNumberTest(b, `nonZero`, `x`);\n      throwNumberTest(c, `nonZero`, `y`);\n      return Object.freeze({\n        x: a.x / b,\n        y: a.y / c,\n      });\n    }\n  } else {\n    if (typeof b !== `number`) {\n      throw new TypeError(`expected second parameter to be y1 coord`);\n    }\n    throwNumberTest(a, `positive`, `x1`);\n    throwNumberTest(b, `positive`, `y1`);\n    if (c === undefined) c = 1;\n    if (d === undefined) d = c;\n    throwNumberTest(c, `nonZero`, `x2`);\n    throwNumberTest(d, `nonZero`, `y2`);\n\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point | number | Array<number>, b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point | number | Array<number>,\n    bb?: number,\n    cc?: number\n  ): Point | Point3d => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { divide as PointDivide } from '../point/Divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param line \n * @param point \n * @returns \n */\nexport const divide = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointDivide(line.a, point),\n  b: PointDivide(line.b, point)\n});","import { fromNumbers } from \"./FromNumbers.js\";\nimport type { Line } from \"./LineType.js\";\n\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n * \n * See {@link toFlatArray} to create an array from a line.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array: ReadonlyArray<number>): Line => {\n  if (!Array.isArray(array)) throw new Error(`arr parameter is not an array`);\n  if (array.length !== 4) throw new Error(`array is expected to have length four`);\n  return fromNumbers(array[ 0 ], array[ 1 ], array[ 2 ], array[ 3 ]);\n};","import { degreeToRadian, radianToDegree } from './Angles.js';\nimport { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport type { Point } from './point/PointType.js';\nimport { subtract } from './point/Subtract.js';\nimport { Empty } from './point/Empty.js';\nimport { isPoint, guard as PointGuard } from './point/Guard.js';\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\n/**\n * Polar coordinate, made up of a distance and angle in radians.\n * Most computations involving PolarCoord require an `origin` as well.\n */\nexport type Coord = {\n  readonly distance: number;\n  readonly angleRadian: number;\n};\n\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtract(point, origin);\n  //eslint-disable-next-line functional/no-let\n  //let a =  Math.atan2(point.y, point.x);\n  //if (a < 0) a = Math.abs(a);\n  //else a = Math.PI + (Math.PI - a);\n\n  const angle = Math.atan2(point.y, point.x);\n  //if (point.x < 0 && point.y > 0) angle += 180;\n  //if (point.x > 0 && point.y < 0) angle += 360;\n  //if (point.x < 0 && point.y < 0) angle += 180;\n\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = Empty;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = Empty;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\n//eslint-disable-next-line func-style\nexport function* spiral(\n  smoothness: number,\n  zoom: number\n): IterableIterator<Coord & { readonly step: number }> {\n  //eslint-disable-next-line functional/no-let\n  let step = 0;\n\n  while (true) {\n    //eslint-disable-next-line functional/no-let\n    const a = smoothness * step++;\n    yield {\n      distance: zoom * a,\n      angleRadian: a,\n      step: step,\n    };\n  }\n}\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c: Coord, amountRadian: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n  });\n\nexport const normalise = (c: Coord): Coord => {\n  //guard(v, `v`);\n  if (c.distance === 0) throw new Error(`Cannot normalise vector of length 0`);\n  return Object.freeze({\n    ...c,\n    distance: 1,\n  });\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Coord, b: Coord): number => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p: Coord): Coord => {\n  guard(p, `c`);\n  return Object.freeze({\n    ...p,\n    angleRadian: p.angleRadian - Math.PI,\n  });\n};\n\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  if (a.distance !== b.distance) return false;\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === b.angleRadian;\n};\n\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c: Coord, amountDeg: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n  });\n\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (\n  step: number,\n  smoothness: number,\n  zoom: number\n): Coord => {\n  const a = smoothness * step;\n  return Object.freeze({\n    distance: zoom * a,\n    angleRadian: a,\n  });\n};\n\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance * amt,\n  });\n};\n\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance / amt,\n  });\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v: Coord, max = 1, min = 0): Coord => {\n  let mag = v.distance;\n  if (mag > max) mag = max;\n  if (mag < min) mag = min;\n  return Object.freeze({\n    ...v,\n    distance: mag,\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = Empty\n): Point => {\n  PointGuard(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyCartesian): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};\n","import type { Point } from './point/PointType.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: ReadonlyArray<number>): ReadonlyArray<number>;\n\n//eslint-disable-next-line func-style\nexport function degreeToRadian(angleInDegrees: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: ReadonlyArray<number>): ReadonlyArray<number>;\n\n//eslint-disable-next-line func-style\nexport function radianToDegree(angleInRadians: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { guard, isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns `a` minus `b`\n *\n * ie.\n * ```js\n * return {\n *   x: a.x - b.x,\n *   y: a.y - b.y\n * };\n * ```\n * @param a Point a\n * @param b Point b\n * @returns Point\n */\nexport function subtract(a: Point, b: Point): Point;\n\n/**\n * Returns `a` minus the given coordinates.\n *\n * ie:\n * ```js\n * return {\n *  x: a.x - x,\n *  y: a.y - y\n * }\n * ```\n * @param a Point\n * @param x X coordinate\n * @param y Y coordinate (if omitted, x is used as well)\n */\nexport function subtract(a: Point, x: number, y?: number): Point;\n\n/**\n * Subtracts two sets of x,y pairs.\n *\n * If first parameter is a Point, any additional properties of it\n * are included in returned Point.\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n */\nexport function subtract(x1: number, y1: number, x2: number, y2: number): Point;\n\n//eslint-disable-next-line func-style\nexport function subtract(\n  a: Point | number,\n  b: Point | number,\n  c?: number,\n  d?: number\n): Point {\n  if (isPoint(a)) {\n    guard(a, `a`);\n    if (isPoint(b)) {\n      guard(b, `b`);\n      return Object.freeze({\n        ...a,\n        x: a.x - b.x,\n        y: a.y - b.y,\n      });\n    } else {\n      if (c === undefined) c = b;\n      return Object.freeze({\n        ...a,\n        x: a.x - b,\n        y: a.y - c,\n      });\n    }\n  } else {\n    throwNumberTest(a, ``, `a`);\n    if (typeof b !== `number`) {\n      throw new TypeError(`Second parameter is expected to by y value`);\n    }\n    throwNumberTest(b, ``, `b`);\n\n    if (Number.isNaN(c)) throw new Error(`Third parameter is NaN`);\n    if (Number.isNaN(d)) throw new Error(`Fourth parameter is NaN`);\n\n    if (c === undefined) c = 0;\n    if (d === undefined) d = 0;\n    return Object.freeze({\n      x: a - c,\n      y: b - d,\n    });\n  }\n}\n","/**\n * An empty point of `{ x:0, y:0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n */\nexport const Empty = { x: 0, y: 0 } as const;","import type { Point } from \"../point/PointType.js\"\nimport * as Polar from \"../Polar.js\";\nimport { radianInvert } from \"../Angles.js\";\n\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n * \n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n * \n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line. \n * * Angle of 45deg will be angled downwards.\n * \n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin: Point = { x: 0.5, y: 0.5 }, length: number = 1, angleRadian: number = 0, balance: number = 0.5) => {\n  const left = length * balance;\n  const right = length * (1 - balance);\n  const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n  const b = Polar.toCartesian(right, angleRadian, origin);\n  return Object.freeze({\n    a, b\n  });\n}","import type { Point } from \"../point/PointType.js\";\nimport { fromPoints } from \"./FromPoints.js\";\nimport type { LinePath } from \"./LinePathType.js\";\nimport { toPath } from \"./ToPath.js\";\n\n/**\n * Returns a {@link LinePath} from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const fromPointsToPath = (a: Point, b: Point): LinePath => toPath(fromPoints(a, b));\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param a\n * @param b\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import type { Line } from \"./LineType.js\";\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a: Line, b: Line): boolean => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);","export * from './Abs.js';\nexport * from './Angle.js';\nexport * from './Apply.js';\nexport * from './Bbox.js';\nexport * from './Centroid.js';\nexport * from './Clamp.js';\nexport * from './Compare.js';\nexport * from './ConvexHull.js';\nexport * from './Distance.js';\nexport * from './DistanceToCenter.js';\nexport * from './DistanceToExterior.js';\nexport * from './Divider.js';\nexport * from './DotProduct.js';\nexport * from './Empty.js';\nexport * from './FindMinimum.js';\nexport * from './From.js';\nexport * from './GetPointParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './Invert.js';\nexport * from './IsEqual.js';\nexport * from './Magnitude.js';\nexport * from './Most.js';\nexport * from './Multiply.js';\nexport * from './Normalise.js';\nexport * from './NormaliseByRect.js';\nexport * from './Pipeline.js';\nexport * from './PointRelationTypes.js';\nexport * from './PointType.js';\nexport * from './ProgressBetween.js';\nexport * from './Project.js';\nexport * from './Quantise.js';\nexport * from './Random.js';\nexport * from './Reduce.js';\nexport * from './Relation.js';\nexport * from './Rotate.js';\nexport * from './RotatePointArray.js';\nexport * from './Round.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './To.js';\nexport * from './ToArray.js';\nexport * from './WithinRange.js';\nexport * from './Wrap.js';\nexport type { Point, Point3d } from './PointType.js';\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns a point with Math.abs applied to x and y.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport const abs = (pt: Point) => ({\n  ...pt,\n  x: Math.abs(pt.x),\n  y: Math.abs(pt.y),\n});","import { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angle = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};","import { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Applies `fn` on `x` and `y` fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport const apply = (\n  pt: Point,\n  fn: (v: number, field?: string) => number\n): Point => {\n  guard(pt, `pt`);\n\n  return Object.freeze<Point>({\n    ...pt,\n    x: fn(pt.x, `x`),\n    y: fn(pt.y, `y`),\n  });\n}","import { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: ReadonlyArray<Point | undefined>): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import { clamp as clampNumber } from '../../data/Clamp.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(pt: Point, min?: number, max?: number): Point;\n\n/**\n * Clamps an x,y pair to be between `min` and `max` (0 & 1 by default)\n * @param x X coordinate\n * @param y Y coordinate\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(x: number, y: number, min?: number, max?: number): Point;\nexport function clamp(\n  a: Point | number,\n  b?: number,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n\n  if (isPoint(a)) {\n    if (b === undefined) b = 0;\n    if (c === undefined) c = 1;\n    throwNumberTest(b, ``, `min`);\n    throwNumberTest(c, ``, `max`);\n    return Object.freeze({\n      x: clampNumber(a.x, b, c),\n      y: clampNumber(a.y, b, c),\n    });\n  } else {\n    if (b === undefined) throw new Error(`Expected y coordinate`);\n    if (c === undefined) c = 0;\n    if (d === undefined) d = 1;\n    throwNumberTest(a, ``, `x`);\n    throwNumberTest(b, ``, `y`);\n    throwNumberTest(c, ``, `min`);\n    throwNumberTest(d, ``, `max`);\n\n    return Object.freeze({\n      x: clampNumber(a, c, d),\n      y: clampNumber(b, c, d),\n    });\n  }\n}\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value.\n * Returns above 0 if a.x > b.x (to the right)\n * Returns 0 if a.x === b.x\n * Returns below 0 if a.x < b.x (to the left)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number =>\n  a.x - b.x || a.y - b.y;","import { compareByX } from \"./Compare.js\";\nimport { isEqual } from \"./IsEqual.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts: ReadonlyArray<Point>): ReadonlyArray<Point> => {\n  const sorted = [ ...pts ].sort(compareByX);\n  if (sorted.length === 1) return sorted;\n\n  const x = (points: Array<Point>) => {\n    const v: Array<Point> = [];\n    for (const p of points) {\n      while (v.length >= 2) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const q = v.at(-1)!;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const r = v.at(-2)!;\n        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n          //eslint-disable-next-line functional/immutable-data\n          v.pop();\n        } else break;\n      }\n      //eslint-disable-next-line functional/immutable-data\n      v.push(p);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    v.pop();\n    return v;\n  };\n\n  const upper = x(sorted);\n  //eslint-disable-next-line functional/immutable-data\n  const lower = x(sorted.reverse());\n\n  if (upper.length === 1 && lower.length === 1 && isEqual(lower[ 0 ], upper[ 0 ])) {\n    return upper;\n  }\n  return [ ...upper, ...lower ];\n};","import { guard as guardPoint } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Circle, CirclePositioned } from './CircleType.js';\n\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle \n * @param parameterName \n */\nexport const guard = (circle: CirclePositioned | Circle, parameterName = `circle`) => {\n  if (isCirclePositioned(circle)) {\n    guardPoint(circle, `circle`);\n  }\n\n  if (Number.isNaN(circle.radius)) throw new Error(`${ parameterName }.radius is NaN`);\n  if (circle.radius <= 0) throw new Error(`${ parameterName }.radius must be greater than zero`);\n};\n\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle \n * @param parameterName \n * @returns \n */\nexport const guardPositioned = (circle: CirclePositioned, parameterName = `circle`) => {\n  if (!isCirclePositioned(circle)) throw new Error(`Expected a positioned circle with x,y`);\n  guard(circle, parameterName);\n};\n\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a: Circle | CirclePositioned): boolean => {\n  if (Number.isNaN(a.radius)) return true;\n  if (isCirclePositioned(a)) {\n    if (Number.isNaN(a.x)) return true;\n    if (Number.isNaN(a.y)) return true;\n  }\n  return false;\n};\n\n\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n * \n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns \n */\nexport const isPositioned = (p: Circle | Point): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCircle = (p: any): p is Circle => (p as Circle).radius !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCirclePositioned = (p: any): p is CirclePositioned => isCircle(p) && isPositioned(p);","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between two circle centers.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a \n * @param b \n * @returns Distance\n */\nexport const distanceCenter = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    guardPositioned(b, `b`);\n  }\n  return pointsDistance(a, b);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isPoint as PointsIsPoint } from \"../point/Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b \n */\nexport const distanceFromExterior = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n  } else if (PointsIsPoint(b)) {\n    const distribution = PointsDistance(a, b);\n    if (distribution < a.radius) return 0;\n    return distribution;\n  } else throw new Error(`Second parameter invalid type`);\n};","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n * \n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n * \n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: CirclePositioned | Circle, b: CirclePositioned | Circle): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isCirclePositioned(a) && isCirclePositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return false;\n};","import { Empty } from \"./Empty.js\";\nimport { guard, isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\ntype Sum = {\n  /**\n   * Adds two sets of coordinates. If y is omitted, the parameter for x is added to both x and y\n   */\n  (aX: number, aY: number, bX: number, bY: number): Point;\n  /**\n   * Add x,y to a\n   */\n  (a: Point, x: number, y?: number): Point;\n  /**\n   * Add two points\n   */\n  (a: Point, b?: Point): Point;\n};\n\n/**\n * Returns a Point of `a` plus `b`. ie:\n *\n * ```js\n * return {\n *   x: a.x + b.x,\n *   y: a.y + b.y\n * };\n * ```\n *\n * Usage:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * sum(ptA, xAndY);\n * ```\n */\nexport const sum: Sum = function (\n  a: Point | number,\n  b: Point | number | undefined,\n  c?: number,\n  d?: number\n): Point {\n  // ✔️ Unit tested\n  if (a === undefined) throw new TypeError(`a missing`);\n\n  let ptA: Point | undefined;\n  let ptB: Point | undefined;\n  if (isPoint(a)) {\n    ptA = a;\n    if (b === undefined) b = Empty;\n    if (isPoint(b)) {\n      ptB = b;\n    } else {\n      if (b === undefined) throw new Error(`Expects x coordinate`);\n      ptB = { x: b, y: c ?? b };\n    }\n  } else if (!isPoint(b)) {\n    // Neither of first two params are points\n    if (b === undefined) throw new Error(`Expected number as second param`);\n    ptA = { x: a, y: b };\n    if (c === undefined) throw new Error(`Expects x coordiante`);\n    ptB = { x: c, y: d ?? 0 };\n  }\n\n  if (ptA === undefined) throw new Error(`ptA missing. a: ${ JSON.stringify(a) }`);\n  if (ptB === undefined) throw new Error(`ptB missing. b: ${ JSON.stringify(b) }`);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  return Object.freeze({\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  });\n};\n","import { isEqual } from \"./IsEqual.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\nimport type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns the point(s) of intersection between a circle and line.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle \n * @param line \n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle: CirclePositioned, line: Line): ReadonlyArray<Point> => {\n  const v1 = {\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n  };\n  const v2 = {\n    x: line.a.x - circle.x,\n    y: line.a.y - circle.y\n  };\n\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n  if (Number.isNaN(d)) return []; // no intercept\n\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  const u2 = (b + d) / c;\n\n  const returnValue = [];\n  if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u1,\n      y: line.a.y + v1.y * u1\n    });\n  }\n  if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u2,\n      y: line.a.y + v1.y * u2\n    });\n  }\n  return returnValue;\n};\n\n\n/**\n * \n * Returns the points of intersection betweeen `a` and `b`.\n * \n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a: CirclePositioned, b: CirclePositioned): ReadonlyArray<Point> => {\n  const vector = PointsSubtract(b, a);\n  const centerD = Math.hypot((vector.y), (vector.x));\n\n  // Do not intersect\n  if (centerD > a.radius + b.radius) return [];\n\n  // Circle contains another\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\n\n  // Circles are the same\n  if (isEqual(a, b)) return [];\n\n  const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n  const centroid = {\n    x: a.x + (vector.x * centroidD / centerD),\n    y: a.y + (vector.y * centroidD / centerD)\n  };\n\n  const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n\n  const intersection = {\n    x: -vector.y * (centroidIntersectionD / centerD),\n    y: vector.x * (centroidIntersectionD / centerD)\n  };\n  return [\n    PointsSum(centroid, intersection),\n    PointsSubtract(centroid, intersection)\n  ];\n};\n","import { intersections as circleIntersections } from \"./circle/Intersections.js\";\nimport type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { RectPositioned } from \"./rect/index.js\";\n\nexport const circleRect = (a: CirclePositioned, b: RectPositioned) => {\n  // https://yal.cc/rectangle-circle-intersection-test/\n  const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n  const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n  return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\n\nexport const circleCircle = (a: CirclePositioned, b: CirclePositioned) => circleIntersections(a, b).length === 2;","import { guard } from \"./Guard.js\";\nimport { isPositioned, isRectPositioned } from \"./Guard.js\";\nimport { isCirclePositioned } from '../circle/Guard.js';\nimport * as Intersects from '../Intersects.js';\nimport { isPoint } from \"../point/Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"../circle/CircleType.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  point: Point\n): boolean;\n\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  x: number,\n  y: number\n): boolean;\n\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  a: Point | number,\n  b?: number\n): boolean {\n  guard(rect, `rect`);\n  //eslint-disable-next-line functional/no-let\n  let x = 0;\n  //eslint-disable-next-line functional/no-let\n  let y = 0;\n  if (typeof a === `number`) {\n    if (b === undefined) throw new Error(`x and y coordinate needed`);\n    x = a;\n    y = b;\n  } else {\n    x = a.x;\n    y = a.y;\n  }\n  if (isPositioned(rect)) {\n    if (x - rect.x > rect.width || x < rect.x) return false;\n    if (y - rect.y > rect.height || y < rect.y) return false;\n  } else {\n    // Assume 0,0\n    if (x > rect.width || x < 0) return false;\n    if (y > rect.height || y < 0) return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (\n  a: RectPositioned,\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  b: CirclePositioned | Point\n): boolean => {\n  if (!isRectPositioned(a)) {\n    throw new Error(`a parameter should be RectPositioned`);\n  }\n\n  if (isCirclePositioned(b)) {\n    return Intersects.circleRect(b, a);\n  } else if (isPoint(b)) {\n    return intersectsPoint(a, b);\n  }\n  throw new Error(`Unknown shape for b: ${ JSON.stringify(b) }`);\n};","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { getRectPositioned, guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the center of a rectangle as a {@link Geometry.Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): Point => {\n  guard(rect);\n  if (origin === undefined && isPoint(rect)) origin = rect;\n  else if (origin === undefined) origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n\n  const r = getRectPositioned(rect, origin);\n  return Object.freeze({\n    x: origin.x + rect.width / 2,\n    y: origin.y + rect.height / 2,\n  });\n};","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point, where x and y is `NaN`.\n * Use `isPlaceholder` to check if a point is a placeholder.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n","import { guardPositioned } from \"./Guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./Center.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { type Point } from '../point/PointType.js';\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { distance as PointsDistance } from '../point/Distance.js';\n\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (\n  rect: RectPositioned,\n  pt: Point\n): number => {\n  guardPositioned(rect, `rect`);\n  PointsGuard(pt, `pt`);\n  if (intersectsPoint(rect, pt)) return 0;\n  const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n  const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n  return Math.hypot(dx, dy);\n};\n\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (\n  rect: RectPositioned,\n  pt: Point\n): number => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance } from \"./Distance.js\";\nimport { isPoint } from \"./Guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport type { Point } from \"./PointType.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance, isPoint } from \"./index.js\";\nimport type { Point, PointCalculableShape } from \"../Types.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\n\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p: Point): ReadonlyArray<number> => [ p.x, p.y ];\n","import { dotProduct as ArraysDotProduct } from '../../numbers/NumericArrays.js';\nimport type { Point } from './PointType.js';\nimport { toArray } from './ToArray.js';\n\nexport const dotProduct = (...pts: ReadonlyArray<Point>): number => {\n  const a = pts.map(p => toArray(p));\n  return ArraysDotProduct(a);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns a point from two coordinates or an array of [x,y]\n * @example\n * ```js\n * let p = from([10, 5]); // yields {x:10, y:5}\n * let p = from(10, 5);   // yields {x:10, y:5}\n * let p = from(10);      // yields {x:10, y:0} 0 is used for default y\n * let p = from();        // yields {x:0, y:0}  0 used for default x & y\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport const from = (\n  xOrArray?: number | ReadonlyArray<number>,\n  y?: number\n): Point => {\n  if (Array.isArray(xOrArray)) {\n    if (xOrArray.length !== 2) {\n      throw new Error(`Expected array of length two, got ${ xOrArray.length }`);\n    }\n    return Object.freeze({\n      x: xOrArray[ 0 ],\n      y: xOrArray[ 1 ],\n    });\n  } else {\n    if (xOrArray === undefined) xOrArray = 0;\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\n    if (y === undefined) y = 0;\n    else if (Number.isNaN(y)) throw new Error(`y is NaN`);\n    return Object.freeze({ x: xOrArray as number, y: y });\n  }\n};\n\n\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (\n  ...coords: ReadonlyArray<ReadonlyArray<number>> | ReadonlyArray<number>\n): ReadonlyArray<Point> => {\n  const pts: Array<Point> = [];\n\n  if (Array.isArray(coords[ 0 ])) {\n    // [[x,y],[x,y]...]\n    for (const coord of (coords as Array<Array<number>>)) {\n      if (!(coord.length % 2 === 0)) {\n        throw new Error(`coords array should be even-numbered`);\n      }\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(Object.freeze({ x: coord[ 0 ], y: coord[ 1 ] }));\n    }\n  } else {\n    // [x,y,x,y,x,y]\n    if (coords.length % 2 !== 0) {\n      throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n    }\n\n    for (let index = 0; index < coords.length; index += 2) {\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(\n        Object.freeze({ x: coords[ index ] as number, y: coords[ index + 1 ] as number })\n      );\n    }\n  }\n  return pts;\n};\n","import type { Point } from \"./PointType.js\";\nimport { interpolate as lineInterpolate } from '../line/Interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isRect } from \"../rect/Guard.js\";\nimport type { Rect } from \"../rect/RectTypes.js\";\nimport { guard as RectsGuard } from '../rect/Guard.js'\nimport type { Point, Point3d } from \"./PointType.js\";\nimport { guard, isPoint, isPoint3d } from \"./Guard.js\";\n\n/**\n * Multiply by a width,height or x,y\n * ```\n * return {\n *  x: a.x * rect.width,\n *  y: a.y * rect.height\n * };\n * ```\n * @param a\n * @param rectOrPoint\n */\nexport function multiply(a: Point, rectOrPoint: Rect | Point): Point;\n\n/**\n * Returns `a` multipled by some x and/or y scaling factor\n *\n * ie.\n * ```js\n * return {\n *  x: a.x * x\n *   y: a.y * y\n * }\n * ```\n *\n * Usage:\n * ```js\n * multiply(pt, 10, 100); // Scale pt by x:10, y:100\n * multiply(pt, Math.min(window.innerWidth, window.innerHeight)); // Scale both x,y by viewport with or height, whichever is smaller\n * ```\n * @export\n * @parama Point to scale\n * @param x Scale factor for x axis\n * @param [y] Scale factor for y axis (if not specified, the x value is used)\n * @returns Scaled point\n */\nexport function multiply(a: Point, x: number, y?: number): Point;\n\n/**\n * Returns `a` multiplied by `b` point, or given x and y.\n * ie.\n * ```js\n * return {\n *   x: a.x * b.x,\n *   y: a.y * b.y\n * };\n * ```\n * @param a\n * @param bOrX\n * @param y\n * @returns\n */\n/* eslint-disable func-style */\nexport function multiply(\n  a: Point,\n  bOrX: Rect | Point | number,\n  y?: number\n): Point {\n  // ✔️ Unit tested\n\n  guard(a, `a`);\n  if (typeof bOrX === `number`) {\n    if (typeof y === `undefined`) y = bOrX;\n    throwNumberTest(y, ``, `y`);\n    throwNumberTest(bOrX, ``, `x`);\n    return Object.freeze({ x: a.x * bOrX, y: a.y * y });\n  } else if (isPoint(bOrX)) {\n    guard(bOrX, `b`);\n    return Object.freeze({\n      x: a.x * bOrX.x,\n      y: a.y * bOrX.y,\n    });\n  } else if (isRect(bOrX)) {\n    RectsGuard(bOrX, `rect`);\n    return Object.freeze({\n      x: a.x * bOrX.width,\n      y: a.y * bOrX.height,\n    });\n  } else {\n    throw new Error(\n      `Invalid arguments. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(bOrX) }`\n    );\n  }\n}\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./Distance.js\";\nimport { multiply } from \"./Multiply.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./Empty.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param pt\n * @param pipeline\n * @returns\n */\nexport const pipelineApply = (\n  pt: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(pt); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","\nimport { isPoint3d } from \"./Guard.js\";\nimport type { Point3d, Point } from \"./PointType.js\";\nimport { subtract } from \"./Subtract.js\";\n\nexport const progressBetween = (\n  currentPos: Point | Point3d,\n  from: Point | Point3d,\n  to: Point | Point3d\n) => {\n  // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n  // from -> current\n  const a = subtract(currentPos, from);\n\n  // from -> to\n  const b = subtract(to, from);\n\n  return isPoint3d(a) && isPoint3d(b) ? (\n    (a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)\n  ) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin: Point, distance: number, angle: number) => {\n  const x = Math.cos(angle) * distance + origin.x;\n  const y = Math.sin(angle) * distance + origin.y;\n  return { x, y };\n};","import { quantiseEvery as quantiseEveryNumber } from '../../numbers/Quantise.js';\nimport type { Point } from './PointType.js';\n\nexport const quantiseEvery = (pt: Point, snap: Point, middleRoundsUp = true) =>\n  Object.freeze({\n    x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n    y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n  });","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Returns a random point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): Point => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n  });\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (\n  pts: ReadonlyArray<Point>,\n  fn: (p: Point, accumulated: Point) => Point,\n  initial?: Point\n): Point => {\n  if (initial === undefined) initial = { x: 0, y: 0 }\n  let accumulator = initial;\n  for (const p of pts) {\n    accumulator = fn(p, accumulator);\n  };\n  return accumulator;\n};","import { angle } from \"./Angle.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { distance } from \"./Distance.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport type { PointRelation } from \"./PointRelationTypes.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use [Data.pointsTracker](./Data.pointsTracker.html)\n * @param start\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angle(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../Polar.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../Polar.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport function rotate(\n  pt: ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): ReadonlyArray<Point>;\n\nexport function rotate(\n  pt: Point | ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): Point | ReadonlyArray<Point> {\n  if (origin === undefined) origin = { x: 0, y: 0 };\n  guard(origin, `origin`);\n  throwNumberTest(amountRadian, ``, `amountRadian`);\n  const arrayInput = Array.isArray(pt);\n\n  // no-op\n  if (amountRadian === 0) return pt;\n\n  if (!arrayInput) {\n    pt = [ pt as Point ];\n  }\n\n  const ptAr = pt as ReadonlyArray<Point>;\n  for (const [ index, p ] of ptAr.entries()) guard(p, `pt[${ index }]`);\n\n  const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n  const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n  const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n  return arrayInput ? asCartesisan : asCartesisan[ 0 ];\n}","\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (\n  v: ReadonlyArray<ReadonlyArray<number>>,\n  amountRadian: number\n): Array<Array<number>> => {\n  const mat = [\n    [ Math.cos(amountRadian), -Math.sin(amountRadian) ],\n    [ Math.sin(amountRadian), Math.cos(amountRadian) ],\n  ];\n  const result = [];\n  for (const [ index, element ] of v.entries()) {\n    //eslint-disable-next-line functional/immutable-data\n    result[ index ] = [\n      mat[ 0 ][ 0 ] * element[ 0 ] + mat[ 0 ][ 1 ] * element[ 1 ],\n      mat[ 1 ][ 0 ] * element[ 0 ] + mat[ 1 ][ 1 ] * element[ 1 ],\n    ];\n  }\n  return result;\n};","import { round as roundNumber } from '../../numbers/Round.js';\nimport { getPointParameter } from './GetPointParameter.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX \n * @param yOrDigits \n * @param digits \n * @returns \n */\nexport const round = (ptOrX: Point | number, yOrDigits?: number, digits?: number): Point => {\n  const pt = getPointParameter(ptOrX, yOrDigits);\n  digits = digits ?? yOrDigits;\n  digits = digits ?? 2;\n  return Object.freeze({\n    ...pt,\n    x: roundNumber(digits, pt.x),\n    y: roundNumber(digits, pt.y)\n  })\n}","import { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (\n  pt: Point,\n  rounder: (x: number) => number = Math.round\n): Point => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    x: rounder(pt.x),\n    y: rounder(pt.y),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p: Point, digits?: number): string {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n  guard(p, `pt`);\n\n  const x = digits ? p.x.toFixed(digits) : p.x;\n  const y = digits ? p.y.toFixed(digits) : p.y;\n\n  if (p.z === undefined) {\n    return `(${ x },${ y })`;\n  } else {\n    const z = digits ? p.z.toFixed(digits) : p.z;\n    return `(${ x },${ y },${ z })`;\n  }\n}","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns true if two points are within a specified range on both axes.\n * \n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (\n  a: Point,\n  b: Point,\n  maxRange: Point | number\n): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n\n  if (typeof maxRange === `number`) {\n    throwNumberTest(maxRange, `positive`, `maxRange`);\n    maxRange = { x: maxRange, y: maxRange };\n  } else {\n    guard(maxRange, `maxRange`);\n  }\n  const x = Math.abs(b.x - a.x);\n  const y = Math.abs(b.y - a.y);\n  return x <= maxRange.x && y <= maxRange.y;\n};","import { wrap as wrapNumber } from '../../data/Wrap.js';\nimport { guard } from './Guard.js';\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (\n  pt: Point,\n  ptMax?: Point,\n  ptMin?: Point\n): Point => {\n\n  if (ptMax === undefined) ptMax = { x: 1, y: 1 };\n  if (ptMin === undefined) ptMin = { x: 0, y: 0 };\n\n  // ✔️ Unit tested\n  guard(pt, `pt`);\n  guard(ptMax, `ptMax`);\n  guard(ptMin, `ptMin`);\n\n  return Object.freeze({\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n  });\n};\n","import type { Point } from \"../Types.js\";\nimport type { Line } from \"./LineType.js\";\nimport { multiply as PointsMultiply } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const multiply = (line: Line, point: Point): Line => (Object.freeze({\n  ...line,\n  a: PointsMultiply(line.a, point),\n  b: PointsMultiply(line.b, point)\n}));","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line \n * @param pt \n */\nexport const relativePosition = (line: Line, pt: Point): number => {\n  const fromStart = PointsDistance(line.a, pt);\n  const total = length(line);\n  return fromStart / total;\n}","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./Interpolate.js\";\n\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n * \n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n * \n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n * \n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns \n */\nexport const rotate = (line: Line, amountRadian?: number, origin?: Point | number): Line => {\n  if (amountRadian === undefined || amountRadian === 0) return line;\n  if (origin === undefined) origin = 0.5;\n  if (typeof origin === `number`) {\n    origin = interpolate(origin, line.a, line.b);\n  }\n  return Object.freeze({\n    ...line,\n    a: PointRotate(line.a, amountRadian, origin),\n    b: PointRotate(line.b, amountRadian, origin)\n  });\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\n\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const subtract = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSubtract(line.a, point),\n  b: PointsSubtract(line.b, point)\n});","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { sum as PointsSum } from '../point/Sum.js';\n\n/**\n * Adds both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const sum = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSum(line.a, point),\n  b: PointsSum(line.b, point)\n});","import type { Point } from \"../point/PointType.js\";\nimport { guard, isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport function toString(a: Point, b: Point): string;\n\n/**\n * Returns a string representation of a line \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toString(line);\n * ```\n * @param line \n */\nexport function toString(line: Line): string;\n\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b \n * @returns \n */\n//eslint-disable-next-line func-style\nexport function toString(a: Point | Line, b?: Point): string {\n  if (isLine(a)) {\n    guard(a, `a`);\n    b = a.b;\n    a = a.a;\n  } else if (b === undefined) throw new Error(`Expect second point if first is a point`);\n  return PointsToString(a) + `-` + PointsToString(b);\n}\n\n","import type { LinePath } from \"./LinePathType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { parallel, perpendicularPoint } from \"./Angles.js\";\nimport { midpoint } from \"./Midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./Bbox.js\";\nimport { relativePosition } from \"./RelativePosition.js\";\nimport { sum } from \"./Sum.js\";\nimport { divide } from \"./Divide.js\";\nimport { rotate } from \"./Rotate.js\";\nimport { nearest } from \"./Nearest.js\";\nimport { distanceSingleLine } from './DistanceSingleLine.js';\nimport { isEqual } from \"./IsEqual.js\";\nimport { multiply } from \"./Multiply.js\";\nimport { subtract } from \"./Subtract.js\";\nimport { toString } from \"./ToString.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n * \n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n * \n * // Now we can use it...\n * l.length();\n * \n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line \n * @returns \n */\nexport const toPath = (line: Line): LinePath => {\n  const { a, b } = line;\n  return Object.freeze({\n    ...line,\n    length: () => length(a, b),\n    interpolate: (amount: number) => interpolate(amount, a, b),\n    relativePosition: (point: Point) => relativePosition(line, point),\n    bbox: () => bbox(line),\n    toString: () => toString(a, b),\n    toFlatArray: () => toFlatArray(a, b),\n    toSvgString: () => toSvgString(a, b),\n    toPoints: () => [ a, b ],\n    rotate: (amountRadian: number, origin: Point) => toPath(rotate(line, amountRadian, origin)),\n    nearest: (point: Point) => nearest(line, point),\n    sum: (point: Point) => toPath(sum(line, point)),\n    divide: (point: Point) => toPath(divide(line, point)),\n    multiply: (point: Point) => toPath(multiply(line, point)),\n    subtract: (point: Point) => toPath(subtract(line, point)),\n    midpoint: () => midpoint(a, b),\n    distanceToPoint: (point: Point) => distanceSingleLine(line, point),\n    parallel: (distance: number) => parallel(line, distance),\n    perpendicularPoint: (distance: number, amount?: number) => perpendicularPoint(line, distance, amount),\n    slope: () => slope(line),\n    withinRange: (point: Point, maxRange: number) => withinRange(line, point, maxRange),\n    isEqual: (otherLine: Line) => isEqual(line, otherLine),\n    apply: (fn: (point: Point) => Point) => toPath(apply(line, fn)),\n    kind: `line`\n  });\n};","export * as CirclePacking from './CirclePacking.js';","import { sortByNumericProperty } from \"../data/arrays/Sort.js\";\nimport type { RandomSource } from \"../random/Types.js\";\nimport { randomPoint as ShapesRandomPoint, type ShapePositioned } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/Intersecting.js\";\nimport type { Circle, CirclePositioned } from \"./circle/CircleType.js\";\nimport type { Point } from \"./point/PointType.js\";\n\nexport type RandomOpts = {\n  readonly attempts?: number\n  readonly randomSource?: RandomSource\n}\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles: ReadonlyArray<Circle>, container: ShapePositioned, opts: RandomOpts = {}) => {\n  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);\n  const attempts = opts.attempts ?? 2000;\n\n  const sorted = sortByNumericProperty(circles, `radius`);\n  const positionedCircles: Array<CirclePositioned> = [];\n\n  const willHit = (b: Point, radius: number) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n\n  while (sorted.length > 0) {\n    //eslint-disable-next-line functional/immutable-data\n    const circle = sorted.pop();\n    if (!circle) break;\n\n    const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < attempts; index++) {\n      const position = ShapesRandomPoint(container, randomPointOpts);\n      if (!willHit(position, circle.radius)) {\n        //eslint-disable-next-line functional/immutable-data\n        positionedCircles.push(Object.freeze({ ...circle, ...position }));\n        break;\n      }\n    }\n  }\n\n  return positionedCircles;\n};","import { toCartesian } from '../Polar.js';\nimport { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { Triangles, Points } from '../index.js';\nimport type { Triangle } from '../triangle/TriangleType.js';\nimport { isCirclePositioned, isCircle } from '../circle/Guard.js';\nimport type { RandomSource } from '../../random/Types.js';\nimport { corners as RectsCorners } from '../rect/Corners.js';\nimport { center as RectsCenter } from '../rect/Center.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/Intersecting.js';\nimport { randomPoint as circleRandomPoint } from '../circle/Random.js';\nimport { center as circleCenter } from '../circle/Center.js';\nimport { randomPoint as rectRandomPoint } from '../rect/Random.js';\nimport { isRect, isRectPositioned } from '../rect/Guard.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\nimport type { Rect, RectPositioned, } from '../rect/RectTypes.js';\nimport type { CirclePositioned, Circle } from '../circle/CircleType.js';\nimport type { Line, PolyLine } from '../line/LineType.js';\nimport type { Point, Point3d } from './../point/PointType.js';\n\nexport type ShapePositioned = CirclePositioned | RectPositioned;\nexport type ContainsResult = `none` | `contained`;\n\nexport type Sphere = Point3d & {\n  readonly radius: number;\n};\n\nexport type PointCalculableShape =\n  | PolyLine\n  | Line\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  | RectPositioned\n  | Point\n  | CirclePositioned\n  ;\n\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link CirclePositioned} or {@link RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (\n  a: ShapePositioned,\n  b: ShapePositioned | Point\n): boolean => {\n  if (isCirclePositioned(a)) {\n    return CirclesIsIntersecting(a, b);\n  } else if (isRectPositioned(a)) {\n    return RectsIsIntersecting(a, b);\n  }\n  throw new Error(\n    `a or b are unknown shapes. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`\n  );\n};\n\n// export enum Quadrant {\n//   Nw, Ne, Sw, Se\n// }\n\nexport type ShapeRandomPointOpts = {\n  readonly randomSource: RandomSource;\n};\n\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link CirclePositioned} or {@link RectPositioned}\n * @param shape \n * @param opts \n * @returns \n */\nexport const randomPoint = (\n  shape: ShapePositioned,\n  opts: Partial<ShapeRandomPointOpts> = {}\n): Point => {\n  if (isCirclePositioned(shape)) {\n    return circleRandomPoint(shape, opts);\n  } else if (isRectPositioned(shape)) {\n    return rectRandomPoint(shape, opts);\n  }\n  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n\n// }\n\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (\n  shape?: Rect | Triangle | Circle\n): Point => {\n  if (shape === undefined) {\n    return Object.freeze({ x: 0.5, y: 0.5 });\n  } else if (isRect(shape)) {\n    return RectsCenter(shape);\n  } else if (Triangles.isTriangle(shape)) {\n    return Triangles.centroid(shape);\n  } else if (isCircle(shape)) {\n    return circleCenter(shape);\n  } else {\n    throw new Error(`Unknown shape: ${ JSON.stringify(shape) }`);\n  }\n};\n\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (\n  outerRadius: number,\n  points = 5,\n  innerRadius?: number,\n  origin: Point = Points.Empty,\n  opts?: { readonly initialAngleRadian?: number }\n): ReadonlyArray<Point> => {\n  throwIntegerTest(points, `positive`, `points`);\n  const angle = (Math.PI * 2) / points;\n  const angleHalf = angle / 2;\n\n  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n  if (innerRadius === undefined) innerRadius = outerRadius / 2;\n\n  //eslint-disable-next-line functional/no-let\n  let a = initialAngle;\n  const pts = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < points; index++) {\n    const peak = toCartesian(outerRadius, a, origin);\n    const left = toCartesian(innerRadius, a - angleHalf, origin);\n    const right = toCartesian(innerRadius, a + angleHalf, origin);\n\n    //eslint-disable-next-line functional/immutable-data\n    pts.push(left, peak);\n    //eslint-disable-next-line functional/immutable-data\n    if (index + 1 < points) pts.push(right);\n    a += angle;\n  }\n  return pts;\n};\n\nexport type ArrowOpts = {\n  readonly arrowSize?: number;\n  readonly tailLength?: number;\n  readonly tailThickness?: number;\n  readonly angleRadian?: number;\n};\n\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (\n  origin: Point,\n  from: `tip` | `tail` | `middle`,\n  opts: ArrowOpts = {}\n): ReadonlyArray<Point> => {\n  const tailLength = opts.tailLength ?? 10;\n  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n  const angleRadian = opts.angleRadian ?? 0;\n  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n\n  const triAngle = Math.PI / 2;\n\n  let tri: Triangle;\n  let tailPoints: ReadonlyArray<Point>;\n\n  if (from === `tip`) {\n    tri = Triangles.equilateralFromVertex(origin, arrowSize, triAngle);\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n  } else if (from === `middle`) {\n    const midX = tailLength + arrowSize / 2;\n    const midY = tailThickness / 2;\n    tri = Triangles.equilateralFromVertex(\n      {\n        x: origin.x + arrowSize * 1.2,\n        y: origin.y,\n      },\n      arrowSize,\n      triAngle\n    );\n\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x - midX, y: origin.y - midY },\n        tailLength + arrowSize,\n        tailThickness\n      )\n    );\n  } else {\n    //const midY = origin.y - tailThickness/2;\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n    tri = Triangles.equilateralFromVertex(\n      { x: origin.x + tailLength + arrowSize * 0.7, y: origin.y },\n      arrowSize,\n      triAngle\n    );\n  }\n\n  const arrow = Points.rotate(\n    [\n      tailPoints[ 0 ],\n      tailPoints[ 1 ],\n      tri.a,\n      tri.b,\n      tri.c,\n      tailPoints[ 2 ],\n      tailPoints[ 3 ],\n    ],\n    angleRadian,\n    origin\n  );\n\n  return arrow;\n};\n","import { type Point } from \"../point/PointType.js\";\nimport { getRectPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import type { Point } from \"../point/PointType.js\";\nimport { guardDim } from \"./Guard.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { isPoint } from \"../point/Guard.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isCircle } from \"./Guard.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n * \n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n * \n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a: CirclePositioned, b: CirclePositioned | Point, c?: number): boolean => {\n  const d = distanceCenter(a, b);\n  if (isCircle(b)) {\n    return (d < Math.abs(a.radius - b.radius));\n  } else if (isPoint(b)) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (c === undefined) {\n      return d <= a.radius;\n    } else {\n      // Defining a circle\n      return (d < Math.abs(a.radius - c));\n    }\n  } else throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport * as Intersects from '../Intersects.js';\nimport { isContainedBy } from \"./IsContainedBy.js\";\nimport { isCircle } from \"./Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/IsEqual.js\";\nimport type { Point } from '../point/PointType.js';\nimport { isPoint } from '../point/Guard.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n * \n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number): boolean => {\n  if (PointsIsEqual(a, b)) return true;\n  if (isContainedBy(a, b, c)) return true;\n  if (isCircle(b)) {\n    return Intersects.circleCircle(a, b);\n  } else if (isRectPositioned(b)) {\n    return Intersects.circleRect(a, b);\n  } else if (isPoint(b) && c !== undefined) {\n    return Intersects.circleCircle(a, { ...b, radius: c });\n  }\n  return false;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../Polar.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n * \n * By default creates a uniform distribution.\n * \n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n * \n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns \n */\nexport const randomPoint = (within: Circle | CirclePositioned, opts: Partial<CircleRandomPointOpts> = {}): Point => {\n  const offset: Point = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n  const strategy = opts.strategy ?? `uniform`;\n  const margin = opts.margin ?? 0;\n  const radius = within.radius - margin;\n  const rand = opts.randomSource ?? Math.random;\n  switch (strategy) {\n    case `naive`: {\n      return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n    }\n    case `uniform`: {\n      return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown strategy '${ strategy }'. Expects 'uniform' or 'naive'`);\n    }\n  }\n};","import type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns the center of a circle\n * \n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 10, y: 10};\n * \n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n * \n * It's a trivial function, but can make for more understandable code\n * @param circle \n * @returns Center of circle\n */\nexport const center = (circle: CirclePositioned | Circle) => {\n  return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport { sum as PointsSum } from '../point/Sum.js';\nimport type { Point } from '../point/PointType.js';\nimport { isPositioned } from './Guard.js';\nimport type { Rect, RectPositioned } from './RectTypes.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): RectPositioned => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    width: rando(),\n    height: rando(),\n  });\n};\n\nexport type RectRandomPointOpts = {\n  readonly strategy?: `naive`;\n  readonly randomSource?: RandomSource;\n  readonly margin?: { readonly x: number; readonly y: number };\n};\n\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (\n  within: Rect | RectPositioned,\n  options: RectRandomPointOpts = {}\n): Point => {\n  // TODO: Does not implement uniform distribution\n  // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n  const rand = options.randomSource ?? defaultRandom;\n  const margin = options.margin ?? { x: 0, y: 0 };\n\n  const x = rand() * (within.width - margin.x - margin.x);\n  const y = rand() * (within.height - margin.y - margin.y);\n\n  const pos = { x: x + margin.x, y: y + margin.y };\n  return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};","export * from './Area.js';\nexport * from './Bbox.js';\nexport * from './Center.js';\nexport type * from './CircleType.js';\nexport * from './CircularPath.js';\nexport * from './DistanceCenter.js';\nexport * from './DistanceFromExterior.js';\nexport * from './ExteriorPoints.js';\nexport * from './Guard.js';\nexport * from './InteriorPoints.js';\nexport * from './Interpolate.js';\nexport * from './Intersecting.js';\nexport * from './Intersections.js';\nexport * from './IsContainedBy.js';\nexport * from './IsEqual.js';\nexport * from './Multiply.js';\nexport * from './Perimeter.js';\nexport * from './Random.js';\nexport * from './Svg.js';\nexport * from './ToPath.js';\nexport * from './ToPositioned.js';\n\n","import type { Circle } from \"./CircleType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns the area of `circle`.\n * @param circle \n * @returns \n */\nexport const area = (circle: Circle) => {\n  guard(circle);\n  return Math.PI * circle.radius * circle.radius;\n};","import { type RectPositioned } from \"./RectTypes.js\";\n\nimport type { Point } from \"../point/PointType.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { guardDim } from \"./Guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  PointsGuard(origin, `origin`);\n\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n\n  const halfW = width / 2;\n  const halfH = height / 2;\n  return {\n    x: origin.x - halfW,\n    y: origin.y - halfH,\n    width: width,\n    height: height,\n  };\n};","import type { RectPositioned } from \"../Types.js\";\nimport type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/FromCenter.js';\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns \n */\nexport const bbox = (circle: CirclePositioned | Circle): RectPositioned => {\n  return isCirclePositioned(circle) ?\n    RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n    { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","import type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\n\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n * \n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const { x, y, radius } = circle;\n\n  let xx = radius;\n  let yy = 0;\n  let radiusError = 1 - x;\n  while (xx >= yy) {\n    yield { x: xx + x, y: yy + y };\n    yield { x: yy + x, y: xx + y };\n    yield { x: -xx + x, y: yy + y };\n    yield { x: -yy + x, y: xx + y };\n    yield { x: -xx + x, y: -yy + y };\n    yield { x: -yy + x, y: -xx + y };\n    yield { x: xx + x, y: -yy + y };\n    yield { x: yy + x, y: -xx + y }\n    yy++;\n    if (radiusError < 0) {\n      radiusError += 2 * yy + 1;\n    } else {\n      xx--;\n      radiusError += 2 * (yy - xx + 1);\n    }\n  }\n}\n\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance } from \"../point/Distance.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns all integer points contained within `circle`.\n * \n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const xMin = circle.x - circle.radius;\n  const xMax = circle.x + circle.radius;\n  const yMin = circle.y - circle.radius;\n  const yMax = circle.y + circle.radius;\n  for (let x = xMin; x < xMax; x++) {\n    for (let y = yMin; y < yMax; y++) {\n      const r = Math.abs(distance(circle, x, y));\n      if (r <= circle.radius) yield { x, y };\n    }\n  }\n}","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { guard, isCirclePositioned } from \"./Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { minIndex } from \"../../numbers/NumericArrays.js\";\nconst piPi = Math.PI * 2;\n\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n * \n * ```js\n * import { Circles } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n * \n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle: CirclePositioned | ReadonlyArray<CirclePositioned>, b: Point): Point => {\n  const n = (a: CirclePositioned): Point => {\n    const l = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n    const x = a.x + (a.radius * ((b.x - a.x) / l));\n    const y = a.y + (a.radius * ((b.y - a.y) / l));\n    return { x, y };\n  };\n\n  if (Array.isArray(circle)) {\n    const pts = circle.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, b));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(circle as CirclePositioned));\n  }\n};\n\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * // Circle without position\n * const circleA = { radius: 5 };\n * \n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n * \n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param Origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point): Point => {\n  if (origin === undefined) {\n    origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n    y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n  };\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle \n * @returns \n */\nexport const circumference = (circle: Circle): number => {\n  guard(circle);\n  return piPi * circle.radius;\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle \n * @returns \n */\nexport const length = (circle: Circle): number => circumference(circle);\n","import type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport { pointOnPerimeter } from \"./Perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 100, x: 100, y: 100 };\n * \n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle \n * @param t Position, 0-1\n * @returns \n */\nexport const interpolate = (circle: CirclePositioned, t: number): Point => pointOnPerimeter(circle, t * piPi);\n","import type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/Multiply.js';\n\nexport function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport function multiplyScalar(a: Circle, value: number): Circle;\n\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n * \n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n * \n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a: Circle | CirclePositioned, value: number): Circle | CirclePositioned {\n  if (isCirclePositioned(a)) {\n    const pt = PointsMultiplyScalar(a, value);\n    return Object.freeze({\n      ...a,\n      ...pt,\n      radius: a.radius * value\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      radius: a.radius * value\n    });\n  }\n}\n\n","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCircle, isCirclePositioned } from \"./Guard.js\";\n\ntype ToSvg = {\n  (circleOrRadius: Circle | number, sweep: boolean, origin: Point): ReadonlyArray<string>;\n  (circle: CirclePositioned, sweep: boolean): ReadonlyArray<string>;\n};\n\n\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns \n */\nexport const toSvg: ToSvg = (a: CirclePositioned | number | Circle, sweep: boolean, origin?: Point): ReadonlyArray<string> => {\n  if (isCircle(a)) {\n    if (origin !== undefined) {\n      return toSvgFull(a.radius, origin, sweep);\n    }\n    if (isCirclePositioned(a)) {\n      return toSvgFull(a.radius, a, sweep);\n    } else throw new Error(`origin parameter needed for non-positioned circle`);\n  } else {\n    if (origin === undefined) { throw new Error(`origin parameter needed`); } else {\n      return toSvgFull(a, origin, sweep);\n    }\n  }\n};\n\nconst toSvgFull = (radius: number, origin: Point, sweep: boolean): ReadonlyArray<string> => {\n  // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n  const { x, y } = origin;\n  const s = sweep ? `1` : `0`;\n  return `\n    M ${ x }, ${ y }\n    m -${ radius }, 0\n    a ${ radius },${ radius } 0 1,${ s } ${ radius * 2 },0\n    a ${ radius },${ radius } 0 1,${ s } -${ radius * 2 },0\n  `.split(`\\n`);\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { bbox } from \"./Bbox.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { CircularPath } from \"./CircularPath.js\";\nimport { guard } from \"./Guard.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport { nearest } from \"./Perimeter.js\";\nimport { toSvg } from \"./Svg.js\";\nimport { circumference } from \"./Perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle: CirclePositioned): CircularPath => {\n  guard(circle);\n\n  return {\n    ...circle,\n    nearest: (point: Point) => nearest(circle, point),\n    /**\n     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n     * @param {t} Relative (0.0-1.0) point\n     * @returns {Point} X,y\n     */\n    interpolate: (t: number) => interpolate(circle, t),\n    bbox: () => bbox(circle),\n    length: () => circumference(circle),\n    toSvgString: (sweep = true) => toSvg(circle, sweep),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `circular`\n  };\n};","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\nimport { getPointParameter } from \"../point/GetPointParameter.js\";\n\n\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle \n * @param defaultPositionOrX \n * @param y \n * @returns \n */\nexport const toPositioned = (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number): CirclePositioned => {\n  if (isCirclePositioned(circle)) return circle;\n\n  // Returns 0,0 if params are undefined\n  const pt = getPointParameter(defaultPositionOrX, y);\n  return Object.freeze({\n    ...circle,\n    ...pt\n  });\n};","export * from './Area.js';\nexport * from './Cardinal.js';\nexport * from './Center.js';\nexport * from './Corners.js';\nexport * from './Distance.js';\nexport * from './Edges.js';\nexport * from './Empty.js';\nexport * from './FromCenter.js';\nexport * from './FromElement.js';\nexport * from './FromNumbers.js';\nexport * from './FromTopLeft.js';\nexport * from './GetRectPositionedParameter.js';\nexport * from './Guard.js';\nexport * from './Intersects.js';\nexport * from './IsEqual.js';\nexport * from './Lengths.js';\nexport * from './Max.js';\nexport * from './Multiply.js';\nexport * from './NormaliseByRect.js';\nexport * from './Random.js';\nexport type * from './RectTypes.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './ToArray.js';","import { guard } from \"./Guard.js\";\nimport type { Rect } from \"./RectTypes.js\";\n\n/**\n * Returns the area of `rect`\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect: Rect): number => {\n  guard(rect);\n  return rect.height * rect.width;\n};","import type { RectPositioned } from \"./RectTypes.js\";\nimport type { CardinalDirection } from '../Grid.js';\nimport type { Point } from \"../point/PointType.js\";\n\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (\n  rect: RectPositioned,\n  card: CardinalDirection | `center`\n): Point => {\n  const { x, y, width, height } = rect;\n  switch (card) {\n    case `nw`: {\n      return Object.freeze({ x, y });\n    }\n    case `n`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y,\n      });\n    }\n    case `ne`: {\n      return Object.freeze({\n        x: x + width,\n        y,\n      });\n    }\n    case `sw`: {\n      return Object.freeze({ x, y: y + height });\n    }\n    case `s`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height,\n      });\n    }\n    case `se`: {\n      return Object.freeze({\n        x: x + width,\n        y: y + height,\n      });\n    }\n    case `w`: {\n      return Object.freeze({ x, y: y + height / 2 });\n    }\n    case `e`: {\n      return Object.freeze({ x: x + width, y: y + height / 2 });\n    }\n    case `center`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height / 2,\n      });\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown direction: ${ card }`);\n    }\n  }\n};","import { isPoint } from \"../point/Guard.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/JoinPointsToLines.js';\n\nimport type { Point } from '../point/PointType.js';\nimport { corners } from \"./Corners.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Line> => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","export const empty = Object.freeze({ width: 0, height: 0 });\nexport const emptyPositioned = Object.freeze({\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n});","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el: HTMLElement): Rect => ({\n  width: el.clientWidth,\n  height: el.clientHeight,\n});","import type { RectPositioned, Rect } from \"./RectTypes.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport function fromNumbers(width: number, height: number): Rect;\n\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function fromNumbers(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): RectPositioned;\n\n/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function fromNumbers(\n  xOrWidth: number,\n  yOrHeight: number,\n  width?: number,\n  height?: number\n): Rect | RectPositioned {\n  if (width === undefined || height === undefined) {\n    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);\n    if (typeof yOrHeight !== `number`) {\n      throw new TypeError(`height is not an number`);\n    }\n    return Object.freeze({ width: xOrWidth, height: yOrHeight });\n  }\n  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);\n  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);\n  if (typeof width !== `number`) throw new Error(`width is not an number`);\n  if (typeof height !== `number`) throw new Error(`height is not an number`);\n\n  return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { isRect, isRectPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a \n * @param b \n * @param c \n * @param d \n * @returns \n */\nexport function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned {\n  if (typeof a === `number`) {\n    if (typeof b === `number`) {\n      if (typeof c === `number` && typeof d === `number`) {\n        return { x: a, y: b, width: c, height: d }\n      } else if (isRect(c)) {\n        return { x: a, y: b, width: c.width, height: c.height }\n      } else {\n        throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n      }\n    } else {\n      throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n    }\n  } else if (isRectPositioned(a)) {\n    return a;\n  } else if (isRect(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { width: a.width, height: a.height, x: b, y: c };\n    } else if (isPoint(b)) {\n      return { width: a.width, height: a.height, x: b.x, y: b.y };\n    } else {\n      throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n    }\n  } else if (isPoint(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { x: a.x, y: a.y, width: b, height: c };\n    } else if (isRect(b)) {\n      return { x: a.x, y: a.y, width: b.width, height: b.height };\n    } else {\n      throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n    }\n  }\n  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n\n","import { isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a: Rect, b: Rect): boolean => {\n  if (a === undefined) throw new Error(`a undefined`);\n  if (b === undefined) throw new Error(`b undefined`);\n  return a.width === b.width && a.height === b.height;\n};\n\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (\n  a: Rect | RectPositioned,\n  b: Rect | RectPositioned\n): boolean => {\n  if (isPositioned(a) && isPositioned(b)) {\n    if (!PointsIsEqual(a, b)) return false;\n    return a.width === b.width && a.height === b.height;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    return a.width === b.width && a.height === b.height;\n  } else {\n    // One param is positioned, the other is not\n    return false;\n  }\n};","import { length as LinesLength } from '../line/Length.js';\n\nimport { edges } from './Edges.js';\nimport { guardPositioned } from './Guard.js';\nimport type { RectPositioned } from './RectTypes.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect: RectPositioned): ReadonlyArray<number> => {\n  guardPositioned(rect, `rect`);\n  return edges(rect).map((l) => LinesLength(l));\n};\n","import { guard } from \"./Guard.js\";\nimport type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./Guard.js\";\n\n/**\n * Multiplies `a` by rectangle or width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle of width 50%, height 50%\n * const r = {width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n *\n * // Returns {width: someRect.width * 100, height: someRect.height * 200}\n * Rects.multiply(someRect, 100, 200);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(\n  a: RectPositioned,\n  b: Rect | number,\n  c?: number\n): RectPositioned;\n\n/**\n * Multiplies `a` by rectangle or width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle of width 50%, height 50%\n * const r = {width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n *\n * // Returns {width: someRect.width * 100, height: someRect.height * 200}\n * Rects.multiply(someRect, 100, 200);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(a: Rect, b: Rect | number, c?: number): Rect;\nexport function multiply(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Multiplies `a` by rectangle or width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle of width 50%, height 50%\n * const r = {width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n *\n * // Returns {width: someRect.width * 100, height: someRect.height * 200}\n * Rects.multiply(someRect, 100, 200);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\n//eslint-disable-next-line func-style\nexport function multiply(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  guard(a, `a`);\n  if (isRect(b)) {\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: a.x * b.width,\n      y: a.y * b.height,\n      width: a.width * b.width,\n      height: a.height * b.height,\n    }) : Object.freeze({\n      ...a,\n      width: a.width * b.width,\n      height: a.height * b.height,\n    });\n  } else {\n    if (typeof b !== `number`) {\n      throw new TypeError(\n        `Expected second parameter of type Rect or number. Got ${ JSON.stringify(\n          b\n        ) }`\n      );\n    }\n    if (c === undefined) c = b;\n\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: a.x * b,\n      y: a.y * c,\n      width: a.width * b,\n      height: a.height * c,\n    }) : Object.freeze({\n      ...a,\n      width: a.width * b,\n      height: a.height * c,\n    });\n  }\n}\n\n/**\n * Multiplies all components of `rect` by `amount`\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect: Rect, amount: number): Rect;\n/**\n * Multiplies all components of `rect` by `amount`\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n/**\n * Multiplies all components of `rect` by `amount`\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return isPositioned(rect) ? Object.freeze({\n    ...rect,\n    x: rect.x * amount,\n    y: rect.y * amount,\n    width: rect.width * amount,\n    height: rect.height * amount,\n  }) : Object.freeze({\n    ...rect,\n    width: rect.width * amount,\n    height: rect.height * amount,\n  });\n}\n","import { isPositioned, isRect } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns `rect` divided by the width,height of `normaliseBy`.\n * This can be useful for normalising based on camera frame.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const frameSize = {width: 640, height: 320};\n * const object = { x: 320, y: 160, width: 64, height: 32};\n *\n * const n = Rects.normaliseByRect(object, frameSize);\n * // Yields: {x: 0.5, y: 0.5, width: 0.1, height: 0.1}\n * ```\n *\n * Height and width can be supplied instead of a rectangle too:\n * ```js\n * const n = Rects.normaliseByRect(object, 640, 320);\n * ```\n * @param rect\n * @param normaliseBy\n * @returns\n */\nexport const normaliseByRect = (\n  rect: Rect | RectPositioned,\n  normaliseByOrWidth: Rect | number,\n  height?: number\n): Rect | RectPositioned => {\n  //eslint-disable-next-line functional/no-let\n  let width;\n  if (height === undefined) {\n    if (isRect(normaliseByOrWidth)) {\n      height = normaliseByOrWidth.height;\n      width = normaliseByOrWidth.width;\n    } else {\n      throw new Error(\n        `Expects rectangle or width and height parameters for normaliseBy`\n      );\n    }\n  } else {\n    if (typeof normaliseByOrWidth === `number`) {\n      width = normaliseByOrWidth;\n    } else {\n      throw new TypeError(\n        `Expects rectangle or width and height parameters for normaliseBy`\n      );\n    }\n  }\n\n  return isPositioned(rect) ? Object.freeze({\n    x: rect.x / width,\n    y: rect.y / height,\n    width: rect.width / width,\n    height: rect.height / height,\n  }) : Object.freeze({\n    width: rect.width / width,\n    height: rect.height / height,\n  });\n};","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function subtract(a: Rect, b: Rect): Rect;\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport function subtract(a: Rect, width: number, height?: number): Rect;\n\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function subtract(a: Rect | undefined, b: Rect | number, c?: number): Rect {\n  if (a === undefined) throw new Error(`First parameter undefined`);\n  if (typeof b === `number`) {\n    const height = c ?? 0;\n    return Object.freeze({\n      ...a,\n      width: a.width - b,\n      height: a.height - height,\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      width: a.width - b.width,\n      height: a.height - b.height,\n    });\n  }\n}\n","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function sum(a: Rect, b: Rect): Rect;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport function sum(a: Rect, width: number, height?: number): Rect;\n\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function sum(a: Rect, b: Rect | number, c?: number): Rect {\n  if (a === undefined) throw new Error(`First parameter undefined`);\n  if (typeof b === `number`) {\n    const height = c ?? 0;\n    return Object.freeze({\n      ...a,\n      width: a.width + b,\n      height: a.height + height,\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      width: a.width + b.width,\n      height: a.height + b.height,\n    });\n  }\n}\n","import { isPositioned, isRect } from \"./Guard.js\";\nimport type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./RectTypes.js\";\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: Rect): RectArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: RectPositioned): RectPositionedArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n// eslint-disable-next-line func-style\nexport function toArray(\n  rect: Rect | RectPositioned\n): RectArray | RectPositionedArray {\n  if (isPositioned(rect)) {\n    return [ rect.x, rect.y, rect.width, rect.height ];\n  } else if (isRect(rect)) {\n    return [ rect.width, rect.height ];\n  } else {\n    throw new Error(\n      `Param 'rect' is not a rectangle. Got: ${ JSON.stringify(rect) }`\n    );\n  }\n}\n","import type { Point } from '../point/PointType.js';\nimport { isLine } from '../line/Guard.js';\nimport type { Path } from './PathType.js';\nimport { isQuadraticBezier } from '../bezier/Guard.js';\nexport * from './PathType.js';\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.a;\n  else if (isLine(path)) return path.a;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.b;\n  else if (isLine(path)) return path.b;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n","import type { Path } from \"../path/PathType.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./BezierType.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n","import type { Point } from './point/PointType.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/FromTopLeft.js';\nimport { throwIntegerTest, throwNumberTest } from '../util/GuardNumbers.js';\nimport { clampIndex } from '../data/Clamp.js';\nimport { randomElement } from '../data/arrays/Random.js';\nimport { type ISetMutable, mutable } from '../collections/set/index.js';\nimport { zipKeyValue } from '../data/maps/MapFns.js';\nimport type { RectPositioned } from './rect/RectTypes.js';\n\nexport type GridVisual = Grid & {\n  readonly size: number;\n};\n\nexport type Grid = {\n  readonly rows: number;\n  readonly cols: number;\n};\n\nexport type Cell = {\n  readonly x: number;\n  readonly y: number;\n};\n\nexport type Neighbours = {\n  readonly n: Cell | undefined;\n  readonly e: Cell | undefined;\n  readonly s: Cell | undefined;\n  readonly w: Cell | undefined;\n  readonly ne: Cell | undefined;\n  readonly nw: Cell | undefined;\n  readonly se: Cell | undefined;\n  readonly sw: Cell | undefined;\n};\n\nexport type CardinalDirection =\n  | `n`\n  | `ne`\n  | `e`\n  | `se`\n  | `s`\n  | `sw`\n  | `w`\n  | `nw`;\nexport type CardinalDirectionOptional = CardinalDirection | ``;\n\nexport type BoundsLogic = `unbounded` | `undefined` | `stop` | `wrap`;\n\nexport type VisitorLogic = {\n  readonly options?: IdentifyNeighbours;\n  readonly select: NeighbourSelector;\n};\nexport type VisitGenerator = Generator<Readonly<Cell>, void>;\nexport type VisitorOpts = {\n  readonly visited?: ISetMutable<Cell>;\n  readonly reversed?: boolean;\n  readonly debug?: boolean;\n  readonly boundsWrap?: BoundsLogic;\n};\n\n/**\n * Visitor function.\n *\n * Implementations:\n * * {@link cells}: left-to-right, top-to-bottom. Same as {@link visitorRow}\n * * {@link visitorBreadth}, {@link visitorDepth}\n * * {@link visitorColumn}: top-to-bottom, left-to-right.\n * * {@link visitorRandom}: Any unvisited location\n * * {@link visitorRandomContiguous}: A random direct neighbour of current cell\n */\nexport type Visitor = (\n  grid: Grid,\n  start: Cell,\n  opts?: VisitorOpts\n) => VisitGenerator;\n\nexport type NeighbourMaybe = readonly [ keyof Neighbours, Cell | undefined ];\nexport type Neighbour = readonly [ keyof Neighbours, Cell ];\n\n/**\n * A function that returns a value (or _undefined_) based on a _cell_\n *\n * Implementations:\n * * {@link access1dArray}: For accessing a single-dimension array as a grid\n */\nexport type CellAccessor<V> = (cell: Cell, wrap: BoundsLogic) => V | undefined;\n\n/**\n * Neighbour selector logic. For a given set of `neighbours` pick one to visit next.\n */\nexport type NeighbourSelector = (\n  neighbours: ReadonlyArray<Neighbour>\n) => Neighbour | undefined;\n\n/**\n * Identify neighbours logic. For a given `grid` and `origin`, return a list of neighbours\n */\nexport type IdentifyNeighbours = (\n  grid: Grid,\n  origin: Cell\n) => ReadonlyArray<Neighbour>;\n\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nconst isCell = (cell: Cell | undefined): cell is Cell => {\n  if (cell === undefined) return false;\n  return `x` in cell && `y` in cell;\n};\n\n/**\n * Returns true if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (\n  n: Neighbour | NeighbourMaybe | undefined\n): n is Neighbour => {\n  if (n === undefined) return false;\n  if (n[ 1 ] === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (\n  a: Grid | GridVisual,\n  b: Grid | GridVisual\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  if (`rows` in a && `cols` in a) {\n    if (`rows` in b && `cols` in b) {\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\n    } else return false;\n  }\n  if (`size` in a) {\n    if (`size` in b) {\n      if (a.size !== b.size) return false;\n    } else return false;\n  }\n  return true;\n};\n\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v: Cell): string => `Cell{${ v.x },${ v.y }}`;\n\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (\n  a: Cell | undefined,\n  b: Cell | undefined\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  return a.x === b.x && a.y === b.y;\n};\n\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (\n  cell: Cell,\n  parameterName = `Param`,\n  grid?: Grid\n) => {\n  if (cell === undefined) {\n    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n  }\n  if (cell.x === undefined) throw new Error(parameterName + `.x is undefined`);\n  if (cell.y === undefined) throw new Error(parameterName + `.y is undefined`);\n  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);\n  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);\n  if (!Number.isInteger(cell.x)) {\n    throw new TypeError(parameterName + `.x is non-integer`);\n  }\n  if (!Number.isInteger(cell.y)) {\n    throw new TypeError(parameterName + `.y is non-integer`);\n  }\n  if (grid !== undefined && !inside(grid, cell)) {\n    throw new Error(\n      `${ parameterName } is outside of grid. Cell: ${ cell.x },${ cell.y } Grid: ${ grid.cols }, ${ grid.rows }`\n    );\n  }\n};\n\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nconst guardGrid = (grid: Grid, parameterName = `Param`) => {\n  if (grid === undefined) {\n    throw new Error(`${ parameterName } is undefined. Expecting grid.`);\n  }\n  if (!(`rows` in grid)) throw new Error(`${ parameterName }.rows is undefined`);\n  if (!(`cols` in grid)) throw new Error(`${ parameterName }.cols is undefined`);\n\n  if (!Number.isInteger(grid.rows)) {\n    throw new TypeError(`${ parameterName }.rows is not an integer`);\n  }\n  if (!Number.isInteger(grid.cols)) {\n    throw new TypeError(`${ parameterName }.cols is not an integer`);\n  }\n};\n\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid: Grid, cell: Cell): boolean => {\n  if (cell.x < 0 || cell.y < 0) return false;\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\n  return true;\n};\n\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (\n  grid: GridVisual,\n  cell: Cell\n): RectPositioned => {\n  guardCell(cell);\n  const size = grid.size;\n  const x = cell.x * size;\n  const y = cell.y * size;\n  const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n  return r;\n};\n\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(\n  grid: GridVisual\n): IterableIterator<RectPositioned> {\n  for (const c of cells(grid)) {\n    yield rectangleForCell(grid, c);\n  }\n}\n\n/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const toArray = <V>(grid: Grid, initialValue?: V): Array<Array<V>> => {\n  const returnValue = [];\n  //eslint-disable-next-line functional/no-let\n  for (let row = 0; row < grid.rows; row++) {\n    //eslint-disable-next-line functional/immutable-data\n    returnValue[ row ] = Array.from<V>({ length: grid.cols });\n    if (initialValue) {\n      //eslint-disable-next-line functional/no-let\n      for (let col = 0; col < grid.cols; col++) {\n        //eslint-disable-next-line functional/immutable-data\n        returnValue[ row ][ col ] = initialValue;\n      }\n    }\n  }\n  return returnValue;\n};\n\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (\n  grid: GridVisual,\n  position: Point\n): Cell | undefined => {\n  const size = grid.size;\n  throwNumberTest(size, `positive`, `grid.size`);\n  if (position.x < 0 || position.y < 0) return;\n  const x = Math.floor(position.x / size);\n  const y = Math.floor(position.y / size);\n  if (x >= grid.cols) return;\n  if (y >= grid.rows) return;\n  return { x, y };\n};\n\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n  `n`,\n  `ne`,\n  `nw`,\n  `e`,\n  `s`,\n  `se`,\n  `sw`,\n  `w`,\n]) as ReadonlyArray<CardinalDirection>;\n\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n  `n`,\n  `e`,\n  `s`,\n  `w`,\n]) as ReadonlyArray<CardinalDirection>;\n\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (\n  grid: Grid,\n  cell: Cell,\n  bounds: BoundsLogic = `undefined`,\n  directions?: ReadonlyArray<CardinalDirection>\n): Neighbours => {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  return zipKeyValue<Cell>(directories, points) as Neighbours;\n};\n\nexport function* visitNeigbours(\n  grid: Grid,\n  cell: Cell,\n  bounds: BoundsLogic = `undefined`,\n  directions?: ReadonlyArray<CardinalDirection>\n) {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  for (const pt of points) {\n    if (pt !== undefined) yield pt;\n  }\n}\n\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid: GridVisual, cell: Cell): Point => {\n  guardCell(cell);\n\n  const size = grid.size;\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n  return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};\n\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start: Cell, end: Cell): ReadonlyArray<Cell> => {\n  // https://stackoverflow.com/a/4672319\n  guardCell(start);\n  guardCell(end);\n\n  // eslint-disable-next-line functional/no-let\n  let startX = start.x;\n  // eslint-disable-next-line functional/no-let\n  let startY = start.y;\n  const dx = Math.abs(end.x - startX);\n  const dy = Math.abs(end.y - startY);\n  const sx = startX < end.x ? 1 : -1;\n  const sy = startY < end.y ? 1 : -1;\n  // eslint-disable-next-line functional/no-let\n  let error = dx - dy;\n\n  const cells = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // eslint-disable-next-line functional/immutable-data\n    cells.push(Object.freeze({ x: startX, y: startY }));\n    if (startX === end.x && startY === end.y) break;\n    const error2 = 2 * error;\n    if (error2 > -dy) {\n      error -= dy;\n      startX += sx;\n    }\n    if (error2 < dx) {\n      error += dx;\n      startY += sy;\n    }\n  }\n  return cells;\n};\n\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bound Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (\n  grid: Grid,\n  start: Cell,\n  steps: number,\n  bounds: BoundsLogic = `stop`\n): Neighbours => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  throwIntegerTest(steps, `aboveZero`, `steps`);\n\n  const directions = allDirections;\n  const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n  const cells = directions.map((d, index) =>\n    offset(grid, start, vectors[ index ], bounds)\n  );\n\n  return zipKeyValue(directions, cells) as Neighbours;\n};\n\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (\n  cardinal: CardinalDirectionOptional,\n  multiplier = 1\n): Cell => {\n  // eslint-disable-next-line functional/no-let\n  let v;\n  switch (cardinal) {\n    case `n`: {\n      v = { x: 0, y: -1 * multiplier };\n      break;\n    }\n    case `ne`: {\n      v = { x: 1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    case `e`: {\n      v = { x: 1 * multiplier, y: 0 };\n      break;\n    }\n    case `se`: {\n      v = { x: 1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `s`: {\n      v = { x: 0, y: 1 * multiplier };\n      break;\n    }\n    case `sw`: {\n      v = { x: -1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `w`: {\n      v = { x: -1 * multiplier, y: 0 };\n      break;\n    }\n    case `nw`: {\n      v = { x: -1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    default: {\n      v = { x: 0, y: 0 };\n    }\n  }\n  return Object.freeze(v);\n};\n\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (\n  start: Cell,\n  end: Cell,\n  endInclusive = false\n): ReadonlyArray<Cell> {\n  // eslint-disable-next-line functional/prefer-readonly-type\n  const cells: Array<Cell> = [];\n  if (start.x === end.x) {\n    // Vertical\n    const lastY = endInclusive ? end.y + 1 : end.y;\n    // eslint-disable-next-line functional/no-let\n    for (let y = start.y; y < lastY; y++) {\n      // eslint-disable-next-line functional/immutable-data\n      cells.push({ x: start.x, y: y });\n    }\n  } else if (start.y === end.y) {\n    // Horizontal\n    const lastX = endInclusive ? end.x + 1 : end.x;\n    // eslint-disable-next-line functional/no-let\n    for (let x = start.x; x < lastX; x++) {\n      // eslint-disable-next-line functional/immutable-data\n      cells.push({ x: x, y: start.y });\n    }\n  } else {\n    throw new Error(\n      `Only does vertical and horizontal: ${ start.x },${ start.y } - ${ end.x },${ end.y }`\n    );\n  }\n  return cells;\n};\n\n/**\n *\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (\n  grid: Grid,\n  start: Cell,\n  vector: Cell,\n  bounds: BoundsLogic = `undefined`\n): Cell | undefined {\n  guardCell(start, `start`, grid);\n  guardCell(vector);\n  guardGrid(grid, `grid`);\n\n  // eslint-disable-next-line functional/no-let\n  let x = start.x;\n  // eslint-disable-next-line functional/no-let\n  let y = start.y;\n  switch (bounds) {\n    case `wrap`: {\n      x += vector.x % grid.cols;\n      y += vector.y % grid.rows;\n      if (x < 0) x = grid.cols + x;\n      else if (x >= grid.cols) {\n        x -= grid.cols;\n      }\n      if (y < 0) y = grid.rows + y;\n      else if (y >= grid.rows) {\n        y -= grid.rows;\n      }\n      break;\n    }\n    case `stop`: {\n      x += vector.x;\n      y += vector.y;\n      x = clampIndex(x, grid.cols);\n      y = clampIndex(y, grid.rows);\n      break;\n    }\n    case `undefined`: {\n      x += vector.x;\n      y += vector.y;\n      if (x < 0 || y < 0) return;\n      if (x >= grid.cols || y >= grid.rows) return;\n      break;\n    }\n    case `unbounded`: {\n      x += vector.x;\n      y += vector.y;\n      break;\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n    }\n  }\n  return Object.freeze({ x, y });\n};\n\nconst neighbourList = (\n  grid: Grid,\n  cell: Cell,\n  directions: ReadonlyArray<CardinalDirection>,\n  bounds: BoundsLogic\n): ReadonlyArray<NeighbourMaybe> => {\n  // Get neighbours for cell\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\n\n  // Filter out undefined cells\n  const entries = Object.entries(cellNeighbours);\n  return (entries as Array<NeighbourMaybe>).filter(n => isNeighbour(n));\n};\n\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a MutableValueSet. This is\n * updated with visited cells (and is used internally anyway)\n * ```js\n *  let visited = new mutableValueSet<Grids.Cell>(c => Grids.cellKeyString(c));\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param neighbourSelect Select neighbour to visit\n * @param grid Grid to visit\n * @param start Starting cell\n * @param visited Optional tracker of visited cells\n * @returns Cells\n */\nexport const visitor = function* (\n  logic: VisitorLogic,\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n): VisitGenerator {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  const v = opts.visited ?? mutable<Cell>(cellKeyString);\n  const possibleNeighbours = logic.options ?? ((g: Grid, c: Cell) => neighbourList(g, c, crossDirections, `undefined`));\n\n  if (!isCell(start)) {\n    throw new Error(`'start' parameter is undefined or not a cell`);\n  }\n\n  let cellQueue: Array<Cell> = [ start ];\n  let moveQueue: Array<Neighbour> = [];\n  let current: Cell | undefined = undefined;\n\n  while (cellQueue.length > 0) {\n    if (current === undefined) {\n      const nv = cellQueue.pop();\n      if (nv === undefined) {\n        break;\n      }\n      current = nv;\n    }\n\n    if (!v.has(current)) {\n      v.add(current);\n      yield current;\n\n      const nextSteps = possibleNeighbours(grid, current).filter(\n        (step) => {\n          if (step[ 1 ] === undefined) return false;\n          return !v.has(step[ 1 ])\n        }\n      );\n\n      if (nextSteps.length === 0) {\n        // No more moves for this cell\n        if (current !== undefined) {\n          cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n        }\n      } else {\n        for (const n of nextSteps) {\n          if (n === undefined) continue;\n          if (n[ 1 ] === undefined) continue;\n          // @ts-expect-error\n          moveQueue.push(n);\n        }\n        //moveQueue.push(...nextSteps);\n      }\n    }\n\n    // Remove steps already made\n    moveQueue = moveQueue.filter((step) => !v.has(step[ 1 ]));\n\n    if (moveQueue.length === 0) {\n      current = undefined;\n    } else {\n      // Pick move\n      const potential = logic.select(moveQueue);\n      if (potential !== undefined) {\n        // eslint-disable-next-line functional/immutable-data\n        cellQueue.push(potential[ 1 ]);\n        current = potential[ 1 ];\n      }\n    }\n  }\n};\n\nexport const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n  visitor(\n    {\n      select: (nbos) => nbos.at(-1),\n    },\n    grid,\n    start,\n    opts\n  );\n\nexport const visitorBreadth = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n) =>\n  visitor(\n    {\n      select: (nbos) => nbos[ 0 ],\n    },\n    grid,\n    start,\n    opts\n  );\n\nconst randomNeighbour = (nbos: ReadonlyArray<Neighbour>) => randomElement(nbos); // .filter(isNeighbour));\n\nexport const visitorRandomContiguous = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n) =>\n  visitor(\n    {\n      select: randomNeighbour,\n    },\n    grid,\n    start,\n    opts\n  );\n\n/**\n * Visit by following rows. Normal order is left-to-right, top-to-bottom.\n * @param grid\n * @param start\n * @param opts\n * @returns\n */\nexport const visitorRandom = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n) =>\n  visitor(\n    {\n      options: (grid, cell) => {\n        const t: Array<Neighbour> = [];\n        for (const c of cells(grid, cell)) {\n          // eslint-disable-next-line functional/immutable-data\n          t.push([ `n`, c ]);\n        }\n        return t;\n      },\n      select: randomNeighbour,\n    },\n    grid,\n    start,\n    opts\n  );\n\nexport const visitorRow = (\n  grid: Grid,\n  start?: Cell,\n  opts: VisitorOpts = {}\n) => {\n  if (!start) start = { x: 0, y: 0 }\n\n  const { reversed = false } = opts;\n\n  const neighbourSelect = (nbos: ReadonlyArray<Neighbour>) =>\n    nbos.find((n) => n[ 0 ] === (reversed ? `w` : `e`));\n\n  const possibleNeighbours = (\n    grid: Grid,\n    cell: Cell\n  ): ReadonlyArray<Neighbour> => {\n    if (reversed) {\n      // WALKING BACKWARD ALONG ROW\n      if (cell.x > 0) {\n        // All fine, step to the left\n        cell = { x: cell.x - 1, y: cell.y };\n      } else {\n        // At the beginning of a row\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (cell.y > 0) {\n          // Wrap to next row up\n          cell = { x: grid.cols - 1, y: cell.y - 1 };\n        } else {\n          // Wrap to end of grid\n          cell = { x: grid.cols - 1, y: grid.rows - 1 };\n        }\n      }\n    } else {\n      /*\n       * WALKING FORWARD ALONG ROWS\n       */\n      if (cell.x < grid.rows - 1) {\n        // All fine, step to the right\n        cell = { x: cell.x + 1, y: cell.y };\n      } else {\n        // At the end of a row\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (cell.y < grid.rows - 1) {\n          // More rows available, wrap to next row down\n          cell = { x: 0, y: cell.y + 1 };\n        } else {\n          // No more rows available, wrap to start of the grid\n          cell = { x: 0, y: 0 };\n        }\n      }\n    }\n    return [ [ reversed ? `w` : `e`, cell ] ];\n  };\n\n  const logic: VisitorLogic = {\n    select: neighbourSelect,\n    options: possibleNeighbours,\n  };\n\n  return visitor(logic, grid, start, opts);\n};\n\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n *\n * ```js\n * // Get a cell 10 steps away (row-wise) from start\n * const cell = visitFor(grid, start, 10, visitorRow);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param steps Number of steps\n * @param visitor Visitor function\n * @returns\n */\nexport const visitFor = (\n  grid: Grid,\n  start: Cell,\n  steps: number,\n  visitor: Visitor\n): Cell => {\n  throwIntegerTest(steps, ``, `steps`);\n\n  const opts: VisitorOpts = {\n    reversed: steps < 0,\n  };\n  steps = Math.abs(steps);\n\n  // eslint-disable-next-line functional/no-let\n  let c = start;\n  // eslint-disable-next-line functional/no-let\n  let v = visitor(grid, start, opts);\n  v.next(); // Burn up starting cell\n\n  // eslint-disable-next-line functional/no-let\n  let stepsMade = 0;\n\n  while (stepsMade < steps) {\n    stepsMade++;\n    const { value } = v.next();\n    if (value) {\n      c = value;\n      if (opts.debug) {\n        console.log(\n          `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n        );\n      }\n    } else {\n      if (steps >= grid.cols * grid.rows) {\n        steps -= grid.cols * grid.rows;\n        stepsMade = 0;\n        v = visitor(grid, start, opts);\n        v.next();\n        c = start;\n        if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n      } else throw new Error(`Value not received by visitor`);\n    }\n  }\n  return c;\n};\n\n/**\n * Visits cells running down columns, left-to-right.\n * @param grid Grid to traverse\n * @param start Start cell\n * @param opts Options\n * @returns Visitor generator\n */\nexport const visitorColumn = (\n  grid: Grid,\n  start: Cell,\n  opts: VisitorOpts = {}\n): VisitGenerator => {\n  const { reversed = false } = opts;\n  const logic: VisitorLogic = {\n    select: (nbos) => nbos.find((n) => n[ 0 ] === (reversed ? `n` : `s`)),\n    options: (grid, cell): ReadonlyArray<Neighbour> => {\n      if (reversed) {\n        // WALK UP COLUMN, RIGHT-TO-LEFT\n        if (cell.y > 0) {\n          // Easy case\n          cell = { x: cell.x, y: cell.y - 1 };\n        } else {\n          // Top of column\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.x === 0) {\n            // Top-left corner, need to wrap\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          } else {\n            cell = { x: cell.x - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n        if (cell.y < grid.rows - 1) {\n          // Easy case, move down by one\n          cell = { x: cell.x, y: cell.y + 1 };\n        } else {\n          // End of column\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.x < grid.cols - 1) {\n            // Move to next column and start at top\n            cell = { x: cell.x + 1, y: 0 };\n          } else {\n            // Move to start of grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `n` : `s`, cell ] ];\n    },\n  };\n  return visitor(logic, grid, start, opts);\n};\n\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid: Grid, start?: Cell) {\n  if (!start) start = { x: 0, y: 0 }\n  //eslint-disable-next-line functional/no-let\n  let row = start.y;\n  //eslint-disable-next-line functional/no-let\n  let rowCells: Array<Cell> = [];\n\n  for (const c of cells(grid, start)) {\n    if (c.y === row) {\n      //eslint-disable-next-line functional/immutable-data\n      rowCells.push(c);\n    } else {\n      yield rowCells;\n      rowCells = [ c ];\n      row = c.y;\n    }\n  }\n  if (rowCells.length > 0) yield rowCells;\n};\n\n/**\n * Enumerate all cells in an efficient manner. Runs left-to-right, top-to-bottom.\n * If end of grid is reached, iterator will wrap to ensure all are visited.\n *\n * @param grid\n * @param start\n */\nexport const cells = function* (grid: Grid, start?: Cell) {\n  if (!start) start = { x: 0, y: 0 }\n\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  // eslint-disable-next-line functional/no-let\n  let { x, y } = start;\n  // eslint-disable-next-line functional/no-let\n  let canMove = true;\n  do {\n    yield { x, y };\n    x++;\n    if (x === grid.cols) {\n      y++;\n      x = 0;\n    }\n    if (y === grid.rows) {\n      y = 0;\n      x = 0;\n    }\n    if (x === start.x && y === start.y) canMove = false; // Complete\n  } while (canMove);\n};\n\nexport const access1dArray = <V>(\n  array: ReadonlyArray<V>,\n  cols: number\n): CellAccessor<V> => {\n  const grid = { cols, rows: Math.ceil(array.length / cols) };\n  const fn: CellAccessor<V> = (\n    cell: Cell,\n    wrap: BoundsLogic\n  ): V | undefined => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined) return undefined;\n    return array[ index ];\n  };\n  return fn;\n};\n\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.array2dUpdater(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n  const fn = (v: V, position: Point) => {\n    const pos = cellAtPoint(grid, position);\n    if (pos === undefined) {\n      throw new Error(\n        `Position does not exist. Pos: ${ JSON.stringify(\n          position\n        ) } Grid: ${ JSON.stringify(grid) }`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    array[ pos.y ][ pos.x ] = v;\n  };\n  return fn;\n};\n\n/**\n * Visits a grid packed into an array.\n *\n * @example By default visits left-to-right, top-to-bottom:\n * ```js\n * const data = [1, 2, 3, 4, 5, 6];\n * const cols = 2;\n * for (const [value,index] of visitArray(data, cols)) {\n *  // Yields: 1, 2, 3, 4, 5, 6\n * }\n * ```\n *\n * @example\n * ```js\n * ```\n * @param array Array\n * @param cols Columns\n * @param iteratorFunction Visitor function\n * @param opts Options\n */\nexport function* visitArray<V>(\n  array: ReadonlyArray<V>,\n  cols: number,\n  iteratorFunction?: Visitor,\n  opts?: VisitorOpts\n): IterableIterator<readonly [ data: V, index: number ]> {\n  if (typeof array === `undefined`) {\n    throw new TypeError(`First parameter is undefined, expected an array`);\n  }\n  if (array === null) throw new Error(`First parameter is null, expected an array`);\n  if (!Array.isArray(array)) throw new Error(`First parameter should be an array`);\n\n  throwIntegerTest(cols, `aboveZero`, `cols`);\n  if (array.length === 0) return;\n\n  const wrap = opts?.boundsWrap ?? `stop`;\n  const rows = Math.ceil(array.length / cols);\n  const grid: Grid = {\n    cols,\n    rows,\n  };\n\n  if (iteratorFunction === undefined) iteratorFunction = cells;\n  const iter = iteratorFunction(grid, { x: 0, y: 0 }, opts);\n  for (const cell of iter) {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined) return undefined;\n    yield [ array[ index ], index ];\n  }\n}\n\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param colsOrGrid\n * @param cell\n * @returns\n */\nexport const indexFromCell = (\n  grid: Grid,\n  cell: Cell,\n  wrap: BoundsLogic\n): number | undefined => {\n  guardGrid(grid, `grid`);\n\n  //eslint-disable-next-line functional/no-let\n\n  if (cell.x < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        //cell = { ...cell, x: grid.cols + cell.x };\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`)!;\n        break;\n      }\n    }\n  }\n  if (cell.y < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: grid.rows + cell.y };\n        break;\n      }\n    }\n  }\n  if (cell.x >= grid.cols) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: grid.cols - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, x: cell.x % grid.cols };\n        break;\n      }\n    }\n  }\n  if (cell.y >= grid.rows) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: grid.rows - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: cell.y % grid.rows };\n        break;\n      }\n    }\n  }\n\n  const index = cell.y * grid.cols + cell.x;\n\n  return index;\n};\n\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (\n  colsOrGrid: number | Grid,\n  index: number\n): Cell => {\n  //eslint-disable-next-line functional/no-let\n  let cols = 0;\n  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n  throwIntegerTest(cols, `aboveZero`, `colsOrGrid`);\n\n  return {\n    x: index % cols,\n    y: Math.floor(index / cols),\n  };\n};\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/Interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport type { Point } from '../point/PointType.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './BezierType.js';\nimport { isCubicBezier, isQuadraticBezier } from './Guard.js';\nexport * from './BezierType.js';\nexport * from './Guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  // eslint-disable-next-line functional/no-let\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\nexport const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n  const q = quadraticSimple(start, end, bend);\n  const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n  return bzr.compute(amt);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","\n//import { Points, Paths } from '../index.js';\nimport * as Paths from '../path/index.js';\nimport { bbox as PointsBbox } from '../point/Bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\nimport type { CompoundPath, Dimensions, Path, RectPositioned } from '../Types.js';\nimport type { Point } from '../point/PointType.js';\nimport { corners as RectsCorners } from '../rect/Corners.js';\nimport { sortByNumericProperty } from '../../data/arrays/Sort.js';\n\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Path): CompoundPath => {\n  const existing = [ ...compoundPath.segments ];\n  //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n  existing[ index ] = path;\n  return fromPaths(...existing);\n};\n\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths: ReadonlyArray<Path>, t: number, useWidth?: boolean, dimensions?: Dimensions) => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n\n  // Expected value to land on\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n  let soFar = 0;\n\n  // Use widths or lengths?\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\n  for (const [ index, element ] of l.entries()) {\n    if (soFar + element >= expected) {\n      const relative = expected - soFar;\n      let amt = relative / element;\n      if (amt > 1) amt = 1;\n      return paths[ index ].interpolate(amt);\n    } else soFar += element;\n  }\n  return { x: 0, y: 0 };\n};\n\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths \n * @param point \n * @returns \n */\nexport const distanceToPoint = (paths: ReadonlyArray<Path>, point: Point): number => {\n  if (paths.length === 0) return 0;\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length === 0) throw new Error(`Could not look up distances`);\n  return distances[ 0 ].distance;\n}\n\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold \n * @param dimensions Pre-computed dimensions\n * @returns \n */\nexport const relativePosition = (paths: ReadonlyArray<Path>, point: Point, intersectionThreshold: number, dimensions?: Dimensions): number => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length < 0) throw new Error(`Point does not intersect with path`);\n  const d = distances[ 0 ];\n  if (d.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${ d.distance }, threshold: ${ intersectionThreshold }`);\n\n  const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n\n  // Add up distances\n  let accumulated = 0;\n  for (let index = 0; index < d.index; index++) {\n    // Add up length of paths before closest path segment\n    accumulated += dimensions.lengths[ index ];\n  }\n\n  // Add up partial amount of closest path\n  accumulated += dimensions.lengths[ d.index ] * relativePositionOnPath;\n  const accumulatedRel = accumulated / dimensions.totalLength;\n  console.log(`acc: ${ accumulated } rel: ${ accumulatedRel } on path: ${ relativePositionOnPath } path: ${ d.index }`);\n  return accumulatedRel;\n}\n\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths: ReadonlyArray<Path>): Dimensions => {\n  const widths = paths.map(l => l.bbox().width);\n  const lengths = paths.map(l => l.length());\n  let totalLength = 0;\n  let totalWidth = 0;\n  for (const length of lengths) {\n    totalLength += length;\n  }\n  for (const width of widths) {\n    totalWidth += width;\n  }\n\n  return { totalLength, totalWidth, widths, lengths };\n};\n\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths: ReadonlyArray<Path>): RectPositioned => {\n  const boxes = paths.map(p => p.bbox());\n  const corners = boxes.flatMap(b => RectsCorners(b));\n\n  return PointsBbox(...corners);\n};\n\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths: ReadonlyArray<Path>): string => paths.map(p => p.toString()).join(`, `);\n\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths: ReadonlyArray<Path>) => {\n  let lastPos = Paths.getEnd(paths[ 0 ]);\n  for (let index = 1; index < paths.length; index++) {\n    const start = Paths.getStart(paths[ index ]);\n    if (!PointsIsEqual(start, lastPos)) throw new Error(`Path index ${ index } does not start at prior path end. Start: ${ start.x },${ start.y } expected: ${ lastPos.x },${ lastPos.y }`);\n    lastPos = Paths.getEnd(paths[ index ]);\n  }\n};\n\nexport const toSvgString = (paths: ReadonlyArray<Path>): ReadonlyArray<string> => paths.flatMap(p => p.toSvgString());\n\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths: ReadonlyArray<Path>): CompoundPath => {\n  guardContinuous(paths); // Throws an error if paths are not connected\n  const dims = computeDimensions(paths);\n\n  return Object.freeze({\n    segments: paths,\n    length: () => dims.totalLength,\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    interpolate: (t: number, useWidth = false) => interpolate(paths, t, useWidth, dims),\n    relativePosition: (point: Point, intersectionThreshold: number) => relativePosition(paths, point, intersectionThreshold, dims),\n    distanceToPoint: (point: Point) => distanceToPoint(paths, point),\n    bbox: () => bbox(paths),\n    toString: () => toString(paths),\n    toSvgString: () => toSvgString(paths),\n    kind: `compound`\n  });\n};\n","\nimport type { Point } from './point/PointType.js';\nimport { degreeToRadian } from './Angles.js';\nimport type { Path } from './path/index.js';\n\n/**\n * An ellipse\n */\nexport type Ellipse = {\n  readonly radiusX: number\n  readonly radiusY: number\n  /**\n   * Rotation, in radians\n   */\n  readonly rotation?: number\n  readonly startAngle?: number\n  readonly endAngle?: number\n}\n\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse\n\n\nexport const fromDegrees = (radiusX: number, radiusY: number, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360): Ellipse => ({\n  radiusX, radiusY,\n  rotation: degreeToRadian(rotationDeg),\n  startAngle: degreeToRadian(startAngleDeg),\n  endAngle: degreeToRadian(endAngleDeg)\n});\n\nexport type EllipticalPath = Ellipse & Path & {\n  readonly kind: `elliptical`\n};","import type { Point } from \"./point/PointType.js\";\nimport { distance } from \"./point/Distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpShortestDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = distanceFromPointToLine(points[ index_ ], firstPoint, lastPoint);\n\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpShortestDistance(l1, epsilon);\n    const r2 = rdpShortestDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];//concat(r2);\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpPerpendicularDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = findPerpendicularDistance(points[ index_ ], firstPoint, lastPoint);\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpPerpendicularDistance(l1, epsilon);\n    const r2 = rdpPerpendicularDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n\nfunction findPerpendicularDistance(p: Point, p1: Point, p2: Point) {\n  // if start and end point are on the same x the distance is the difference in X.\n  let result;\n  let slope;\n  let intercept;\n  if (p1.x == p2.x) {\n    result = Math.abs(p.x - p1.x);\n  } else {\n    slope = (p2.y - p1.y) / (p2.x - p1.x);\n    intercept = p1.y - (slope * p1.x);\n    result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n  }\n\n  return result;\n}\n\n\nconst distanceFromPointToLine = (p: Point, index: Point, index_: Point) => {\n  const lineLength = distance(index, index_);//First, we need the length of the line segment.\n  if (lineLength == 0) {\t//if it's 0, the line is actually just a point.\n    return distance(p, index);\n  }\n  const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n\n  //t is very important. t is a number that essentially compares the individual coordinates\n  //distances between the point and each point on the line.\n\n  if (t < 0) {\t//if t is less than 0, the point is behind i, and closest to i.\n    return distance(p, index);\n  }\t//if greater than 1, it's closest to j.\n  if (t > 1) {\n    return distance(p, index_);\n  }\n  return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n}\n\n\n","import { type TraversableTree } from '../collections/tree/Types.js';\nimport * as Shapes from './shape/index.js';\nimport type { Point } from './point/PointType.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/FromTopLeft.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/From.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/RectTypes.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n  /**\n   * Maximum items per node\n   */\n  readonly maxItems: number;\n  /**\n   * Maximum level of sub-division\n   */\n  readonly maxLevels: number;\n};\n\n/**\n * Direction\n */\nexport enum Direction {\n  Nw,\n  Ne,\n  Sw,\n  Se,\n}\n\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds: RectPositioned, initialData: ReadonlyArray<QuadTreeItem> = [], opts: Partial<QuadTreeOpts> = {}): QuadTreeNode => {\n  const o: QuadTreeOpts = {\n    maxItems: opts.maxItems ?? 4,\n    maxLevels: opts.maxLevels ?? 4\n  };\n\n  const n = new QuadTreeNode(undefined, bounds, 0, o);\n  for (const d of initialData) {\n    n.add(d);\n  }\n  return n;\n};\n\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n * \n */\nexport class QuadTreeNode implements TraversableTree<Array<QuadTreeItem>> {\n  #items: Array<QuadTreeItem> = [];\n  #children: Array<QuadTreeNode> = [];\n  #parent: QuadTreeNode | undefined;\n  /**\n   * Constructor\n   * @param boundary\n   * @param level\n   * @param opts\n   */\n  constructor(\n    parent: QuadTreeNode | undefined,\n    readonly boundary: RectPositioned,\n    readonly level: number,\n    readonly opts: QuadTreeOpts\n  ) {\n    this.#parent = parent;\n  }\n\n  getLengthChildren(): number {\n    return this.#children.length;\n  }\n\n  *parents(): IterableIterator<QuadTreeNode> {\n    //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n    let n: QuadTreeNode | undefined = this;\n    while (n.#parent !== undefined) {\n      yield n.#parent;\n      n = n.#parent;\n    }\n  }\n\n  getParent() {\n    return this.#parent;\n  }\n\n  /**\n   * Iterates over immediate children\n   */\n  *children(): IterableIterator<QuadTreeNode> {\n    for (const c of this.#children) {\n      yield c;\n    }\n  }\n\n  /**\n   * Array of QuadTreeItem\n   * @returns\n   */\n  getValue() {\n    return this.#items;\n  }\n\n  getIdentity() {\n    return this;\n  }\n  /**\n   * Get a descendant node in a given direction\n   * @param d\n   * @returns\n   */\n  direction(d: Direction): QuadTreeNode | undefined {\n    return this.#children[ d ] as QuadTreeNode | undefined;\n  }\n\n  /**\n   * Add an item to the quadtree\n   * @param p\n   * @returns False if item is outside of boundary, True if item was added\n   */\n  add(p: QuadTreeItem): boolean {\n    if (!Shapes.isIntersecting(this.boundary, p)) return false;\n\n    if (this.#children.length > 0) {\n      for (const d of this.#children) (d).add(p);\n      return true;\n    }\n\n    this.#items.push(p);\n\n    if (\n      this.#items.length > this.opts.maxItems &&\n      this.level < this.opts.maxLevels\n    ) {\n      if (this.#children.length === 0) {\n        this.#subdivide();\n      }\n\n      // Add to child\n      for (const item of this.#items) {\n        for (const d of this.#children) (d).add(item);\n      }\n      //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n      this.#items = [];\n    }\n    return true;\n  }\n\n  /**\n   * Returns true if point is inside node's boundary\n   * @param p\n   * @returns\n   */\n  couldHold(p: Point) {\n    return RectsIntersectsPoint(this.boundary, p);\n  }\n\n  #subdivide() {\n    const w = this.boundary.width / 2;\n    const h = this.boundary.height / 2;\n    const x = this.boundary.x;\n    const y = this.boundary.y;\n\n    // top-left corners of each of the four new sections\n    const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n    const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n    // rects.forEach((r, index) => {\n    //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n    // });\n    this.#children = rects.map(\n      (r) => new QuadTreeNode(this, r, this.level + 1, this.opts)\n    );\n  }\n}\n","\nimport type { Point } from './point/PointType.js';\nimport type { Rect } from './rect/index.js';\nimport { isPoint } from './point/index.js';\nimport { isRect } from './rect/Guard.js';\nimport { placeholder as PlaceholderRect } from './rect/Placeholder.js';\n\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (\n  a: number | Point,\n  b?: number | Rect,\n  c?: number | Rect,\n  d?: number\n) => Point;\n\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n  /**\n   * Relative to absolute coordinates\n   */\n  readonly abs: Scaler;\n  /**\n   * Absolute to relative coordintes\n   */\n  readonly rel: Scaler;\n\n  readonly width: number;\n\n  readonly height: number;\n\n  computeScale(): Point\n};\n\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (\n  scaleBy: ScaleBy = `both`,\n  defaultRect?: Rect\n): ScalerCombined => {\n  const defaultBounds = defaultRect ?? PlaceholderRect;\n\n  let sw = 1;\n  let sh = 1;\n  let s = { x: 1, y: 1 };\n\n  const computeScale = () => {\n    switch (scaleBy) {\n      case `height`: {\n        return { x: sh, y: sh };\n      }\n      case `width`: {\n        return { x: sw, y: sw };\n      }\n      case `min`: {\n        return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n      }\n      case `max`: {\n        return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n      }\n      default: {\n        return { x: sw, y: sh };\n      }\n    }\n  };\n\n  const normalise = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): [ x: number, y: number, w: number, h: number ] => {\n    let inX = Number.NaN;\n    let inY = Number.NaN;\n    let outW = defaultBounds.width;\n    let outH = defaultBounds.height;\n\n    if (typeof a === `number`) {\n      inX = a;\n      if (typeof b === `number`) {\n        inY = b;\n        if (c === undefined) return [ inX, inY, outW, outH ];\n        if (isRect(c)) {\n          outW = c.width;\n          outH = c.height;\n        } else if (typeof c === `number`) {\n          outW = c;\n          if (typeof d === `number`) {\n            outH = d;\n          } else {\n            throw new TypeError(`Missing final height value`);\n          }\n        } else throw new Error(`Missing valid output range`);\n      } else if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else {\n        throw new Error(\n          `Expected input y or output Rect to follow first number parameter`\n        );\n      }\n    } else if (isPoint(a)) {\n      inX = a.x;\n      inY = a.y;\n      if (b === undefined) return [ inX, inY, outW, outH ];\n      if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else if (typeof b === `number`) {\n        outW = b;\n        if (typeof c === `number`) {\n          outH = c;\n        } else {\n          throw new TypeError(\n            `Expected height as third parameter after Point and output width`\n          );\n        }\n      } else {\n        throw new TypeError(\n          `Expected Rect or width as second parameter when first parameter is a Point`\n        );\n      }\n    } else {\n      throw new Error(`Expected input Point or x value as first parameter`);\n    }\n    return [ inX, inY, outW, outH ];\n  };\n\n  const scaleAbs = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(true, ...n);\n  };\n\n  const scaleRel = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(false, ...n);\n  };\n\n  const scaleNormalised = (\n    abs: boolean,\n    x: number,\n    y: number,\n    w: number,\n    h: number\n  ): Point => {\n    if (Number.isNaN(w)) throw new Error(`Output width range missing`);\n    if (Number.isNaN(h)) throw new Error(`Output height range missing`);\n\n    // If output dimensions has changed since last, create a new scale\n    if (w !== sw || h !== sh) {\n      sw = w;\n      sh = h;\n      s = computeScale();\n    }\n\n    return abs ? {\n      x: x * s.x,\n      y: y * s.y,\n    } : {\n      x: x / s.x,\n      y: y / s.y,\n    };\n  };\n\n  return {\n    computeScale,\n    rel: scaleRel,\n    abs: scaleAbs,\n    width: defaultBounds.width,\n    height: defaultBounds.height\n  };\n};\n\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }","export const placeholder = Object.freeze({\n  width: Number.NaN,\n  height: Number.NaN,\n});\nexport const placeholderPositioned = Object.freeze({\n  x: Number.NaN,\n  y: Number.NaN,\n  width: Number.NaN,\n  height: Number.NaN,\n});\n","import { type Rgb } from '../visual/Colour.js';\nimport * as ImageDataGrid from '../visual/ImageDataGrid.js';\nimport * as Grids from './Grid.js';\n\nexport type Kernel = ReadonlyArray<ReadonlyArray<number>>;\nexport type CellWithValue<V> = readonly [ cell: Grids.Cell, value: V | undefined ];\nexport type ScalarAndValue<V> = readonly [ scalar: number, v: V | undefined ];\nexport type KernelCompute = <V>(offset: Grids.Cell, value: V) => V;\nexport type KernelReduce<V> = (values: ReadonlyArray<ScalarAndValue<V>>) => V | undefined;\n\n/**\n * Multiply every element of kernel by the same `scalar` value.\n * Returns new result, input is unmodified\n * @param kernel \n * @param scalar \n * @returns \n */\nexport const multiply = (kernel: Kernel, scalar: number): Kernel => {\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  const copy: Array<Array<number>> = [];\n  //eslint-disable-next-line functional/no-let\n  for (let row = 0; row < rows; row++) {\n    //eslint-disable-next-line functional/immutable-data\n    copy[ row ] = [];\n    //eslint-disable-next-line functional/no-let\n    for (let col = 0; col < cols; col++) {\n      //eslint-disable-next-line functional/immutable-data\n      copy[ row ][ col ] = kernel[ row ][ col ] * scalar;\n    }\n  }\n  return copy;\n};\n\n\nexport function convolveCell<V>(c: Grids.Cell, kernel: Kernel2dArray, source: Grids.Grid, access: Grids.CellAccessor<V>, reduce: KernelReduce<V>): V | undefined {\n  const valuesAtKernelPos: Array<ScalarAndValue<V>> = kernel.map(o => {\n    const pos = Grids.offset(source, c, o[ 0 ], `stop`); // `stop` avoids fringing at extents of image\n    if (!pos) return [ o[ 1 ], undefined ];\n    return [ o[ 1 ], access(pos, `undefined`) ];\n  });\n  return reduce(valuesAtKernelPos);\n}\n\n/**\n * Performs kernel-based convolution over `image`.\n * @param kernel \n * @param image \n */\nexport function* convolveImage(kernel: Kernel, image: ImageData) {\n  const grid = { rows: image.width, cols: image.height };\n  const imageDataAsGrid = ImageDataGrid.accessor(image);\n\n  yield* convolve(kernel, grid, imageDataAsGrid, Grids.cells(grid), rgbReducer);\n}\n\nexport function* convolve<V>(kernel: Kernel, source: Grids.Grid, access: Grids.CellAccessor<V>, visitor: Grids.VisitGenerator, reduce: KernelReduce<V>, origin?: Grids.Cell): IterableIterator<CellWithValue<V>> {\n\n  //const wrap:Grids.BoundsLogic = `undefined`;\n  // Use middle, eg 3x3 = 1,1\n  if (!origin) {\n    const kernelRows = kernel.length;\n    const kernelCols = kernel[ 0 ].length;\n    origin = { x: Math.floor(kernelRows / 2), y: Math.floor(kernelCols / 2) };\n  }\n\n  const asArray = kernel2dToArray(kernel, origin);\n  for (const c of visitor) {\n    const v = convolveCell<V>(c, asArray, source, access, reduce);\n    yield [ c, v ];\n  }\n}\n\nexport type Kernel2dArray = ReadonlyArray<readonly [ cell: Grids.Cell, value: number ]>;\n\n/**\n * For a given kernel, returns an array of offsets. These\n * consist of a cell offset (eg `{x:-1,y:-1}`) and the value at that kernel position.\n * @param kernel \n * @param origin \n * @returns \n */\nexport const kernel2dToArray = (kernel: Kernel, origin?: Grids.Cell): Kernel2dArray => {\n  const offsets: Kernel2dArray = [];\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  if (!origin) origin = { x: Math.floor(rows / 2), y: Math.floor(cols / 2) };\n\n  //eslint-disable-next-line functional/no-let\n  for (let xx = 0; xx < rows; xx++) {\n    //eslint-disable-next-line functional/no-let\n    for (let yy = 0; yy < cols; yy++) {\n      //eslint-disable-next-line functional/immutable-data\n      // @ts-expect-error\n      offsets.push([ { x: xx - origin.x, y: yy - origin.y }, kernel[ xx ][ yy ] ]);\n    }\n  }\n  return offsets;\n};\n\nexport const rgbReducer: KernelReduce<Rgb> = (values: ReadonlyArray<ScalarAndValue<Rgb>>) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  //eslint-disable-next-line functional/no-let\n  let g = 0;\n  //eslint-disable-next-line functional/no-let\n  let b = 0;\n  //eslint-disable-next-line functional/no-let\n  const opacity = 0;\n  //eslint-disable-next-line functional/no-let\n  for (const value of values) {\n    const rgb = value[ 1 ];\n    const scale = value[ 0 ];\n    if (rgb === undefined) continue;\n    if (rgb.opacity === 0) continue;\n    if (scale === 0) continue;\n    r += (rgb.r * scale);\n    g += (rgb.g * scale);\n    b += (rgb.b * scale);\n    //opacity += ((rgb.opacity ?? 1) * scale);\n  }\n\n  const result = {\n    r: r,\n    g: g,\n    b: b,\n    opacity: 255,\n    space: `srgb`\n  } as const;\n  return result;\n};\nexport const identityKernel = [\n  [ 0, 0, 0 ],\n  [ 0, 1, 0 ],\n  [ 0, 0, 0 ]\n];\n\n\nexport const edgeDetectionKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 4, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const sharpenKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 5, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const boxBlurKernel = multiply([\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ]\n], 1 / 9);\n\nexport const gaussianBlur3Kernel = multiply([\n  [ 1, 2, 1 ],\n  [ 2, 4, 2 ],\n  [ 1, 2, 1 ]\n], 1 / 16);\n\nexport const gaussianBlur5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, 36, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], 1 / 256);\n\nexport const unsharpMasking5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, -476, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], -1 / 256);","import * as Grids from '../geometry/Grid.js';\nimport type { Rgb } from './Colour.js';\n\nexport const accessor = (image: ImageData): Grids.CellAccessor<Rgb> => {\n  const grid = { rows: image.width, cols: image.height };\n  const data = image.data;\n\n  const fn: Grids.CellAccessor<Rgb> = (cell: Grids.Cell, bounds) => {\n    const index = Grids.indexFromCell(grid, cell, bounds);\n    if (index === undefined) {\n      return undefined;\n    }\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n","import { degreeToRadian } from '../Angles.js';\nimport { guard as guardPoint, isPoint } from '../point/Guard.js';\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { bbox as pointsBbox } from '../point/Bbox.js';\nimport { toCartesian } from '../Polar.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Line } from '../line/LineType.js';\nimport type { Path } from '../path/index.js';\nimport type { Rect, RectPositioned } from '../rect/index.js';\nimport { fromPoints as LinesFromPoints } from '../line/FromPoints.js';\nimport type { Arc, ArcPositioned } from './ArcType.js';\n\nexport type * from './ArcType.js';\n\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns \n */\nexport const isArc = (p: unknown): p is Arc => (p as Arc).startRadian !== undefined && (p as Arc).endRadian !== undefined;\n\n/**\n * Returns true if parameter has a positioned (x,y) \n * @param p Point, Arc or ArcPositiond\n * @returns \n */\nexport const isPositioned = (p: Point | Arc | ArcPositioned): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n\nconst piPi = Math.PI * 2;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number): Arc;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @returns Arc\n */export function fromDegrees(radius: number, startDegrees: number, endDegrees: number, origin: Point): ArcPositioned\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @returns Arc\n */\n//eslint-disable-next-line func-style\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, origin?: Point): Arc | ArcPositioned {\n  const a: Arc = {\n    radius,\n    startRadian: degreeToRadian(startDegrees),\n    endRadian: degreeToRadian(endDegrees)\n  };\n  if (isPoint(origin)) {\n    guardPoint(origin);\n    const ap: ArcPositioned = {\n      ...a,\n      x: origin.x,\n      y: origin.y\n    };\n    return Object.freeze(ap);\n  } else {\n    return Object.freeze(a);\n  }\n}\n\n/**\n * Returns a {@link Geometry.Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc: ArcPositioned): Line => LinesFromPoints(\n  point(arc, arc.startRadian),\n  point(arc, arc.endRadian)\n);\n\n/**\n * Calculates a coordinate on an arc, based on an angle\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate \n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point): Point => {\n  if (angleRadian > arc.endRadian) throw new Error(`angleRadian beyond end angle of arc`);\n  if (angleRadian < arc.startRadian) throw new Error(`angleRadian beyond start angle of arc`);\n\n  if (origin === undefined) {\n    origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n    y: (Math.sin(angleRadian) * arc.radius) + origin.y\n  };\n};\n\n/**\n * Throws an error if arc instance is invalid\n * @param arc \n */\nexport const guard = (arc: Arc | ArcPositioned) => {\n  if (arc === undefined) throw new Error(`Arc is undefined`);\n  if (isPositioned(arc)) {\n    guardPoint(arc, `arc`);\n  }\n  if (arc.radius === undefined) throw new Error(`Arc radius is undefined (${ JSON.stringify(arc) })`);\n  if (typeof arc.radius !== `number`) throw new Error(`Radius must be a number`);\n  if (Number.isNaN(arc.radius)) throw new Error(`Radius is NaN`);\n  if (arc.radius <= 0) throw new Error(`Radius must be greater than zero`);\n\n  if (arc.startRadian === undefined) throw new Error(`Arc is missing 'startRadian' field`);\n  if (arc.endRadian === undefined) throw new Error(`Arc is missing 'startRadian' field`);\n  if (Number.isNaN(arc.endRadian)) throw new Error(`Arc endRadian is NaN`);\n  if (Number.isNaN(arc.startRadian)) throw new Error(`Arc endRadian is NaN`);\n\n  if (arc.startRadian >= arc.endRadian) throw new Error(`startRadian is expected to be les than endRadian`);\n};\n\n\ntype Interpolate = {\n  (amount: number, arc: Arc, origin: Point): Point;\n  (amount: number, arc: ArcPositioned): Point;\n};\n\n/**\n * Compute relative position on arc\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @returns \n */\nexport const interpolate: Interpolate = (amount: number, arc: ArcPositioned | Arc, origin?: Point): Point => {\n  guard(arc);\n  return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n\n/**\n * Creates a {@link Geometry.Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc \n * @returns Path\n */\nexport const toPath = (arc: ArcPositioned): Path => {\n  guard(arc);\n\n  return Object.freeze({\n    ...arc,\n    nearest: (point: Point) => { throw new Error(`not implemented`); },\n    interpolate: (amount: number) => interpolate(amount, arc),\n    bbox: () => bbox(arc) as RectPositioned,\n    length: () => length(arc),\n    toSvgString: () => toSvg(arc),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `arc`\n  });\n};\n\n/**\n * Calculates the length of the arc\n * @param arc \n * @returns Length\n */\nexport const length = (arc: Arc): number => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n\n/**\n * Calculates a {@link Geometry.Rect | Rect} bounding box for arc.\n * @param arc \n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc: ArcPositioned | Arc): RectPositioned | Rect => {\n  if (isPositioned(arc)) {\n    const middle = interpolate(0.5, arc);\n    const asLine = toLine(arc);\n    return pointsBbox(middle, asLine.a, asLine.b);\n  } else {\n    return {\n      width: arc.radius * 2,\n      height: arc.radius * 2\n    };\n  }\n};\n\n\ntype ToSvg = {\n  /**\n   * SVG path for arc description\n   * @param origin Origin of arc\n   * @param radius Radius\n   * @param startRadian Start\n   * @param endRadian End\n   */\n  (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: SvgOpts): ReadonlyArray<string>;\n  /**\n   * SVG path for non-positioned arc\n   */\n  (arc: Arc, origin: Point, opts?: SvgOpts): ReadonlyArray<string>;\n  /**\n   * SVG path for positioned arc\n   */\n  (arc: ArcPositioned, opts?: SvgOpts): ReadonlyArray<string>;\n};\n\n\n/**\n * Creates an SV path snippet for arc\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg: ToSvg = (a: Point | Arc | ArcPositioned, b?: number | Point | SvgOpts, c?: number | SvgOpts, d?: number, e?: SvgOpts) => {\n  if (isArc(a)) {\n    if (isPositioned(a)) {\n      return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b as SvgOpts);\n    } else {\n      return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as SvgOpts) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n    }\n  } else {\n    if (c === undefined) throw new Error(`startAngle undefined`);\n    if (d === undefined) throw new Error(`endAngle undefined`);\n\n    if (isPoint(a)) {\n      if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n        return toSvgFull(a, b, c, d, e);\n      } else {\n        throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n      }\n    } else {\n      throw new Error(`Expected (point, number, number, number). Missing first point.`);\n    }\n  }\n};\n\nexport type SvgOpts = {\n\n  /**\n   * \"If the arc should be greater or less than 180 degrees\"\n   * ie. tries to maximise arc length\n   */\n  readonly largeArc?: boolean\n\n  /**\n   * \"If the arc should begin moving at positive angles\"\n   * ie. the kind of bend it makes to reach end point\n   */\n  readonly sweep?: boolean\n}\n\nconst toSvgFull = (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: SvgOpts): ReadonlyArray<string> => {\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n  // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n  // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n\n  if (opts === undefined || typeof opts !== `object`) opts = {};\n\n  const isFullCircle = endRadian - startRadian === 360;\n  const start = toCartesian(radius, endRadian - 0.01, origin);\n  const end = toCartesian(radius, startRadian, origin);\n\n  const { largeArc = false, sweep = false } = opts;\n\n  const d = [ `\n    M ${ start.x } ${ start.y }\n    A ${ radius } ${ radius } 0 ${ largeArc ? `1` : `0` } ${ sweep ? `1` : `0` } ${ end.x } ${ end.y },\n  `];\n\n  //eslint-disable-next-line functional/immutable-data\n  if (isFullCircle) d.push(`z`);\n\n  return d;\n};\n\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b \n * @returns Distance \n */\nexport const distanceCenter = (a: ArcPositioned, b: ArcPositioned): number => pointsDistance(a, b);\n\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a: Arc | ArcPositioned, b: Arc | ArcPositioned): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isPositioned(a) && isPositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  if (a.endRadian !== b.endRadian) return false;\n  if (a.startRadian !== b.startRadian) return false;\n  return true;\n};","import type { Line } from './line/LineType.js';\nimport type { Point } from './point/PointType.js';\nimport { normalise as PointsNormalise } from './point/Normalise.js';\nimport { isPoint } from './point/Guard.js';\n//import * as Points from './point/index.js'\nimport * as Polar from './Polar.js';\nimport type { Vector } from './Types.js';\nimport { divide as PointDivide } from './point/Divider.js';\nimport { guard as LinesGuard } from './line/Guard.js';\nimport { sum as PointsSum } from './point/Sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/Multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/DotProduct.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/Magnitude.js';\nimport { distance as PointsDistance } from './point/Distance.js';\nimport { Empty as PointEmpty } from './point/Empty.js';\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\n\nexport const fromRadians = (radians: number) => {\n  return Object.freeze({\n    x: Math.cos(radians),\n    y: Math.sin(radians)\n  });\n}\n\nexport const toRadians = (point: Point) => {\n  return Math.atan2(point.y, point.x);\n}\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2π\n * if `bipolar` normalisation is used, direction will be fixed to -π...π\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (\n  pt: Point,\n  angleNormalisation: `` | `unipolar` | `bipolar` = ``,\n  origin: Point = EmptyCartesian\n): Polar.Coord => {\n  pt = PointsSubtract(pt, origin);\n\n  //eslint-disable-next-line functional/no-let\n  let direction = Math.atan2(pt.y, pt.x);\n  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi;\n  else if (angleNormalisation === `bipolar`) {\n    if (direction > pi) direction -= piPi;\n    else if (direction <= -pi) direction += piPi;\n  }\n\n  return Object.freeze({\n    distance: PointsDistance(pt),\n    angleRadian: direction,\n  });\n};\n\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line: Line): Point =>\n  PointsSubtract(line.b, line.a);\n\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line: Line): Polar.Coord => {\n  LinesGuard(line, `line`);\n  const pt = PointsSubtract(line.b, line.a);\n  return fromPointPolar(pt);\n};\n\nconst isPolar = (v: Vector): v is Polar.Coord => {\n  if (Polar.isPolarCoord(v)) return true;\n  return false;\n};\n\nconst isCartesian = (v: Vector): v is Point => {\n  if (isPoint(v)) return true;\n  return false;\n};\n\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v: Vector): Vector => {\n  if (isPolar(v)) {\n    return Polar.normalise(v);\n  } else if (isCartesian(v)) {\n    return PointsNormalise(v);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\nexport const quadrantOffsetAngle = (p: Point): number => {\n  if (p.x >= 0 && p.y >= 0) return 0; // Q1\n  if (p.x < 0 && p.y >= 0) return pi; // Q2\n  if (p.x < 0 && p.y < 0) return pi; // Q3\n  return piPi; // Q4\n};\n\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v: Vector, origin = PointEmpty): Polar.Coord => {\n  if (isPolar(v)) {\n    return v;\n  } else if (isCartesian(v)) {\n    return Polar.fromCartesian(v, origin);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v: Vector): Point => {\n  if (isPolar(v)) {\n    return Polar.toPoint(v);\n  } else if (isCartesian(v)) {\n    return v;\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v: Vector, digits?: number) => {\n  if (isPolar(v)) {\n    return Polar.toString(v, digits);\n  } else if (isCartesian(v)) {\n    return PointsToString(v, digits);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Vector, b: Vector) => {\n  if (isPolar(a) && isPolar(b)) {\n    return Polar.dotProduct(a, b);\n  } else if (isCartesian(a) && isCartesian(b)) {\n    return PointsDotProduct(a, b);\n  }\n  throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v: Vector, max = 1, min = 0) => {\n  if (isPolar(v)) {\n    return Polar.clampMagnitude(v, max, min);\n  } else if (isCartesian(v)) {\n    return PointsClampMagnitude(v, max, min);\n  }\n  throw new Error(`Expected either polar or Cartesian vector`);\n};\n\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSum(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSubtract(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsMultiply(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointDivide(a, b);\n  return polar ? toPolar(c) : c;\n};\n","import type { Point, Point3d } from './point/PointType.js';\nimport type { Circle, CirclePositioned } from './circle/CircleType.js';\nimport type { Sphere } from './shape/index.js';\n\nimport { toPositioned as circleToPositioned } from './circle/ToPositioned.js';\nimport { scale } from '../data/Scale.js';\nimport { linearSpace } from '../numbers/LinearSpace.js';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n  /**\n   * Upper limit of points to produce.\n   * By default, 5000.\n   */\n  readonly maxPoints?: number;\n  /**\n   * Density value (0..1) which determines spacing of points.\n   * This is useful because it scales with whatever circle radius is given\n   * Use this parameter OR the `spacing` parameter.\n   */\n  readonly density?: number;\n  /**\n   * Spacing between points.\n   * Use this option OR the density value.\n   */\n  readonly spacing?: number;\n  /**\n   * Rotation offset to apply, in radians. 0 by default\n   */\n  readonly rotation?: number;\n};\n\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(\n  circle?: Circle,\n  opts: VogelSpiralOpts = {}\n): IterableIterator<Point> {\n  const maxPoints = opts.maxPoints ?? 5000;\n  const density = opts.density ?? 0.95;\n  const rotationOffset = opts.rotation ?? 0;\n\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const max = c.radius;\n  //eslint-disable-next-line functional/no-let\n  let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n  if (opts.spacing) spacing = opts.spacing;\n\n  //eslint-disable-next-line functional/no-let\n  let radius = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n  //eslint-disable-next-line functional/no-let\n  let angle = 0;\n  while (count < maxPoints && radius < max) {\n    radius = spacing * count ** 0.5;\n    angle = rotationOffset + (count * 2 * pi) / goldenSection;\n    yield Object.freeze({\n      x: c.x + radius * cos(angle),\n      y: c.y + radius * sin(angle),\n    });\n    count++;\n  }\n}\n\nexport type CircleRingsOpts = {\n  readonly rings?: number;\n  /**\n   * Rotation offset, in radians\n   */\n  readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(\n  circle?: Circle | CirclePositioned,\n  opts: CircleRingsOpts = {}\n): IterableIterator<Point> {\n  const rings = opts.rings ?? 5;\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const ringR = 1 / rings;\n  const rotationOffset = opts.rotation ?? 0;\n\n  //eslint-disable-next-line functional/no-let\n  let ringCount = 1;\n\n  // Origin\n  yield Object.freeze({ x: c.x, y: c.y });\n\n  //eslint-disable-next-line functional/no-let\n  for (let r = ringR; r <= 1; r += ringR) {\n    const n = Math.round(pi / asin(1 / (2 * ringCount)));\n    for (const theta of linearSpace(0, piPi, n + 1)) {\n      yield Object.freeze({\n        x: c.x + r * cos(theta + rotationOffset) * c.radius,\n        y: c.y + r * sin(theta + rotationOffset) * c.radius,\n      });\n    }\n    ringCount++;\n  }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(\n  samples = 100,\n  rotationRadians = 0,\n  sphere?: Sphere\n): IterableIterator<Point3d> {\n  const offset = 2 / samples;\n  const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n\n  for (let index = 0; index < samples; index++) {\n    const y = index * offset - 1 + offset / 2;\n    const r = sqrt(1 - pow(y, 2));\n    const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n    const x = cos(a) * r;\n    const z = sin(a) * r;\n    //eslint-disable-next-line functional/immutable-data\n    yield Object.freeze({\n      x: s.x + x * s.radius,\n      y: s.y + y * s.radius,\n      z: s.z + z * s.radius,\n    });\n  }\n}\n","import * as Polar from '../Polar.js';\nimport * as Points from '../point/index.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { radianToDegree } from '../Angles.js';\nimport { guard } from './Guard.js';\nimport { intersectsPoint as RectsIntersectsPoint } from '../rect/Intersects.js';\nimport type { RectPositioned } from '../Types.js';\nimport type { Point } from '../point/PointType.js';\nimport { getPointParameter } from '../point/GetPointParameter.js';\nimport type { Triangle } from './TriangleType.js';\n\nexport * from './Area.js';\nexport * from './Centroid.js';\nexport * from './Edges.js';\nexport * from './InnerCircle.js';\nexport * from './Guard.js';\nexport * from './OuterCircle.js';\nexport * from './Perimeter.js';\nexport * from './Rotate.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './Equilateral.js';\n\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './Right.js';\n\nexport * as Isosceles from './Isosceles.js';\n\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n\n\nconst piPi = Math.PI * 2;\n\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Empty = Object.freeze({\n  a: { x: 0, y: 0 },\n  b: { x: 0, y: 0 },\n  c: { x: 0, y: 0 },\n});\n\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({\n  a: { x: Number.NaN, y: Number.NaN },\n  b: { x: Number.NaN, y: Number.NaN },\n  c: { x: Number.NaN, y: Number.NaN },\n});\n\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t: Triangle): boolean =>\n  Points.isEmpty(t.a) && Points.isEmpty(t.b) && Points.isEmpty(t.c);\n\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t: Triangle): boolean =>\n  Points.isPlaceholder(t.a) &&\n  Points.isPlaceholder(t.b) &&\n  Points.isPlaceholder(t.c);\n\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport const apply = (\n  t: Triangle,\n  fn: (p: Point, label?: string) => Point\n) =>\n  Object.freeze<Triangle>({\n    ...t,\n    a: fn(t.a, `a`),\n    b: fn(t.b, `b`),\n    c: fn(t.c, `c`),\n  });\n\n\n\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p: unknown): p is Triangle => {\n  if (p === undefined) return false;\n  const tri = p as Triangle;\n  if (!Points.isPoint(tri.a)) return false;\n  if (!Points.isPoint(tri.b)) return false;\n  if (!Points.isPoint(tri.c)) return false;\n  return true;\n};\n\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: Triangle, b: Triangle): boolean =>\n  Points.isEqual(a.a, b.a) &&\n  Points.isEqual(a.b, b.b) &&\n  Points.isEqual(a.c, b.c);\n\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t: Triangle): ReadonlyArray<Point> => {\n  guard(t);\n  return [ t.a, t.b, t.c ];\n};\n\n\n\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    Points.distance(t.a, t.b),\n    Points.distance(t.b, t.c),\n    Points.distance(t.c, t.a),\n  ];\n};\n\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    Points.angle(t.a, t.b),\n    Points.angle(t.b, t.c),\n    Points.angle(t.c, t.a),\n  ];\n};\n\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return radianToDegree(angles(t));\n};\n\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t: Triangle): boolean => {\n  guard(t);\n  const [ a, b, c ] = lengths(t);\n  return a === b && b === c;\n};\n\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t: Triangle): boolean => {\n  const [ a, b, c ] = lengths(t);\n  if (a === b) return true;\n  if (b === c) return true;\n  if (c === a) return true;\n  return false;\n};\n\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t: Triangle): boolean =>\n  angles(t).includes(Math.PI / 2);\n\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t: Triangle): boolean => !isRightAngle(t);\n\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t: Triangle): boolean =>\n  !angles(t).some((v) => v >= Math.PI / 2);\n\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t: Triangle): boolean =>\n  angles(t).some((v) => v > Math.PI / 2);\n\n\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (\n  origin: Point,\n  radius: number,\n  opts: { readonly initialAngleRadian?: number } = {}\n): Triangle => {\n  throwNumberTest(radius, `positive`, `radius`);\n  Points.guard(origin, `origin`);\n\n  const initialAngleRadian = opts.initialAngleRadian ?? 0;\n\n  const angles = [\n    initialAngleRadian,\n    initialAngleRadian + (piPi * 1) / 3,\n    initialAngleRadian + (piPi * 2) / 3,\n  ];\n  const points = angles.map((a) => Polar.toCartesian(radius, a, origin));\n  return fromPoints(points);\n};\n\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`).\n * @param triangle Triangle\n * @param vertex Name of vertex: a, b or c.\n */\nexport const rotateByVertex = (\n  triangle: Triangle,\n  amountRadian: number,\n  vertex: `a` | `b` | `c` = `b`\n): Triangle => {\n  const origin =\n    vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n  return Object.freeze({\n    a: Points.rotate(triangle.a, amountRadian, origin),\n    b: Points.rotate(triangle.b, amountRadian, origin),\n    c: Points.rotate(triangle.c, amountRadian, origin),\n  });\n};\n\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (\n  origin?: Point,\n  length = 10,\n  angleRadian: number = Math.PI / 2\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const a = Points.project(origin, length, Math.PI - -angleRadian / 2);\n  const c = Points.project(origin, length, Math.PI - angleRadian / 2);\n  return { a, b: origin, c };\n};\n\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport const toFlatArray = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [ t.a.x, t.a.y, t.b.x, t.b.y, t.c.x, t.c.y ];\n};\n\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords: ReadonlyArray<number>): Triangle => {\n  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);\n  if (coords.length !== 6) {\n    throw new Error(\n      `coords array expected with 6 elements. Got ${ coords.length }`\n    );\n  }\n  return fromPoints(Points.fromNumbers(...coords));\n};\n\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points: ReadonlyArray<Point>): Triangle => {\n  if (!Array.isArray(points)) throw new Error(`points expected as array`);\n  if (points.length !== 3) {\n    throw new Error(\n      `points array expected with 3 elements. Got ${ points.length }`\n    );\n  }\n  const t: Triangle = {\n    a: points[ 0 ],\n    b: points[ 1 ],\n    c: points[ 2 ],\n  };\n  return t;\n};\n\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t: Triangle, inflation = 0): RectPositioned => {\n  const { a, b, c } = t;\n  const xMin = Math.min(a.x, b.x, c.x) - inflation;\n  const xMax = Math.max(a.x, b.x, c.x) + inflation;\n  const yMin = Math.min(a.y, b.y, c.y) - inflation;\n  const yMax = Math.max(a.y, b.y, c.y) + inflation;\n\n  const r: RectPositioned = {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin,\n  };\n  return r;\n};\n\nexport type BarycentricCoord = {\n  readonly a: number;\n  readonly b: number;\n  readonly c: number;\n};\n\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): BarycentricCoord => {\n  const pt = getPointParameter(a, b);\n\n  const ab = (x: number, y: number, pa: Point, pb: Point) =>\n    (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n\n  const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n  const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n  const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n\n  return {\n    a: alpha,\n    b: theta,\n    c: gamma,\n  };\n};\n\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (\n  t: Triangle,\n  bc: BarycentricCoord\n): Point => {\n  guard(t);\n  const { a, b, c } = t;\n\n  const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n  const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n\n  if (a.z && b.z && c.z) {\n    const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n    return Object.freeze({ x, y, z });\n  } else {\n    return Object.freeze({ x, y });\n  }\n};\n\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport const intersectsPoint = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): boolean => {\n  const box = bbox(t);\n\n  const pt = getPointParameter(a, b);\n\n  // If it's not in the bounding box, can return false straight away\n  if (!RectsIntersectsPoint(box, pt)) return false;\n\n  const bc = barycentricCoord(t, pt);\n\n  return (\n    0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1\n  );\n};\n","import type { Triangle } from \"./TriangleType.js\";\nimport { guard as PointsGuard } from '../point/Guard.js'\n\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t: Triangle, name = `t`) => {\n  if (t === undefined) throw new Error(`{$name} undefined`);\n  PointsGuard(t.a, name + `.a`);\n  PointsGuard(t.b, name + `.b`);\n  PointsGuard(t.c, name + `.c`);\n};","\nimport type { Triangle } from \"../Types.js\";\nimport type { PolyLine } from \"../line/LineType.js\";\nimport { joinPointsToLines } from \"../line/JoinPointsToLines.js\";\nimport { guard } from \"./Guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t: Triangle): PolyLine => {\n  guard(t);\n  return joinPointsToLines(t.a, t.b, t.c, t.a);\n};","import { guard } from \"./Guard.js\";\nimport { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t: Triangle): number => {\n  guard(t, `t`);\n\n  // Get length of edges\n  const lengths = edges(t).map((l) => LinesLength(l));\n\n  // Add up length of edges, halve\n  const p = (lengths[ 0 ] + lengths[ 1 ] + lengths[ 2 ]) / 2;\n  return Math.sqrt(p * (p - lengths[ 0 ]) * (p - lengths[ 1 ]) * (p - lengths[ 2 ]));\n};","import type { Point } from \"../point/PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t: Triangle): Point => {\n  guard(t);\n  const total = PointsReduce(\n    [ t.a, t.b, t.c ],\n    (p: Point, accumulator: Point) => ({\n      x: p.x + accumulator.x,\n      y: p.y + accumulator.y,\n    })\n  );\n  const div = {\n    x: total.x / 3,\n    y: total.y / 3,\n  };\n  return div;\n};","import { guard } from \"./Guard.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\n\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t: Triangle): number => {\n  guard(t);\n  return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};","import type { CirclePositioned } from \"../circle/CircleType.js\";\nimport { area } from \"./Area.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { perimeter } from \"./Perimeter.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t: Triangle): CirclePositioned => {\n  const c = centroid(t);\n  const p = perimeter(t) / 2;\n  const a = area(t);\n  const radius = a / p;\n  return { radius, ...c };\n};","import { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\nimport { centroid } from './Centroid.js';\nimport type { Triangle } from \"./TriangleType.js\";\nimport type { CirclePositioned } from '../circle/CircleType.js';\n\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t: Triangle): CirclePositioned => {\n  const [ a, b, c ] = edges(t).map((l) => LinesLength(l));\n  const cent = centroid(t);\n  const radius =\n    (a * b * c) /\n    Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n  return {\n    radius,\n    ...cent,\n  };\n};","import type { Point } from \"../point/PointType.js\";\nimport { centroid } from \"./Centroid.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * // Rotate triangle by 5 degrees\n * rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * rotate(triangle, Math.PI / 2);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns\n */\nexport const rotate = (\n  t: Triangle,\n  amountRadian?: number,\n  origin?: Point\n): Triangle => {\n  if (amountRadian === undefined || amountRadian === 0) return t;\n  if (origin === undefined) origin = centroid(t);\n  return Object.freeze({\n    ...t,\n    a: PointsRotate(t.a, amountRadian, origin),\n    b: PointsRotate(t.b, amountRadian, origin),\n    c: PointsRotate(t.c, amountRadian, origin),\n  });\n};\n","import type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\nconst pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\n\nexport type TriangleEquilateral =\n  | {\n    readonly length: number;\n  }\n  | number;\n\nconst resolveLength = (t: TriangleEquilateral): number => {\n  if (typeof t === `number`) return t;\n  return t.length;\n};\n\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * * ▶️ 0: a and c on vertical, b at the tip\n * * ◀️ Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * * 🔽 Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * * 🔼 Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (\n  t: TriangleEquilateral,\n  origin?: Point,\n  rotationRad?: number\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t) / Math.sqrt(3);\n  const rot = rotationRad ?? Math.PI * 1.5;\n  const b = {\n    x: r * Math.cos(rot) + origin.x,\n    y: r * Math.sin(rot) + origin.y,\n  };\n  const a = {\n    x: r * Math.cos(rot + pi4over3) + origin.x,\n    y: r * Math.sin(rot + pi4over3) + origin.y,\n  };\n  const c = {\n    x: r * Math.cos(rot + pi2over3) + origin.x,\n    y: r * Math.sin(rot + pi2over3) + origin.y,\n  };\n\n  return Object.freeze({ a, b, c });\n};\n\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (\n  t: TriangleEquilateral,\n  ptA?: Point\n): Point => {\n  if (!ptA) ptA = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n  return {\n    x: ptA.x + r / 2,\n    y: ptA.y - radius,\n  };\n};\n\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (\n  t: TriangleEquilateral,\n  ptB?: Point\n): Point => {\n  if (!ptB) ptB = Object.freeze({ x: 0, y: 0 })\n\n  const { radius } = incircle(t);\n  return {\n    x: ptB.x,\n    y: ptB.y + radius * 2,\n  };\n};\n\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (\n  t: TriangleEquilateral,\n  ptC?: Point\n): Point => {\n  if (!ptC) ptC = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n\n  return {\n    x: ptC.x - r / 2,\n    y: ptC.y - radius,\n  };\n};\n\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t: TriangleEquilateral): number =>\n  (Math.sqrt(3) / 2) * resolveLength(t);\n\nexport const perimeter = (t: TriangleEquilateral): number =>\n  resolveLength(t) * 3;\n\nexport const area = (t: TriangleEquilateral): number =>\n  (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","import type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nexport type Right = {\n  readonly adjacent?: number;\n  readonly hypotenuse?: number;\n  readonly opposite?: number;\n};\n\nexport type DefinedRight = {\n  readonly adjacent: number;\n  readonly hypotenuse: number;\n  readonly opposite: number;\n};\n\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x + seg[ 1 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x - seg[ 0 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - seg[ 1 ], y: origin.y + h };\n  const b = { x: origin.x + seg[ 0 ], y: origin.y + h };\n  return { a, b, c };\n};\n\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t: Right): DefinedRight => {\n  const a = t.adjacent;\n  const o = t.opposite;\n  const h = t.hypotenuse;\n\n  if (a !== undefined && o !== undefined) {\n    return {\n      ...t,\n      adjacent: a,\n      opposite: o,\n      hypotenuse: Math.hypot(a, o),\n    };\n  } else if (a && h) {\n    return {\n      ...t,\n      adjacent: a,\n      hypotenuse: h,\n      opposite: h * h - a * a,\n    };\n  } else if (o && h) {\n    return {\n      ...t,\n      hypotenuse: h,\n      opposite: o,\n      adjacent: h * h - o * o,\n    };\n  } else if (t.opposite && t.hypotenuse && t.adjacent) {\n    return t as DefinedRight;\n  }\n  throw new Error(`Missing at least two edges`);\n};\n\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t: Right): number => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return Math.sqrt(p * q);\n};\n\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (\n  t: Right\n): readonly [ p: number, q: number ] => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return [ p, q ];\n};\n\nexport const perimeter = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\n\nexport const area = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return (tt.opposite * tt.adjacent) / 2;\n};\n\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.adjacent * tt.adjacent +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.opposite * tt.opposite) /\n    (2 * tt.adjacent * tt.hypotenuse)\n  );\n};\n\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.opposite * tt.opposite +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.adjacent * tt.adjacent) /\n    (2 * tt.opposite * tt.hypotenuse)\n  );\n};\n\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (\n  t: Right\n): readonly [ a: number, b: number, c: number ] => {\n  const tt = resolveLengths(t);\n  const b = tt.adjacent * tt.adjacent;\n  const c = tt.hypotenuse * tt.hypotenuse;\n  const a = tt.opposite * tt.opposite;\n\n  return [\n    Math.sqrt(2 * (b + c) - a) / 2,\n    Math.sqrt(2 * (c + a) - b) / 2,\n    Math.sqrt(2 * (a + b) - c) / 2,\n  ];\n};\n\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return { radius: tt.hypotenuse / 2 };\n};\n\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return {\n    radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n  };\n};\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (\n  angleRad: number,\n  adjacent: number\n): number => Math.tan(angleRad) * adjacent;\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (\n  angleRad: number,\n  hypotenuse: number\n): number => Math.sin(angleRad) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const adjacentFromHypotenuse = (\n  angleRad: number,\n  hypotenuse: number\n): number => Math.cos(angleRad) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (\n  angleRad: number,\n  opposite: number\n): number => opposite / Math.tan(angleRad);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromOpposite = (\n  angleRad: number,\n  opposite: number\n): number => opposite / Math.sin(angleRad);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (\n  angleRad: number,\n  adjacent: number\n): number => adjacent / Math.cos(angleRad);\n","\nimport type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nexport type Isosceles = {\n  readonly legs: number;\n  readonly base: number;\n};\n\nexport const baseAngle = (t: Isosceles): number =>\n  Math.acos(t.base / (2 * t.legs));\n\nexport const apexAngle = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.acos((2 * aa - cc) / (2 * aa));\n};\n\nexport const height = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.sqrt((4 * aa - cc) / 4);\n};\n\nexport const legHeights = (t: Isosceles): number => {\n  const b = baseAngle(t);\n  return t.base * Math.sin(b);\n};\n\nexport const perimeter = (t: Isosceles): number => 2 * t.legs + t.base;\n\nexport const area = (t: Isosceles): number => {\n  const h = height(t);\n  return (h * t.base) / 2;\n};\n\nexport const circumcircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  const hh = h * h;\n  const cc = t.base * t.base;\n  return { radius: (4 * hh + cc) / (8 * h) };\n};\n\nexport const incircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\n\nexport const medians = (\n  t: Isosceles\n): readonly [ a: number, b: number, c: number ] => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n  const medianC = Math.sqrt(4 * aa - cc) / 2;\n  return [ medianAB, medianAB, medianC ];\n};\n\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const incircleR = incircle(t).radius;\n  const verticalToApex = h - incircleR;\n\n  const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n  const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n  const c = { x: origin.x, y: origin.y - verticalToApex };\n  return { a, b, c };\n};\n\nexport const fromA = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + t.base, y: origin.y };\n  const c = { x: origin.x + t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromB = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base, y: origin.y };\n  const c = { x: origin.x - t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromC = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base / 2, y: origin.y + h };\n  const b = { x: origin.x + t.base / 2, y: origin.y + h };\n  return { a, b, c };\n};\n"],"mappings":"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","names":["fromPoints","guard","sum","distance","Empty","Placeholder","apply","bbox","distance","divide","guard","isEmpty","isEqual","isPlaceholder","multiply","normaliseByRect","rotate","subtract","sum","toString","withinRange","guard","isEmpty","isPlaceholder","getPointParameter","getPointParameter","point","line","length","t","point","guard","min","bbox","guard","getPointParameter","divide","point","divide","dotProduct","guard","point","point","angle","guard","dotProduct","divide","max","min","distance","length","angleRadian","isEqual","clamp","clampMagnitude","dotProduct","fromNumbers","getPointParameter","interpolate","invert","multiply","normalise","quantiseEvery","rotate","round","toString","wrap","sum","clamp","guard","guardPositioned","isNaN","isPositioned","guardPositioned","guardPositioned","isEqual","isEqual","centroid","guard","guard","distanceFromExterior","distanceFromExterior","distanceFromExterior","dotProduct","fromNumbers","interpolate","invert","multiply","guard","clampMagnitude","max","min","length","multiply","length","normalise","getPointParameter","pipeline","from","distance","angle","quantiseEvery","getPointParameter","rotate","round","getPointParameter","toString","wrap","multiply","point","rotate","subtract","point","sum","point","toString","guard","Empty","Placeholder","isEmpty","isPlaceholder","apply","normaliseByRect","height","withinRange","point","distance","point","bbox","toString","rotate","sum","divide","multiply","subtract","distance","withinRange","isEqual","apply","fromPoints","nearest","distance","random","center","isIntersecting","randomPoint","height","isIntersecting","offset","center","random","randomPoint","isIntersecting","randomPoint","center","angle","from","angleRadian","arrow","random","isIntersecting","randomPoint","bbox","center","guard","guardPositioned","interpolate","isEqual","isIntersecting","isNaN","isPositioned","length","multiplyScalar","nearest","toPath","guard","height","bbox","piPi","nearest","angleRadian","guard","length","piPi","interpolate","t","multiplyScalar","toPath","guard","point","nearest","t","interpolate","bbox","getPointParameter","area","distanceFromExterior","fromNumbers","guard","isEmpty","isEqual","isPlaceholder","multiply","multiplyScalar","normaliseByRect","random","randomPoint","subtract","sum","toArray","area","guard","height","guard","fromNumbers","height","isEqual","multiply","guard","multiplyScalar","normaliseByRect","height","subtract","height","sum","height","toArray","isEqual","toArray","isEqual","toArray","cells","cardinal","grid","t","visitor","wrap","rows","toPath","abs","t","t2","sum","point","bbox","bbox2","intersections","min","max","reduce","a","b","c","d","v1","q","bbox","offset","abs","cos","sin","acos","sqrt","pi","point","t","abs","angle","pi","sqrt","acos","d","ls","le","segments","tlen","alen","intersections","cos","sin","toPath","cubic","cubic2","t","quadratic","bbox","interpolate","relativePosition","toString","toSvgString","interpolate","t","point","relativePosition","lengths","length","bbox","corners","toString","toSvgString","epsilon","slope","t","Direction","isIntersecting","fromNumbers","normalise","abs","multiply","multiply","rows","reduce","visitor","scale","bbox","distanceCenter","fromDegrees","guard","interpolate","isEqual","isPositioned","length","toPath","toSvg","isPositioned","piPi","fromDegrees","angleRadian","guard","interpolate","toPath","point","bbox","length","toSvg","toSvgFull","distanceCenter","isEqual","clampMagnitude","divide","dotProduct","multiply","normalise","subtract","sum","toCartesian","toString","EmptyCartesian","piPi","pi","point","guard","normalise","toCartesian","toString","dotProduct","clampMagnitude","max","min","sum","subtract","multiply","divide","cos","sin","sqrt","pow","pi","piPi","max","angle","offset","Empty","Placeholder","apply","area","bbox","centroid","corners","edges","fromFlatArray","fromPoints","guard","intersectsPoint","isEmpty","isEqual","isPlaceholder","lengths","rotate","toFlatArray","guard","t","edges","t","guard","area","t","guard","lengths","edges","centroid","t","guard","t","guard","edges","t","centroid","area","t","edges","centroid","rotate","t","centroid","area","fromCenter","perimeter","t","area","circumcircle","height","incircle","perimeter","t","area","circumcircle","fromA","fromB","fromC","fromCenter","height","incircle","medians","perimeter","t","piPi","Empty","Placeholder","isEmpty","t","isPlaceholder","apply","isEqual","corners","guard","lengths","angles","fromPoints","rotate","length","angleRadian","toFlatArray","fromFlatArray","fromNumbers","bbox","getPointParameter","intersectsPoint"]}