{"version":3,"sources":["../src/collections/queue/QueueFns.ts","../src/collections/queue/QueueMutable.ts"],"sourcesContent":["import type { QueueOpts } from './QueueTypes.js';\n\nexport const debug = (opts: QueueOpts<any>, message: string): void => {\n  opts.debug ? console.log(`queue:${ message }`) : undefined;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`: {\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [ ...queue, ...toAdd.slice(0, toRemove - 1) ];\n      }\n    }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`: {\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          return [ ...toAdd.slice(0, capacity - 1), toAdd.at(-1)! ];\n        }\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        //return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [ ...toKeep, ...toAddFinal ];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`: {\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [ ...queue, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown overflow policy ${ policy }`);\n    }\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [ ...queue, ...toAdd ];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${ toReturn.length\n      } capacity: ${ opts.capacity } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${ toReturn.length\n      } expected: ${ potentialLength } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @template V\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[ 0 ];\n\nexport const isEmpty = <V>(opts: QueueOpts<V>, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import { type IQueueMutable } from './IQueueMutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './QueueFns.js';\nimport { type QueueOpts } from './QueueTypes.js';\nimport { without } from '../arrays/index.js';\nimport { isEqualDefault, type IsEqual } from '../../IsEqual.js';\n/**\n * Returns a mutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @template V Data type of items\n * @param opts\n * @param startingItems Items are added in array order. So first item will be at the front of the queue.\n */\nexport class QueueMutable<V> implements IQueueMutable<V> {\n  readonly opts: QueueOpts<V>;\n  // eslint-disable-next-line functional/prefer-readonly-type\n  data: ReadonlyArray<V>;\n  eq: IsEqual<V>;\n\n  constructor(opts: QueueOpts<V> = {}, data: ReadonlyArray<V> = []) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.opts = opts;\n    this.data = data;\n    this.eq = opts.eq ?? isEqualDefault;\n  }\n\n  clear() {\n    this.data = [];\n  }\n\n  at(index: number): V {\n    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);\n    const v = this.data.at(index);\n    if (v === undefined) throw new Error(`Index appears to be outside range of queue`);\n    return v;\n  }\n\n  /**\n   * Return a copy of the array\n   * @returns \n   */\n  toArray() {\n    return [ ...this.data ];\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V>): number {\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = enqueue(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.opts, this.data);\n    if (v === undefined) return;\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.opts, this.data);\n    return v;\n  }\n\n  /**\n   * Remove value from queue, regardless of position.\n   * Returns _true_ if something was removed.\n   * \n   * See also {@link removeWhere} to remove based on a predicate\n   * @param value \n   */\n  remove(value: V, comparer?: IsEqual<V>): boolean {\n    const length = this.data.length;\n    this.data = without(this.data, value, comparer ?? this.eq);\n    return this.data.length !== length;\n  }\n\n  /**\n   * Removes values that match `predicate`.\n   * See also {@link remove} if to remove a value based on equality checking.\n   * @param predicate \n   * @returns Returns number of items removed.\n   */\n  removeWhere(predicate: (item: V) => boolean) {\n    const countPre = this.data.length;\n    this.data = this.data.filter((element) => predicate(element));\n    return countPre - this.data.length;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n}\n\nexport function mutable<V>(\n  opts: QueueOpts<V> = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueMutable<V> {\n  return new QueueMutable({ ...opts }, [ ...startingItems ]);\n}\n\n"],"mappings":"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","names":[]}