{"version":3,"sources":["../src/iterables/IterableSync.ts"],"sourcesContent":["import { type ToString, toStringDefault } from '../Util.js';\nimport { type IsEqual } from '../IsEqual.js';\nimport { isIterable } from './Iterable.js';\nexport { slice } from './sync/Slice.js';\n\nexport function* uniqueByValue<T>(input: Iterable<T>, toString: ToString<T> = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> {\n  for (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(\n  generator: Generator<number>,\n  defaultValue?: number\n) {\n\n  return (): number | undefined => {\n    const v: number | undefined = generator.next().value as number | undefined;\n    if (v === undefined) return defaultValue;\n    return v;\n  };\n}\n\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first<V>(it: Iterable<V>): V | undefined {\n  for (const value of it) {\n    return value;\n  }\n}\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last<V>(it: Iterable<V>): V | undefined {\n  //eslint-disable-next-line functional/no-let\n  let returnValue: V | undefined;\n  for (const value of it) {\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping<V>(it: Iterable<V>, size: number) {\n  if (size <= 1) throw new Error(`Size should be at least 2`);\n\n  //eslint-disable-next-line functional/no-let\n  let buffer: Array<V> = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      buffer = [ buffer.at(-1)! ];\n    }\n  }\n  if (buffer.length <= 1) return;\n\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport function* chunks<V>(it: Iterable<V>, size: number) {\n  //eslint-disable-next-line functional/no-let\n  let buffer = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\nexport function* concat<V>(...its: ReadonlyArray<Iterable<V>>) {\n  for (const it of its) yield* it;\n}\n\nexport function* dropWhile<V>(\n  it: Iterable<V>,\n  f: (v: V) => boolean\n) {\n  for (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it: Iterable<any>, callback: () => (void | boolean | never)) => {\n  for (const _ of it) {\n    const value = callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(\n  it1: IterableIterator<V>,\n  it2: IterableIterator<V>,\n  equality?: IsEqual<V>\n) {\n  //it1 = it1[Symbol.iterator]();\n  //it2 = it2[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const index1 = it1.next(),\n      index2 = it2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport function every<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  for (const v of it) {\n    const result = f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\n\nexport function* fill<V>(it: Iterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n\n  //eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const _ of it) yield v;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach<V>(it: Iterable<V>, f: (v: V) => boolean | void) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    const result = f(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\nexport function find<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return v;\n  }\n}\n\nexport function* flatten<V>(it: Iterable<V>) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport function* map<V, X>(it: Iterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    yield f(v);\n  }\n}\n\nexport function* max<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b): Generator<V> {\n  let max: V | undefined;\n  for (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield max;\n      continue;\n    }\n    if (gt(v, max)) {\n      max = v;\n      yield max;\n    }\n  }\n  return max;\n}\n\nexport function* min<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n    }\n    if (gt(min, v)) {\n      min = v;\n      yield min;\n    }\n  }\n}\n\nexport function reduce<V>(\n  it: Iterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) start = f(start, v);\n  return start;\n}\n\n\nexport function some<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return true;\n  }\n  return false;\n}\n\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\nexport function* repeat<T>(genCreator: () => Iterable<T>, repeatsOrSignal: number | AbortSignal): Generator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n\nexport function* unique<V>(\n  iterable: Iterable<V> | Array<Iterable<V>>\n) {\n  // Adapted from https://surma.github.io/underdash/\n  const buffer: Array<any> = [];\n  let itera: Array<Iterable<V>> = [];\n  itera = Array.isArray(iterable) ? iterable : [ iterable ];\n  for (const it of itera) {\n    for (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function* zip<V>(...its: ReadonlyArray<Iterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.iterator ]());\n\n  while (true) {\n    const vs = iits.map((it) => it.next());\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n\nexport function* fromIterable<T>(iterable: Iterable<T>) {\n  for (const v of iterable) {\n    yield v;\n  }\n}\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function toArray<V>(\n  it: Iterable<V>,\n  count = Number.POSITIVE_INFINITY\n): Array<V> {\n  const result: Array<V> = [];\n  for (const v of it) {\n    if (result.length === count) break;\n    result.push(v);\n  }\n  return result;\n}\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray<V>(array: Array<V>): Generator<V> {\n  for (const v of array) {\n    yield v;\n  }\n}"],"mappings":"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","names":["max","min"]}